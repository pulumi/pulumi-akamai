// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppSecSiemSettingsExceptions {
    /**
     * Whether there should be an exception to include api request constraints events in SIEM
     */
    apiRequestConstraints?: string[];
    /**
     * Whether there should be an exception to include apr protection events in SIEM
     */
    aprProtections?: string[];
    /**
     * Whether there should be an exception to include bot management events in SIEM
     */
    botManagements?: string[];
    /**
     * Whether there should be an exception to include client reputation events in SIEM
     */
    clientReps?: string[];
    /**
     * Whether there should be an exception to include custom rules events in SIEM
     */
    customRules?: string[];
    /**
     * Whether there should be an exception to include ip geo events in SIEM
     */
    ipGeos?: string[];
    /**
     * Whether there should be an exception to include malware protection events in SIEM
     */
    malwareProtections?: string[];
    /**
     * Whether there should be an exception to include rate events in SIEM
     */
    rates?: string[];
    /**
     * Whether there should be an exception to include slow post events in SIEM
     */
    slowPosts?: string[];
    /**
     * Whether there should be an exception to include url protection events in SIEM
     */
    urlProtections?: string[];
    /**
     * Whether there should be an exception to include waf events in SIEM
     */
    wafs?: string[];
}

export interface ClientlistListItem {
    /**
     * A description of the item.
     */
    description?: string;
    /**
     * The item expiration date.
     */
    expirationDate?: string;
    /**
     * The item tags.
     */
    tags?: string[];
    /**
     * Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
     */
    value: string;
}

export interface CloudAccessKeyCredentialsA {
    /**
     * Access key id from cloud provider which is used to sign API requests
     */
    cloudAccessKeyId: string;
    /**
     * Cloud Access secret from cloud provider which is used to sign API requests
     */
    cloudSecretAccessKey: string;
    /**
     * Boolean value which helps to define if credentials should be assigned to property
     */
    primaryKey: boolean;
    /**
     * Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
     */
    version: number;
    /**
     * The unique identifier assigned to specific access key version
     */
    versionGuid: string;
}

export interface CloudAccessKeyCredentialsB {
    /**
     * Access key id from cloud provider which is used to sign API requests
     */
    cloudAccessKeyId: string;
    /**
     * Cloud Access secret from cloud provider which is used to sign API requests
     */
    cloudSecretAccessKey: string;
    /**
     * Boolean value which helps to define if credentials should be assigned to property
     */
    primaryKey: boolean;
    /**
     * Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
     */
    version: number;
    /**
     * The unique identifier assigned to specific access key version
     */
    versionGuid: string;
}

export interface CloudAccessKeyNetworkConfiguration {
    /**
     * Additional type of the deployment network that the access key will be deployed to.
     */
    additionalCdn?: string;
    /**
     * The API deploys the access key to this secure network
     */
    securityNetwork: string;
}

export interface CloudAccessKeyTimeouts {
    /**
     * Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
     */
    create?: string;
    /**
     * Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
     */
    delete?: string;
    /**
     * Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
     */
    update?: string;
}

export interface CloudletsApplicationLoadBalancerActivationTimeouts {
    default?: string;
}

export interface CloudletsApplicationLoadBalancerDataCenter {
    /**
     * The city in which the data center is located.
     */
    city?: string;
    /**
     * Describes if cloud server host header is overridden
     */
    cloudServerHostHeaderOverride?: boolean;
    /**
     * Describes if this datacenter is a cloud service
     */
    cloudService?: boolean;
    /**
     * The continent on which the data center is located
     */
    continent: string;
    /**
     * The country in which the data center is located
     */
    country: string;
    /**
     * This should match the 'hostname' value defined for this datacenter in Property Manager
     */
    hostname?: string;
    /**
     * The latitude value for the data center. This member supports six decimal places of precision.
     */
    latitude: number;
    /**
     * An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
     */
    livenessHosts?: string[];
    /**
     * The longitude value for the data center. This member supports six decimal places of precision.
     */
    longitude: number;
    /**
     * The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
     */
    originId: string;
    /**
     * The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     */
    percent: number;
    /**
     * The state, province, or region where the data center is located
     */
    stateOrProvince?: string;
}

export interface CloudletsApplicationLoadBalancerLivenessSettings {
    /**
     * Maps additional case-insensitive HTTP header names included to the liveness testing requests
     */
    additionalHeaders?: {[key: string]: string};
    /**
     * The Host header for the liveness HTTP request
     */
    hostHeader?: string;
    /**
     * Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
     */
    interval?: number;
    /**
     * The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     */
    path: string;
    /**
     * Describes whether or not to validate the origin certificate for an HTTPS request
     */
    peerCertificateVerification?: boolean;
    /**
     * The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     */
    port: number;
    /**
     * The protocol or scheme for the database, either HTTP or HTTPS.
     */
    protocol: string;
    /**
     * The request which will be used for TCP(S) tests
     */
    requestString?: string;
    responseString?: string;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
     */
    status3xxFailure?: boolean;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
     */
    status4xxFailure?: boolean;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
     */
    status5xxFailure?: boolean;
    /**
     * The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
     */
    timeout?: number;
}

export interface CloudletsPolicyActivationTimeouts {
    default?: string;
}

export interface CloudletsPolicyTimeouts {
    default?: string;
}

export interface CloudwrapperActivationTimeouts {
    /**
     * Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
     */
    create?: string;
    /**
     * Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
     */
    update?: string;
}

export interface CloudwrapperConfigurationLocation {
    /**
     * The capacity assigned to this configuration's location
     */
    capacity?: outputs.CloudwrapperConfigurationLocationCapacity;
    /**
     * Additional comments provided by the user.
     */
    comments: string;
    /**
     * Unique identifier for the location and traffic type combination
     */
    trafficTypeId: number;
}

export interface CloudwrapperConfigurationLocationCapacity {
    /**
     * Unit of capacity. Can be either 'GB' or 'TB'.
     */
    unit: string;
    /**
     * Value of capacity.
     */
    value: number;
}

export interface CloudwrapperConfigurationTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
}

export interface CpCodeTimeouts {
    update?: string;
}

export interface CpsDvEnrollmentAdminContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface CpsDvEnrollmentCsr {
    /**
     * City where organization is located
     */
    city: string;
    /**
     * The code of the country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization used in all legal documents
     */
    organization: string;
    /**
     * Organizational unit of organization
     */
    organizationalUnit?: string;
    /**
     * For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
     */
    preferredTrustChain?: string;
    /**
     * State or province of organization location
     */
    state?: string;
}

export interface CpsDvEnrollmentDnsChallenge {
    /**
     * Domain for which the challenges were completed
     */
    domain: string;
    /**
     * The domain name where Akamai publishes the response body to validate
     */
    fullPath: string;
    /**
     * The unique content of the challenge
     */
    responseBody: string;
}

export interface CpsDvEnrollmentHttpChallenge {
    /**
     * Domain for which the challenges were completed
     */
    domain: string;
    /**
     * The URL where Akamai publishes the response body to validate
     */
    fullPath: string;
    /**
     * The unique content of the challenge
     */
    responseBody: string;
}

export interface CpsDvEnrollmentNetworkConfiguration {
    /**
     * The trust chain configuration used for client mutual authentication
     */
    clientMutualAuthentication?: outputs.CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication;
    /**
     * Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
     */
    cloneDnsNames?: boolean;
    /**
     * TLS versions which are disallowed
     */
    disallowedTlsVersions?: string[];
    /**
     * Geography type used for enrollment
     */
    geography: string;
    /**
     * Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
     */
    mustHaveCiphers?: string;
    /**
     * Enable OCSP stapling. Default is 'on'
     */
    ocspStapling?: string;
    /**
     * Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
     */
    preferredCiphers?: string;
    /**
     * Enable QUIC protocol. Default is false
     */
    quicEnabled?: boolean;
}

export interface CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication {
    /**
     * Enable OCSP stapling
     */
    ocspEnabled?: boolean;
    /**
     * Enable the server to send the certificate authority (CA) list to the client
     */
    sendCaListToClient?: boolean;
    /**
     * The identifier of the set of trust chains, created in the Trust Chain Manager
     */
    setId?: string;
}

export interface CpsDvEnrollmentOrganization {
    /**
     * The address of organization
     */
    addressLineOne: string;
    /**
     * The address of organization
     */
    addressLineTwo?: string;
    /**
     * City of organization
     */
    city: string;
    /**
     * Country code of organization
     */
    countryCode: string;
    /**
     * Name of organization
     */
    name: string;
    /**
     * Phone number of organization
     */
    phone: string;
    /**
     * Postal code of organization
     */
    postalCode: string;
    /**
     * The region of organization
     */
    region: string;
}

export interface CpsDvEnrollmentTechContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface CpsDvEnrollmentTimeouts {
    default?: string;
}

export interface CpsDvValidationTimeouts {
    default?: string;
}

export interface CpsThirdPartyEnrollmentAdminContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface CpsThirdPartyEnrollmentCsr {
    /**
     * City where organization is located
     */
    city: string;
    /**
     * The code of the country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization used in all legal documents
     */
    organization: string;
    /**
     * Organizational unit of organization
     */
    organizationalUnit?: string;
    /**
     * For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
     */
    preferredTrustChain?: string;
    /**
     * State or province of organization location
     */
    state?: string;
}

export interface CpsThirdPartyEnrollmentNetworkConfiguration {
    /**
     * The trust chain configuration used for client mutual authentication
     */
    clientMutualAuthentication?: outputs.CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication;
    /**
     * Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
     */
    cloneDnsNames?: boolean;
    /**
     * TLS versions which are disallowed
     */
    disallowedTlsVersions?: string[];
    /**
     * Geography type used for enrollment
     */
    geography: string;
    /**
     * Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
     */
    mustHaveCiphers?: string;
    /**
     * Enable OCSP stapling. Default is 'on'
     */
    ocspStapling?: string;
    /**
     * Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
     */
    preferredCiphers?: string;
    /**
     * Enable QUIC protocol. Default is false
     */
    quicEnabled?: boolean;
}

export interface CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication {
    /**
     * Enable OCSP stapling
     */
    ocspEnabled?: boolean;
    /**
     * Enable the server to send the certificate authority (CA) list to the client
     */
    sendCaListToClient?: boolean;
    /**
     * The identifier of the set of trust chains, created in the Trust Chain Manager
     */
    setId?: string;
}

export interface CpsThirdPartyEnrollmentOrganization {
    /**
     * The address of organization
     */
    addressLineOne: string;
    /**
     * The address of organization
     */
    addressLineTwo?: string;
    /**
     * City of organization
     */
    city: string;
    /**
     * Country code of organization
     */
    countryCode: string;
    /**
     * Name of organization
     */
    name: string;
    /**
     * Phone number of organization
     */
    phone: string;
    /**
     * Postal code of organization
     */
    postalCode: string;
    /**
     * The region of organization
     */
    region: string;
}

export interface CpsThirdPartyEnrollmentTechContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface CpsThirdPartyEnrollmentTimeouts {
    default?: string;
}

export interface CpsUploadCertificateTimeouts {
    default?: string;
}

export interface DatastreamAzureConnector {
    /**
     * Access keys associated with Azure Storage account
     */
    accessKey: string;
    /**
     * Specifies the Azure Storage account name
     */
    accountName: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs: boolean;
    /**
     * Specifies the Azure Storage container name
     */
    containerName: string;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The path to the folder within Azure Storage container where logs will be stored
     */
    path: string;
}

export interface DatastreamDatadogConnector {
    /**
     * The API key associated with Datadog account
     */
    authToken: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs?: boolean;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The Datadog endpoint where logs will be stored
     */
    endpoint: string;
    /**
     * The service of the Datadog connector
     */
    service?: string;
    /**
     * The source of the Datadog connector
     */
    source?: string;
    /**
     * The tags of the Datadog connector
     */
    tags?: string;
}

export interface DatastreamDeliveryConfiguration {
    /**
     * A delimiter that you use to separate data set fields in log lines
     */
    fieldDelimiter?: string;
    /**
     * The format in which logs will be received
     */
    format: string;
    /**
     * The frequency of collecting logs from each uploader and sending these logs to a destination
     */
    frequency: outputs.DatastreamDeliveryConfigurationFrequency;
    /**
     * The prefix of the log file that will be send to a destination
     */
    uploadFilePrefix?: string;
    /**
     * The suffix of the log file that will be send to a destination
     */
    uploadFileSuffix?: string;
}

export interface DatastreamDeliveryConfigurationFrequency {
    /**
     * The time in seconds after which the system bundles log lines into a file and sends it to a destination
     */
    intervalInSecs: number;
}

export interface DatastreamElasticsearchConnector {
    /**
     * The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     */
    caCert?: string;
    /**
     * The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     */
    clientCert?: string;
    /**
     * The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     */
    clientKey?: string;
    /**
     * The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
     */
    contentType?: string;
    /**
     * A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
     */
    customHeaderValue?: string;
    /**
     * The name of the connector.
     */
    displayName: string;
    /**
     * The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
     */
    endpoint: string;
    /**
     * The index name of the Elastic cloud where you want to store log files.
     */
    indexName: string;
    /**
     * Indicates whether mTLS is enabled or not.
     */
    mTls: boolean;
    /**
     * The Elasticsearch basic access authentication password.
     */
    password: string;
    /**
     * The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     */
    tlsHostname?: string;
    /**
     * The Elasticsearch basic access authentication username.
     */
    userName: string;
}

export interface DatastreamGcsConnector {
    /**
     * The name of the storage bucket created in Google Cloud account
     */
    bucket: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs: boolean;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The path to the folder within Google Cloud bucket where logs will be stored
     */
    path?: string;
    /**
     * The contents of the JSON private key generated and downloaded in Google Cloud Storage account
     */
    privateKey: string;
    /**
     * The unique ID of Google Cloud project
     */
    projectId: string;
    /**
     * The name of the service account with the storage.object.create permission or Storage Object Creator role
     */
    serviceAccountName: string;
}

export interface DatastreamHttpsConnector {
    /**
     * Either NONE for no authentication, or BASIC for username and password authentication
     */
    authenticationType: string;
    /**
     * The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     */
    caCert?: string;
    /**
     * The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     */
    clientCert?: string;
    /**
     * The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     */
    clientKey?: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs?: boolean;
    /**
     * Content type to pass in the log file header
     */
    contentType?: string;
    /**
     * The name of custom header passed with the request to the destination
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request to the destination
     */
    customHeaderValue?: string;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * URL where logs will be stored
     */
    endpoint: string;
    /**
     * Indicates whether mTLS is enabled or not.
     */
    mTls: boolean;
    /**
     * Password set for custom HTTPS endpoint for authentication
     */
    password?: string;
    /**
     * The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     */
    tlsHostname?: string;
    /**
     * Username used for authentication
     */
    userName?: string;
}

export interface DatastreamLogglyConnector {
    /**
     * The unique HTTP code for your Loggly bulk endpoint.
     */
    authToken: string;
    /**
     * The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
     */
    contentType?: string;
    /**
     * A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
     */
    customHeaderValue?: string;
    /**
     * The name of the connector.
     */
    displayName: string;
    /**
     * The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
     */
    endpoint: string;
    /**
     * The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
     */
    tags?: string;
}

export interface DatastreamNewRelicConnector {
    /**
     * Your Log API token for your account in New Relic.
     */
    authToken: string;
    /**
     * The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
     */
    contentType?: string;
    /**
     * A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
     */
    customHeaderValue?: string;
    /**
     * The name of the connector.
     */
    displayName: string;
    /**
     * A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
     */
    endpoint: string;
}

export interface DatastreamOracleConnector {
    /**
     * The access key identifier used to authenticate requests to the Oracle Cloud account
     */
    accessKey: string;
    /**
     * The name of the Oracle Cloud Storage bucket
     */
    bucket: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs: boolean;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The namespace of Oracle Cloud Storage account
     */
    namespace: string;
    /**
     * The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
     */
    path: string;
    /**
     * The Oracle Cloud Storage region where bucket resides
     */
    region: string;
    /**
     * The secret access key identifier used to authenticate requests to the Oracle Cloud account
     */
    secretAccessKey: string;
}

export interface DatastreamS3Connector {
    /**
     * The access key identifier used to authenticate requests to the Amazon S3 account
     */
    accessKey: string;
    /**
     * The name of the Amazon S3 bucket
     */
    bucket: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs: boolean;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The path to the folder within Amazon S3 bucket where logs will be stored
     */
    path: string;
    /**
     * The AWS region where Amazon S3 bucket resides
     */
    region: string;
    /**
     * The secret access key identifier used to authenticate requests to the Amazon S3 account
     */
    secretAccessKey: string;
}

export interface DatastreamSplunkConnector {
    /**
     * The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     */
    caCert?: string;
    /**
     * The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     */
    clientCert?: string;
    /**
     * The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     */
    clientKey?: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs?: boolean;
    /**
     * The name of custom header passed with the request to the destination
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request to the destination
     */
    customHeaderValue?: string;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The raw event Splunk URL where logs will be stored
     */
    endpoint: string;
    /**
     * The Event Collector token associated with Splunk account
     */
    eventCollectorToken: string;
    /**
     * Indicates whether mTLS is enabled or not.
     */
    mTls: boolean;
    /**
     * The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     */
    tlsHostname?: string;
}

export interface DatastreamSumologicConnector {
    /**
     * The unique HTTP collector code of Sumo Logic endpoint
     */
    collectorCode: string;
    /**
     * Indicates whether the logs should be compressed
     */
    compressLogs?: boolean;
    /**
     * Content type to pass in the log file header
     */
    contentType?: string;
    /**
     * The name of custom header passed with the request to the destination
     */
    customHeaderName?: string;
    /**
     * The custom header's contents passed with the request to the destination
     */
    customHeaderValue?: string;
    /**
     * The name of the connector
     */
    displayName: string;
    /**
     * The Sumo Logic collection endpoint where logs will be stored
     */
    endpoint: string;
}

export interface DnsZoneOutboundZoneTransfer {
    /**
     * The access control list, defined as IPv4 and IPv6 CIDR blocks.
     */
    acls?: string[];
    /**
     * Enables outbound zone transfer.
     */
    enabled?: boolean;
    /**
     * Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
     */
    notifyTargets?: string[];
    /**
     * The TSIG key used for outbound zone transfers.
     */
    tsigKey?: outputs.DnsZoneOutboundZoneTransferTsigKey;
}

export interface DnsZoneOutboundZoneTransferTsigKey {
    /**
     * The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
     */
    algorithm: string;
    /**
     * The zone name.
     */
    name: string;
    /**
     * A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
     */
    secret: string;
}

export interface DnsZoneTsigKey {
    algorithm: string;
    name: string;
    secret: string;
}

export interface EdgeHostNameTimeouts {
    default?: string;
}

export interface EdgeWorkerTimeouts {
    default?: string;
}

export interface EdgeWorkersActivationTimeouts {
    default?: string;
    delete?: string;
}

export interface EdgekvGroupItemsTimeouts {
    default?: string;
}

export interface GetAppsecRapidRulesRapidRule {
    /**
     * The rapid rule action.
     */
    action: string;
    /**
     * The unique identifier of attack group, rapid rule belongs to.
     */
    attackGroup: string;
    /**
     * The attack group exception.
     */
    attackGroupException: string;
    /**
     * The rapid rule exception.
     */
    conditionException: string;
    /**
     * The unique identifier of rapid rule.
     */
    id: number;
    /**
     * The the rapid rule action lock.
     */
    lock: boolean;
    /**
     * The rapid rule name.
     */
    name: string;
}

export interface GetCPSEnrollmentAdminContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface GetCPSEnrollmentCsr {
    /**
     * City where organization is located
     */
    city: string;
    /**
     * The code of the country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization used in all legal documents
     */
    organization: string;
    /**
     * Organizational unit of organization
     */
    organizationalUnit: string;
    /**
     * For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
     */
    preferredTrustChain: string;
    /**
     * State or province of organization location
     */
    state: string;
}

export interface GetCPSEnrollmentDnsChallenge {
    /**
     * Domain for which the challenges were completed
     */
    domain: string;
    /**
     * The domain name where Akamai publishes the response body to validate
     */
    fullPath: string;
    /**
     * The unique content of the challenge
     */
    responseBody: string;
}

export interface GetCPSEnrollmentHttpChallenge {
    /**
     * Domain for which the challenges were completed
     */
    domain: string;
    /**
     * The URL where Akamai publishes the response body to validate
     */
    fullPath: string;
    /**
     * The unique content of the challenge
     */
    responseBody: string;
}

export interface GetCPSEnrollmentNetworkConfiguration {
    /**
     * The trust chain configuration used for client mutual authentication
     */
    clientMutualAuthentications: outputs.GetCPSEnrollmentNetworkConfigurationClientMutualAuthentication[];
    /**
     * Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
     */
    cloneDnsNames: boolean;
    /**
     * TLS versions which are disallowed
     */
    disallowedTlsVersions: string[];
    /**
     * Geography type used for enrollment
     */
    geography: string;
    /**
     * Mandatory Ciphers which are included for enrollment
     */
    mustHaveCiphers: string;
    /**
     * Enable OCSP stapling
     */
    ocspStapling: string;
    /**
     * Preferred Ciphers which are included for enrollment
     */
    preferredCiphers: string;
    /**
     * Enable QUIC protocol
     */
    quicEnabled: boolean;
}

export interface GetCPSEnrollmentNetworkConfigurationClientMutualAuthentication {
    /**
     * Enable the OCSP stapling
     */
    ocspEnabled: boolean;
    /**
     * Enable the server to send the certificate authority (CA) list to the client
     */
    sendCaListToClient: boolean;
    /**
     * The identifier of the set of trust chains, created in the Trust Chain Manager
     */
    setId: string;
}

export interface GetCPSEnrollmentOrganization {
    /**
     * The address of organization
     */
    addressLineOne: string;
    /**
     * The address of organization
     */
    addressLineTwo: string;
    /**
     * City where organization is located
     */
    city: string;
    /**
     * Country code of country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization
     */
    name: string;
    /**
     * The phone number of the administrator who is organization contact
     */
    phone: string;
    /**
     * The postal code of organization
     */
    postalCode: string;
    /**
     * The region where organization resides
     */
    region: string;
}

export interface GetCPSEnrollmentTechContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface GetCPSEnrollmentsEnrollment {
    /**
     * Contact information for the certificate administrator used at organization
     */
    adminContacts: outputs.GetCPSEnrollmentsEnrollmentAdminContact[];
    /**
     * Slots where the certificate either will be deployed or is already deployed
     */
    assignedSlots: number[];
    /**
     * Certificate trust chain type
     */
    certificateChainType: string;
    /**
     * Certificate type of enrollment
     */
    certificateType: string;
    /**
     * Common name used for enrollment
     */
    commonName: string;
    /**
     * Data used for generation of Certificate Signing Request
     */
    csrs: outputs.GetCPSEnrollmentsEnrollmentCsr[];
    /**
     * Enable Dual-Stacked certificate deployment for enrollment
     */
    enableMultiStackedCertificates: boolean;
    /**
     * The unique identifier of enrollment
     */
    enrollmentId: number;
    /**
     * Settings containing network information and TLS metadata used by CPS
     */
    networkConfigurations: outputs.GetCPSEnrollmentsEnrollmentNetworkConfiguration[];
    /**
     * The Digicert unique identifier for the organization
     */
    orgId: number;
    /**
     * Organization information
     */
    organizations: outputs.GetCPSEnrollmentsEnrollmentOrganization[];
    /**
     * Whether some changes are pending
     */
    pendingChanges: boolean;
    /**
     * Slots where the certificate is deployed on the production network
     */
    productionSlots: number[];
    /**
     * The registration authority or certificate authority (CA) used to obtain a certificate
     */
    registrationAuthority: string;
    /**
     * List of SANs
     */
    sans: string[];
    /**
     * Type of TLS deployment network
     */
    secureNetwork: string;
    /**
     * SHA algorithm type
     */
    signatureAlgorithm: string;
    /**
     * Whether Server Name Indication is used for enrollment
     */
    sniOnly: boolean;
    /**
     * Slots where the certificate is deployed on the staging network
     */
    stagingSlots: number[];
    /**
     * Contact information for an administrator at Akamai
     */
    techContacts: outputs.GetCPSEnrollmentsEnrollmentTechContact[];
    /**
     * Enrolment validation type
     */
    validationType: string;
}

export interface GetCPSEnrollmentsEnrollmentAdminContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface GetCPSEnrollmentsEnrollmentCsr {
    /**
     * City where organization is located
     */
    city: string;
    /**
     * The code of the country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization used in all legal documents
     */
    organization: string;
    /**
     * Organizational unit of organization
     */
    organizationalUnit: string;
    /**
     * For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
     */
    preferredTrustChain: string;
    /**
     * State or province of organization location
     */
    state: string;
}

export interface GetCPSEnrollmentsEnrollmentNetworkConfiguration {
    /**
     * The trust chain configuration used for client mutual authentication
     */
    clientMutualAuthentications: outputs.GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication[];
    /**
     * Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
     */
    cloneDnsNames: boolean;
    /**
     * TLS versions which are disallowed
     */
    disallowedTlsVersions: string[];
    /**
     * Geography type used for enrollment
     */
    geography: string;
    /**
     * Mandatory Ciphers which are included for enrollment
     */
    mustHaveCiphers: string;
    /**
     * Enable OCSP stapling
     */
    ocspStapling: string;
    /**
     * Preferred Ciphers which are included for enrollment
     */
    preferredCiphers: string;
    /**
     * Enable QUIC protocol
     */
    quicEnabled: boolean;
}

export interface GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication {
    /**
     * Enable the OCSP stapling
     */
    ocspEnabled: boolean;
    /**
     * Enable the server to send the certificate authority (CA) list to the client
     */
    sendCaListToClient: boolean;
    /**
     * The identifier of the set of trust chains, created in the Trust Chain Manager
     */
    setId: string;
}

export interface GetCPSEnrollmentsEnrollmentOrganization {
    /**
     * The address of organization
     */
    addressLineOne: string;
    /**
     * The address of organization
     */
    addressLineTwo: string;
    /**
     * City where organization is located
     */
    city: string;
    /**
     * Country code of country where organization is located
     */
    countryCode: string;
    /**
     * Name of organization
     */
    name: string;
    /**
     * The phone number of the administrator who is organization contact
     */
    phone: string;
    /**
     * The postal code of organization
     */
    postalCode: string;
    /**
     * The region where organization resides
     */
    region: string;
}

export interface GetCPSEnrollmentsEnrollmentTechContact {
    /**
     * The address of the contact
     */
    addressLineOne?: string;
    /**
     * The address of the contact
     */
    addressLineTwo?: string;
    /**
     * City of residence of the contact
     */
    city?: string;
    /**
     * Country code of the contact
     */
    countryCode?: string;
    /**
     * E-mail address of the contact
     */
    email: string;
    /**
     * First name of the contact
     */
    firstName: string;
    /**
     * Last name of the contact
     */
    lastName: string;
    /**
     * Organization where contact is hired
     */
    organization?: string;
    /**
     * Phone number of the contact
     */
    phone: string;
    /**
     * Postal code of the contact
     */
    postalCode?: string;
    /**
     * The region of the contact
     */
    region?: string;
    /**
     * Title of the the contact
     */
    title?: string;
}

export interface GetClientlistListsList {
    /**
     * The client list creation date.
     */
    createDate: string;
    /**
     * The username of the user who created the client list.
     */
    createdBy: string;
    /**
     * Whether the client list was removed.
     */
    deprecated: boolean;
    /**
     * The number of items that a client list contains.
     */
    itemsCount: number;
    /**
     * The ID of the client list.
     */
    listId: string;
    /**
     * The client list type.
     */
    listType: string;
    /**
     * The name of the client list
     */
    name?: string;
    /**
     * The client list notes
     */
    notes: string;
    /**
     * The activation status in production environment.
     */
    productionActivationStatus: string;
    /**
     * Whether the client is editable for the authenticated user.
     */
    readOnly: boolean;
    /**
     * Whether the client list is shared.
     */
    shared: boolean;
    /**
     * The activation status in staging environment.
     */
    stagingActivationStatus: string;
    /**
     * The client list tags
     */
    tags: string[];
    /**
     * The type of the client list
     */
    type?: string;
    /**
     * The date of last update.
     */
    updateDate: string;
    /**
     * The username of the user that updated the client list last.
     */
    updatedBy: string;
    /**
     * The current version of the client list.
     */
    version: number;
}

export interface GetCloudaccessKeyGroup {
    /**
     * The Akamai contracts that are associated with this access key for the group_id.
     */
    contractsIds: string[];
    /**
     * The unique identifier of Akamai group that's associated with the access key.
     */
    groupId: number;
    /**
     * The name of Akamai group that's associated with the access key.
     */
    groupName: string;
}

export interface GetCloudaccessKeyNetworkConfiguration {
    /**
     * The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
     */
    additionalCdn: string;
    /**
     * Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
     */
    securityNetwork: string;
}

export interface GetCloudaccessKeyPropertiesProperty {
    /**
     * Version of the access key.
     */
    accessKeyVersion: number;
    /**
     * Identifies the specific property version whose production status is either active or activating.
     */
    productionVersion: number;
    /**
     * The unique identifier Akamai assigned to the matching property.
     */
    propertyId: string;
    /**
     * Identifies the specific property name whose Origin Characteristics behavior uses the access key version.
     */
    propertyName: string;
    /**
     * Identifies the specific property version whose staging status is either active or activating.
     */
    stagingVersion: number;
}

export interface GetCloudaccessKeyVersionsAccessKeyVersion {
    /**
     * The unique identifier assigned to the access key assigned from AWS or GCS.
     */
    cloudAccessKeyId: string;
    /**
     * The username of the person who created the access key.
     */
    createdBy: string;
    /**
     * The time the access key was created, in ISO 8601 format.
     */
    createdTime: string;
    /**
     * Indicates if the version has been activated to the Akamai networks. Available statuses are: PENDING_DELETION, ACTIVE and PENDING_ACTIVATION.
     */
    deploymentStatus: string;
    /**
     * Version of the access key.
     */
    version: number;
    /**
     * The unique identifier assigned to an access key version.
     */
    versionGuid: string;
}

export interface GetCloudaccessKeysAccessKey {
    /**
     * Name of the access key.
     */
    accessKeyName: string;
    /**
     * Identifier of the retrieved access key.
     */
    accessKeyUid: number;
    /**
     * The type of signing process used to authenticate API requests: AWS4_HMAC_SHA256 for Amazon Web Services or GOOG4_HMAC_SHA256 for Google Cloud Services in interoperability mode.
     */
    authenticationMethod: string;
    /**
     * The username of the person who created the access key.
     */
    createdBy: string;
    /**
     * The time the access key was created, in ISO 8601 format.
     */
    createdTime: string;
    /**
     * A list of groups to which the access key is assigned.
     */
    groups: outputs.GetCloudaccessKeysAccessKeyGroup[];
    /**
     * The most recent version of the access key.
     */
    latestVersion: number;
    /**
     * The API deploys the access key to this secure network.
     */
    networkConfiguration: outputs.GetCloudaccessKeysAccessKeyNetworkConfiguration;
}

export interface GetCloudaccessKeysAccessKeyGroup {
    /**
     * The Akamai contracts that are associated with this access key for the group_id.
     */
    contractsIds: string[];
    /**
     * The unique identifier of Akamai group that's associated with the access key.
     */
    groupId: number;
    /**
     * The name of Akamai group that's associated with the access key.
     */
    groupName: string;
}

export interface GetCloudaccessKeysAccessKeyNetworkConfiguration {
    /**
     * The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
     */
    additionalCdn: string;
    /**
     * Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
     */
    securityNetwork: string;
}

export interface GetCloudletsApiPrioritizationMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatch[];
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
     */
    passThroughPercent: number;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsApiPrioritizationMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple type)
     */
    values?: string[];
}

export interface GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsApplicationLoadBalancerDataCenter {
    /**
     * The city in which the data center is located.
     */
    city: string;
    /**
     * Describes if cloud server host header is overridden
     */
    cloudServerHostHeaderOverride: boolean;
    /**
     * Describes if this datacenter is a cloud service
     */
    cloudService: boolean;
    /**
     * The continent on which the data center is located
     */
    continent: string;
    /**
     * The country in which the data center is located
     */
    country: string;
    /**
     * This should match the 'hostname' value defined for this datacenter in Property Manager
     */
    hostname: string;
    /**
     * The latitude value for the data center. This member supports six decimal places of precision.
     */
    latitude: number;
    /**
     * An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
     */
    livenessHosts: string[];
    /**
     * The longitude value for the data center. This member supports six decimal places of precision.
     */
    longitude: number;
    /**
     * The id of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
     */
    originId: string;
    /**
     * The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     */
    percent: number;
    /**
     * The state, province, or region where the data center is located
     */
    stateOrProvince: string;
}

export interface GetCloudletsApplicationLoadBalancerLivenessSetting {
    /**
     * Maps additional case-insensitive HTTP header names included to the liveness testing requests
     */
    additionalHeaders: {[key: string]: string};
    /**
     * The Host header for the liveness HTTP request
     */
    hostHeader: string;
    /**
     * Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
     */
    interval: number;
    /**
     * The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     */
    path: string;
    /**
     * Describes whether or not to validate the origin certificate for an HTTPS request
     */
    peerCertificateVerification: boolean;
    /**
     * The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     */
    port: number;
    /**
     * The protocol or scheme for the database, either HTTP or HTTPS.
     */
    protocol: string;
    /**
     * The request which will be used for TCP(S) tests
     */
    requestString: string;
    /**
     * The response which will be used for TCP(S) tests
     */
    responseString: string;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
     */
    status3xxFailure: boolean;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
     */
    status4xxFailure: boolean;
    /**
     * Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
     */
    status5xxFailure: boolean;
    /**
     * The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
     */
    timeout: number;
}

export interface GetCloudletsApplicationLoadBalancerMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
     */
    forwardSettings: outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting[];
    /**
     * Akamai internal use only
     */
    id?: number;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch[];
    /**
     * Is used in some cloudlets to support default rules (rule that is always matched)
     */
    matchesAlways?: boolean;
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting {
    /**
     * The ID of the Conditional Origin requests are forwarded to
     */
    originId: string;
}

export interface GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
     */
    objectMatchValues?: outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple or range type)
     */
    values?: string[];
}

export interface GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsAudienceSegmentationMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
     */
    forwardSettings: outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatch[];
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings {
    /**
     * The ID of the Conditional Origin requests are forwarded to
     */
    originId?: string;
    /**
     * If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
     */
    pathAndQs?: string;
    /**
     * If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
     */
    useIncomingQueryString?: boolean;
}

export interface GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple or range type)
     */
    values?: string[];
}

export interface GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsEdgeRedirectorMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatch[];
    /**
     * Is used in some cloudlets to support default rules (rule that is always matched)
     */
    matchesAlways?: boolean;
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
     */
    redirectUrl: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
     */
    statusCode: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
    /**
     * If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
     */
    useIncomingQueryString?: boolean;
    /**
     * If set to relative_url, takes the path entered for the redirectUrl and sets it in the response’s Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirectUrl should be fully-qualified URL
     */
    useRelativeUrl?: string;
}

export interface GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple type)
     */
    values?: string[];
}

export interface GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsForwardRewriteMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
     */
    forwardSettings: outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatch[];
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings {
    /**
     * The ID of the Conditional Origin requests are forwarded to
     */
    originId?: string;
    /**
     * If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
     */
    pathAndQs?: string;
    /**
     * If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
     */
    useIncomingQueryString?: boolean;
}

export interface GetCloudletsForwardRewriteMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple or range type)
     */
    values?: string[];
}

export interface GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsPhasedReleaseMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
     */
    forwardSettings: outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatch[];
    /**
     * Is used in some cloudlets to support default rules (rule that is always matched)
     */
    matchesAlways?: boolean;
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
     */
    type: string;
}

export interface GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings {
    /**
     * The ID of the Conditional Origin requests are forwarded to
     */
    originId: string;
    /**
     * The percent of traffic that is sent to the data center.
     */
    percent: number;
}

export interface GetCloudletsPhasedReleaseMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple or range type)
     */
    values?: string[];
}

export interface GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsPolicyActivation {
    /**
     * The specific version of this API
     */
    apiVersion: string;
    /**
     * The network type, either 'staging' or 'prod' where a property or a Cloudlet policy has been activated
     */
    network: string;
    /**
     * The object containing Cloudlet policy information
     */
    policyInfos: outputs.GetCloudletsPolicyActivationPolicyInfo[];
    /**
     * A set containing information about the property associated with a particular Cloudlet policy
     */
    propertyInfos: outputs.GetCloudletsPolicyActivationPropertyInfo[];
}

export interface GetCloudletsPolicyActivationPolicyInfo {
    /**
     * The name of the user who activated the policy
     */
    activatedBy: string;
    /**
     * The date on which the policy was activated (in milliseconds since Epoch)
     */
    activationDate: number;
    /**
     * The name of the policy
     */
    name: string;
    /**
     * An integer ID that is associated with all versions of a policy
     */
    policyId: number;
    /**
     * The activation status for the policy: active, inactive, deactivated, pending or failed
     */
    status: string;
    /**
     * Information about the status of an activation operation
     */
    statusDetail: string;
    /**
     * The version number of the activated policy
     */
    version: number;
}

export interface GetCloudletsPolicyActivationPropertyInfo {
    /**
     * The name of the user who activated the property
     */
    activatedBy: string;
    /**
     * The date on which the property was activated (in milliseconds since Epoch)
     */
    activationDate: number;
    /**
     * Defines the group association for the policy or property
     */
    groupId: number;
    /**
     * The name of the property
     */
    name: string;
    /**
     * The activation status for the property. Can be active, inactive, deactivated, pending or failed
     */
    status: string;
    /**
     * The version number of the activated property
     */
    version: number;
}

export interface GetCloudletsRequestControlMatchRuleMatchRule {
    /**
     * If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
     */
    allowDeny: string;
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatch[];
    /**
     * Is used in some cloudlets to support default rules (rule that is always matched)
     */
    matchesAlways?: boolean;
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsRequestControlMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple type)
     */
    values?: string[];
}

export interface GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudletsSharedPolicyActivations {
    /**
     * The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
     */
    production?: outputs.GetCloudletsSharedPolicyActivationsProduction;
    /**
     * The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
     */
    staging?: outputs.GetCloudletsSharedPolicyActivationsStaging;
}

export interface GetCloudletsSharedPolicyActivationsProduction {
    /**
     * The status of the activation that's currently in use on this network, or null if the policy has no activations.
     */
    effective?: outputs.GetCloudletsSharedPolicyActivationsProductionEffective;
    /**
     * The status of the latest activation or null if the policy has no activations.
     */
    latest?: outputs.GetCloudletsSharedPolicyActivationsProductionLatest;
}

export interface GetCloudletsSharedPolicyActivationsProductionEffective {
    /**
     * Identifies the activation.
     */
    activationId: number;
    /**
     * The username who created the activation.
     */
    createdBy: string;
    /**
     * ISO 8601 timestamp indicating when the activation was created.
     */
    createdDate: string;
    /**
     * ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
     */
    finishDate: string;
    /**
     * The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
     */
    network: string;
    /**
     * The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
     */
    operation: string;
    /**
     * Identifies the shared policy.
     */
    policyId: number;
    /**
     * The number of the policy version.
     */
    policyVersion: number;
    /**
     * Indicates if the policy version is deleted.
     */
    policyVersionDeleted: boolean;
    /**
     * The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
     */
    status: string;
}

export interface GetCloudletsSharedPolicyActivationsProductionLatest {
    /**
     * Identifies the activation.
     */
    activationId: number;
    /**
     * The username who created the activation.
     */
    createdBy: string;
    /**
     * ISO 8601 timestamp indicating when the activation was created.
     */
    createdDate: string;
    /**
     * ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
     */
    finishDate: string;
    /**
     * The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
     */
    network: string;
    /**
     * The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
     */
    operation: string;
    /**
     * Identifies the shared policy.
     */
    policyId: number;
    /**
     * The number of the policy version.
     */
    policyVersion: number;
    /**
     * Indicates if the policy version is deleted.
     */
    policyVersionDeleted: boolean;
    /**
     * The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
     */
    status: string;
}

export interface GetCloudletsSharedPolicyActivationsStaging {
    /**
     * The status of the activation that's currently in use on this network, or null if the policy has no activations.
     */
    effective?: outputs.GetCloudletsSharedPolicyActivationsStagingEffective;
    /**
     * The status of the latest activation or null if the policy has no activations.
     */
    latest?: outputs.GetCloudletsSharedPolicyActivationsStagingLatest;
}

export interface GetCloudletsSharedPolicyActivationsStagingEffective {
    /**
     * Identifies the activation.
     */
    activationId: number;
    /**
     * The username who created the activation.
     */
    createdBy: string;
    /**
     * ISO 8601 timestamp indicating when the activation was created.
     */
    createdDate: string;
    /**
     * ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
     */
    finishDate: string;
    /**
     * The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
     */
    network: string;
    /**
     * The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
     */
    operation: string;
    /**
     * Identifies the shared policy.
     */
    policyId: number;
    /**
     * The number of the policy version.
     */
    policyVersion: number;
    /**
     * Indicates if the policy version is deleted.
     */
    policyVersionDeleted: boolean;
    /**
     * The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
     */
    status: string;
}

export interface GetCloudletsSharedPolicyActivationsStagingLatest {
    /**
     * Identifies the activation.
     */
    activationId: number;
    /**
     * The username who created the activation.
     */
    createdBy: string;
    /**
     * ISO 8601 timestamp indicating when the activation was created.
     */
    createdDate: string;
    /**
     * ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
     */
    finishDate: string;
    /**
     * The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
     */
    network: string;
    /**
     * The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
     */
    operation: string;
    /**
     * Identifies the shared policy.
     */
    policyId: number;
    /**
     * The number of the policy version.
     */
    policyVersion: number;
    /**
     * Indicates if the policy version is deleted.
     */
    policyVersionDeleted: boolean;
    /**
     * The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
     */
    status: string;
}

export interface GetCloudletsVisitorPrioritizationMatchRuleMatchRule {
    /**
     * If set to true, disables a rule so it is not evaluated against incoming requests.
     */
    disabled?: boolean;
    /**
     * The end time for this match (in seconds since the epoch)
     */
    end?: number;
    /**
     * If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
     */
    matchUrl?: string;
    /**
     * Defines a set of match objects
     */
    matches?: outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch[];
    /**
     * The name of the rule
     */
    name?: string;
    /**
     * The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
     */
    passThroughPercent: number;
    /**
     * The start time for this match (in seconds since the epoch)
     */
    start?: number;
    /**
     * The type of Cloudlet the rule is for
     */
    type: string;
}

export interface GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch {
    /**
     * If true, the match is case sensitive
     */
    caseSensitive?: boolean;
    /**
     * For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
     */
    checkIps?: string;
    /**
     * Valid entries for this property: contains, exists, and equals
     */
    matchOperator?: string;
    /**
     * The type of match used
     */
    matchType?: string;
    /**
     * Depends on the matchType
     */
    matchValue?: string;
    /**
     * If true, negates the match
     */
    negate?: boolean;
    /**
     * An object used when a rule either includes more complex match criteria, like multiple value attributes
     */
    objectMatchValues?: outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue[];
}

export interface GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue {
    /**
     * If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
     */
    name?: string;
    /**
     * Set to true if the entry for the name property should be evaluated based on case sensitivity
     */
    nameCaseSensitive?: boolean;
    /**
     * Set to true if the entry for the name property includes wildcards
     */
    nameHasWildcard?: boolean;
    /**
     * If using the object type, use this set to list the values to match on (use only with the object type)
     */
    options?: outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions;
    /**
     * The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
     */
    type: string;
    /**
     * The value attributes in the incoming request to match on (use only with simple type)
     */
    values?: string[];
}

export interface GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions {
    /**
     * Set to true if the entries for the value property should be evaluated based on case sensitivity
     */
    valueCaseSensitive?: boolean;
    /**
     * Set to true if provided value should be compared in escaped form
     */
    valueEscaped?: boolean;
    /**
     * Set to true if the entries for the value property include wildcards
     */
    valueHasWildcard?: boolean;
    /**
     * The value attributes in the incoming request to match on
     */
    values?: string[];
}

export interface GetCloudwrapperCapacitiesCapacity {
    /**
     * Capacity allocated for the location.
     */
    approved: outputs.GetCloudwrapperCapacitiesCapacityApproved;
    /**
     * Capacity already assigned to Cloud Wrapper configurations.
     */
    assigned: outputs.GetCloudwrapperCapacitiesCapacityAssigned;
    /**
     * Contract ID having Cloud Wrapper entitlement.
     */
    contractId: string;
    /**
     * Unique identifier of the configured location.
     */
    locationId: number;
    /**
     * Name of the location.
     */
    locationName: string;
    /**
     * The type of property this capacity is related to.
     */
    type: string;
    /**
     * Capacity value that can be assigned to Cloud Wrapper configurations.
     */
    unassigned: outputs.GetCloudwrapperCapacitiesCapacityUnassigned;
}

export interface GetCloudwrapperCapacitiesCapacityApproved {
    unit: string;
    value: number;
}

export interface GetCloudwrapperCapacitiesCapacityAssigned {
    unit: string;
    value: number;
}

export interface GetCloudwrapperCapacitiesCapacityUnassigned {
    unit: string;
    value: number;
}

export interface GetCloudwrapperConfigurationLocation {
    /**
     * The capacity assigned to this configuration's location.
     */
    capacity: outputs.GetCloudwrapperConfigurationLocationCapacity;
    /**
     * Additional comments provided by user.
     */
    comments: string;
    /**
     * The name of the map.
     */
    mapName: string;
    /**
     * Unique identifier for the location and traffic type combination.
     */
    trafficTypeId: number;
}

export interface GetCloudwrapperConfigurationLocationCapacity {
    unit: string;
    value: number;
}

export interface GetCloudwrapperConfigurationMultiCdnSettings {
    /**
     * Specify diagnostic data beacons details.
     */
    bocc?: outputs.GetCloudwrapperConfigurationMultiCdnSettingsBocc;
    /**
     * List of CDN added for the configuration.
     */
    cdns?: outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdn[];
    /**
     * Specifies data streams details.
     */
    dataStreams?: outputs.GetCloudwrapperConfigurationMultiCdnSettingsDataStreams;
    /**
     * Option to opt out of alerts based on soft limits of bandwidth usage.
     */
    enableSoftAlerts: boolean;
    /**
     * List of origins corresponding to the properties selected in the configuration.
     */
    origins?: outputs.GetCloudwrapperConfigurationMultiCdnSettingsOrigin[];
}

export interface GetCloudwrapperConfigurationMultiCdnSettingsBocc {
    /**
     * The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
     */
    conditionalSamplingFrequency: string;
    /**
     * Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
     */
    enabled: boolean;
    /**
     * Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
     */
    forwardType: string;
    /**
     * Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
     */
    requestType: string;
    /**
     * The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
     */
    samplingFrequency: string;
}

export interface GetCloudwrapperConfigurationMultiCdnSettingsCdn {
    /**
     * List of auth keys configured for the CDN.
     */
    cdnAuthKeys?: outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKey[];
    /**
     * Unique identifier for the CDN.
     */
    cdnCode: string;
    /**
     * Enable CDN.
     */
    enabled: boolean;
    /**
     * Specify whether CDN communication is HTTPS only.
     */
    httpsOnly: boolean;
    /**
     * Configure an access control list using IP addresses in CIDR notation.
     */
    ipAclCidrs: string[];
}

export interface GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKey {
    /**
     * The name of the auth key.
     */
    authKeyName: string;
    /**
     * The expirty date of an auth key.
     */
    expiryDate: string;
    /**
     * The header name of an auth key.
     */
    headerName: string;
    /**
     * The secret of an auth key.
     */
    secret: string;
}

export interface GetCloudwrapperConfigurationMultiCdnSettingsDataStreams {
    /**
     * Unique identifiers of the Data Streams.
     */
    dataStreamIds: number[];
    /**
     * Enables DataStream reporting.
     */
    enabled: boolean;
    /**
     * Specifies the percentage of log data you want to collect for this configuration.
     */
    samplingRate: number;
}

export interface GetCloudwrapperConfigurationMultiCdnSettingsOrigin {
    /**
     * Origins hostname corresponding to the Akamai Delivery Property.
     */
    hostname: string;
    /**
     * Origin identifier and will be used to generated Multi CDN host names.
     */
    originId: string;
    /**
     * Property ID of the property that origin belongs to.
     */
    propertyId: number;
}

export interface GetCloudwrapperConfigurationsConfiguration {
    /**
     * Represents the threshold for sending alerts.
     */
    capacityAlertsThreshold: number;
    /**
     * Additional information provided by user which can help to differentiate or track changes of the configuration.
     */
    comments: string;
    /**
     * Name of the configuration.
     */
    configName: string;
    /**
     * Contract ID with Cloud Wrapper entitlement.
     */
    contractId: string;
    /**
     * Unique identifier of a Cloud Wrapper configuration.
     */
    id: number;
    /**
     * User to last activate the configuration.
     */
    lastActivatedBy: string;
    /**
     * ISO format date that represents when the configuration was last activated successfully.
     */
    lastActivatedDate: string;
    /**
     * User to last modify the configuration.
     */
    lastUpdatedBy: string;
    /**
     * ISO format date that represents when the configuration was last edited.
     */
    lastUpdatedDate: string;
    /**
     * List of all unused properties.
     */
    locations?: outputs.GetCloudwrapperConfigurationsConfigurationLocation[];
    /**
     * Specify details about the Multi CDN settings.
     */
    multiCdnSettings?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettings;
    /**
     * Email addresses to receive notifications.
     */
    notificationEmails: string[];
    /**
     * List of properties belonging to media delivery products. Properties need to be unique across configurations.
     */
    propertyIds: string[];
    /**
     * Retain idle objects beyond their max idle lifetime.
     */
    retainIdleObjects: boolean;
    /**
     * Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
     */
    status: string;
}

export interface GetCloudwrapperConfigurationsConfigurationLocation {
    /**
     * The capacity assigned to this configuration's location.
     */
    capacity: outputs.GetCloudwrapperConfigurationsConfigurationLocationCapacity;
    /**
     * Additional comments provided by user.
     */
    comments: string;
    /**
     * The name of the map.
     */
    mapName: string;
    /**
     * Unique identifier for the location and traffic type combination.
     */
    trafficTypeId: number;
}

export interface GetCloudwrapperConfigurationsConfigurationLocationCapacity {
    unit: string;
    value: number;
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettings {
    /**
     * Specify diagnostic data beacons details.
     */
    bocc?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBocc;
    /**
     * List of CDN added for the configuration.
     */
    cdns?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdn[];
    /**
     * Specifies data streams details.
     */
    dataStreams?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreams;
    /**
     * Option to opt out of alerts based on soft limits of bandwidth usage.
     */
    enableSoftAlerts: boolean;
    /**
     * List of origins corresponding to the properties selected in the configuration.
     */
    origins?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOrigin[];
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBocc {
    /**
     * The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
     */
    conditionalSamplingFrequency: string;
    /**
     * Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
     */
    enabled: boolean;
    /**
     * Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
     */
    forwardType: string;
    /**
     * Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
     */
    requestType: string;
    /**
     * The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
     */
    samplingFrequency: string;
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdn {
    /**
     * List of auth keys configured for the CDN.
     */
    cdnAuthKeys?: outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKey[];
    /**
     * Unique identifier for the CDN.
     */
    cdnCode: string;
    /**
     * Enable CDN.
     */
    enabled: boolean;
    /**
     * Specify whether CDN communication is HTTPS only.
     */
    httpsOnly: boolean;
    /**
     * Configure an access control list using IP addresses in CIDR notation.
     */
    ipAclCidrs: string[];
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKey {
    /**
     * The name of the auth key.
     */
    authKeyName: string;
    /**
     * The expirty date of an auth key.
     */
    expiryDate: string;
    /**
     * The header name of an auth key.
     */
    headerName: string;
    /**
     * The secret of an auth key.
     */
    secret: string;
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreams {
    /**
     * Unique identifiers of the Data Streams.
     */
    dataStreamIds: number[];
    /**
     * Enables DataStream reporting.
     */
    enabled: boolean;
    /**
     * Specifies the percentage of log data you want to collect for this configuration.
     */
    samplingRate: number;
}

export interface GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOrigin {
    /**
     * Origins hostname corresponding to the Akamai Delivery Property.
     */
    hostname: string;
    /**
     * Origin identifier and will be used to generated Multi CDN host names.
     */
    originId: string;
    /**
     * Property ID of the property that origin belongs to.
     */
    propertyId: number;
}

export interface GetCloudwrapperLocationsLocation {
    /**
     * Unique identifier of the location.
     */
    locationId: number;
    /**
     * Name of the location.
     */
    locationName: string;
    /**
     * Unique identifier of the multi CDN location.
     */
    multiCdnLocationId: string;
    /**
     * List of traffic types for the location.
     */
    trafficTypes?: outputs.GetCloudwrapperLocationsLocationTrafficType[];
}

export interface GetCloudwrapperLocationsLocationTrafficType {
    /**
     * Represents the failover map.
     */
    locationId: string;
    /**
     * Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
     */
    trafficType: string;
    /**
     * Unique identifier for the location and traffic type combination.
     */
    trafficTypeId: number;
}

export interface GetCloudwrapperPropertiesProperty {
    /**
     * Contract ID having Cloud Wrapper entitlement.
     */
    contractId: string;
    /**
     * ID of the group which the property belongs to.
     */
    groupId: number;
    /**
     * Property ID of the property.
     */
    propertyId: number;
    /**
     * Name of the property belonging to the origin.
     */
    propertyName: string;
    /**
     * The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
     */
    type: string;
}

export interface GetContractsContract {
    contractId: string;
    contractTypeName: string;
}

export interface GetCpCodesCpCode {
    /**
     * The ID of a specific CP code.
     */
    cpCodeId: string;
    /**
     * The date and time when the CP code was created.
     */
    createdDate: string;
    /**
     * Name of the CP code.
     */
    name: string;
    /**
     * A list of of product IDs for a given CP code.
     */
    productIds: string[];
}

export interface GetDatastreamActivationHistoryActivation {
    /**
     * The username who activated or deactivated the stream
     */
    modifiedBy: string;
    /**
     * The date and time when activation status was modified
     */
    modifiedDate: string;
    /**
     * Stream Status
     */
    status: string;
    /**
     * Identifies the stream
     */
    streamId: number;
    /**
     * Identifies the version of the stream
     */
    streamVersion: number;
}

export interface GetDatastreamDatasetFieldsDatasetField {
    /**
     * Describes the data set field
     */
    datasetFieldDescription: string;
    /**
     * A name of the group for data set field
     */
    datasetFieldGroup: string;
    /**
     * Identifies the field
     */
    datasetFieldId: number;
    /**
     * Specifies the JSON key for the field in a log line
     */
    datasetFieldJsonKey: string;
    /**
     * A name of the data set field
     */
    datasetFieldName: string;
}

export interface GetDatastreamsStreamsDetail {
    /**
     * Identifies the contract that the stream is associated with.
     */
    contractId: string;
    /**
     * The username who created the stream.
     */
    createdBy: string;
    /**
     * The date and time when the stream was created.
     */
    createdDate: string;
    /**
     * Identifies the group where the stream is created.
     */
    groupId: number;
    /**
     * Identifies the latestVersion version of the stream.
     */
    latestVersion: number;
    /**
     * The username who activated or deactivated the stream
     */
    modifiedBy: string;
    /**
     * The date and time when activation status was modified
     */
    modifiedDate: string;
    /**
     * The productId.
     */
    productId: string;
    /**
     * List of properties associated with the stream.
     */
    properties: outputs.GetDatastreamsStreamsDetailProperty[];
    /**
     * Identifies the stream.
     */
    streamId: number;
    /**
     * The name of the stream.
     */
    streamName: string;
    /**
     * The activation status of the stream.
     */
    streamStatus: string;
    /**
     * Identifies the current version of the stream.
     */
    streamVersion: number;
}

export interface GetDatastreamsStreamsDetailProperty {
    /**
     * The identifier of the property.
     */
    propertyId: number;
    /**
     * The descriptive label for the property.
     */
    propertyName: string;
}

export interface GetGroupsGroup {
    contractIds: string[];
    groupId: string;
    groupName: string;
    parentGroupId: string;
}

export interface GetGtmAsmapAssignment {
    /**
     * Specifies an array of AS numbers.
     */
    asNumbers: number[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for the group.
     */
    nickname: string;
}

export interface GetGtmAsmapDefaultDatacenter {
    /**
     * For each property, an identifier for all other AS zones
     */
    datacenterId: number;
    /**
     * A descriptive label for all other AS zones
     */
    nickname: string;
}

export interface GetGtmAsmapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmCidrmapAssignment {
    /**
     * Specifies an array of CIDR blocks.
     */
    blocks: string[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for the CIDR zone group.
     */
    nickname: string;
}

export interface GetGtmCidrmapDefaultDatacenter {
    /**
     * For each property, an identifier for all other CIDR zones' CNAME.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other CIDR blocks.
     */
    nickname: string;
}

export interface GetGtmCidrmapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDatacenterDefaultLoadObject {
    /**
     * Specifies the load object that GTM requests.
     */
    loadObject: string;
    /**
     * Specifies the TCP port to connect to when requesting the load object.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
}

export interface GetGtmDatacenterLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDatacentersDatacenter {
    /**
     * The name of the city where the data center is located.
     */
    city: string;
    /**
     * Identifies the data center's ID of which this data center is a clone.
     */
    cloneOf: number;
    /**
     * Balances load between two or more servers in a cloud environment.
     */
    cloudServerHostHeaderOverride: boolean;
    /**
     * Balances load between two or more servers in a cloud environment.
     */
    cloudServerTargeting: boolean;
    /**
     * A two-letter code that specifies the continent where the data center maps to.
     */
    continent: string;
    /**
     * A two-letter ISO 3166 country code that specifies the country where the data center is located.
     */
    country: string;
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Specifies the load reporting interface between you and the GTM system.
     */
    defaultLoadObjects: outputs.GetGtmDatacentersDatacenterDefaultLoadObject[];
    /**
     * Specifies the geographic latitude of the data center's position.
     */
    latitude: number;
    /**
     * Provides a URL path that allows direct navigation to a data center.
     */
    links: outputs.GetGtmDatacentersDatacenterLink[];
    /**
     * Specifies the geographic longitude of the data center's position.
     */
    longitude: number;
    /**
     * A descriptive label for the datacenter.
     */
    nickname: string;
    /**
     * Influences the score for a datacenter.
     */
    scorePenalty: number;
    /**
     * The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.)
     */
    servermonitorPool: string;
    /**
     * Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
     */
    stateOrProvince: string;
    /**
     * Indicates whether or not the data center is virtual or physical.
     */
    virtual: boolean;
}

export interface GetGtmDatacentersDatacenterDefaultLoadObject {
    /**
     * Specifies the load object that GTM requests.
     */
    loadObject: string;
    /**
     * Specifies the TCP port to connect to when requesting the load object.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
}

export interface GetGtmDatacentersDatacenterLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainAsMap {
    /**
     * Contains information about the AS zone groupings of AS IDs.
     */
    assignments?: outputs.GetGtmDomainAsMapAssignment[];
    /**
     * A placeholder for all other AS zones, AS IDs not found in these AS zones.
     */
    defaultDatacenter?: outputs.GetGtmDomainAsMapDefaultDatacenter;
    /**
     * Specifies the URL path that allows direct navigation to the As map.
     */
    links?: outputs.GetGtmDomainAsMapLink[];
    /**
     * A descriptive label for the AS map.
     */
    name: string;
}

export interface GetGtmDomainAsMapAssignment {
    /**
     * Specifies an array of AS numbers.
     */
    asNumbers: number[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other AS zones.
     */
    nickname: string;
}

export interface GetGtmDomainAsMapDefaultDatacenter {
    /**
     * For each property, an identifier for all other AS zones' CNAME.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other AS zones.
     */
    nickname: string;
}

export interface GetGtmDomainAsMapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainCidrMap {
    /**
     * Contains information about the CIDR zone groupings of CIDR blocks.
     */
    assignments?: outputs.GetGtmDomainCidrMapAssignment[];
    /**
     * A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
     */
    defaultDatacenter?: outputs.GetGtmDomainCidrMapDefaultDatacenter;
    /**
     * Specifies the URL path that allows direct navigation to the CIDR map.
     */
    links?: outputs.GetGtmDomainCidrMapLink[];
    /**
     * Unique name for the CIDR map.
     */
    name: string;
}

export interface GetGtmDomainCidrMapAssignment {
    /**
     * Specifies an array of CIDR blocks.
     */
    blocks: string[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other AS zones.
     */
    nickname: string;
}

export interface GetGtmDomainCidrMapDefaultDatacenter {
    /**
     * For each property, an identifier for all other CIDR zones' CNAME.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other CIDR blocks.
     */
    nickname: string;
}

export interface GetGtmDomainCidrMapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainDatacenter {
    /**
     * The name of the city where the data center is located.
     */
    city: string;
    /**
     * Identifies the data center's ID of which this data center is a clone.
     */
    cloneOf: number;
    /**
     * Balances load between two or more servers in a cloud environment.
     */
    cloudServerHostHeaderOverride: boolean;
    /**
     * Balances load between two or more servers in a cloud environment.
     */
    cloudServerTargeting: boolean;
    /**
     * A two-letter code that specifies the continent where the data center maps to.
     */
    continent: string;
    /**
     * A two-letter ISO 3166 country code that specifies the country where the data center is located.
     */
    country: string;
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Specifies the load reporting interface between you and the GTM system.
     */
    defaultLoadObjects?: outputs.GetGtmDomainDatacenterDefaultLoadObject[];
    /**
     * Specifies the geographic latitude of the data center's position.
     */
    latitude: number;
    /**
     * Provides a URL path that allows direct navigation to a data center.
     */
    links?: outputs.GetGtmDomainDatacenterLink[];
    /**
     * Specifies the geographic longitude of the data center's position.
     */
    longitude: number;
    /**
     * A descriptive label for the datacenter.
     */
    nickname: string;
    /**
     * Influences the score for a datacenter.
     */
    scorePenalty: number;
    /**
     * The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
     */
    serverMonitorPool: string;
    /**
     * Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
     */
    stateOrProvince: string;
    /**
     * Indicates whether or not the data center is virtual or physical.
     */
    virtual: boolean;
}

export interface GetGtmDomainDatacenterDefaultLoadObject {
    /**
     * Specifies the load object that GTM requests.
     */
    loadObject: string;
    /**
     * Specifies the TCP port to connect to when requesting the load object.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
}

export interface GetGtmDomainDatacenterLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainGeographicMap {
    /**
     * Contains information about the geographic zone groupings of countries.
     */
    assignments?: outputs.GetGtmDomainGeographicMapAssignment[];
    /**
     * A placeholder for all other geographic zones, countries not found in these geographic zones.
     */
    defaultDatacenter?: outputs.GetGtmDomainGeographicMapDefaultDatacenter;
    /**
     * Specifies the URL path that allows direct navigation to the geographic map.
     */
    links?: outputs.GetGtmDomainGeographicMapLink[];
    /**
     * A descriptive label for the geographic map.
     */
    name: string;
}

export interface GetGtmDomainGeographicMapAssignment {
    /**
     * Specifies an array of two-letter ISO 3166 `country` codes.
     */
    countries: string[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other AS zones.
     */
    nickname: string;
}

export interface GetGtmDomainGeographicMapDefaultDatacenter {
    /**
     * An identifier for all other geographic zones' CNAME.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other geographic zones.
     */
    nickname: string;
}

export interface GetGtmDomainGeographicMapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainProperty {
    /**
     * Specifies a backup CNAME.
     */
    backupCname: string;
    /**
     * Specifies a backup IP.
     */
    backupIp: string;
    /**
     * Indicates whether download score based load balancing is enabled.
     */
    balanceByDownloadScore: boolean;
    /**
     * Indicates the fully qualified name aliased to a particular property.
     */
    cname: string;
    /**
     * Descriptive comments for the property.
     */
    comments: string;
    /**
     * Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     */
    dynamicTtl: number;
    /**
     * Specifies the failback delay in seconds.
     */
    failbackDelay: number;
    /**
     * Specifies the failover delay in seconds.
     */
    failoverDelay: number;
    /**
     * Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     */
    ghostDemandReporting: boolean;
    /**
     * Indicates the limit for the number of live IPs handed out to a DNS request.
     */
    handoutLimit: number;
    /**
     * Specifies how IPs are returned when more than one IP is alive and available.
     */
    handoutMode: string;
    /**
     * Defines the absolute limit beyond which IPs are declared unhealthy.
     */
    healthMax: number;
    /**
     * Configures a cutoff value that is computed from the median scores.
     */
    healthMultiplier: number;
    /**
     * Configures a cutoff value that is computed from the median scores.
     */
    healthThreshold: number;
    /**
     * Indicates the type of IP address handed out by a property.
     */
    ipv6: boolean;
    /**
     * An ISO 8601 timestamp that indicates when the property was last changed.
     */
    lastModified: string;
    /**
     * Provides a URL path that allows direct navigation to the property.
     */
    links?: outputs.GetGtmDomainPropertyLink[];
    /**
     * Contains information about liveness tests.
     */
    livenessTests?: outputs.GetGtmDomainPropertyLivenessTest[];
    /**
     * Indicates the percent of load imbalance factor for the domain.
     */
    loadImbalancePercentage: number;
    /**
     * A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
     */
    mapName: string;
    /**
     * For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     */
    maxUnreachablePenalty: number;
    /**
     * Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     */
    minLiveFraction: number;
    /**
     * A descriptive label for the property.
     */
    name: string;
    /**
     * Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     */
    scoreAggregationType: string;
    /**
     * Contains static recordsets.
     */
    staticRrSets?: outputs.GetGtmDomainPropertyStaticRrSet[];
    /**
     * Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
     */
    staticTtl: number;
    /**
     * Specifies a percentage used to configure data center affinity.
     */
    sticknessBonusConstant: number;
    /**
     * Specifies a percentage used to configure data center affinity.
     */
    sticknessBonusPercentage: number;
    /**
     * Traffic targets for the property.
     */
    trafficTargets?: outputs.GetGtmDomainPropertyTrafficTarget[];
    /**
     * Specifies the load balancing behvior for the property.
     */
    type: string;
    /**
     * For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     */
    unreachableThreshold: number;
    /**
     * For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     */
    useComputedTargets: boolean;
    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     */
    weightedHashBitsForIpv4: number;
    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     */
    weightedHashBitsForIpv6: number;
}

export interface GetGtmDomainPropertyLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainPropertyLivenessTest {
    /**
     * List of alternate trust anchors (CA certificates)
     */
    alternateCaCertificates: string[];
    /**
     * If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
     */
    answersRequired: boolean;
    /**
     * Disables warnings when non-standard ports are used.
     */
    disableNonstandardPortWarning: boolean;
    /**
     * Disables the liveness test.
     */
    disabled: boolean;
    /**
     * Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
     */
    errorPenalty: number;
    /**
     * Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
     */
    httpError3xx: boolean;
    /**
     * Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
     */
    httpError4xx: boolean;
    /**
     * Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
     */
    httpError5xx: boolean;
    /**
     * List of HTTP headers for the liveness test.
     */
    httpHeaders?: outputs.GetGtmDomainPropertyLivenessTestHttpHeader[];
    /**
     * Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
     */
    httpMethod: string;
    /**
     * Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
     */
    httpRequestBody: string;
    /**
     * A descriptive name for the liveness test.
     */
    name: string;
    /**
     * Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
     */
    peerCertificateVerification: boolean;
    /**
     * Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
     */
    pre2023SecurityPosture: boolean;
    /**
     * Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
     */
    recursionRequested: boolean;
    /**
     * Specifies a request string.
     */
    requestString: string;
    /**
     * Specifies the query type, if testObjectProtocol is DNS.
     */
    resourceType: string;
    /**
     * Specifies a response string.
     */
    responseString: string;
    /**
     * Indicates a base64-encoded certificate.
     */
    sslClientCertificate: string;
    /**
     * Indicates a base64-encoded private key.
     */
    sslClientPrivateKey: string;
    /**
     * Indicates the interval at which the liveness test is run, in seconds.
     */
    testInterval: number;
    /**
     * Specifies the static text that acts as a stand-in for the data that you're sending on the network.
     */
    testObject: string;
    /**
     * Specifies the test object's password.
     */
    testObjectPassword: string;
    /**
     * Specifies the port number for the testObject.
     */
    testObjectPort: number;
    /**
     * Specifies the test protocol.
     */
    testObjectProtocol: string;
    /**
     * A descriptive name for the testObject.
     */
    testObjectUsername: string;
    /**
     * Specifies the duration of the liveness test before it fails.
     */
    testTimeout: number;
    /**
     * Specifies the timeout penalty score.
     */
    timeoutPenalty: number;
}

export interface GetGtmDomainPropertyLivenessTestHttpHeader {
    /**
     * Name of the HTTP header.
     */
    name: string;
    /**
     * Value of the HTTP header.
     */
    value: string;
}

export interface GetGtmDomainPropertyStaticRrSet {
    /**
     * An array of data strings, representing multiple records within a set.
     */
    rdatas: string[];
    /**
     * The number of seconds that this record should live in a resolver's cache before being refetched.
     */
    ttl: number;
    /**
     * The record type.
     */
    type: string;
}

export interface GetGtmDomainPropertyTrafficTarget {
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Indicates whether the traffic target is used.
     */
    enabled: boolean;
    /**
     * Specifies an optional data center for the property.
     */
    handoutCname: string;
    /**
     * An alternative label for the traffic target.
     */
    name: string;
    /**
     * Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
     */
    precedence: number;
    /**
     * Identifies the IP address or the hostnames of the servers.
     */
    servers: string[];
    /**
     * Specifies the traffic target weight for the target.
     */
    weight: number;
}

export interface GetGtmDomainResource {
    /**
     * Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
     */
    aggregationType: string;
    /**
     * Specifies the name of the property that this resource constraints.
     */
    constrainedProperty: string;
    /**
     * For internal use only.
     */
    decayRate: number;
    /**
     * A descriptive note to help you track what the resource constraints.
     */
    description: string;
    /**
     * Specifies the host header used when fetching the load object.
     */
    hostHeader: string;
    /**
     * Specifies the text that comes before the loadObject.
     */
    leaderString: string;
    /**
     * For internal use only.
     */
    leastSquaresDecay: number;
    /**
     * Specifies the URL path that allows direct navigation to the resource.
     */
    links?: outputs.GetGtmDomainResourceLink[];
    /**
     * Indicates the percent of load imbalance factor for the domain.
     */
    loadImbalancePercentage: number;
    /**
     * For internal use only.
     */
    maxUMultiplicativeIncrement: number;
    /**
     * A descriptive label for the resource.
     */
    name: string;
    /**
     * List of resource instances.
     */
    resourceInstances?: outputs.GetGtmDomainResourceResourceInstance[];
    /**
     * Indicates the kind of loadObject format used to determine the load on the resource.
     */
    type: string;
    /**
     * An optional sanity check that specifies the maximum allowed value for any component of the load object.
     */
    upperBound: number;
}

export interface GetGtmDomainResourceLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainResourceResourceInstance {
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
     */
    loadObject: string;
    /**
     * Specifies the TCP port of the loadObject.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
    /**
     * Whether to use default loadObject.
     */
    useDefaultLoadObject: boolean;
}

export interface GetGtmDomainStatus {
    /**
     * A unique identifier generated when a change occurs to the domain.
     */
    changeId: string;
    /**
     * Specifies the URL path that allows direct navigation to the domain.
     */
    links?: outputs.GetGtmDomainStatusLink[];
    /**
     * A notification generated when a change occurs to the domain.
     */
    message: string;
    /**
     * Indicates if the domain validates.
     */
    passingValidation: boolean;
    /**
     * Tracks the status of the domain's propagation state.
     */
    propagationStatus: string;
    /**
     * An ISO 8601 timestamp indicating when a change occurs to the domain.
     */
    propagationStatusDate: string;
}

export interface GetGtmDomainStatusLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmDomainsDomain {
    /**
     * The contract's identifier, with which the domain is associated.
     */
    acgId: string;
    /**
     * 'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
     */
    activationState: string;
    /**
     * UUID that identifies a version of the domain configuration.
     */
    changeId: string;
    /**
     * UUID for delete request during domain deletion. Null if the domain is not being deleted.
     */
    deleteRequestId: string;
    /**
     * An ISO 8601 timestamp that indicates the time of the last domain change.
     */
    lastModified: string;
    /**
     * The email address of the administrator who made the last change to the domain.
     */
    lastModifiedBy: string;
    /**
     * Provides a URL path that allows direct navigation to the domain.
     */
    links?: outputs.GetGtmDomainsDomainLink[];
    /**
     * A descriptive note about changes to the domain.
     */
    modificationComments: string;
    /**
     * A unique domain name.
     */
    name: string;
    /**
     * If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
     */
    signAndServe: boolean;
    /**
     * The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
     */
    signAndServeAlgorithm: string;
    /**
     * The current status of the domain.
     */
    status: string;
}

export interface GetGtmDomainsDomainLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmGeomapAssignment {
    /**
     * Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
     */
    countries: string[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for the group.
     */
    nickname: string;
}

export interface GetGtmGeomapDefaultDatacenter {
    /**
     * For each property, an identifier for all other geographic zones.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other geographic zones.
     */
    nickname: string;
}

export interface GetGtmGeomapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmGeomapsGeoMap {
    /**
     * Contains information about the geographic zone groupings of countries.
     */
    assignments: outputs.GetGtmGeomapsGeoMapAssignment[];
    /**
     * A placeholder for all other geographic zones, countries not found in these geographic zones.
     */
    defaultDatacenter: outputs.GetGtmGeomapsGeoMapDefaultDatacenter;
    /**
     * Specifies the URL path that allows direct navigation to the Geographic maps.
     */
    links: outputs.GetGtmGeomapsGeoMapLink[];
    /**
     * A descriptive label for the Geographic map.
     */
    name: string;
}

export interface GetGtmGeomapsGeoMapAssignment {
    /**
     * Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
     */
    countries: string[];
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * A descriptive label for the group.
     */
    nickname: string;
}

export interface GetGtmGeomapsGeoMapDefaultDatacenter {
    /**
     * For each property, an identifier for all other geographic zones.
     */
    datacenterId: number;
    /**
     * A descriptive label for all other geographic zones.
     */
    nickname: string;
}

export interface GetGtmGeomapsGeoMapLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmResourceLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmResourceResourceInstance {
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
     */
    loadObject: string;
    /**
     * Specifies the TCP port of the loadObject.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
    /**
     * Whether to use default loadObject.
     */
    useDefaultLoadObject: boolean;
}

export interface GetGtmResourcesResource {
    /**
     * Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
     */
    aggregationType: string;
    /**
     * Specifies the name of the property that this resource constraints.
     */
    constrainedProperty: string;
    /**
     * For internal use only.
     */
    decayRate: number;
    /**
     * A descriptive note which allows to track what is constrained by this resource.
     */
    description: string;
    /**
     * Specifies the host header used when fetching the load object.
     */
    hostHeader: string;
    /**
     * Specifies the text that comes before the load object.
     */
    leaderString: string;
    /**
     * For internal use only.
     */
    leastSquaresDecay: number;
    /**
     * Specifies the URL path that allows direct navigation to the resource.
     */
    links?: outputs.GetGtmResourcesResourceLink[];
    /**
     * Indicates the percentage of load imbalance for the domain.
     */
    loadImbalancePercentage: number;
    /**
     * For internal use only.
     */
    maxUMultiplicativeIncrement: number;
    /**
     * A descriptive label for the resource.
     */
    name: string;
    /**
     * Instances of the resource.
     */
    resourceInstances?: outputs.GetGtmResourcesResourceResourceInstance[];
    /**
     * Indicates the type of load object used to determine the load on the resource.
     */
    type: string;
    /**
     * An optional sanity check that specifies the maximum allowed value for any component of the load object.
     */
    upperBound: number;
}

export interface GetGtmResourcesResourceLink {
    /**
     * A hypermedia link to the complete URL that uniquely defines a resource.
     */
    href: string;
    /**
     * Indicates the link relationship of the object.
     */
    rel: string;
}

export interface GetGtmResourcesResourceResourceInstance {
    /**
     * A unique identifier for an existing data center in the domain.
     */
    datacenterId: number;
    /**
     * Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
     */
    loadObject: string;
    /**
     * Specifies the TCP port of the loadObject.
     */
    loadObjectPort: number;
    /**
     * Specifies the list of servers to requests the load object from.
     */
    loadServers: string[];
    /**
     * Whether to use default loadObject.
     */
    useDefaultLoadObject: boolean;
}

export interface GetIamAccountSwitchKeysAccountSwitchKey {
    /**
     * Descriptive label for the account.
     */
    accountName: string;
    /**
     * The identifier for an account other than your API client's default.
     */
    accountSwitchKey: string;
}

export interface GetIamAllowedApisAllowedApi {
    /**
     * API access levels, possible values are READ-ONLY and READ-WRITE.
     */
    accessLevels: string[];
    /**
     * Unique identifier for each API.
     */
    apiId: number;
    /**
     * Name of the API.
     */
    apiName: string;
    /**
     * Descriptive label for the API.
     */
    description: string;
    /**
     * Link to more information about the API.
     */
    documentationUrl: string;
    /**
     * Specifies where the API can access resources.
     */
    endpoint: string;
    /**
     * Confirms access to the API.
     */
    hasAccess: boolean;
    /**
     * Unique identifier for the API's service provider.
     */
    serviceProviderId: number;
}

export interface GetIamBlockedPropertiesBlockedProperty {
    /**
     * IAM's blocked property ID.
     */
    assetId: number;
    /**
     * PAPI's blocked property ID.
     */
    propertyId: string;
}

export interface GetIamCidrBlockActions {
    /**
     * Whether you can delete this CIDR block.
     */
    delete: boolean;
    /**
     * Whether you can edit this CIDR block.
     */
    edit: boolean;
}

export interface GetIamCidrBlocksCidrBlock {
    /**
     * Specifies activities available for the CIDR block.
     */
    actions: outputs.GetIamCidrBlocksCidrBlockActions;
    /**
     * The value of an IP address or IP address range.
     */
    cidrBlock: string;
    /**
     * Unique identifier for each CIDR block.
     */
    cidrBlockId: number;
    /**
     * Descriptive label you provide for the CIDR block.
     */
    comments: string;
    /**
     * The user who created the CIDR block.
     */
    createdBy: string;
    /**
     * ISO 8601 timestamp indicating when the CIDR block was created.
     */
    createdDate: string;
    /**
     * Whether the CIDR block is enabled.
     */
    enabled: boolean;
    /**
     * The user who last edited the CIDR block.
     */
    modifiedBy: string;
    /**
     * ISO 8601 timestamp indicating when the CIDR block was last modified.
     */
    modifiedDate: string;
}

export interface GetIamCidrBlocksCidrBlockActions {
    /**
     * Whether you can delete this CIDR block.
     */
    delete: boolean;
    /**
     * Whether you can edit this CIDR block.
     */
    edit: boolean;
}

export interface GetIamGrantableRolesGrantableRole {
    /**
     * Granted role description.
     */
    description: string;
    /**
     * Granted role ID.
     */
    grantedRoleId: number;
    /**
     * Granted role name.
     */
    name: string;
}

export interface GetIamPropertyUsersUser {
    /**
     * The user's first name.
     */
    firstName: string;
    /**
     * Whether a user's access to a property is blocked.
     */
    isBlocked: boolean;
    /**
     * The user's surname.
     */
    lastName: string;
    /**
     * Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
     */
    uiIdentityId: string;
    /**
     * The user's username in Control Center.
     */
    uiUserName: string;
}

export interface GetIamRoleActions {
    /**
     * Whether you can remove the role.
     */
    delete: boolean;
    /**
     * Whether you can modify the role.
     */
    edit: boolean;
}

export interface GetIamRoleGrantedRole {
    /**
     * Descriptive label for the role to convey its use.
     */
    grantedRoleDescription: string;
    /**
     * Unique identifier for each granted role.
     */
    grantedRoleId: number;
    /**
     * Descriptive label for the granted role.
     */
    grantedRoleName: string;
}

export interface GetIamRoleUser {
    /**
     * Unique identifier for each account.
     */
    accountId: string;
    /**
     * The user's email address.
     */
    email: string;
    /**
     * The user's first name.
     */
    firstName: string;
    /**
     * ISO 8601 timestamp indicating when the user last logged in.
     */
    lastLoginDate: string;
    /**
     * The user's surname.
     */
    lastName: string;
    /**
     * Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
     */
    uiIdentityId: string;
}

export interface GetIamRolesRole {
    /**
     * The user name or email of the person who created the role.
     */
    createdBy: string;
    /**
     * The role's description.
     */
    description: string;
    /**
     * The username or email of the last person to edit the role.
     */
    modifiedBy: string;
    /**
     * The role's name.
     */
    name: string;
    /**
     * A unique identifier for each role.
     */
    roleId: string;
    /**
     * ISO 8601 timestamp indicating when the role was originally created.
     */
    timeCreated: string;
    /**
     * ISO 8601 timestamp indicating when the role was last updated.
     */
    timeModified: string;
    /**
     * Whether the role is a standard role or a custom role.
     */
    type: string;
}

export interface GetIamTimezonesTimezone {
    /**
     * The description of a time zone, including the GMT +/-.
     */
    description: string;
    /**
     * The time zone offset from GMT.
     */
    offset: string;
    /**
     * The time zone posix.
     */
    posix: string;
    /**
     * The time zone ID.
     */
    timezone: string;
}

export interface GetIamUsersAffectedByMovingGroupUser {
    /**
     * Unique identifier for each account.
     */
    accountId: string;
    /**
     * The user's email address.
     */
    email: string;
    /**
     * The user's first name.
     */
    firstName: string;
    /**
     * ISO 8601 timestamp indicating when the user last logged in.
     */
    lastLoginDate: string;
    /**
     * The user's surname.
     */
    lastName: string;
    /**
     * Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
     */
    uiIdentityId: string;
    /**
     * The user's username in Control Center.
     */
    uiUsername: string;
}

export interface GetImagingPolicyImagePolicy {
    /**
     * The breakpoint widths (in pixels) to use to create derivative images/videos.
     */
    breakpoints?: outputs.GetImagingPolicyImagePolicyBreakpoints;
    /**
     * Hosts that are allowed for image/video URLs within transformations or variables.
     */
    hosts?: string[];
    /**
     * Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
     */
    output?: outputs.GetImagingPolicyImagePolicyOutput;
    /**
     * Post-processing Transformations are applied to the image after image and quality settings have been applied.
     */
    postBreakpointTransformations?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation[];
    /**
     * The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
     */
    rolloutDuration?: string;
    /**
     * The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
     */
    serveStaleDuration?: string;
    /**
     * Set of image transformations to apply to the source image. If unspecified, no operations are performed.
     */
    transformations?: outputs.GetImagingPolicyImagePolicyTransformation[];
    /**
     * Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
     */
    variables?: outputs.GetImagingPolicyImagePolicyVariable[];
}

export interface GetImagingPolicyImagePolicyBreakpoints {
    widths?: number[];
}

export interface GetImagingPolicyImagePolicyOutput {
    /**
     * Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
     */
    adaptiveQuality?: string;
    /**
     * Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
     */
    allowPristineOnDownsize?: string;
    /**
     * The graphics file formats allowed for browser specific results.
     */
    allowedFormats?: string[];
    /**
     * The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
     */
    forcedFormats?: string[];
    /**
     * Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
     */
    perceptualQuality?: string;
    /**
     * Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
     */
    perceptualQualityFloor?: string;
    /**
     * Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
     */
    perceptualQualityVar?: string;
    /**
     * Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
     */
    preferModernFormats?: string;
    /**
     * Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
     */
    quality?: string;
    /**
     * Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
     */
    qualityVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformation {
    /**
     * Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
     */
    backgroundColors?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColor[];
    /**
     * Applies a Gaussian blur to the image.
     */
    blurs?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBlur[];
    /**
     * Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
     */
    chromaKeys?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKey[];
    /**
     * Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
     */
    composites?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationComposite[];
    compounds?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompound[];
    /**
     * Adjusts both the contrast and brightness of an image.
     */
    contrasts?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationContrast[];
    /**
     * Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
     */
    goops?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGoop[];
    /**
     * Restricts image color to shades of gray only.
     */
    grayscales?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscale[];
    /**
     * Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
     */
    hsls?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHsl[];
    /**
     * Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
     */
    hsvs?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHsv[];
    ifDimensions?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimension[];
    ifOrientations?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientation[];
    /**
     * Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
     */
    maxColors?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColor[];
    /**
     * Flips an image horizontally, vertically, or both.
     */
    mirrors?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMirror[];
    /**
     * Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
     */
    monoHues?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHue[];
    /**
     * Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
     */
    opacities?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationOpacity[];
    /**
     * Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
     */
    removeColors?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColor[];
    /**
     * Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
     */
    unsharpMasks?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMask[];
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColor {
    /**
     * The hexadecimal CSS color value for the background.
     */
    color?: string;
    /**
     * The hexadecimal CSS color value for the background.
     */
    colorVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationBlur {
    /**
     * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
     */
    sigma?: string;
    /**
     * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
     */
    sigmaVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKey {
    /**
     * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
     */
    hue?: string;
    /**
     * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
     */
    hueFeather?: string;
    /**
     * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
     */
    hueFeatherVar?: string;
    /**
     * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
     */
    hueTolerance?: string;
    /**
     * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
     */
    hueToleranceVar?: string;
    /**
     * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
     */
    hueVar?: string;
    /**
     * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
     */
    lightnessFeather?: string;
    /**
     * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
     */
    lightnessFeatherVar?: string;
    /**
     * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
     */
    lightnessTolerance?: string;
    /**
     * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
     */
    lightnessToleranceVar?: string;
    /**
     * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
     */
    saturationFeather?: string;
    /**
     * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
     */
    saturationFeatherVar?: string;
    /**
     * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
     */
    saturationTolerance?: string;
    /**
     * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
     */
    saturationToleranceVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationComposite {
    /**
     * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
     */
    gravity?: string;
    /**
     * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
     */
    gravityVar?: string;
    image: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImage;
    /**
     * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
     */
    placement?: string;
    /**
     * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
     */
    placementVar?: string;
    /**
     * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
     */
    scale?: string;
    /**
     * The dimension, either `width` or `height`, of the source image to scale.
     */
    scaleDimension?: string;
    /**
     * The dimension, either `width` or `height`, of the source image to scale.
     */
    scaleDimensionVar?: string;
    /**
     * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
     */
    scaleVar?: string;
    /**
     * The x-axis position of the image to apply.
     */
    xPosition?: string;
    /**
     * The x-axis position of the image to apply.
     */
    xPositionVar?: string;
    /**
     * The y-axis position of the image to apply.
     */
    yPosition?: string;
    /**
     * The y-axis position of the image to apply.
     */
    yPositionVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImage {
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    boxImages?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImage[];
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    circleImages?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImage[];
    /**
     * A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
     */
    textImages?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImage[];
    /**
     * An image loaded from a URL.
     */
    urlImages?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImage[];
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImage {
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The height of the box in pixels.
     */
    height?: string;
    /**
     * The height of the box in pixels.
     */
    heightVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImage {
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameter?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameterVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImage {
    /**
     * The main fill color of the text.
     */
    fill?: string;
    /**
     * The main fill color of the text.
     */
    fillVar?: string;
    /**
     * The size in pixels to render the text.
     */
    size?: string;
    /**
     * The size in pixels to render the text.
     */
    sizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    stroke?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSize?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    strokeVar?: string;
    /**
     * The line of text to render.
     */
    text?: string;
    /**
     * The line of text to render.
     */
    textVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typeface?: string;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typefaceVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImage {
    transformation?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The URL of the image.
     */
    url?: string;
    /**
     * The URL of the image.
     */
    urlVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationCompound {
    transformations?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation[];
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationContrast {
    /**
     * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
     */
    brightness?: string;
    /**
     * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
     */
    brightnessVar?: string;
    /**
     * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
     */
    contrast?: string;
    /**
     * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
     */
    contrastVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationGoop {
    /**
     * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
     */
    chaos?: string;
    /**
     * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
     */
    chaosVar?: string;
    /**
     * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
     */
    density?: string;
    /**
     * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
     */
    densityVar?: string;
    /**
     * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
     */
    power?: string;
    /**
     * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
     */
    powerVar?: string;
    /**
     * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
     */
    seed?: string;
    /**
     * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
     */
    seedVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscale {
    /**
     * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
     */
    type?: string;
    /**
     * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
     */
    typeVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationHsl {
    /**
     * The number of degrees to rotate colors around the color wheel, `0` by default.
     */
    hue?: string;
    /**
     * The number of degrees to rotate colors around the color wheel, `0` by default.
     */
    hueVar?: string;
    /**
     * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
     */
    lightness?: string;
    /**
     * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
     */
    lightnessVar?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturation?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturationVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationHsv {
    /**
     * The number of degrees to rotate colors around the color wheel, `0.0` by default.
     */
    hue?: string;
    /**
     * The number of degrees to rotate colors around the color wheel, `0.0` by default.
     */
    hueVar?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturation?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturationVar?: string;
    /**
     * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
     */
    value?: string;
    /**
     * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
     */
    valueVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimension {
    default?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The dimension to use to select the transformation, either `height`, `width`, or `both`.
     */
    dimension?: string;
    /**
     * The dimension to use to select the transformation, either `height`, `width`, or `both`.
     */
    dimensionVar?: string;
    equal?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    greaterThan?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    lessThan?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    /**
     * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
     */
    value?: string;
    /**
     * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
     */
    valueVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientation {
    default?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    landscape?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    portrait?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
    square?: outputs.GetImagingPolicyImagePolicyPostBreakpointTransformation;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColor {
    /**
     * The value representing the maximum number of colors to use with the source image.
     */
    colors?: string;
    /**
     * The value representing the maximum number of colors to use with the source image.
     */
    colorsVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationMirror {
    /**
     * Flips the image horizontally.
     */
    horizontal?: string;
    /**
     * Flips the image horizontally.
     */
    horizontalVar?: string;
    /**
     * Flips the image vertically.
     */
    vertical?: string;
    /**
     * Flips the image vertically.
     */
    verticalVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHue {
    /**
     * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
     */
    hue?: string;
    /**
     * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
     */
    hueVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationOpacity {
    /**
     * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
     */
    opacity?: string;
    /**
     * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
     */
    opacityVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColor {
    /**
     * The hexadecimal CSS color value to remove.
     */
    color?: string;
    /**
     * The hexadecimal CSS color value to remove.
     */
    colorVar?: string;
    /**
     * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
     */
    feather?: string;
    /**
     * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
     */
    featherVar?: string;
    /**
     * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
     */
    tolerance?: string;
    /**
     * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
     */
    toleranceVar?: string;
}

export interface GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMask {
    /**
     * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
     */
    gain?: string;
    /**
     * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
     */
    gainVar?: string;
    /**
     * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
     */
    sigma?: string;
    /**
     * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
     */
    sigmaVar?: string;
    /**
     * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
     */
    threshold?: string;
    /**
     * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
     */
    thresholdVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformation {
    /**
     * Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
     */
    appends?: outputs.GetImagingPolicyImagePolicyTransformationAppend[];
    /**
     * Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
     */
    aspectCrops?: outputs.GetImagingPolicyImagePolicyTransformationAspectCrop[];
    /**
     * Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
     */
    backgroundColors?: outputs.GetImagingPolicyImagePolicyTransformationBackgroundColor[];
    /**
     * Applies a Gaussian blur to the image.
     */
    blurs?: outputs.GetImagingPolicyImagePolicyTransformationBlur[];
    /**
     * Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
     */
    chromaKeys?: outputs.GetImagingPolicyImagePolicyTransformationChromaKey[];
    /**
     * Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
     */
    composites?: outputs.GetImagingPolicyImagePolicyTransformationComposite[];
    compounds?: outputs.GetImagingPolicyImagePolicyTransformationCompound[];
    /**
     * Adjusts both the contrast and brightness of an image.
     */
    contrasts?: outputs.GetImagingPolicyImagePolicyTransformationContrast[];
    /**
     * Crops an image.
     */
    crops?: outputs.GetImagingPolicyImagePolicyTransformationCrop[];
    /**
     * Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
     */
    faceCrops?: outputs.GetImagingPolicyImagePolicyTransformationFaceCrop[];
    /**
     * Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
     */
    featureCrops?: outputs.GetImagingPolicyImagePolicyTransformationFeatureCrop[];
    /**
     * Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
     */
    fitAndFills?: outputs.GetImagingPolicyImagePolicyTransformationFitAndFill[];
    /**
     * Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
     */
    goops?: outputs.GetImagingPolicyImagePolicyTransformationGoop[];
    /**
     * Restricts image color to shades of gray only.
     */
    grayscales?: outputs.GetImagingPolicyImagePolicyTransformationGrayscale[];
    /**
     * Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
     */
    hsls?: outputs.GetImagingPolicyImagePolicyTransformationHsl[];
    /**
     * Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
     */
    hsvs?: outputs.GetImagingPolicyImagePolicyTransformationHsv[];
    ifDimensions?: outputs.GetImagingPolicyImagePolicyTransformationIfDimension[];
    ifOrientations?: outputs.GetImagingPolicyImagePolicyTransformationIfOrientation[];
    /**
     * Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
     */
    imQueries?: outputs.GetImagingPolicyImagePolicyTransformationImQuery[];
    /**
     * Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
     */
    maxColors?: outputs.GetImagingPolicyImagePolicyTransformationMaxColor[];
    /**
     * Flips an image horizontally, vertically, or both.
     */
    mirrors?: outputs.GetImagingPolicyImagePolicyTransformationMirror[];
    /**
     * Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
     */
    monoHues?: outputs.GetImagingPolicyImagePolicyTransformationMonoHue[];
    /**
     * Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
     */
    opacities?: outputs.GetImagingPolicyImagePolicyTransformationOpacity[];
    /**
     * Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
     */
    regionOfInterestCrops?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCrop[];
    /**
     * Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
     */
    relativeCrops?: outputs.GetImagingPolicyImagePolicyTransformationRelativeCrop[];
    /**
     * Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
     */
    removeColors?: outputs.GetImagingPolicyImagePolicyTransformationRemoveColor[];
    /**
     * Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
     */
    resizes?: outputs.GetImagingPolicyImagePolicyTransformationResize[];
    /**
     * Rotate the image around its center by indicating the degrees of rotation.
     */
    rotates?: outputs.GetImagingPolicyImagePolicyTransformationRotate[];
    /**
     * Changes the image's size to different dimensions relative to its starting size.
     */
    scales?: outputs.GetImagingPolicyImagePolicyTransformationScale[];
    /**
     * Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
     */
    shears?: outputs.GetImagingPolicyImagePolicyTransformationShears[];
    /**
     * Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
     */
    smartCrops?: outputs.GetImagingPolicyImagePolicyTransformationSmartCrop[];
    /**
     * Automatically crops uniform backgrounds from the edges of an image.
     */
    trims?: outputs.GetImagingPolicyImagePolicyTransformationTrim[];
    /**
     * Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
     */
    unsharpMasks?: outputs.GetImagingPolicyImagePolicyTransformationUnsharpMask[];
}

export interface GetImagingPolicyImagePolicyTransformationAppend {
    /**
     * Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
     */
    gravity?: string;
    /**
     * Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
     */
    gravityPriority?: string;
    /**
     * Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
     */
    gravityPriorityVar?: string;
    /**
     * Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
     */
    gravityVar?: string;
    image: outputs.GetImagingPolicyImagePolicyTransformationAppendImage;
    /**
     * Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
     */
    preserveMinorDimension?: string;
    /**
     * Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
     */
    preserveMinorDimensionVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationAppendImage {
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    boxImages?: outputs.GetImagingPolicyImagePolicyTransformationAppendImageBoxImage[];
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    circleImages?: outputs.GetImagingPolicyImagePolicyTransformationAppendImageCircleImage[];
    /**
     * A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
     */
    textImages?: outputs.GetImagingPolicyImagePolicyTransformationAppendImageTextImage[];
    /**
     * An image loaded from a URL.
     */
    urlImages?: outputs.GetImagingPolicyImagePolicyTransformationAppendImageUrlImage[];
}

export interface GetImagingPolicyImagePolicyTransformationAppendImageBoxImage {
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The height of the box in pixels.
     */
    height?: string;
    /**
     * The height of the box in pixels.
     */
    heightVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationAppendImageCircleImage {
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameter?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameterVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationAppendImageTextImage {
    /**
     * The main fill color of the text.
     */
    fill?: string;
    /**
     * The main fill color of the text.
     */
    fillVar?: string;
    /**
     * The size in pixels to render the text.
     */
    size?: string;
    /**
     * The size in pixels to render the text.
     */
    sizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    stroke?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSize?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    strokeVar?: string;
    /**
     * The line of text to render.
     */
    text?: string;
    /**
     * The line of text to render.
     */
    textVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typeface?: string;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typefaceVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationAppendImageUrlImage {
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The URL of the image.
     */
    url?: string;
    /**
     * The URL of the image.
     */
    urlVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationAspectCrop {
    /**
     * Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
     */
    allowExpansion?: string;
    /**
     * Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
     */
    allowExpansionVar?: string;
    /**
     * The height term of the aspect ratio to crop.
     */
    height?: string;
    /**
     * The height term of the aspect ratio to crop.
     */
    heightVar?: string;
    /**
     * The width term of the aspect ratio to crop.
     */
    width?: string;
    /**
     * The width term of the aspect ratio to crop.
     */
    widthVar?: string;
    /**
     * Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
     */
    xPosition?: string;
    /**
     * Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
     */
    xPositionVar?: string;
    /**
     * Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
     */
    yPosition?: string;
    /**
     * Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
     */
    yPositionVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationBackgroundColor {
    /**
     * The hexadecimal CSS color value for the background.
     */
    color?: string;
    /**
     * The hexadecimal CSS color value for the background.
     */
    colorVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationBlur {
    /**
     * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
     */
    sigma?: string;
    /**
     * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
     */
    sigmaVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationChromaKey {
    /**
     * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
     */
    hue?: string;
    /**
     * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
     */
    hueFeather?: string;
    /**
     * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
     */
    hueFeatherVar?: string;
    /**
     * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
     */
    hueTolerance?: string;
    /**
     * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
     */
    hueToleranceVar?: string;
    /**
     * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
     */
    hueVar?: string;
    /**
     * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
     */
    lightnessFeather?: string;
    /**
     * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
     */
    lightnessFeatherVar?: string;
    /**
     * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
     */
    lightnessTolerance?: string;
    /**
     * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
     */
    lightnessToleranceVar?: string;
    /**
     * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
     */
    saturationFeather?: string;
    /**
     * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
     */
    saturationFeatherVar?: string;
    /**
     * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
     */
    saturationTolerance?: string;
    /**
     * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
     */
    saturationToleranceVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationComposite {
    /**
     * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
     */
    gravity?: string;
    /**
     * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
     */
    gravityVar?: string;
    image: outputs.GetImagingPolicyImagePolicyTransformationCompositeImage;
    /**
     * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
     */
    placement?: string;
    /**
     * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
     */
    placementVar?: string;
    /**
     * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
     */
    scale?: string;
    /**
     * The dimension, either `width` or `height`, of the source image to scale.
     */
    scaleDimension?: string;
    /**
     * The dimension, either `width` or `height`, of the source image to scale.
     */
    scaleDimensionVar?: string;
    /**
     * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
     */
    scaleVar?: string;
    /**
     * The x-axis position of the image to apply.
     */
    xPosition?: string;
    /**
     * The x-axis position of the image to apply.
     */
    xPositionVar?: string;
    /**
     * The y-axis position of the image to apply.
     */
    yPosition?: string;
    /**
     * The y-axis position of the image to apply.
     */
    yPositionVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCompositeImage {
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    boxImages?: outputs.GetImagingPolicyImagePolicyTransformationCompositeImageBoxImage[];
    /**
     * A rectangular box, with a specified color and applied transformation.
     */
    circleImages?: outputs.GetImagingPolicyImagePolicyTransformationCompositeImageCircleImage[];
    /**
     * A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
     */
    textImages?: outputs.GetImagingPolicyImagePolicyTransformationCompositeImageTextImage[];
    /**
     * An image loaded from a URL.
     */
    urlImages?: outputs.GetImagingPolicyImagePolicyTransformationCompositeImageUrlImage[];
}

export interface GetImagingPolicyImagePolicyTransformationCompositeImageBoxImage {
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The height of the box in pixels.
     */
    height?: string;
    /**
     * The height of the box in pixels.
     */
    heightVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCompositeImageCircleImage {
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    color?: string;
    /**
     * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
     */
    colorVar?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameter?: string;
    /**
     * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
     */
    diameterVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The width of the box in pixels.
     */
    width?: string;
    /**
     * The width of the box in pixels.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCompositeImageTextImage {
    /**
     * The main fill color of the text.
     */
    fill?: string;
    /**
     * The main fill color of the text.
     */
    fillVar?: string;
    /**
     * The size in pixels to render the text.
     */
    size?: string;
    /**
     * The size in pixels to render the text.
     */
    sizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    stroke?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSize?: string;
    /**
     * The thickness in points for the outline of the text.
     */
    strokeSizeVar?: string;
    /**
     * The color for the outline of the text.
     */
    strokeVar?: string;
    /**
     * The line of text to render.
     */
    text?: string;
    /**
     * The line of text to render.
     */
    textVar?: string;
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typeface?: string;
    /**
     * The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
     */
    typefaceVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCompositeImageUrlImage {
    transformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The URL of the image.
     */
    url?: string;
    /**
     * The URL of the image.
     */
    urlVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCompound {
    transformations?: outputs.GetImagingPolicyImagePolicyTransformation[];
}

export interface GetImagingPolicyImagePolicyTransformationContrast {
    /**
     * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
     */
    brightness?: string;
    /**
     * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
     */
    brightnessVar?: string;
    /**
     * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
     */
    contrast?: string;
    /**
     * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
     */
    contrastVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationCrop {
    /**
     * If cropping an area outside of the existing canvas, expands the image canvas.
     */
    allowExpansion?: string;
    /**
     * If cropping an area outside of the existing canvas, expands the image canvas.
     */
    allowExpansionVar?: string;
    /**
     * Frame of reference for X and Y Positions.
     */
    gravity?: string;
    /**
     * Frame of reference for X and Y Positions.
     */
    gravityVar?: string;
    /**
     * The number of pixels to crop along the y-axis.
     */
    height?: string;
    /**
     * The number of pixels to crop along the y-axis.
     */
    heightVar?: string;
    /**
     * The number of pixels to crop along the x-axis.
     */
    width?: string;
    /**
     * The number of pixels to crop along the x-axis.
     */
    widthVar?: string;
    /**
     * The x-axis position of the image to crop from.
     */
    xPosition?: string;
    /**
     * The x-axis position of the image to crop from.
     */
    xPositionVar?: string;
    /**
     * The y-axis position of the image to crop from.
     */
    yPosition?: string;
    /**
     * The y-axis position of the image to crop from.
     */
    yPositionVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationFaceCrop {
    /**
     * Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
     */
    algorithm?: string;
    /**
     * Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
     */
    algorithmVar?: string;
    /**
     * With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
     */
    confidence?: string;
    /**
     * With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
     */
    confidenceVar?: string;
    /**
     * Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
     */
    failGravity?: string;
    /**
     * Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
     */
    failGravityVar?: string;
    /**
     * Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
     */
    focus?: string;
    /**
     * Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
     */
    focusVar?: string;
    /**
     * Controls placement of the crop. Directions are relative to the face(s) plus padding.
     */
    gravity?: string;
    /**
     * Controls placement of the crop. Directions are relative to the face(s) plus padding.
     */
    gravityVar?: string;
    /**
     * The height of the output image in pixels relative to the specified `style` value.
     */
    height?: string;
    /**
     * The height of the output image in pixels relative to the specified `style` value.
     */
    heightVar?: string;
    /**
     * The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
     */
    padding?: string;
    /**
     * The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
     */
    paddingVar?: string;
    /**
     * Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
     */
    style?: string;
    /**
     * Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
     */
    styleVar?: string;
    /**
     * The width of the output image in pixels relative to the specified `style` value.
     */
    width?: string;
    /**
     * The width of the output image in pixels relative to the specified `style` value.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationFeatureCrop {
    /**
     * Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
     */
    failGravity?: string;
    /**
     * Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
     */
    failGravityVar?: string;
    /**
     * The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
     */
    featureRadius?: string;
    /**
     * The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
     */
    featureRadiusVar?: string;
    /**
     * Controls placement of the crop. Directions are relative to the region of interest plus padding.
     */
    gravity?: string;
    /**
     * Controls placement of the crop. Directions are relative to the region of interest plus padding.
     */
    gravityVar?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    height?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    heightVar?: string;
    /**
     * The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
     */
    maxFeatures?: string;
    /**
     * The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
     */
    maxFeaturesVar?: string;
    /**
     * Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
     */
    minFeatureQuality?: string;
    /**
     * Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
     */
    minFeatureQualityVar?: string;
    /**
     * Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
     */
    padding?: string;
    /**
     * Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
     */
    paddingVar?: string;
    /**
     * Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
     */
    style?: string;
    /**
     * Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
     */
    styleVar?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    width?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationFitAndFill {
    fillTransformation?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The height value of the resized image.
     */
    height?: string;
    /**
     * The height value of the resized image.
     */
    heightVar?: string;
    /**
     * The width value of the resized image.
     */
    width?: string;
    /**
     * The width value of the resized image.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationGoop {
    /**
     * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
     */
    chaos?: string;
    /**
     * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
     */
    chaosVar?: string;
    /**
     * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
     */
    density?: string;
    /**
     * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
     */
    densityVar?: string;
    /**
     * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
     */
    power?: string;
    /**
     * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
     */
    powerVar?: string;
    /**
     * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
     */
    seed?: string;
    /**
     * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
     */
    seedVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationGrayscale {
    /**
     * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
     */
    type?: string;
    /**
     * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
     */
    typeVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationHsl {
    /**
     * The number of degrees to rotate colors around the color wheel, `0` by default.
     */
    hue?: string;
    /**
     * The number of degrees to rotate colors around the color wheel, `0` by default.
     */
    hueVar?: string;
    /**
     * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
     */
    lightness?: string;
    /**
     * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
     */
    lightnessVar?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturation?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturationVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationHsv {
    /**
     * The number of degrees to rotate colors around the color wheel, `0.0` by default.
     */
    hue?: string;
    /**
     * The number of degrees to rotate colors around the color wheel, `0.0` by default.
     */
    hueVar?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturation?: string;
    /**
     * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
     */
    saturationVar?: string;
    /**
     * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
     */
    value?: string;
    /**
     * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
     */
    valueVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationIfDimension {
    default?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The dimension to use to select the transformation, either `height`, `width`, or `both`.
     */
    dimension?: string;
    /**
     * The dimension to use to select the transformation, either `height`, `width`, or `both`.
     */
    dimensionVar?: string;
    equal?: outputs.GetImagingPolicyImagePolicyTransformation;
    greaterThan?: outputs.GetImagingPolicyImagePolicyTransformation;
    lessThan?: outputs.GetImagingPolicyImagePolicyTransformation;
    /**
     * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
     */
    value?: string;
    /**
     * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
     */
    valueVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationIfOrientation {
    default?: outputs.GetImagingPolicyImagePolicyTransformation;
    landscape?: outputs.GetImagingPolicyImagePolicyTransformation;
    portrait?: outputs.GetImagingPolicyImagePolicyTransformation;
    square?: outputs.GetImagingPolicyImagePolicyTransformation;
}

export interface GetImagingPolicyImagePolicyTransformationImQuery {
    /**
     * Specifies the transformations that can be applied using the query string parameter.
     */
    allowedTransformations: string[];
    queryVar: string;
}

export interface GetImagingPolicyImagePolicyTransformationMaxColor {
    /**
     * The value representing the maximum number of colors to use with the source image.
     */
    colors?: string;
    /**
     * The value representing the maximum number of colors to use with the source image.
     */
    colorsVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationMirror {
    /**
     * Flips the image horizontally.
     */
    horizontal?: string;
    /**
     * Flips the image horizontally.
     */
    horizontalVar?: string;
    /**
     * Flips the image vertically.
     */
    vertical?: string;
    /**
     * Flips the image vertically.
     */
    verticalVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationMonoHue {
    /**
     * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
     */
    hue?: string;
    /**
     * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
     */
    hueVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationOpacity {
    /**
     * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
     */
    opacity?: string;
    /**
     * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
     */
    opacityVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCrop {
    /**
     * The placement of the crop area relative to the specified area of interest.
     */
    gravity?: string;
    /**
     * The placement of the crop area relative to the specified area of interest.
     */
    gravityVar?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    height?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    heightVar?: string;
    regionOfInterest: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterest;
    /**
     * Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
     */
    style?: string;
    /**
     * Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
     */
    styleVar?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    width?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterest {
    /**
     * Defines a circle with a specified `radius` from its `center` point.
     */
    circleShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShape[];
    pointShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShape[];
    /**
     * Defines a polygon from a series of connected points.
     */
    polygonShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShape[];
    /**
     * Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
     */
    rectangleShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShape[];
    /**
     * Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
     */
    unionShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShape[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShape {
    /**
     * Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
     */
    center: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenter;
    /**
     * The radius of the circle measured in pixels.
     */
    radius?: string;
    /**
     * The radius of the circle measured in pixels.
     */
    radiusVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenter {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShape {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShape {
    /**
     * Series of PointShapeType objects. The last and first points connect to close the shape automatically.
     */
    points: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePoint[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePoint {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShape {
    anchor: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchor;
    /**
     * Extends the rectangle down from the `anchor` point.
     */
    height?: string;
    /**
     * Extends the rectangle down from the `anchor` point.
     */
    heightVar?: string;
    /**
     * Extends the rectangle right from the `anchor` point.
     */
    width?: string;
    /**
     * Extends the rectangle right from the `anchor` point.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchor {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShape {
    shapes: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShape[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShape {
    /**
     * Defines a circle with a specified `radius` from its `center` point.
     */
    circleShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShape[];
    pointShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShape[];
    /**
     * Defines a polygon from a series of connected points.
     */
    polygonShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShape[];
    /**
     * Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
     */
    rectangleShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShape[];
    /**
     * Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
     */
    unionShapes?: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShape[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShape {
    /**
     * Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
     */
    center: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenter;
    /**
     * The radius of the circle measured in pixels.
     */
    radius?: string;
    /**
     * The radius of the circle measured in pixels.
     */
    radiusVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenter {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShape {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShape {
    /**
     * Series of PointShapeType objects. The last and first points connect to close the shape automatically.
     */
    points: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePoint[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePoint {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShape {
    anchor: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchor;
    /**
     * Extends the rectangle down from the `anchor` point.
     */
    height?: string;
    /**
     * Extends the rectangle down from the `anchor` point.
     */
    heightVar?: string;
    /**
     * Extends the rectangle right from the `anchor` point.
     */
    width?: string;
    /**
     * Extends the rectangle right from the `anchor` point.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchor {
    /**
     * The horizontal position of the point, measured in pixels.
     */
    x?: string;
    /**
     * The horizontal position of the point, measured in pixels.
     */
    xVar?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    y?: string;
    /**
     * The vertical position of the point, measured in pixels.
     */
    yVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShape {
    shapes: outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShape[];
}

export interface GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShape {
}

export interface GetImagingPolicyImagePolicyTransformationRelativeCrop {
    /**
     * The number of pixels to shrink or expand the right side of the image.
     */
    east?: string;
    /**
     * The number of pixels to shrink or expand the right side of the image.
     */
    eastVar?: string;
    /**
     * The number of pixels to shrink or expand the top side of the image.
     */
    north?: string;
    /**
     * The number of pixels to shrink or expand the top side of the image.
     */
    northVar?: string;
    /**
     * The number of pixels to shrink or expand the bottom side of the image.
     */
    south?: string;
    /**
     * The number of pixels to shrink or expand the bottom side of the image.
     */
    southVar?: string;
    /**
     * The number of pixels to shrink or expand the left side of the image.
     */
    west?: string;
    /**
     * The number of pixels to shrink or expand the left side of the image.
     */
    westVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRemoveColor {
    /**
     * The hexadecimal CSS color value to remove.
     */
    color?: string;
    /**
     * The hexadecimal CSS color value to remove.
     */
    colorVar?: string;
    /**
     * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
     */
    feather?: string;
    /**
     * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
     */
    featherVar?: string;
    /**
     * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
     */
    tolerance?: string;
    /**
     * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
     */
    toleranceVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationResize {
    /**
     * Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
     */
    aspect?: string;
    /**
     * Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
     */
    aspectVar?: string;
    /**
     * The height to resize the source image to. Must be set if height is not specified.
     */
    height?: string;
    /**
     * The height to resize the source image to. Must be set if height is not specified.
     */
    heightVar?: string;
    /**
     * Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
     */
    type?: string;
    /**
     * Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
     */
    typeVar?: string;
    /**
     * The width to resize the source image to. Must be set if width is not specified.
     */
    width?: string;
    /**
     * The width to resize the source image to. Must be set if width is not specified.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationRotate {
    /**
     * The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
     */
    degrees?: string;
    /**
     * The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
     */
    degreesVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationScale {
    /**
     * Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
     */
    height?: string;
    /**
     * Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
     */
    heightVar?: string;
    /**
     * Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
     */
    width?: string;
    /**
     * Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationShears {
    /**
     * The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
     */
    xShear?: string;
    /**
     * The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
     */
    xShearVar?: string;
    /**
     * The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
     */
    yShear?: string;
    /**
     * The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
     */
    yShearVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationSmartCrop {
    /**
     * When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
     */
    debug?: string;
    /**
     * When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
     */
    debugVar?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    height?: string;
    /**
     * The height in pixels of the output image relative to the specified `style` value.
     */
    heightVar?: string;
    /**
     * Whether to sacrifice any image fidelity for transformation performance.
     */
    sloppy?: string;
    /**
     * Whether to sacrifice any image fidelity for transformation performance.
     */
    sloppyVar?: string;
    /**
     * Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
     */
    style?: string;
    /**
     * Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
     */
    styleVar?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    width?: string;
    /**
     * The width in pixels of the output image relative to the specified `style` value.
     */
    widthVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationTrim {
    /**
     * The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
     */
    fuzz?: string;
    /**
     * The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
     */
    fuzzVar?: string;
    /**
     * The amount of padding in pixels to add to the trimmed image.
     */
    padding?: string;
    /**
     * The amount of padding in pixels to add to the trimmed image.
     */
    paddingVar?: string;
}

export interface GetImagingPolicyImagePolicyTransformationUnsharpMask {
    /**
     * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
     */
    gain?: string;
    /**
     * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
     */
    gainVar?: string;
    /**
     * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
     */
    sigma?: string;
    /**
     * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
     */
    sigmaVar?: string;
    /**
     * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
     */
    threshold?: string;
    /**
     * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
     */
    thresholdVar?: string;
}

export interface GetImagingPolicyImagePolicyVariable {
    /**
     * The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
     */
    defaultValue: string;
    enumOptions?: outputs.GetImagingPolicyImagePolicyVariableEnumOption[];
    /**
     * The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
     */
    name: string;
    /**
     * A postfix added to the value provided for the variable, or to the default value.
     */
    postfix?: string;
    /**
     * A prefix added to the value provided for the variable, or to the default value.
     */
    prefix?: string;
    /**
     * The type of value for the variable.
     */
    type: string;
}

export interface GetImagingPolicyImagePolicyVariableEnumOption {
    /**
     * The unique identifier for each enum value, up to 50 alphanumeric characters.
     */
    id: string;
    /**
     * The value of the variable when the `id` is provided.
     */
    value: string;
}

export interface GetImagingPolicyVideoPolicy {
    /**
     * The breakpoint widths (in pixels) to use to create derivative images/videos.
     */
    breakpoints?: outputs.GetImagingPolicyVideoPolicyBreakpoints;
    /**
     * Hosts that are allowed for image/video URLs within transformations or variables.
     */
    hosts?: string[];
    /**
     * Dictates the output quality that are created for each resized video.
     */
    output?: outputs.GetImagingPolicyVideoPolicyOutput;
    /**
     * The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
     */
    rolloutDuration?: string;
    /**
     * Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
     */
    variables?: outputs.GetImagingPolicyVideoPolicyVariable[];
}

export interface GetImagingPolicyVideoPolicyBreakpoints {
    widths?: number[];
}

export interface GetImagingPolicyVideoPolicyOutput {
    /**
     * The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
     */
    perceptualQuality?: string;
    /**
     * The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
     */
    perceptualQualityVar?: string;
    /**
     * Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
     */
    placeholderVideoUrl?: string;
    /**
     * Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
     */
    placeholderVideoUrlVar?: string;
    /**
     * Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
     */
    videoAdaptiveQuality?: string;
    /**
     * Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
     */
    videoAdaptiveQualityVar?: string;
}

export interface GetImagingPolicyVideoPolicyVariable {
    /**
     * The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
     */
    defaultValue: string;
    enumOptions?: outputs.GetImagingPolicyVideoPolicyVariableEnumOption[];
    /**
     * The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
     */
    name: string;
    /**
     * A postfix added to the value provided for the variable, or to the default value.
     */
    postfix?: string;
    /**
     * A prefix added to the value provided for the variable, or to the default value.
     */
    prefix?: string;
    /**
     * The type of value for the variable.
     */
    type: string;
}

export interface GetImagingPolicyVideoPolicyVariableEnumOption {
    /**
     * The unique identifier for each enum value, up to 50 alphanumeric characters.
     */
    id: string;
    /**
     * The value of the variable when the `id` is provided.
     */
    value: string;
}

export interface GetPropertiesProperty {
    contractId: string;
    groupId: string;
    latestVersion: number;
    note: string;
    productionVersion: number;
    propertyId: string;
    propertyName: string;
    /**
     * Specifies the type of the property.
     */
    propertyType: string;
    stagingVersion: number;
}

export interface GetPropertiesSearchProperty {
    accountId: string;
    assetId: string;
    contractId: string;
    edgeHostname: string;
    groupId: string;
    hostname: string;
    productionStatus: string;
    propertyId: string;
    propertyName: string;
    propertyVersion: number;
    stagingStatus: string;
    updatedByUser: string;
    updatedDate: string;
}

export interface GetPropertyHostnameActivationHostname {
    /**
     * Specifies whether a given activation adds or removes a hostname item. Available options are `ADD` and `REMOVE`.
     */
    action: string;
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    certProvisioningType: string;
    /**
     * The hostname that your end users see, indicated by the Host header in end user requests.
     */
    cnameFrom: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers.
     */
    cnameTo: string;
    /**
     * Identifies the edge hostname you mapped your traffic to on the production network.
     */
    edgeHostnameId: string;
}

export interface GetPropertyHostnameActivationsHostnameActivation {
    /**
     * The activation type, either `ACTIVATE` or `DEACTIVATE`.
     */
    activationType: string;
    /**
     * The ISO 8601 timestamp property hostname activation's unique identifier.
     */
    hostnameActivationId: string;
    /**
     * The network of activation, either `STAGING` or `PRODUCTION`.`
     */
    network: string;
    /**
     * Assigns a log message to the activation request.
     */
    note: string;
    /**
     * Email addresses to notify when the activation status changes.
     */
    notifyEmails: string[];
    /**
     * The activation's status. `ACTIVE` if currently serving traffic. `INACTIVE` if another activation has superseded this one. `PENDING` if not yet active. `ABORTED` if the client followed up with a `DELETE` request in time. `FAILED` if the activation causes a range of edge network errors that may cause a fallback to the previous activation. `PENDING_DEACTIVATION` or `DEACTIVATED` when the `activationType` is `DEACTIVATE` to no longer serve traffic.
     */
    status: string;
    /**
     * The timestamp indicating when the activation was initiated.
     */
    submitDate: string;
    /**
     * The ISO 8601 timestamp indicating when the status last changed.
     */
    updateDate: string;
}

export interface GetPropertyHostnamesDiffHostname {
    /**
     * The hostname that your end users see, indicated by the Host header in end user requests.
     */
    cnameFrom: string;
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    productionCertProvisioningType: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    productionCnameTo: string;
    /**
     * A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
     */
    productionCnameType: string;
    /**
     * The unique identifier for the edge hostname.
     */
    productionEdgeHostnameId: string;
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    stagingCertProvisioningType: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    stagingCnameTo: string;
    /**
     * A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
     */
    stagingCnameType: string;
    /**
     * The unique identifier for the edge hostname.
     */
    stagingEdgeHostnameId: string;
}

export interface GetPropertyHostnamesHostname {
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    certProvisioningType: string;
    certStatuses: outputs.GetPropertyHostnamesHostnameCertStatus[];
    /**
     * The hostname that your end users see, indicated by the Host header in end user requests.
     */
    cnameFrom: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    cnameTo: string;
    /**
     * A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
     */
    cnameType: string;
    /**
     * The unique identifier for the edge hostname.
     */
    edgeHostnameId: string;
}

export interface GetPropertyHostnamesHostnameBucket {
    certStatuses: outputs.GetPropertyHostnamesHostnameBucketCertStatus[];
    /**
     * The hostname that your end users see, indicated by the Host header in end user requests.
     */
    cnameFrom: string;
    /**
     * A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
     */
    cnameType: string;
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    productionCertType: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    productionCnameTo: string;
    /**
     * The unique identifier for the edge hostname.
     */
    productionEdgeHostnameId: string;
    /**
     * Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
     */
    stagingCertType: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    stagingCnameTo: string;
    /**
     * The unique identifier for the edge hostname.
     */
    stagingEdgeHostnameId: string;
}

export interface GetPropertyHostnamesHostnameBucketCertStatus {
    /**
     * The hostname part of the CNAME record used to validate the certificate's domain.
     */
    hostname: string;
    /**
     * The certificate's deployment status on the production network.
     */
    productionStatus: string;
    /**
     * The certificate's deployment status on the staging network.
     */
    stagingStatus: string;
    /**
     * The destination part of the CNAME record used to validate the certificate's domain.
     */
    target: string;
}

export interface GetPropertyHostnamesHostnameCertStatus {
    /**
     * The hostname part of the CNAME record used to validate the certificate's domain.
     */
    hostname: string;
    /**
     * The certificate's deployment status on the production network.
     */
    productionStatus: string;
    /**
     * The certificate's deployment status on the staging network.
     */
    stagingStatus: string;
    /**
     * The destination part of the CNAME record used to validate the certificate's domain.
     */
    target: string;
}

export interface GetPropertyIncludeParentsParent {
    /**
     * The property's unique identifier
     */
    id: string;
    /**
     * Indicates if the include is used in the production network
     */
    isIncludeUsedInProductionVersion: boolean;
    /**
     * Indicates if the include is used in the staging network
     */
    isIncludeUsedInStagingVersion: boolean;
    /**
     * A descriptive name for the property
     */
    name: string;
    /**
     * The most recent property version to be activated to the production network
     */
    productionVersion: string;
    /**
     * The most recent property version to be activated to the staging network
     */
    stagingVersion: string;
}

export interface GetPropertyIncludesInclude {
    /**
     * The include's unique identifier
     */
    id: string;
    /**
     * Specifies the most recent version of the include
     */
    latestVersion: number;
    /**
     * A descriptive name for the include
     */
    name: string;
    /**
     * The most recent version to be activated to the production network
     */
    productionVersion: string;
    /**
     * The most recent version to be activated to the staging network
     */
    stagingVersion: string;
    /**
     * Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`
     */
    type: string;
}

export interface GetPropertyIncludesParentProperty {
    /**
     * The property's unique identifier
     */
    id: string;
    /**
     * The property's version for which the data is requested
     */
    version: number;
}

export interface GetPropertyProductsProduct {
    productId: string;
    productName: string;
}

export interface GetPropertyRulesTemplateTemplate {
    /**
     * Content of the template as string
     */
    templateData: string;
    /**
     * Directory points to a folder, which contains snippets to include into template.
     */
    templateDir: string;
}

export interface GetPropertyRulesTemplateVariable {
    name: string;
    type?: string;
    value: string;
}

export interface GetZoneDnssecStatusCurrentRecords {
    /**
     * The generated DNSKEY record for this zone.
     */
    dnskeyRecord: string;
    /**
     * The generated DS record for this zone.
     */
    dsRecord: string;
    /**
     * The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
     */
    expectedTtl: number;
    /**
     * The ISO 8601 timestamp on which these records were generated.
     */
    lastModifiedDate: string;
}

export interface GetZoneDnssecStatusNewRecords {
    /**
     * The generated DNSKEY record for this zone.
     */
    dnskeyRecord: string;
    /**
     * The generated DS record for this zone.
     */
    dsRecord: string;
    /**
     * The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
     */
    expectedTtl: number;
    /**
     * The ISO 8601 timestamp on which these records were generated.
     */
    lastModifiedDate: string;
}

export interface GtmAsmapAssignment {
    asNumbers: number[];
    datacenterId: number;
    nickname: string;
}

export interface GtmAsmapDefaultDatacenter {
    datacenterId: number;
    nickname?: string;
}

export interface GtmCidrmapAssignment {
    blocks?: string[];
    datacenterId: number;
    nickname: string;
}

export interface GtmCidrmapDefaultDatacenter {
    datacenterId: number;
    nickname?: string;
}

export interface GtmDatacenterDefaultLoadObject {
    loadObject?: string;
    loadObjectPort?: number;
    loadServers?: string[];
}

export interface GtmGeomapAssignment {
    countries?: string[];
    datacenterId: number;
    nickname: string;
}

export interface GtmGeomapDefaultDatacenter {
    datacenterId: number;
    nickname?: string;
}

export interface GtmPropertyLivenessTest {
    alternateCaCertificates?: string[];
    answersRequired?: boolean;
    disableNonstandardPortWarning?: boolean;
    disabled?: boolean;
    errorPenalty?: number;
    httpError3xx?: boolean;
    httpError4xx?: boolean;
    httpError5xx?: boolean;
    httpHeaders?: outputs.GtmPropertyLivenessTestHttpHeader[];
    httpMethod?: string;
    httpRequestBody?: string;
    name: string;
    peerCertificateVerification?: boolean;
    /**
     * Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
     */
    pre2023SecurityPosture?: boolean;
    recursionRequested?: boolean;
    requestString?: string;
    resourceType?: string;
    responseString?: string;
    sslClientCertificate?: string;
    sslClientPrivateKey?: string;
    testInterval: number;
    testObject?: string;
    testObjectPassword?: string;
    testObjectPort?: number;
    testObjectProtocol: string;
    testObjectUsername?: string;
    testTimeout: number;
    timeoutPenalty?: number;
}

export interface GtmPropertyLivenessTestHttpHeader {
    name?: string;
    value?: string;
}

export interface GtmPropertyStaticRrSet {
    rdatas?: string[];
    ttl?: number;
    type?: string;
}

export interface GtmPropertyTrafficTarget {
    datacenterId?: number;
    enabled?: boolean;
    handoutCname?: string;
    precedence?: number;
    servers?: string[];
    weight?: number;
}

export interface GtmResourceResourceInstance {
    datacenterId: number;
    loadObject?: string;
    loadObjectPort?: number;
    loadServers?: string[];
    useDefaultLoadObject?: boolean;
}

export interface IamCidrBlockActions {
    /**
     * Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
     */
    delete: boolean;
    /**
     * Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
     */
    edit: boolean;
}

export interface IamUserUserNotifications {
    /**
     * Enables notifications for expiring API client credentials.
     */
    apiClientCredentialExpiryNotification?: boolean;
    /**
     * Enables email notifications.
     */
    enableEmailNotifications: boolean;
    /**
     * Enables notifications for group administrators when the user creates other new users.
     */
    newUserNotification?: boolean;
    /**
     * Enables notifications for expiring passwords.
     */
    passwordExpiry: boolean;
    /**
     * Products for which the user gets notifications for service issues.
     */
    proactives: string[];
    /**
     * Products for which the user receives notifications for upgrades.
     */
    upgrades: string[];
}

export interface PropertyActivationComplianceRecord {
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
     */
    noncomplianceReasonEmergency?: outputs.PropertyActivationComplianceRecordNoncomplianceReasonEmergency;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
     */
    noncomplianceReasonNoProductionTraffic?: outputs.PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `NONE`
     */
    noncomplianceReasonNone?: outputs.PropertyActivationComplianceRecordNoncomplianceReasonNone;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
     */
    noncomplianceReasonOther?: outputs.PropertyActivationComplianceRecordNoncomplianceReasonOther;
}

export interface PropertyActivationComplianceRecordNoncomplianceReasonEmergency {
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic {
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyActivationComplianceRecordNoncomplianceReasonNone {
    /**
     * Identifies the customer
     */
    customerEmail?: string;
    /**
     * Identifies person who has independently approved the activation request
     */
    peerReviewedBy?: string;
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
    /**
     * Whether the metadata to activate has been fully tested
     */
    unitTested?: boolean;
}

export interface PropertyActivationComplianceRecordNoncomplianceReasonOther {
    /**
     * Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
     */
    otherNoncomplianceReason?: string;
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyActivationRuleError {
    behaviorName?: string;
    detail?: string;
    errorLocation?: string;
    instance?: string;
    statusCode?: number;
    title?: string;
    type?: string;
}

export interface PropertyActivationTimeouts {
    default?: string;
}

export interface PropertyHostname {
    certProvisioningType: string;
    certStatuses: outputs.PropertyHostnameCertStatus[];
    cnameFrom: string;
    cnameTo: string;
    cnameType: string;
    edgeHostnameId: string;
}

export interface PropertyHostnameBucketHostnames {
    /**
     * Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
     */
    certProvisioningType: string;
    /**
     * The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
     */
    cnameTo: string;
    /**
     * Identifies the edge hostname you mapped your traffic to on the production network.
     */
    edgeHostnameId: string;
}

export interface PropertyHostnameCertStatus {
    /**
     * The hostname part of the CNAME record used to validate the certificate's domain.
     */
    hostname: string;
    /**
     * The certificate's deployment status on the production network.
     */
    productionStatus: string;
    /**
     * The certificate's deployment status on the staging network.
     */
    stagingStatus: string;
    /**
     * The destination part of the CNAME record used to validate the certificate's domain.
     */
    target: string;
}

export interface PropertyIncludeActivationComplianceRecord {
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
     */
    noncomplianceReasonEmergency?: outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
     */
    noncomplianceReasonNoProductionTraffic?: outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `NONE`
     */
    noncomplianceReasonNone?: outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone;
    /**
     * Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
     */
    noncomplianceReasonOther?: outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther;
}

export interface PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency {
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic {
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone {
    /**
     * Identifies the customer
     */
    customerEmail?: string;
    /**
     * Identifies person who has independently approved the activation request
     */
    peerReviewedBy?: string;
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
    /**
     * Whether the metadata to activate has been fully tested
     */
    unitTested?: boolean;
}

export interface PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther {
    /**
     * Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
     */
    otherNoncomplianceReason?: string;
    /**
     * Identifies the ticket that describes the need for the activation
     */
    ticketId?: string;
}

export interface PropertyIncludeActivationTimeouts {
    default?: string;
}

export interface PropertyRuleError {
    behaviorName?: string;
    detail?: string;
    errorLocation?: string;
    instance?: string;
    statusCode?: number;
    title?: string;
    type?: string;
}

export interface PropertyRuleWarning {
    behaviorName?: string;
    detail?: string;
    errorLocation?: string;
    instance?: string;
    statusCode?: number;
    title?: string;
    type?: string;
}

export namespace config {
    export interface Config {
        accessToken: string;
        accountKey?: string;
        clientSecret: string;
        clientToken: string;
        host: string;
        maxBody?: number;
    }

}
