// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Akamai.Outputs
{

    [OutputType]
    public sealed class GetGtmDomainPropertyResult
    {
        /// <summary>
        /// Specifies a backup CNAME.
        /// </summary>
        public readonly string BackupCname;
        /// <summary>
        /// Specifies a backup IP.
        /// </summary>
        public readonly string BackupIp;
        /// <summary>
        /// Indicates whether download score based load balancing is enabled.
        /// </summary>
        public readonly bool BalanceByDownloadScore;
        /// <summary>
        /// Indicates the fully qualified name aliased to a particular property.
        /// </summary>
        public readonly string Cname;
        /// <summary>
        /// Descriptive comments for the property.
        /// </summary>
        public readonly string Comments;
        /// <summary>
        /// Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        /// </summary>
        public readonly int DynamicTtl;
        /// <summary>
        /// Specifies the failback delay in seconds.
        /// </summary>
        public readonly int FailbackDelay;
        /// <summary>
        /// Specifies the failover delay in seconds.
        /// </summary>
        public readonly int FailoverDelay;
        /// <summary>
        /// Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        /// </summary>
        public readonly bool GhostDemandReporting;
        /// <summary>
        /// Indicates the limit for the number of live IPs handed out to a DNS request.
        /// </summary>
        public readonly int HandoutLimit;
        /// <summary>
        /// Specifies how IPs are returned when more than one IP is alive and available.
        /// </summary>
        public readonly string HandoutMode;
        /// <summary>
        /// Defines the absolute limit beyond which IPs are declared unhealthy.
        /// </summary>
        public readonly double HealthMax;
        /// <summary>
        /// Configures a cutoff value that is computed from the median scores.
        /// </summary>
        public readonly double HealthMultiplier;
        /// <summary>
        /// Configures a cutoff value that is computed from the median scores.
        /// </summary>
        public readonly double HealthThreshold;
        /// <summary>
        /// Indicates the type of IP address handed out by a property.
        /// </summary>
        public readonly bool Ipv6;
        /// <summary>
        /// An ISO 8601 timestamp that indicates when the property was last changed.
        /// </summary>
        public readonly string LastModified;
        /// <summary>
        /// Provides a URL path that allows direct navigation to the property.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetGtmDomainPropertyLinkResult> Links;
        /// <summary>
        /// Contains information about liveness tests.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetGtmDomainPropertyLivenessTestResult> LivenessTests;
        /// <summary>
        /// Indicates the percent of load imbalance factor for the domain.
        /// </summary>
        public readonly double LoadImbalancePercentage;
        /// <summary>
        /// A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        /// </summary>
        public readonly string MapName;
        /// <summary>
        /// For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        /// </summary>
        public readonly int MaxUnreachablePenalty;
        /// <summary>
        /// Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        /// </summary>
        public readonly double MinLiveFraction;
        /// <summary>
        /// A descriptive label for the property.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        /// </summary>
        public readonly string ScoreAggregationType;
        /// <summary>
        /// Contains static recordsets.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetGtmDomainPropertyStaticRrSetResult> StaticRrSets;
        /// <summary>
        /// Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        /// </summary>
        public readonly int StaticTtl;
        /// <summary>
        /// Specifies a percentage used to configure data center affinity.
        /// </summary>
        public readonly int SticknessBonusConstant;
        /// <summary>
        /// Specifies a percentage used to configure data center affinity.
        /// </summary>
        public readonly int SticknessBonusPercentage;
        /// <summary>
        /// Traffic targets for the property.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetGtmDomainPropertyTrafficTargetResult> TrafficTargets;
        /// <summary>
        /// Specifies the load balancing behvior for the property.
        /// </summary>
        public readonly string Type;
        /// <summary>
        /// For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        /// </summary>
        public readonly double UnreachableThreshold;
        /// <summary>
        /// For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        /// </summary>
        public readonly bool UseComputedTargets;
        /// <summary>
        /// For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        /// </summary>
        public readonly int WeightedHashBitsForIpv4;
        /// <summary>
        /// For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        /// </summary>
        public readonly int WeightedHashBitsForIpv6;

        [OutputConstructor]
        private GetGtmDomainPropertyResult(
            string backupCname,

            string backupIp,

            bool balanceByDownloadScore,

            string cname,

            string comments,

            int dynamicTtl,

            int failbackDelay,

            int failoverDelay,

            bool ghostDemandReporting,

            int handoutLimit,

            string handoutMode,

            double healthMax,

            double healthMultiplier,

            double healthThreshold,

            bool ipv6,

            string lastModified,

            ImmutableArray<Outputs.GetGtmDomainPropertyLinkResult> links,

            ImmutableArray<Outputs.GetGtmDomainPropertyLivenessTestResult> livenessTests,

            double loadImbalancePercentage,

            string mapName,

            int maxUnreachablePenalty,

            double minLiveFraction,

            string name,

            string scoreAggregationType,

            ImmutableArray<Outputs.GetGtmDomainPropertyStaticRrSetResult> staticRrSets,

            int staticTtl,

            int sticknessBonusConstant,

            int sticknessBonusPercentage,

            ImmutableArray<Outputs.GetGtmDomainPropertyTrafficTargetResult> trafficTargets,

            string type,

            double unreachableThreshold,

            bool useComputedTargets,

            int weightedHashBitsForIpv4,

            int weightedHashBitsForIpv6)
        {
            BackupCname = backupCname;
            BackupIp = backupIp;
            BalanceByDownloadScore = balanceByDownloadScore;
            Cname = cname;
            Comments = comments;
            DynamicTtl = dynamicTtl;
            FailbackDelay = failbackDelay;
            FailoverDelay = failoverDelay;
            GhostDemandReporting = ghostDemandReporting;
            HandoutLimit = handoutLimit;
            HandoutMode = handoutMode;
            HealthMax = healthMax;
            HealthMultiplier = healthMultiplier;
            HealthThreshold = healthThreshold;
            Ipv6 = ipv6;
            LastModified = lastModified;
            Links = links;
            LivenessTests = livenessTests;
            LoadImbalancePercentage = loadImbalancePercentage;
            MapName = mapName;
            MaxUnreachablePenalty = maxUnreachablePenalty;
            MinLiveFraction = minLiveFraction;
            Name = name;
            ScoreAggregationType = scoreAggregationType;
            StaticRrSets = staticRrSets;
            StaticTtl = staticTtl;
            SticknessBonusConstant = sticknessBonusConstant;
            SticknessBonusPercentage = sticknessBonusPercentage;
            TrafficTargets = trafficTargets;
            Type = type;
            UnreachableThreshold = unreachableThreshold;
            UseComputedTargets = useComputedTargets;
            WeightedHashBitsForIpv4 = weightedHashBitsForIpv4;
            WeightedHashBitsForIpv6 = weightedHashBitsForIpv6;
        }
    }
}
