# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'GetCPSEnrollmentResult',
    'AwaitableGetCPSEnrollmentResult',
    'get_cps_enrollment',
    'get_cps_enrollment_output',
]

@pulumi.output_type
class GetCPSEnrollmentResult:
    """
    A collection of values returned by getCPSEnrollment.
    """
    def __init__(__self__, admin_contacts=None, certificate_chain_type=None, certificate_type=None, common_name=None, contract_id=None, csrs=None, dns_challenges=None, enable_multi_stacked_certificates=None, enrollment_id=None, http_challenges=None, id=None, network_configurations=None, organizations=None, registration_authority=None, sans=None, secure_network=None, signature_algorithm=None, sni_only=None, tech_contacts=None, validation_type=None):
        if admin_contacts and not isinstance(admin_contacts, list):
            raise TypeError("Expected argument 'admin_contacts' to be a list")
        pulumi.set(__self__, "admin_contacts", admin_contacts)
        if certificate_chain_type and not isinstance(certificate_chain_type, str):
            raise TypeError("Expected argument 'certificate_chain_type' to be a str")
        pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
        if certificate_type and not isinstance(certificate_type, str):
            raise TypeError("Expected argument 'certificate_type' to be a str")
        pulumi.set(__self__, "certificate_type", certificate_type)
        if common_name and not isinstance(common_name, str):
            raise TypeError("Expected argument 'common_name' to be a str")
        pulumi.set(__self__, "common_name", common_name)
        if contract_id and not isinstance(contract_id, str):
            raise TypeError("Expected argument 'contract_id' to be a str")
        pulumi.set(__self__, "contract_id", contract_id)
        if csrs and not isinstance(csrs, list):
            raise TypeError("Expected argument 'csrs' to be a list")
        pulumi.set(__self__, "csrs", csrs)
        if dns_challenges and not isinstance(dns_challenges, list):
            raise TypeError("Expected argument 'dns_challenges' to be a list")
        pulumi.set(__self__, "dns_challenges", dns_challenges)
        if enable_multi_stacked_certificates and not isinstance(enable_multi_stacked_certificates, bool):
            raise TypeError("Expected argument 'enable_multi_stacked_certificates' to be a bool")
        pulumi.set(__self__, "enable_multi_stacked_certificates", enable_multi_stacked_certificates)
        if enrollment_id and not isinstance(enrollment_id, int):
            raise TypeError("Expected argument 'enrollment_id' to be a int")
        pulumi.set(__self__, "enrollment_id", enrollment_id)
        if http_challenges and not isinstance(http_challenges, list):
            raise TypeError("Expected argument 'http_challenges' to be a list")
        pulumi.set(__self__, "http_challenges", http_challenges)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if network_configurations and not isinstance(network_configurations, list):
            raise TypeError("Expected argument 'network_configurations' to be a list")
        pulumi.set(__self__, "network_configurations", network_configurations)
        if organizations and not isinstance(organizations, list):
            raise TypeError("Expected argument 'organizations' to be a list")
        pulumi.set(__self__, "organizations", organizations)
        if registration_authority and not isinstance(registration_authority, str):
            raise TypeError("Expected argument 'registration_authority' to be a str")
        pulumi.set(__self__, "registration_authority", registration_authority)
        if sans and not isinstance(sans, list):
            raise TypeError("Expected argument 'sans' to be a list")
        pulumi.set(__self__, "sans", sans)
        if secure_network and not isinstance(secure_network, str):
            raise TypeError("Expected argument 'secure_network' to be a str")
        pulumi.set(__self__, "secure_network", secure_network)
        if signature_algorithm and not isinstance(signature_algorithm, str):
            raise TypeError("Expected argument 'signature_algorithm' to be a str")
        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if sni_only and not isinstance(sni_only, bool):
            raise TypeError("Expected argument 'sni_only' to be a bool")
        pulumi.set(__self__, "sni_only", sni_only)
        if tech_contacts and not isinstance(tech_contacts, list):
            raise TypeError("Expected argument 'tech_contacts' to be a list")
        pulumi.set(__self__, "tech_contacts", tech_contacts)
        if validation_type and not isinstance(validation_type, str):
            raise TypeError("Expected argument 'validation_type' to be a str")
        pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter(name="adminContacts")
    def admin_contacts(self) -> Sequence['outputs.GetCPSEnrollmentAdminContactResult']:
        return pulumi.get(self, "admin_contacts")

    @property
    @pulumi.getter(name="certificateChainType")
    def certificate_chain_type(self) -> str:
        return pulumi.get(self, "certificate_chain_type")

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> str:
        return pulumi.get(self, "contract_id")

    @property
    @pulumi.getter
    def csrs(self) -> Sequence['outputs.GetCPSEnrollmentCsrResult']:
        return pulumi.get(self, "csrs")

    @property
    @pulumi.getter(name="dnsChallenges")
    def dns_challenges(self) -> Sequence['outputs.GetCPSEnrollmentDnsChallengeResult']:
        return pulumi.get(self, "dns_challenges")

    @property
    @pulumi.getter(name="enableMultiStackedCertificates")
    def enable_multi_stacked_certificates(self) -> bool:
        return pulumi.get(self, "enable_multi_stacked_certificates")

    @property
    @pulumi.getter(name="enrollmentId")
    def enrollment_id(self) -> int:
        return pulumi.get(self, "enrollment_id")

    @property
    @pulumi.getter(name="httpChallenges")
    def http_challenges(self) -> Sequence['outputs.GetCPSEnrollmentHttpChallengeResult']:
        return pulumi.get(self, "http_challenges")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkConfigurations")
    def network_configurations(self) -> Sequence['outputs.GetCPSEnrollmentNetworkConfigurationResult']:
        return pulumi.get(self, "network_configurations")

    @property
    @pulumi.getter
    def organizations(self) -> Sequence['outputs.GetCPSEnrollmentOrganizationResult']:
        return pulumi.get(self, "organizations")

    @property
    @pulumi.getter(name="registrationAuthority")
    def registration_authority(self) -> str:
        return pulumi.get(self, "registration_authority")

    @property
    @pulumi.getter
    def sans(self) -> Sequence[str]:
        return pulumi.get(self, "sans")

    @property
    @pulumi.getter(name="secureNetwork")
    def secure_network(self) -> str:
        return pulumi.get(self, "secure_network")

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> str:
        return pulumi.get(self, "signature_algorithm")

    @property
    @pulumi.getter(name="sniOnly")
    def sni_only(self) -> bool:
        return pulumi.get(self, "sni_only")

    @property
    @pulumi.getter(name="techContacts")
    def tech_contacts(self) -> Sequence['outputs.GetCPSEnrollmentTechContactResult']:
        return pulumi.get(self, "tech_contacts")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> str:
        return pulumi.get(self, "validation_type")


class AwaitableGetCPSEnrollmentResult(GetCPSEnrollmentResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetCPSEnrollmentResult(
            admin_contacts=self.admin_contacts,
            certificate_chain_type=self.certificate_chain_type,
            certificate_type=self.certificate_type,
            common_name=self.common_name,
            contract_id=self.contract_id,
            csrs=self.csrs,
            dns_challenges=self.dns_challenges,
            enable_multi_stacked_certificates=self.enable_multi_stacked_certificates,
            enrollment_id=self.enrollment_id,
            http_challenges=self.http_challenges,
            id=self.id,
            network_configurations=self.network_configurations,
            organizations=self.organizations,
            registration_authority=self.registration_authority,
            sans=self.sans,
            secure_network=self.secure_network,
            signature_algorithm=self.signature_algorithm,
            sni_only=self.sni_only,
            tech_contacts=self.tech_contacts,
            validation_type=self.validation_type)


def get_cps_enrollment(enrollment_id: Optional[int] = None,
                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCPSEnrollmentResult:
    """
    Use the _get_cps_enrollment_ data source to return data for specific enrollment.

    ## Basic usage

    This example shows how to set up a user:

    ```python
    import pulumi
    import pulumi_akamai as akamai

    test_enrollment = akamai.get_cps_enrollment(enrollment_id=var["enrollment_id"])
    pulumi.export("dvOutput", test_enrollment)
    ```

    ## Attributes reference

    This data source returns these attributes:

      * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
      * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
      * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.
      * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
      * `admin_contact` - Contact information for the certificate administrator at your company.
      * `certificate_chain_type` - Certificate trust chain type.
      * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
        * `country_code` - The country code for the country where your organization is located.
        * `city` - The city where your organization resides.
        * `organization` - The name of your company or organization.
        * `organizational_unit` - Your organizational unit.
        * `preferred_trust_chain` - For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake.
        * `state` - Your state or province.
      * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
      * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
        * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
          * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
          * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
          * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
        * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
        * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
        * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
        * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
        * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
      * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
      * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.
      * `organization` - The name of the organization in Akamai where your technical contact works.
        * `name` - The name of the technical contact at Akamai.
        * `phone` - The phone number of the technical contact at Akamai.
        * `address_line_one` - The address for the technical contact at Akamai.
        * `address_line_two` - The address for the technical contact at Akamai.
        * `city` - The address for the technical contact at Akamai.
        * `region` - The region for the technical contact at Akamai.
        * `postal_code` - The postal code for the technical contact at Akamai.
        * `country_code` - The country code for the technical contact at Akamai.
      * `contract_id` - A contract's ID, optionally with the `ctr_` prefix.
      * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
      * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
      * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
      * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
        * `domain` - The domain to validate.
        * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.
        * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.


    :param int enrollment_id: Unique identifier for the certificate enrollment.
    """
    __args__ = dict()
    __args__['enrollmentId'] = enrollment_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('akamai:index/getCPSEnrollment:getCPSEnrollment', __args__, opts=opts, typ=GetCPSEnrollmentResult).value

    return AwaitableGetCPSEnrollmentResult(
        admin_contacts=__ret__.admin_contacts,
        certificate_chain_type=__ret__.certificate_chain_type,
        certificate_type=__ret__.certificate_type,
        common_name=__ret__.common_name,
        contract_id=__ret__.contract_id,
        csrs=__ret__.csrs,
        dns_challenges=__ret__.dns_challenges,
        enable_multi_stacked_certificates=__ret__.enable_multi_stacked_certificates,
        enrollment_id=__ret__.enrollment_id,
        http_challenges=__ret__.http_challenges,
        id=__ret__.id,
        network_configurations=__ret__.network_configurations,
        organizations=__ret__.organizations,
        registration_authority=__ret__.registration_authority,
        sans=__ret__.sans,
        secure_network=__ret__.secure_network,
        signature_algorithm=__ret__.signature_algorithm,
        sni_only=__ret__.sni_only,
        tech_contacts=__ret__.tech_contacts,
        validation_type=__ret__.validation_type)


@_utilities.lift_output_func(get_cps_enrollment)
def get_cps_enrollment_output(enrollment_id: Optional[pulumi.Input[int]] = None,
                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCPSEnrollmentResult]:
    """
    Use the _get_cps_enrollment_ data source to return data for specific enrollment.

    ## Basic usage

    This example shows how to set up a user:

    ```python
    import pulumi
    import pulumi_akamai as akamai

    test_enrollment = akamai.get_cps_enrollment(enrollment_id=var["enrollment_id"])
    pulumi.export("dvOutput", test_enrollment)
    ```

    ## Attributes reference

    This data source returns these attributes:

      * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
      * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
      * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.
      * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
      * `admin_contact` - Contact information for the certificate administrator at your company.
      * `certificate_chain_type` - Certificate trust chain type.
      * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
        * `country_code` - The country code for the country where your organization is located.
        * `city` - The city where your organization resides.
        * `organization` - The name of your company or organization.
        * `organizational_unit` - Your organizational unit.
        * `preferred_trust_chain` - For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake.
        * `state` - Your state or province.
      * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
      * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
        * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
          * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
          * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
          * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
        * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
        * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
        * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
        * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
        * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
      * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
      * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.
      * `organization` - The name of the organization in Akamai where your technical contact works.
        * `name` - The name of the technical contact at Akamai.
        * `phone` - The phone number of the technical contact at Akamai.
        * `address_line_one` - The address for the technical contact at Akamai.
        * `address_line_two` - The address for the technical contact at Akamai.
        * `city` - The address for the technical contact at Akamai.
        * `region` - The region for the technical contact at Akamai.
        * `postal_code` - The postal code for the technical contact at Akamai.
        * `country_code` - The country code for the technical contact at Akamai.
      * `contract_id` - A contract's ID, optionally with the `ctr_` prefix.
      * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
      * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
      * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
      * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
        * `domain` - The domain to validate.
        * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.
        * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.


    :param int enrollment_id: Unique identifier for the certificate enrollment.
    """
    ...
