# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AppSecSiemSettingsExceptions',
    'ClientlistListItem',
    'CloudAccessKeyCredentialsA',
    'CloudAccessKeyCredentialsB',
    'CloudAccessKeyNetworkConfiguration',
    'CloudAccessKeyTimeouts',
    'CloudletsApplicationLoadBalancerActivationTimeouts',
    'CloudletsApplicationLoadBalancerDataCenter',
    'CloudletsApplicationLoadBalancerLivenessSettings',
    'CloudletsPolicyActivationTimeouts',
    'CloudletsPolicyTimeouts',
    'CloudwrapperActivationTimeouts',
    'CloudwrapperConfigurationLocation',
    'CloudwrapperConfigurationLocationCapacity',
    'CloudwrapperConfigurationTimeouts',
    'CpCodeTimeouts',
    'CpsDvEnrollmentAdminContact',
    'CpsDvEnrollmentCsr',
    'CpsDvEnrollmentDnsChallenge',
    'CpsDvEnrollmentHttpChallenge',
    'CpsDvEnrollmentNetworkConfiguration',
    'CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication',
    'CpsDvEnrollmentOrganization',
    'CpsDvEnrollmentTechContact',
    'CpsDvEnrollmentTimeouts',
    'CpsDvValidationTimeouts',
    'CpsThirdPartyEnrollmentAdminContact',
    'CpsThirdPartyEnrollmentCsr',
    'CpsThirdPartyEnrollmentNetworkConfiguration',
    'CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication',
    'CpsThirdPartyEnrollmentOrganization',
    'CpsThirdPartyEnrollmentTechContact',
    'CpsThirdPartyEnrollmentTimeouts',
    'CpsUploadCertificateTimeouts',
    'DatastreamAzureConnector',
    'DatastreamDatadogConnector',
    'DatastreamDeliveryConfiguration',
    'DatastreamDeliveryConfigurationFrequency',
    'DatastreamElasticsearchConnector',
    'DatastreamGcsConnector',
    'DatastreamHttpsConnector',
    'DatastreamLogglyConnector',
    'DatastreamNewRelicConnector',
    'DatastreamOracleConnector',
    'DatastreamS3Connector',
    'DatastreamSplunkConnector',
    'DatastreamSumologicConnector',
    'DnsZoneOutboundZoneTransfer',
    'DnsZoneOutboundZoneTransferTsigKey',
    'DnsZoneTsigKey',
    'EdgeHostNameTimeouts',
    'EdgeWorkerTimeouts',
    'EdgeWorkersActivationTimeouts',
    'EdgekvGroupItemsTimeouts',
    'GtmAsmapAssignment',
    'GtmAsmapDefaultDatacenter',
    'GtmCidrmapAssignment',
    'GtmCidrmapDefaultDatacenter',
    'GtmDatacenterDefaultLoadObject',
    'GtmGeomapAssignment',
    'GtmGeomapDefaultDatacenter',
    'GtmPropertyLivenessTest',
    'GtmPropertyLivenessTestHttpHeader',
    'GtmPropertyStaticRrSet',
    'GtmPropertyTrafficTarget',
    'GtmResourceResourceInstance',
    'IamApiClientActions',
    'IamApiClientApiAccess',
    'IamApiClientApiAccessApi',
    'IamApiClientCredential',
    'IamApiClientCredentialActions',
    'IamApiClientGroupAccess',
    'IamApiClientGroupAccessGroup',
    'IamApiClientGroupAccessGroupSubGroup',
    'IamApiClientIpAcl',
    'IamApiClientPurgeOptions',
    'IamApiClientPurgeOptionsCpCodeAccess',
    'IamCidrBlockActions',
    'IamUserUserNotifications',
    'PropertyActivationComplianceRecord',
    'PropertyActivationComplianceRecordNoncomplianceReasonEmergency',
    'PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic',
    'PropertyActivationComplianceRecordNoncomplianceReasonNone',
    'PropertyActivationComplianceRecordNoncomplianceReasonOther',
    'PropertyActivationRuleError',
    'PropertyActivationTimeouts',
    'PropertyHostname',
    'PropertyHostnameBucketHostnames',
    'PropertyHostnameCertStatus',
    'PropertyIncludeActivationComplianceRecord',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther',
    'PropertyIncludeActivationTimeouts',
    'PropertyRuleError',
    'PropertyRuleWarning',
    'GetAppsecRapidRulesRapidRuleResult',
    'GetCPSEnrollmentAdminContactResult',
    'GetCPSEnrollmentCsrResult',
    'GetCPSEnrollmentDnsChallengeResult',
    'GetCPSEnrollmentHttpChallengeResult',
    'GetCPSEnrollmentNetworkConfigurationResult',
    'GetCPSEnrollmentNetworkConfigurationClientMutualAuthenticationResult',
    'GetCPSEnrollmentOrganizationResult',
    'GetCPSEnrollmentTechContactResult',
    'GetCPSEnrollmentsEnrollmentResult',
    'GetCPSEnrollmentsEnrollmentAdminContactResult',
    'GetCPSEnrollmentsEnrollmentCsrResult',
    'GetCPSEnrollmentsEnrollmentNetworkConfigurationResult',
    'GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthenticationResult',
    'GetCPSEnrollmentsEnrollmentOrganizationResult',
    'GetCPSEnrollmentsEnrollmentTechContactResult',
    'GetClientlistListsListResult',
    'GetCloudaccessKeyGroupResult',
    'GetCloudaccessKeyNetworkConfigurationResult',
    'GetCloudaccessKeyPropertiesPropertyResult',
    'GetCloudaccessKeyVersionsAccessKeyVersionResult',
    'GetCloudaccessKeysAccessKeyResult',
    'GetCloudaccessKeysAccessKeyGroupResult',
    'GetCloudaccessKeysAccessKeyNetworkConfigurationResult',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleResult',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchResult',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsApplicationLoadBalancerDataCenterResult',
    'GetCloudletsApplicationLoadBalancerLivenessSettingResult',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleResult',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingResult',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchResult',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleResult',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsResult',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchResult',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleResult',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchResult',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleResult',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsResult',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchResult',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleResult',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsResult',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchResult',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsPolicyActivationResult',
    'GetCloudletsPolicyActivationPolicyInfoResult',
    'GetCloudletsPolicyActivationPropertyInfoResult',
    'GetCloudletsRequestControlMatchRuleMatchRuleResult',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchResult',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudletsSharedPolicyActivationsResult',
    'GetCloudletsSharedPolicyActivationsProductionResult',
    'GetCloudletsSharedPolicyActivationsProductionEffectiveResult',
    'GetCloudletsSharedPolicyActivationsProductionLatestResult',
    'GetCloudletsSharedPolicyActivationsStagingResult',
    'GetCloudletsSharedPolicyActivationsStagingEffectiveResult',
    'GetCloudletsSharedPolicyActivationsStagingLatestResult',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleResult',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchResult',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult',
    'GetCloudwrapperCapacitiesCapacityResult',
    'GetCloudwrapperCapacitiesCapacityApprovedResult',
    'GetCloudwrapperCapacitiesCapacityAssignedResult',
    'GetCloudwrapperCapacitiesCapacityUnassignedResult',
    'GetCloudwrapperConfigurationLocationResult',
    'GetCloudwrapperConfigurationLocationCapacityResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsBoccResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsResult',
    'GetCloudwrapperConfigurationMultiCdnSettingsOriginResult',
    'GetCloudwrapperConfigurationsConfigurationResult',
    'GetCloudwrapperConfigurationsConfigurationLocationResult',
    'GetCloudwrapperConfigurationsConfigurationLocationCapacityResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsResult',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginResult',
    'GetCloudwrapperLocationsLocationResult',
    'GetCloudwrapperLocationsLocationTrafficTypeResult',
    'GetCloudwrapperPropertiesPropertyResult',
    'GetContractsContractResult',
    'GetCpCodesCpCodeResult',
    'GetDatastreamActivationHistoryActivationResult',
    'GetDatastreamDatasetFieldsDatasetFieldResult',
    'GetDatastreamsStreamsDetailResult',
    'GetDatastreamsStreamsDetailPropertyResult',
    'GetGroupsGroupResult',
    'GetGtmAsmapAssignmentResult',
    'GetGtmAsmapDefaultDatacenterResult',
    'GetGtmAsmapLinkResult',
    'GetGtmCidrmapAssignmentResult',
    'GetGtmCidrmapDefaultDatacenterResult',
    'GetGtmCidrmapLinkResult',
    'GetGtmDatacenterDefaultLoadObjectResult',
    'GetGtmDatacenterLinkResult',
    'GetGtmDatacentersDatacenterResult',
    'GetGtmDatacentersDatacenterDefaultLoadObjectResult',
    'GetGtmDatacentersDatacenterLinkResult',
    'GetGtmDomainAsMapResult',
    'GetGtmDomainAsMapAssignmentResult',
    'GetGtmDomainAsMapDefaultDatacenterResult',
    'GetGtmDomainAsMapLinkResult',
    'GetGtmDomainCidrMapResult',
    'GetGtmDomainCidrMapAssignmentResult',
    'GetGtmDomainCidrMapDefaultDatacenterResult',
    'GetGtmDomainCidrMapLinkResult',
    'GetGtmDomainDatacenterResult',
    'GetGtmDomainDatacenterDefaultLoadObjectResult',
    'GetGtmDomainDatacenterLinkResult',
    'GetGtmDomainGeographicMapResult',
    'GetGtmDomainGeographicMapAssignmentResult',
    'GetGtmDomainGeographicMapDefaultDatacenterResult',
    'GetGtmDomainGeographicMapLinkResult',
    'GetGtmDomainLinkResult',
    'GetGtmDomainPropertyResult',
    'GetGtmDomainPropertyLinkResult',
    'GetGtmDomainPropertyLivenessTestResult',
    'GetGtmDomainPropertyLivenessTestHttpHeaderResult',
    'GetGtmDomainPropertyStaticRrSetResult',
    'GetGtmDomainPropertyTrafficTargetResult',
    'GetGtmDomainResourceResult',
    'GetGtmDomainResourceLinkResult',
    'GetGtmDomainResourceResourceInstanceResult',
    'GetGtmDomainStatusResult',
    'GetGtmDomainStatusLinkResult',
    'GetGtmDomainsDomainResult',
    'GetGtmDomainsDomainLinkResult',
    'GetGtmGeomapAssignmentResult',
    'GetGtmGeomapDefaultDatacenterResult',
    'GetGtmGeomapLinkResult',
    'GetGtmGeomapsGeoMapResult',
    'GetGtmGeomapsGeoMapAssignmentResult',
    'GetGtmGeomapsGeoMapDefaultDatacenterResult',
    'GetGtmGeomapsGeoMapLinkResult',
    'GetGtmResourceLinkResult',
    'GetGtmResourceResourceInstanceResult',
    'GetGtmResourcesResourceResult',
    'GetGtmResourcesResourceLinkResult',
    'GetGtmResourcesResourceResourceInstanceResult',
    'GetIamAccountSwitchKeysAccountSwitchKeyResult',
    'GetIamAllowedApisAllowedApiResult',
    'GetIamApiClientActionsResult',
    'GetIamApiClientApiAccessResult',
    'GetIamApiClientApiAccessApiResult',
    'GetIamApiClientCredentialResult',
    'GetIamApiClientCredentialActionsResult',
    'GetIamApiClientGroupAccessResult',
    'GetIamApiClientGroupAccessGroupResult',
    'GetIamApiClientGroupAccessGroupSubGroupResult',
    'GetIamApiClientIpAclResult',
    'GetIamApiClientPurgeOptionsResult',
    'GetIamApiClientPurgeOptionsCpCodeAccessResult',
    'GetIamApiClientsApiClientResult',
    'GetIamApiClientsApiClientActionsResult',
    'GetIamBlockedPropertiesBlockedPropertyResult',
    'GetIamCidrBlockActionsResult',
    'GetIamCidrBlocksCidrBlockResult',
    'GetIamCidrBlocksCidrBlockActionsResult',
    'GetIamGrantableRolesGrantableRoleResult',
    'GetIamPropertyUsersUserResult',
    'GetIamRoleActionsResult',
    'GetIamRoleGrantedRoleResult',
    'GetIamRoleUserResult',
    'GetIamRolesRoleResult',
    'GetIamTimezonesTimezoneResult',
    'GetIamUsersAffectedByMovingGroupUserResult',
    'GetImagingPolicyImagePolicyResult',
    'GetImagingPolicyImagePolicyBreakpointsResult',
    'GetImagingPolicyImagePolicyOutputResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBlurResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationContrastResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGoopResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHslResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHsvResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorResult',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskResult',
    'GetImagingPolicyImagePolicyTransformationResult',
    'GetImagingPolicyImagePolicyTransformationAppendResult',
    'GetImagingPolicyImagePolicyTransformationAppendImageResult',
    'GetImagingPolicyImagePolicyTransformationAppendImageBoxImageResult',
    'GetImagingPolicyImagePolicyTransformationAppendImageCircleImageResult',
    'GetImagingPolicyImagePolicyTransformationAppendImageTextImageResult',
    'GetImagingPolicyImagePolicyTransformationAppendImageUrlImageResult',
    'GetImagingPolicyImagePolicyTransformationAspectCropResult',
    'GetImagingPolicyImagePolicyTransformationBackgroundColorResult',
    'GetImagingPolicyImagePolicyTransformationBlurResult',
    'GetImagingPolicyImagePolicyTransformationChromaKeyResult',
    'GetImagingPolicyImagePolicyTransformationCompositeResult',
    'GetImagingPolicyImagePolicyTransformationCompositeImageResult',
    'GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageResult',
    'GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageResult',
    'GetImagingPolicyImagePolicyTransformationCompositeImageTextImageResult',
    'GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageResult',
    'GetImagingPolicyImagePolicyTransformationCompoundResult',
    'GetImagingPolicyImagePolicyTransformationContrastResult',
    'GetImagingPolicyImagePolicyTransformationCropResult',
    'GetImagingPolicyImagePolicyTransformationFaceCropResult',
    'GetImagingPolicyImagePolicyTransformationFeatureCropResult',
    'GetImagingPolicyImagePolicyTransformationFitAndFillResult',
    'GetImagingPolicyImagePolicyTransformationGoopResult',
    'GetImagingPolicyImagePolicyTransformationGrayscaleResult',
    'GetImagingPolicyImagePolicyTransformationHslResult',
    'GetImagingPolicyImagePolicyTransformationHsvResult',
    'GetImagingPolicyImagePolicyTransformationIfDimensionResult',
    'GetImagingPolicyImagePolicyTransformationIfOrientationResult',
    'GetImagingPolicyImagePolicyTransformationImQueryResult',
    'GetImagingPolicyImagePolicyTransformationMaxColorResult',
    'GetImagingPolicyImagePolicyTransformationMirrorResult',
    'GetImagingPolicyImagePolicyTransformationMonoHueResult',
    'GetImagingPolicyImagePolicyTransformationOpacityResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeResult',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeResult',
    'GetImagingPolicyImagePolicyTransformationRelativeCropResult',
    'GetImagingPolicyImagePolicyTransformationRemoveColorResult',
    'GetImagingPolicyImagePolicyTransformationResizeResult',
    'GetImagingPolicyImagePolicyTransformationRotateResult',
    'GetImagingPolicyImagePolicyTransformationScaleResult',
    'GetImagingPolicyImagePolicyTransformationShearsResult',
    'GetImagingPolicyImagePolicyTransformationSmartCropResult',
    'GetImagingPolicyImagePolicyTransformationTrimResult',
    'GetImagingPolicyImagePolicyTransformationUnsharpMaskResult',
    'GetImagingPolicyImagePolicyVariableResult',
    'GetImagingPolicyImagePolicyVariableEnumOptionResult',
    'GetImagingPolicyVideoPolicyResult',
    'GetImagingPolicyVideoPolicyBreakpointsResult',
    'GetImagingPolicyVideoPolicyOutputResult',
    'GetImagingPolicyVideoPolicyVariableResult',
    'GetImagingPolicyVideoPolicyVariableEnumOptionResult',
    'GetPropertiesPropertyResult',
    'GetPropertiesSearchPropertyResult',
    'GetPropertyHostnameActivationHostnameResult',
    'GetPropertyHostnameActivationsHostnameActivationResult',
    'GetPropertyHostnamesDiffHostnameResult',
    'GetPropertyHostnamesHostnameResult',
    'GetPropertyHostnamesHostnameBucketResult',
    'GetPropertyHostnamesHostnameBucketCertStatusResult',
    'GetPropertyHostnamesHostnameCertStatusResult',
    'GetPropertyIncludeParentsParentResult',
    'GetPropertyIncludesIncludeResult',
    'GetPropertyIncludesParentPropertyResult',
    'GetPropertyProductsProductResult',
    'GetPropertyRulesTemplateTemplateResult',
    'GetPropertyRulesTemplateVariableResult',
    'GetZoneDnssecStatusCurrentRecordsResult',
    'GetZoneDnssecStatusNewRecordsResult',
]

@pulumi.output_type
class AppSecSiemSettingsExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiRequestConstraints":
            suggest = "api_request_constraints"
        elif key == "aprProtections":
            suggest = "apr_protections"
        elif key == "botManagements":
            suggest = "bot_managements"
        elif key == "clientReps":
            suggest = "client_reps"
        elif key == "customRules":
            suggest = "custom_rules"
        elif key == "ipGeos":
            suggest = "ip_geos"
        elif key == "malwareProtections":
            suggest = "malware_protections"
        elif key == "slowPosts":
            suggest = "slow_posts"
        elif key == "urlProtections":
            suggest = "url_protections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSecSiemSettingsExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSecSiemSettingsExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSecSiemSettingsExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_request_constraints: Optional[Sequence[_builtins.str]] = None,
                 apr_protections: Optional[Sequence[_builtins.str]] = None,
                 bot_managements: Optional[Sequence[_builtins.str]] = None,
                 client_reps: Optional[Sequence[_builtins.str]] = None,
                 custom_rules: Optional[Sequence[_builtins.str]] = None,
                 ip_geos: Optional[Sequence[_builtins.str]] = None,
                 malware_protections: Optional[Sequence[_builtins.str]] = None,
                 rates: Optional[Sequence[_builtins.str]] = None,
                 slow_posts: Optional[Sequence[_builtins.str]] = None,
                 url_protections: Optional[Sequence[_builtins.str]] = None,
                 wafs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_request_constraints: Whether there should be an exception to include api request constraints events in SIEM
        :param Sequence[_builtins.str] apr_protections: Whether there should be an exception to include apr protection events in SIEM
        :param Sequence[_builtins.str] bot_managements: Whether there should be an exception to include bot management events in SIEM
        :param Sequence[_builtins.str] client_reps: Whether there should be an exception to include client reputation events in SIEM
        :param Sequence[_builtins.str] custom_rules: Whether there should be an exception to include custom rules events in SIEM
        :param Sequence[_builtins.str] ip_geos: Whether there should be an exception to include ip geo events in SIEM
        :param Sequence[_builtins.str] malware_protections: Whether there should be an exception to include malware protection events in SIEM
        :param Sequence[_builtins.str] rates: Whether there should be an exception to include rate events in SIEM
        :param Sequence[_builtins.str] slow_posts: Whether there should be an exception to include slow post events in SIEM
        :param Sequence[_builtins.str] url_protections: Whether there should be an exception to include url protection events in SIEM
        :param Sequence[_builtins.str] wafs: Whether there should be an exception to include waf events in SIEM
        """
        if api_request_constraints is not None:
            pulumi.set(__self__, "api_request_constraints", api_request_constraints)
        if apr_protections is not None:
            pulumi.set(__self__, "apr_protections", apr_protections)
        if bot_managements is not None:
            pulumi.set(__self__, "bot_managements", bot_managements)
        if client_reps is not None:
            pulumi.set(__self__, "client_reps", client_reps)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if ip_geos is not None:
            pulumi.set(__self__, "ip_geos", ip_geos)
        if malware_protections is not None:
            pulumi.set(__self__, "malware_protections", malware_protections)
        if rates is not None:
            pulumi.set(__self__, "rates", rates)
        if slow_posts is not None:
            pulumi.set(__self__, "slow_posts", slow_posts)
        if url_protections is not None:
            pulumi.set(__self__, "url_protections", url_protections)
        if wafs is not None:
            pulumi.set(__self__, "wafs", wafs)

    @_builtins.property
    @pulumi.getter(name="apiRequestConstraints")
    def api_request_constraints(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include api request constraints events in SIEM
        """
        return pulumi.get(self, "api_request_constraints")

    @_builtins.property
    @pulumi.getter(name="aprProtections")
    def apr_protections(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include apr protection events in SIEM
        """
        return pulumi.get(self, "apr_protections")

    @_builtins.property
    @pulumi.getter(name="botManagements")
    def bot_managements(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include bot management events in SIEM
        """
        return pulumi.get(self, "bot_managements")

    @_builtins.property
    @pulumi.getter(name="clientReps")
    def client_reps(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include client reputation events in SIEM
        """
        return pulumi.get(self, "client_reps")

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include custom rules events in SIEM
        """
        return pulumi.get(self, "custom_rules")

    @_builtins.property
    @pulumi.getter(name="ipGeos")
    def ip_geos(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include ip geo events in SIEM
        """
        return pulumi.get(self, "ip_geos")

    @_builtins.property
    @pulumi.getter(name="malwareProtections")
    def malware_protections(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include malware protection events in SIEM
        """
        return pulumi.get(self, "malware_protections")

    @_builtins.property
    @pulumi.getter
    def rates(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include rate events in SIEM
        """
        return pulumi.get(self, "rates")

    @_builtins.property
    @pulumi.getter(name="slowPosts")
    def slow_posts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include slow post events in SIEM
        """
        return pulumi.get(self, "slow_posts")

    @_builtins.property
    @pulumi.getter(name="urlProtections")
    def url_protections(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include url protection events in SIEM
        """
        return pulumi.get(self, "url_protections")

    @_builtins.property
    @pulumi.getter
    def wafs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Whether there should be an exception to include waf events in SIEM
        """
        return pulumi.get(self, "wafs")


@pulumi.output_type
class ClientlistListItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientlistListItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientlistListItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientlistListItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 expiration_date: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str value: Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
        :param _builtins.str description: A description of the item.
        :param _builtins.str expiration_date: The item expiration date.
        :param Sequence[_builtins.str] tags: The item tags.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the item.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[_builtins.str]:
        """
        The item expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        The item tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CloudAccessKeyCredentialsA(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccessKeyId":
            suggest = "cloud_access_key_id"
        elif key == "cloudSecretAccessKey":
            suggest = "cloud_secret_access_key"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "versionGuid":
            suggest = "version_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccessKeyCredentialsA. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccessKeyCredentialsA.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccessKeyCredentialsA.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_access_key_id: _builtins.str,
                 cloud_secret_access_key: _builtins.str,
                 primary_key: _builtins.bool,
                 version: Optional[_builtins.int] = None,
                 version_guid: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_access_key_id: Access key id from cloud provider which is used to sign API requests
        :param _builtins.str cloud_secret_access_key: Cloud Access secret from cloud provider which is used to sign API requests
        :param _builtins.bool primary_key: Boolean value which helps to define if credentials should be assigned to property
        :param _builtins.int version: Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        :param _builtins.str version_guid: The unique identifier assigned to specific access key version
        """
        pulumi.set(__self__, "cloud_access_key_id", cloud_access_key_id)
        pulumi.set(__self__, "cloud_secret_access_key", cloud_secret_access_key)
        pulumi.set(__self__, "primary_key", primary_key)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="cloudAccessKeyId")
    def cloud_access_key_id(self) -> _builtins.str:
        """
        Access key id from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_access_key_id")

    @_builtins.property
    @pulumi.getter(name="cloudSecretAccessKey")
    def cloud_secret_access_key(self) -> _builtins.str:
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> _builtins.bool:
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[_builtins.str]:
        """
        The unique identifier assigned to specific access key version
        """
        return pulumi.get(self, "version_guid")


@pulumi.output_type
class CloudAccessKeyCredentialsB(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccessKeyId":
            suggest = "cloud_access_key_id"
        elif key == "cloudSecretAccessKey":
            suggest = "cloud_secret_access_key"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "versionGuid":
            suggest = "version_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccessKeyCredentialsB. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccessKeyCredentialsB.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccessKeyCredentialsB.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_access_key_id: _builtins.str,
                 cloud_secret_access_key: _builtins.str,
                 primary_key: _builtins.bool,
                 version: Optional[_builtins.int] = None,
                 version_guid: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_access_key_id: Access key id from cloud provider which is used to sign API requests
        :param _builtins.str cloud_secret_access_key: Cloud Access secret from cloud provider which is used to sign API requests
        :param _builtins.bool primary_key: Boolean value which helps to define if credentials should be assigned to property
        :param _builtins.int version: Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        :param _builtins.str version_guid: The unique identifier assigned to specific access key version
        """
        pulumi.set(__self__, "cloud_access_key_id", cloud_access_key_id)
        pulumi.set(__self__, "cloud_secret_access_key", cloud_secret_access_key)
        pulumi.set(__self__, "primary_key", primary_key)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="cloudAccessKeyId")
    def cloud_access_key_id(self) -> _builtins.str:
        """
        Access key id from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_access_key_id")

    @_builtins.property
    @pulumi.getter(name="cloudSecretAccessKey")
    def cloud_secret_access_key(self) -> _builtins.str:
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> _builtins.bool:
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[_builtins.str]:
        """
        The unique identifier assigned to specific access key version
        """
        return pulumi.get(self, "version_guid")


@pulumi.output_type
class CloudAccessKeyNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityNetwork":
            suggest = "security_network"
        elif key == "additionalCdn":
            suggest = "additional_cdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccessKeyNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccessKeyNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccessKeyNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_network: _builtins.str,
                 additional_cdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str security_network: The API deploys the access key to this secure network
        :param _builtins.str additional_cdn: Additional type of the deployment network that the access key will be deployed to.
        """
        pulumi.set(__self__, "security_network", security_network)
        if additional_cdn is not None:
            pulumi.set(__self__, "additional_cdn", additional_cdn)

    @_builtins.property
    @pulumi.getter(name="securityNetwork")
    def security_network(self) -> _builtins.str:
        """
        The API deploys the access key to this secure network
        """
        return pulumi.get(self, "security_network")

    @_builtins.property
    @pulumi.getter(name="additionalCdn")
    def additional_cdn(self) -> Optional[_builtins.str]:
        """
        Additional type of the deployment network that the access key will be deployed to.
        """
        return pulumi.get(self, "additional_cdn")


@pulumi.output_type
class CloudAccessKeyTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
        :param _builtins.str delete: Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
        :param _builtins.str update: Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CloudletsApplicationLoadBalancerActivationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CloudletsApplicationLoadBalancerDataCenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"
        elif key == "cloudServerHostHeaderOverride":
            suggest = "cloud_server_host_header_override"
        elif key == "cloudService":
            suggest = "cloud_service"
        elif key == "livenessHosts":
            suggest = "liveness_hosts"
        elif key == "stateOrProvince":
            suggest = "state_or_province"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudletsApplicationLoadBalancerDataCenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudletsApplicationLoadBalancerDataCenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudletsApplicationLoadBalancerDataCenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent: _builtins.str,
                 country: _builtins.str,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 origin_id: _builtins.str,
                 percent: _builtins.float,
                 city: Optional[_builtins.str] = None,
                 cloud_server_host_header_override: Optional[_builtins.bool] = None,
                 cloud_service: Optional[_builtins.bool] = None,
                 hostname: Optional[_builtins.str] = None,
                 liveness_hosts: Optional[Sequence[_builtins.str]] = None,
                 state_or_province: Optional[_builtins.str] = None):
        """
        :param _builtins.str continent: The continent on which the data center is located
        :param _builtins.str country: The country in which the data center is located
        :param _builtins.float latitude: The latitude value for the data center. This member supports six decimal places of precision.
        :param _builtins.float longitude: The longitude value for the data center. This member supports six decimal places of precision.
        :param _builtins.str origin_id: The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        :param _builtins.float percent: The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        :param _builtins.str city: The city in which the data center is located.
        :param _builtins.bool cloud_server_host_header_override: Describes if cloud server host header is overridden
        :param _builtins.bool cloud_service: Describes if this datacenter is a cloud service
        :param _builtins.str hostname: This should match the 'hostname' value defined for this datacenter in Property Manager
        :param Sequence[_builtins.str] liveness_hosts: An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        :param _builtins.str state_or_province: The state, province, or region where the data center is located
        """
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if cloud_server_host_header_override is not None:
            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        if cloud_service is not None:
            pulumi.set(__self__, "cloud_service", cloud_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if liveness_hosts is not None:
            pulumi.set(__self__, "liveness_hosts", liveness_hosts)
        if state_or_province is not None:
            pulumi.set(__self__, "state_or_province", state_or_province)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        The continent on which the data center is located
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        The country in which the data center is located
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        The latitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        The longitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.float:
        """
        The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        """
        return pulumi.get(self, "percent")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        The city in which the data center is located.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> Optional[_builtins.bool]:
        """
        Describes if cloud server host header is overridden
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @_builtins.property
    @pulumi.getter(name="cloudService")
    def cloud_service(self) -> Optional[_builtins.bool]:
        """
        Describes if this datacenter is a cloud service
        """
        return pulumi.get(self, "cloud_service")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        This should match the 'hostname' value defined for this datacenter in Property Manager
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="livenessHosts")
    def liveness_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        """
        return pulumi.get(self, "liveness_hosts")

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> Optional[_builtins.str]:
        """
        The state, province, or region where the data center is located
        """
        return pulumi.get(self, "state_or_province")


@pulumi.output_type
class CloudletsApplicationLoadBalancerLivenessSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalHeaders":
            suggest = "additional_headers"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "peerCertificateVerification":
            suggest = "peer_certificate_verification"
        elif key == "requestString":
            suggest = "request_string"
        elif key == "responseString":
            suggest = "response_string"
        elif key == "status3xxFailure":
            suggest = "status3xx_failure"
        elif key == "status4xxFailure":
            suggest = "status4xx_failure"
        elif key == "status5xxFailure":
            suggest = "status5xx_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudletsApplicationLoadBalancerLivenessSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudletsApplicationLoadBalancerLivenessSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudletsApplicationLoadBalancerLivenessSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 additional_headers: Optional[Mapping[str, _builtins.str]] = None,
                 host_header: Optional[_builtins.str] = None,
                 interval: Optional[_builtins.int] = None,
                 peer_certificate_verification: Optional[_builtins.bool] = None,
                 request_string: Optional[_builtins.str] = None,
                 response_string: Optional[_builtins.str] = None,
                 status3xx_failure: Optional[_builtins.bool] = None,
                 status4xx_failure: Optional[_builtins.bool] = None,
                 status5xx_failure: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.float] = None):
        """
        :param _builtins.str path: The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        :param _builtins.int port: The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        :param _builtins.str protocol: The protocol or scheme for the database, either HTTP or HTTPS.
        :param Mapping[str, _builtins.str] additional_headers: Maps additional case-insensitive HTTP header names included to the liveness testing requests
        :param _builtins.str host_header: The Host header for the liveness HTTP request
        :param _builtins.int interval: Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        :param _builtins.bool peer_certificate_verification: Describes whether or not to validate the origin certificate for an HTTPS request
        :param _builtins.str request_string: The request which will be used for TCP(S) tests
        :param _builtins.bool status3xx_failure: Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        :param _builtins.bool status4xx_failure: Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        :param _builtins.bool status5xx_failure: Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        :param _builtins.float timeout: The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if status3xx_failure is not None:
            pulumi.set(__self__, "status3xx_failure", status3xx_failure)
        if status4xx_failure is not None:
            pulumi.set(__self__, "status4xx_failure", status4xx_failure)
        if status5xx_failure is not None:
            pulumi.set(__self__, "status5xx_failure", status5xx_failure)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol or scheme for the database, either HTTP or HTTPS.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Maps additional case-insensitive HTTP header names included to the liveness testing requests
        """
        return pulumi.get(self, "additional_headers")

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[_builtins.str]:
        """
        The Host header for the liveness HTTP request
        """
        return pulumi.get(self, "host_header")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[_builtins.bool]:
        """
        Describes whether or not to validate the origin certificate for an HTTPS request
        """
        return pulumi.get(self, "peer_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[_builtins.str]:
        """
        The request which will be used for TCP(S) tests
        """
        return pulumi.get(self, "request_string")

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_string")

    @_builtins.property
    @pulumi.getter(name="status3xxFailure")
    def status3xx_failure(self) -> Optional[_builtins.bool]:
        """
        Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        """
        return pulumi.get(self, "status3xx_failure")

    @_builtins.property
    @pulumi.getter(name="status4xxFailure")
    def status4xx_failure(self) -> Optional[_builtins.bool]:
        """
        Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        """
        return pulumi.get(self, "status4xx_failure")

    @_builtins.property
    @pulumi.getter(name="status5xxFailure")
    def status5xx_failure(self) -> Optional[_builtins.bool]:
        """
        Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        """
        return pulumi.get(self, "status5xx_failure")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.float]:
        """
        The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class CloudletsPolicyActivationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CloudletsPolicyTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CloudwrapperActivationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
        :param _builtins.str update: Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CloudwrapperConfigurationLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficTypeId":
            suggest = "traffic_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwrapperConfigurationLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwrapperConfigurationLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwrapperConfigurationLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comments: _builtins.str,
                 traffic_type_id: _builtins.int,
                 capacity: Optional['outputs.CloudwrapperConfigurationLocationCapacity'] = None):
        """
        :param _builtins.str comments: Additional comments provided by the user.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination
        :param 'CloudwrapperConfigurationLocationCapacityArgs' capacity: The capacity assigned to this configuration's location
        """
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional comments provided by the user.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination
        """
        return pulumi.get(self, "traffic_type_id")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.CloudwrapperConfigurationLocationCapacity']:
        """
        The capacity assigned to this configuration's location
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class CloudwrapperConfigurationLocationCapacity(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str unit: Unit of capacity. Can be either 'GB' or 'TB'.
        :param _builtins.int value: Value of capacity.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Unit of capacity. Can be either 'GB' or 'TB'.
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Value of capacity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudwrapperConfigurationTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class CpCodeTimeouts(dict):
    def __init__(__self__, *,
                 update: Optional[_builtins.str] = None):
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "update")


@pulumi.output_type
class CpsDvEnrollmentAdminContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "addressLineTwo":
            suggest = "address_line_two"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentAdminContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentAdminContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentAdminContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class CpsDvEnrollmentCsr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "preferredTrustChain":
            suggest = "preferred_trust_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentCsr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentCsr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentCsr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 organization: _builtins.str,
                 organizational_unit: Optional[_builtins.str] = None,
                 preferred_trust_chain: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: The code of the country where organization is located
        :param _builtins.str organization: Name of organization used in all legal documents
        :param _builtins.str organizational_unit: Organizational unit of organization
        :param _builtins.str preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param _builtins.str state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if preferred_trust_chain is not None:
            pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[_builtins.str]:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> Optional[_builtins.str]:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CpsDvEnrollmentDnsChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullPath":
            suggest = "full_path"
        elif key == "responseBody":
            suggest = "response_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentDnsChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentDnsChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentDnsChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 full_path: Optional[_builtins.str] = None,
                 response_body: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: Domain for which the challenges were completed
        :param _builtins.str full_path: The domain name where Akamai publishes the response body to validate
        :param _builtins.str response_body: The unique content of the challenge
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[_builtins.str]:
        """
        The domain name where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[_builtins.str]:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")


@pulumi.output_type
class CpsDvEnrollmentHttpChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullPath":
            suggest = "full_path"
        elif key == "responseBody":
            suggest = "response_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentHttpChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentHttpChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentHttpChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: Optional[_builtins.str] = None,
                 full_path: Optional[_builtins.str] = None,
                 response_body: Optional[_builtins.str] = None):
        """
        :param _builtins.str domain: Domain for which the challenges were completed
        :param _builtins.str full_path: The URL where Akamai publishes the response body to validate
        :param _builtins.str response_body: The unique content of the challenge
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[_builtins.str]:
        """
        The URL where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[_builtins.str]:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")


@pulumi.output_type
class CpsDvEnrollmentNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientMutualAuthentication":
            suggest = "client_mutual_authentication"
        elif key == "cloneDnsNames":
            suggest = "clone_dns_names"
        elif key == "disallowedTlsVersions":
            suggest = "disallowed_tls_versions"
        elif key == "mustHaveCiphers":
            suggest = "must_have_ciphers"
        elif key == "ocspStapling":
            suggest = "ocsp_stapling"
        elif key == "preferredCiphers":
            suggest = "preferred_ciphers"
        elif key == "quicEnabled":
            suggest = "quic_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geography: _builtins.str,
                 client_mutual_authentication: Optional['outputs.CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication'] = None,
                 clone_dns_names: Optional[_builtins.bool] = None,
                 disallowed_tls_versions: Optional[Sequence[_builtins.str]] = None,
                 must_have_ciphers: Optional[_builtins.str] = None,
                 ocsp_stapling: Optional[_builtins.str] = None,
                 preferred_ciphers: Optional[_builtins.str] = None,
                 quic_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str geography: Geography type used for enrollment
        :param 'CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs' client_mutual_authentication: The trust chain configuration used for client mutual authentication
        :param _builtins.bool clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        :param Sequence[_builtins.str] disallowed_tls_versions: TLS versions which are disallowed
        :param _builtins.str must_have_ciphers: Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param _builtins.str ocsp_stapling: Enable OCSP stapling. Default is 'on'
        :param _builtins.str preferred_ciphers: Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param _builtins.bool quic_enabled: Enable QUIC protocol. Default is false
        """
        pulumi.set(__self__, "geography", geography)
        if client_mutual_authentication is not None:
            pulumi.set(__self__, "client_mutual_authentication", client_mutual_authentication)
        if clone_dns_names is not None:
            pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        if disallowed_tls_versions is not None:
            pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        if must_have_ciphers is not None:
            pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        if ocsp_stapling is not None:
            pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        if preferred_ciphers is not None:
            pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        if quic_enabled is not None:
            pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter
    def geography(self) -> _builtins.str:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentication")
    def client_mutual_authentication(self) -> Optional['outputs.CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication']:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentication")

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> Optional[_builtins.bool]:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        return pulumi.get(self, "clone_dns_names")

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> Optional[_builtins.str]:
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "must_have_ciphers")

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> Optional[_builtins.str]:
        """
        Enable OCSP stapling. Default is 'on'
        """
        return pulumi.get(self, "ocsp_stapling")

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> Optional[_builtins.str]:
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "preferred_ciphers")

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable QUIC protocol. Default is false
        """
        return pulumi.get(self, "quic_enabled")


@pulumi.output_type
class CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocspEnabled":
            suggest = "ocsp_enabled"
        elif key == "sendCaListToClient":
            suggest = "send_ca_list_to_client"
        elif key == "setId":
            suggest = "set_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocsp_enabled: Optional[_builtins.bool] = None,
                 send_ca_list_to_client: Optional[_builtins.bool] = None,
                 set_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool ocsp_enabled: Enable OCSP stapling
        :param _builtins.bool send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param _builtins.str set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        if ocsp_enabled is not None:
            pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        if send_ca_list_to_client is not None:
            pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        if set_id is not None:
            pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> Optional[_builtins.bool]:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")


@pulumi.output_type
class CpsDvEnrollmentOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "addressLineTwo":
            suggest = "address_line_two"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_line_one: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 name: _builtins.str,
                 phone: _builtins.str,
                 postal_code: _builtins.str,
                 region: _builtins.str,
                 address_line_two: Optional[_builtins.str] = None):
        """
        :param _builtins.str address_line_one: The address of organization
        :param _builtins.str city: City of organization
        :param _builtins.str country_code: Country code of organization
        :param _builtins.str name: Name of organization
        :param _builtins.str phone: Phone number of organization
        :param _builtins.str postal_code: Postal code of organization
        :param _builtins.str region: The region of organization
        :param _builtins.str address_line_two: The address of organization
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City of organization
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        Country code of organization
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of organization
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> _builtins.str:
        """
        Postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region of organization
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")


@pulumi.output_type
class CpsDvEnrollmentTechContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "addressLineTwo":
            suggest = "address_line_two"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsDvEnrollmentTechContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsDvEnrollmentTechContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsDvEnrollmentTechContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class CpsDvEnrollmentTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CpsDvValidationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CpsThirdPartyEnrollmentAdminContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "addressLineTwo":
            suggest = "address_line_two"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentAdminContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentAdminContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentAdminContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class CpsThirdPartyEnrollmentCsr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "preferredTrustChain":
            suggest = "preferred_trust_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentCsr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentCsr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentCsr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 organization: _builtins.str,
                 organizational_unit: Optional[_builtins.str] = None,
                 preferred_trust_chain: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: The code of the country where organization is located
        :param _builtins.str organization: Name of organization used in all legal documents
        :param _builtins.str organizational_unit: Organizational unit of organization
        :param _builtins.str preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param _builtins.str state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if preferred_trust_chain is not None:
            pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[_builtins.str]:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> Optional[_builtins.str]:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CpsThirdPartyEnrollmentNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientMutualAuthentication":
            suggest = "client_mutual_authentication"
        elif key == "cloneDnsNames":
            suggest = "clone_dns_names"
        elif key == "disallowedTlsVersions":
            suggest = "disallowed_tls_versions"
        elif key == "mustHaveCiphers":
            suggest = "must_have_ciphers"
        elif key == "ocspStapling":
            suggest = "ocsp_stapling"
        elif key == "preferredCiphers":
            suggest = "preferred_ciphers"
        elif key == "quicEnabled":
            suggest = "quic_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geography: _builtins.str,
                 client_mutual_authentication: Optional['outputs.CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication'] = None,
                 clone_dns_names: Optional[_builtins.bool] = None,
                 disallowed_tls_versions: Optional[Sequence[_builtins.str]] = None,
                 must_have_ciphers: Optional[_builtins.str] = None,
                 ocsp_stapling: Optional[_builtins.str] = None,
                 preferred_ciphers: Optional[_builtins.str] = None,
                 quic_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str geography: Geography type used for enrollment
        :param 'CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs' client_mutual_authentication: The trust chain configuration used for client mutual authentication
        :param _builtins.bool clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        :param Sequence[_builtins.str] disallowed_tls_versions: TLS versions which are disallowed
        :param _builtins.str must_have_ciphers: Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param _builtins.str ocsp_stapling: Enable OCSP stapling. Default is 'on'
        :param _builtins.str preferred_ciphers: Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param _builtins.bool quic_enabled: Enable QUIC protocol. Default is false
        """
        pulumi.set(__self__, "geography", geography)
        if client_mutual_authentication is not None:
            pulumi.set(__self__, "client_mutual_authentication", client_mutual_authentication)
        if clone_dns_names is not None:
            pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        if disallowed_tls_versions is not None:
            pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        if must_have_ciphers is not None:
            pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        if ocsp_stapling is not None:
            pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        if preferred_ciphers is not None:
            pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        if quic_enabled is not None:
            pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter
    def geography(self) -> _builtins.str:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentication")
    def client_mutual_authentication(self) -> Optional['outputs.CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication']:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentication")

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> Optional[_builtins.bool]:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        return pulumi.get(self, "clone_dns_names")

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> Optional[_builtins.str]:
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "must_have_ciphers")

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> Optional[_builtins.str]:
        """
        Enable OCSP stapling. Default is 'on'
        """
        return pulumi.get(self, "ocsp_stapling")

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> Optional[_builtins.str]:
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "preferred_ciphers")

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable QUIC protocol. Default is false
        """
        return pulumi.get(self, "quic_enabled")


@pulumi.output_type
class CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocspEnabled":
            suggest = "ocsp_enabled"
        elif key == "sendCaListToClient":
            suggest = "send_ca_list_to_client"
        elif key == "setId":
            suggest = "set_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocsp_enabled: Optional[_builtins.bool] = None,
                 send_ca_list_to_client: Optional[_builtins.bool] = None,
                 set_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool ocsp_enabled: Enable OCSP stapling
        :param _builtins.bool send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param _builtins.str set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        if ocsp_enabled is not None:
            pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        if send_ca_list_to_client is not None:
            pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        if set_id is not None:
            pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> Optional[_builtins.bool]:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")


@pulumi.output_type
class CpsThirdPartyEnrollmentOrganization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "addressLineTwo":
            suggest = "address_line_two"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentOrganization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentOrganization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentOrganization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_line_one: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 name: _builtins.str,
                 phone: _builtins.str,
                 postal_code: _builtins.str,
                 region: _builtins.str,
                 address_line_two: Optional[_builtins.str] = None):
        """
        :param _builtins.str address_line_one: The address of organization
        :param _builtins.str city: City of organization
        :param _builtins.str country_code: Country code of organization
        :param _builtins.str name: Name of organization
        :param _builtins.str phone: Phone number of organization
        :param _builtins.str postal_code: Postal code of organization
        :param _builtins.str region: The region of organization
        :param _builtins.str address_line_two: The address of organization
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City of organization
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        Country code of organization
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of organization
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> _builtins.str:
        """
        Postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region of organization
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")


@pulumi.output_type
class CpsThirdPartyEnrollmentTechContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "addressLineOne":
            suggest = "address_line_one"
        elif key == "addressLineTwo":
            suggest = "address_line_two"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "postalCode":
            suggest = "postal_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpsThirdPartyEnrollmentTechContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpsThirdPartyEnrollmentTechContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpsThirdPartyEnrollmentTechContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class CpsThirdPartyEnrollmentTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class CpsUploadCertificateTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class DatastreamAzureConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "compressLogs":
            suggest = "compress_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamAzureConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamAzureConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamAzureConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 account_name: _builtins.str,
                 container_name: _builtins.str,
                 display_name: _builtins.str,
                 path: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_key: Access keys associated with Azure Storage account
        :param _builtins.str account_name: Specifies the Azure Storage account name
        :param _builtins.str container_name: Specifies the Azure Storage container name
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str path: The path to the folder within Azure Storage container where logs will be stored
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "path", path)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Access keys associated with Azure Storage account
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> _builtins.str:
        """
        Specifies the Azure Storage account name
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> _builtins.str:
        """
        Specifies the Azure Storage container name
        """
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the folder within Azure Storage container where logs will be stored
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")


@pulumi.output_type
class DatastreamDatadogConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "compressLogs":
            suggest = "compress_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamDatadogConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamDatadogConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamDatadogConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: _builtins.str,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None,
                 service: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_token: The API key associated with Datadog account
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str endpoint: The Datadog endpoint where logs will be stored
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        :param _builtins.str service: The service of the Datadog connector
        :param _builtins.str source: The source of the Datadog connector
        :param _builtins.str tags: The tags of the Datadog connector
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        The API key associated with Datadog account
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The Datadog endpoint where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        The service of the Datadog connector
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the Datadog connector
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        The tags of the Datadog connector
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DatastreamDeliveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "uploadFilePrefix":
            suggest = "upload_file_prefix"
        elif key == "uploadFileSuffix":
            suggest = "upload_file_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamDeliveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamDeliveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamDeliveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: _builtins.str,
                 frequency: 'outputs.DatastreamDeliveryConfigurationFrequency',
                 field_delimiter: Optional[_builtins.str] = None,
                 upload_file_prefix: Optional[_builtins.str] = None,
                 upload_file_suffix: Optional[_builtins.str] = None):
        """
        :param _builtins.str format: The format in which logs will be received
        :param 'DatastreamDeliveryConfigurationFrequencyArgs' frequency: The frequency of collecting logs from each uploader and sending these logs to a destination
        :param _builtins.str field_delimiter: A delimiter that you use to separate data set fields in log lines
        :param _builtins.str upload_file_prefix: The prefix of the log file that will be send to a destination
        :param _builtins.str upload_file_suffix: The suffix of the log file that will be send to a destination
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "frequency", frequency)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if upload_file_prefix is not None:
            pulumi.set(__self__, "upload_file_prefix", upload_file_prefix)
        if upload_file_suffix is not None:
            pulumi.set(__self__, "upload_file_suffix", upload_file_suffix)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format in which logs will be received
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> 'outputs.DatastreamDeliveryConfigurationFrequency':
        """
        The frequency of collecting logs from each uploader and sending these logs to a destination
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[_builtins.str]:
        """
        A delimiter that you use to separate data set fields in log lines
        """
        return pulumi.get(self, "field_delimiter")

    @_builtins.property
    @pulumi.getter(name="uploadFilePrefix")
    def upload_file_prefix(self) -> Optional[_builtins.str]:
        """
        The prefix of the log file that will be send to a destination
        """
        return pulumi.get(self, "upload_file_prefix")

    @_builtins.property
    @pulumi.getter(name="uploadFileSuffix")
    def upload_file_suffix(self) -> Optional[_builtins.str]:
        """
        The suffix of the log file that will be send to a destination
        """
        return pulumi.get(self, "upload_file_suffix")


@pulumi.output_type
class DatastreamDeliveryConfigurationFrequency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalInSecs":
            suggest = "interval_in_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamDeliveryConfigurationFrequency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamDeliveryConfigurationFrequency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamDeliveryConfigurationFrequency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_in_secs: _builtins.int):
        """
        :param _builtins.int interval_in_secs: The time in seconds after which the system bundles log lines into a file and sends it to a destination
        """
        pulumi.set(__self__, "interval_in_secs", interval_in_secs)

    @_builtins.property
    @pulumi.getter(name="intervalInSecs")
    def interval_in_secs(self) -> _builtins.int:
        """
        The time in seconds after which the system bundles log lines into a file and sends it to a destination
        """
        return pulumi.get(self, "interval_in_secs")


@pulumi.output_type
class DatastreamElasticsearchConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "indexName":
            suggest = "index_name"
        elif key == "userName":
            suggest = "user_name"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"
        elif key == "mTls":
            suggest = "m_tls"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamElasticsearchConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamElasticsearchConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamElasticsearchConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 index_name: _builtins.str,
                 password: _builtins.str,
                 user_name: _builtins.str,
                 ca_cert: Optional[_builtins.str] = None,
                 client_cert: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 content_type: Optional[_builtins.str] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None,
                 m_tls: Optional[_builtins.bool] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param _builtins.str display_name: The name of the connector.
        :param _builtins.str endpoint: The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
        :param _builtins.str index_name: The index name of the Elastic cloud where you want to store log files.
        :param _builtins.str password: The Elasticsearch basic access authentication password.
        :param _builtins.str user_name: The Elasticsearch basic access authentication username.
        :param _builtins.str ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param _builtins.str client_cert: The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param _builtins.str client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param _builtins.str content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        :param _builtins.bool m_tls: Indicates whether mTLS is enabled or not.
        :param _builtins.str tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> _builtins.str:
        """
        The index name of the Elastic cloud where you want to store log files.
        """
        return pulumi.get(self, "index_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The Elasticsearch basic access authentication password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The Elasticsearch basic access authentication username.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[_builtins.str]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[_builtins.str]:
        """
        The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_cert")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[_builtins.bool]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DatastreamGcsConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "serviceAccountName":
            suggest = "service_account_name"
        elif key == "compressLogs":
            suggest = "compress_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamGcsConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamGcsConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamGcsConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 display_name: _builtins.str,
                 private_key: _builtins.str,
                 project_id: _builtins.str,
                 service_account_name: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: The name of the storage bucket created in Google Cloud account
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str private_key: The contents of the JSON private key generated and downloaded in Google Cloud Storage account
        :param _builtins.str project_id: The unique ID of Google Cloud project
        :param _builtins.str service_account_name: The name of the service account with the storage.object.create permission or Storage Object Creator role
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        :param _builtins.str path: The path to the folder within Google Cloud bucket where logs will be stored
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_name", service_account_name)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The name of the storage bucket created in Google Cloud account
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        The contents of the JSON private key generated and downloaded in Google Cloud Storage account
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID of Google Cloud project
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> _builtins.str:
        """
        The name of the service account with the storage.object.create permission or Storage Object Creator role
        """
        return pulumi.get(self, "service_account_name")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path to the folder within Google Cloud bucket where logs will be stored
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatastreamHttpsConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationType":
            suggest = "authentication_type"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "compressLogs":
            suggest = "compress_logs"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"
        elif key == "mTls":
            suggest = "m_tls"
        elif key == "tlsHostname":
            suggest = "tls_hostname"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamHttpsConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamHttpsConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamHttpsConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_type: _builtins.str,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 ca_cert: Optional[_builtins.str] = None,
                 client_cert: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 compress_logs: Optional[_builtins.bool] = None,
                 content_type: Optional[_builtins.str] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None,
                 m_tls: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 tls_hostname: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_type: Either NONE for no authentication, or BASIC for username and password authentication
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str endpoint: URL where logs will be stored
        :param _builtins.str ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param _builtins.str client_cert: The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        :param _builtins.str client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        :param _builtins.str content_type: Content type to pass in the log file header
        :param _builtins.str custom_header_name: The name of custom header passed with the request to the destination
        :param _builtins.str custom_header_value: The custom header's contents passed with the request to the destination
        :param _builtins.bool m_tls: Indicates whether mTLS is enabled or not.
        :param _builtins.str password: Password set for custom HTTPS endpoint for authentication
        :param _builtins.str tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        :param _builtins.str user_name: Username used for authentication
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> _builtins.str:
        """
        Either NONE for no authentication, or BASIC for username and password authentication
        """
        return pulumi.get(self, "authentication_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        URL where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[_builtins.str]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[_builtins.str]:
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        return pulumi.get(self, "client_cert")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        Content type to pass in the log file header
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[_builtins.bool]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password set for custom HTTPS endpoint for authentication
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Username used for authentication
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DatastreamLogglyConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamLogglyConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamLogglyConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamLogglyConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: _builtins.str,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 content_type: Optional[_builtins.str] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_token: The unique HTTP code for your Loggly bulk endpoint.
        :param _builtins.str display_name: The name of the connector.
        :param _builtins.str endpoint: The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
        :param _builtins.str content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        :param _builtins.str tags: The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        The unique HTTP code for your Loggly bulk endpoint.
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DatastreamNewRelicConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamNewRelicConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamNewRelicConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamNewRelicConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: _builtins.str,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 content_type: Optional[_builtins.str] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_token: Your Log API token for your account in New Relic.
        :param _builtins.str display_name: The name of the connector.
        :param _builtins.str endpoint: A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
        :param _builtins.str content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param _builtins.str custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> _builtins.str:
        """
        Your Log API token for your account in New Relic.
        """
        return pulumi.get(self, "auth_token")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")


@pulumi.output_type
class DatastreamOracleConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "compressLogs":
            suggest = "compress_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamOracleConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamOracleConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamOracleConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 bucket: _builtins.str,
                 display_name: _builtins.str,
                 namespace: _builtins.str,
                 path: _builtins.str,
                 region: _builtins.str,
                 secret_access_key: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_key: The access key identifier used to authenticate requests to the Oracle Cloud account
        :param _builtins.str bucket: The name of the Oracle Cloud Storage bucket
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str namespace: The namespace of Oracle Cloud Storage account
        :param _builtins.str path: The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
        :param _builtins.str region: The Oracle Cloud Storage region where bucket resides
        :param _builtins.str secret_access_key: The secret access key identifier used to authenticate requests to the Oracle Cloud account
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        The access key identifier used to authenticate requests to the Oracle Cloud account
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The name of the Oracle Cloud Storage bucket
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of Oracle Cloud Storage account
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The Oracle Cloud Storage region where bucket resides
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        The secret access key identifier used to authenticate requests to the Oracle Cloud account
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")


@pulumi.output_type
class DatastreamS3Connector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "compressLogs":
            suggest = "compress_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamS3Connector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamS3Connector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamS3Connector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 bucket: _builtins.str,
                 display_name: _builtins.str,
                 path: _builtins.str,
                 region: _builtins.str,
                 secret_access_key: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_key: The access key identifier used to authenticate requests to the Amazon S3 account
        :param _builtins.str bucket: The name of the Amazon S3 bucket
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str path: The path to the folder within Amazon S3 bucket where logs will be stored
        :param _builtins.str region: The AWS region where Amazon S3 bucket resides
        :param _builtins.str secret_access_key: The secret access key identifier used to authenticate requests to the Amazon S3 account
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        The access key identifier used to authenticate requests to the Amazon S3 account
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The name of the Amazon S3 bucket
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the folder within Amazon S3 bucket where logs will be stored
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region where Amazon S3 bucket resides
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        The secret access key identifier used to authenticate requests to the Amazon S3 account
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")


@pulumi.output_type
class DatastreamSplunkConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "eventCollectorToken":
            suggest = "event_collector_token"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "compressLogs":
            suggest = "compress_logs"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"
        elif key == "mTls":
            suggest = "m_tls"
        elif key == "tlsHostname":
            suggest = "tls_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamSplunkConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamSplunkConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamSplunkConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 event_collector_token: _builtins.str,
                 ca_cert: Optional[_builtins.str] = None,
                 client_cert: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 compress_logs: Optional[_builtins.bool] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None,
                 m_tls: Optional[_builtins.bool] = None,
                 tls_hostname: Optional[_builtins.str] = None):
        """
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str endpoint: The raw event Splunk URL where logs will be stored
        :param _builtins.str event_collector_token: The Event Collector token associated with Splunk account
        :param _builtins.str ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param _builtins.str client_cert: The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        :param _builtins.str client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        :param _builtins.str custom_header_name: The name of custom header passed with the request to the destination
        :param _builtins.str custom_header_value: The custom header's contents passed with the request to the destination
        :param _builtins.bool m_tls: Indicates whether mTLS is enabled or not.
        :param _builtins.str tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "event_collector_token", event_collector_token)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The raw event Splunk URL where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="eventCollectorToken")
    def event_collector_token(self) -> _builtins.str:
        """
        The Event Collector token associated with Splunk account
        """
        return pulumi.get(self, "event_collector_token")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[_builtins.str]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[_builtins.str]:
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        return pulumi.get(self, "client_cert")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[_builtins.bool]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[_builtins.str]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")


@pulumi.output_type
class DatastreamSumologicConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectorCode":
            suggest = "collector_code"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "compressLogs":
            suggest = "compress_logs"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "customHeaderName":
            suggest = "custom_header_name"
        elif key == "customHeaderValue":
            suggest = "custom_header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastreamSumologicConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastreamSumologicConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastreamSumologicConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collector_code: _builtins.str,
                 display_name: _builtins.str,
                 endpoint: _builtins.str,
                 compress_logs: Optional[_builtins.bool] = None,
                 content_type: Optional[_builtins.str] = None,
                 custom_header_name: Optional[_builtins.str] = None,
                 custom_header_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str collector_code: The unique HTTP collector code of Sumo Logic endpoint
        :param _builtins.str display_name: The name of the connector
        :param _builtins.str endpoint: The Sumo Logic collection endpoint where logs will be stored
        :param _builtins.bool compress_logs: Indicates whether the logs should be compressed
        :param _builtins.str content_type: Content type to pass in the log file header
        :param _builtins.str custom_header_name: The name of custom header passed with the request to the destination
        :param _builtins.str custom_header_value: The custom header's contents passed with the request to the destination
        """
        pulumi.set(__self__, "collector_code", collector_code)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="collectorCode")
    def collector_code(self) -> _builtins.str:
        """
        The unique HTTP collector code of Sumo Logic endpoint
        """
        return pulumi.get(self, "collector_code")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The Sumo Logic collection endpoint where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        Content type to pass in the log file header
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[_builtins.str]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[_builtins.str]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")


@pulumi.output_type
class DnsZoneOutboundZoneTransfer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyTargets":
            suggest = "notify_targets"
        elif key == "tsigKey":
            suggest = "tsig_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsZoneOutboundZoneTransfer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsZoneOutboundZoneTransfer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsZoneOutboundZoneTransfer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acls: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 notify_targets: Optional[Sequence[_builtins.str]] = None,
                 tsig_key: Optional['outputs.DnsZoneOutboundZoneTransferTsigKey'] = None):
        """
        :param Sequence[_builtins.str] acls: The access control list, defined as IPv4 and IPv6 CIDR blocks.
        :param _builtins.bool enabled: Enables outbound zone transfer.
        :param Sequence[_builtins.str] notify_targets: Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
        :param 'DnsZoneOutboundZoneTransferTsigKeyArgs' tsig_key: The TSIG key used for outbound zone transfers.
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if notify_targets is not None:
            pulumi.set(__self__, "notify_targets", notify_targets)
        if tsig_key is not None:
            pulumi.set(__self__, "tsig_key", tsig_key)

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[Sequence[_builtins.str]]:
        """
        The access control list, defined as IPv4 and IPv6 CIDR blocks.
        """
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables outbound zone transfer.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="notifyTargets")
    def notify_targets(self) -> Optional[Sequence[_builtins.str]]:
        """
        Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
        """
        return pulumi.get(self, "notify_targets")

    @_builtins.property
    @pulumi.getter(name="tsigKey")
    def tsig_key(self) -> Optional['outputs.DnsZoneOutboundZoneTransferTsigKey']:
        """
        The TSIG key used for outbound zone transfers.
        """
        return pulumi.get(self, "tsig_key")


@pulumi.output_type
class DnsZoneOutboundZoneTransferTsigKey(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 name: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str algorithm: The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
        :param _builtins.str name: The zone name.
        :param _builtins.str secret: A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The zone name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DnsZoneTsigKey(dict):
    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 name: _builtins.str,
                 secret: _builtins.str):
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class EdgeHostNameTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class EdgeWorkerTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class EdgeWorkersActivationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delete")


@pulumi.output_type
class EdgekvGroupItemsTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class GtmAsmapAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asNumbers":
            suggest = "as_numbers"
        elif key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmAsmapAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmAsmapAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmAsmapAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_numbers: Sequence[_builtins.int],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "as_numbers")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GtmAsmapDefaultDatacenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmAsmapDefaultDatacenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmAsmapDefaultDatacenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmAsmapDefaultDatacenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GtmCidrmapAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmCidrmapAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmCidrmapAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmCidrmapAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str,
                 blocks: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        return pulumi.get(self, "nickname")

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "blocks")


@pulumi.output_type
class GtmCidrmapDefaultDatacenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmCidrmapDefaultDatacenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmCidrmapDefaultDatacenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmCidrmapDefaultDatacenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GtmDatacenterDefaultLoadObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadObject":
            suggest = "load_object"
        elif key == "loadObjectPort":
            suggest = "load_object_port"
        elif key == "loadServers":
            suggest = "load_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmDatacenterDefaultLoadObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmDatacenterDefaultLoadObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmDatacenterDefaultLoadObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_object: Optional[_builtins.str] = None,
                 load_object_port: Optional[_builtins.int] = None,
                 load_servers: Optional[Sequence[_builtins.str]] = None):
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "load_servers")


@pulumi.output_type
class GtmGeomapAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmGeomapAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmGeomapAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmGeomapAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str,
                 countries: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        return pulumi.get(self, "nickname")

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "countries")


@pulumi.output_type
class GtmGeomapDefaultDatacenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmGeomapDefaultDatacenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmGeomapDefaultDatacenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmGeomapDefaultDatacenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GtmPropertyLivenessTest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testInterval":
            suggest = "test_interval"
        elif key == "testObjectProtocol":
            suggest = "test_object_protocol"
        elif key == "testTimeout":
            suggest = "test_timeout"
        elif key == "alternateCaCertificates":
            suggest = "alternate_ca_certificates"
        elif key == "answersRequired":
            suggest = "answers_required"
        elif key == "disableNonstandardPortWarning":
            suggest = "disable_nonstandard_port_warning"
        elif key == "errorPenalty":
            suggest = "error_penalty"
        elif key == "httpError3xx":
            suggest = "http_error3xx"
        elif key == "httpError4xx":
            suggest = "http_error4xx"
        elif key == "httpError5xx":
            suggest = "http_error5xx"
        elif key == "httpHeaders":
            suggest = "http_headers"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpRequestBody":
            suggest = "http_request_body"
        elif key == "peerCertificateVerification":
            suggest = "peer_certificate_verification"
        elif key == "pre2023SecurityPosture":
            suggest = "pre2023_security_posture"
        elif key == "recursionRequested":
            suggest = "recursion_requested"
        elif key == "requestString":
            suggest = "request_string"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "responseString":
            suggest = "response_string"
        elif key == "sslClientCertificate":
            suggest = "ssl_client_certificate"
        elif key == "sslClientPrivateKey":
            suggest = "ssl_client_private_key"
        elif key == "testObject":
            suggest = "test_object"
        elif key == "testObjectPassword":
            suggest = "test_object_password"
        elif key == "testObjectPort":
            suggest = "test_object_port"
        elif key == "testObjectUsername":
            suggest = "test_object_username"
        elif key == "timeoutPenalty":
            suggest = "timeout_penalty"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmPropertyLivenessTest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmPropertyLivenessTest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmPropertyLivenessTest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 test_interval: _builtins.int,
                 test_object_protocol: _builtins.str,
                 test_timeout: _builtins.float,
                 alternate_ca_certificates: Optional[Sequence[_builtins.str]] = None,
                 answers_required: Optional[_builtins.bool] = None,
                 disable_nonstandard_port_warning: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 error_penalty: Optional[_builtins.float] = None,
                 http_error3xx: Optional[_builtins.bool] = None,
                 http_error4xx: Optional[_builtins.bool] = None,
                 http_error5xx: Optional[_builtins.bool] = None,
                 http_headers: Optional[Sequence['outputs.GtmPropertyLivenessTestHttpHeader']] = None,
                 http_method: Optional[_builtins.str] = None,
                 http_request_body: Optional[_builtins.str] = None,
                 peer_certificate_verification: Optional[_builtins.bool] = None,
                 pre2023_security_posture: Optional[_builtins.bool] = None,
                 recursion_requested: Optional[_builtins.bool] = None,
                 request_string: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 response_string: Optional[_builtins.str] = None,
                 ssl_client_certificate: Optional[_builtins.str] = None,
                 ssl_client_private_key: Optional[_builtins.str] = None,
                 test_object: Optional[_builtins.str] = None,
                 test_object_password: Optional[_builtins.str] = None,
                 test_object_port: Optional[_builtins.int] = None,
                 test_object_username: Optional[_builtins.str] = None,
                 timeout_penalty: Optional[_builtins.float] = None):
        """
        :param _builtins.bool pre2023_security_posture: Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "test_interval", test_interval)
        pulumi.set(__self__, "test_object_protocol", test_object_protocol)
        pulumi.set(__self__, "test_timeout", test_timeout)
        if alternate_ca_certificates is not None:
            pulumi.set(__self__, "alternate_ca_certificates", alternate_ca_certificates)
        if answers_required is not None:
            pulumi.set(__self__, "answers_required", answers_required)
        if disable_nonstandard_port_warning is not None:
            pulumi.set(__self__, "disable_nonstandard_port_warning", disable_nonstandard_port_warning)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if error_penalty is not None:
            pulumi.set(__self__, "error_penalty", error_penalty)
        if http_error3xx is not None:
            pulumi.set(__self__, "http_error3xx", http_error3xx)
        if http_error4xx is not None:
            pulumi.set(__self__, "http_error4xx", http_error4xx)
        if http_error5xx is not None:
            pulumi.set(__self__, "http_error5xx", http_error5xx)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_request_body is not None:
            pulumi.set(__self__, "http_request_body", http_request_body)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if pre2023_security_posture is not None:
            pulumi.set(__self__, "pre2023_security_posture", pre2023_security_posture)
        if recursion_requested is not None:
            pulumi.set(__self__, "recursion_requested", recursion_requested)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if ssl_client_certificate is not None:
            pulumi.set(__self__, "ssl_client_certificate", ssl_client_certificate)
        if ssl_client_private_key is not None:
            pulumi.set(__self__, "ssl_client_private_key", ssl_client_private_key)
        if test_object is not None:
            pulumi.set(__self__, "test_object", test_object)
        if test_object_password is not None:
            pulumi.set(__self__, "test_object_password", test_object_password)
        if test_object_port is not None:
            pulumi.set(__self__, "test_object_port", test_object_port)
        if test_object_username is not None:
            pulumi.set(__self__, "test_object_username", test_object_username)
        if timeout_penalty is not None:
            pulumi.set(__self__, "timeout_penalty", timeout_penalty)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="testInterval")
    def test_interval(self) -> _builtins.int:
        return pulumi.get(self, "test_interval")

    @_builtins.property
    @pulumi.getter(name="testObjectProtocol")
    def test_object_protocol(self) -> _builtins.str:
        return pulumi.get(self, "test_object_protocol")

    @_builtins.property
    @pulumi.getter(name="testTimeout")
    def test_timeout(self) -> _builtins.float:
        return pulumi.get(self, "test_timeout")

    @_builtins.property
    @pulumi.getter(name="alternateCaCertificates")
    def alternate_ca_certificates(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "alternate_ca_certificates")

    @_builtins.property
    @pulumi.getter(name="answersRequired")
    def answers_required(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "answers_required")

    @_builtins.property
    @pulumi.getter(name="disableNonstandardPortWarning")
    def disable_nonstandard_port_warning(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_nonstandard_port_warning")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="errorPenalty")
    def error_penalty(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "error_penalty")

    @_builtins.property
    @pulumi.getter(name="httpError3xx")
    def http_error3xx(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "http_error3xx")

    @_builtins.property
    @pulumi.getter(name="httpError4xx")
    def http_error4xx(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "http_error4xx")

    @_builtins.property
    @pulumi.getter(name="httpError5xx")
    def http_error5xx(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "http_error5xx")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GtmPropertyLivenessTestHttpHeader']]:
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="httpRequestBody")
    def http_request_body(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http_request_body")

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "peer_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="pre2023SecurityPosture")
    def pre2023_security_posture(self) -> Optional[_builtins.bool]:
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        return pulumi.get(self, "pre2023_security_posture")

    @_builtins.property
    @pulumi.getter(name="recursionRequested")
    def recursion_requested(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "recursion_requested")

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "request_string")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_string")

    @_builtins.property
    @pulumi.getter(name="sslClientCertificate")
    def ssl_client_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssl_client_certificate")

    @_builtins.property
    @pulumi.getter(name="sslClientPrivateKey")
    def ssl_client_private_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssl_client_private_key")

    @_builtins.property
    @pulumi.getter(name="testObject")
    def test_object(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "test_object")

    @_builtins.property
    @pulumi.getter(name="testObjectPassword")
    def test_object_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "test_object_password")

    @_builtins.property
    @pulumi.getter(name="testObjectPort")
    def test_object_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "test_object_port")

    @_builtins.property
    @pulumi.getter(name="testObjectUsername")
    def test_object_username(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "test_object_username")

    @_builtins.property
    @pulumi.getter(name="timeoutPenalty")
    def timeout_penalty(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "timeout_penalty")


@pulumi.output_type
class GtmPropertyLivenessTestHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GtmPropertyStaticRrSet(dict):
    def __init__(__self__, *,
                 rdatas: Optional[Sequence[_builtins.str]] = None,
                 ttl: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        if rdatas is not None:
            pulumi.set(__self__, "rdatas", rdatas)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def rdatas(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "rdatas")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GtmPropertyTrafficTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "handoutCname":
            suggest = "handout_cname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmPropertyTrafficTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmPropertyTrafficTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmPropertyTrafficTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 handout_cname: Optional[_builtins.str] = None,
                 precedence: Optional[_builtins.int] = None,
                 servers: Optional[Sequence[_builtins.str]] = None,
                 weight: Optional[_builtins.float] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if handout_cname is not None:
            pulumi.set(__self__, "handout_cname", handout_cname)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="handoutCname")
    def handout_cname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "handout_cname")

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "precedence")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GtmResourceResourceInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "loadObject":
            suggest = "load_object"
        elif key == "loadObjectPort":
            suggest = "load_object_port"
        elif key == "loadServers":
            suggest = "load_servers"
        elif key == "useDefaultLoadObject":
            suggest = "use_default_load_object"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GtmResourceResourceInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GtmResourceResourceInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GtmResourceResourceInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: Optional[_builtins.str] = None,
                 load_object_port: Optional[_builtins.int] = None,
                 load_servers: Optional[Sequence[_builtins.str]] = None,
                 use_default_load_object: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)
        if use_default_load_object is not None:
            pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "load_servers")

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_default_load_object")


@pulumi.output_type
class IamApiClientActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deactivateAll":
            suggest = "deactivate_all"
        elif key == "editApis":
            suggest = "edit_apis"
        elif key == "editAuth":
            suggest = "edit_auth"
        elif key == "editGroups":
            suggest = "edit_groups"
        elif key == "editIpAcl":
            suggest = "edit_ip_acl"
        elif key == "editSwitchAccount":
            suggest = "edit_switch_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deactivate_all: Optional[_builtins.bool] = None,
                 delete: Optional[_builtins.bool] = None,
                 edit: Optional[_builtins.bool] = None,
                 edit_apis: Optional[_builtins.bool] = None,
                 edit_auth: Optional[_builtins.bool] = None,
                 edit_groups: Optional[_builtins.bool] = None,
                 edit_ip_acl: Optional[_builtins.bool] = None,
                 edit_switch_account: Optional[_builtins.bool] = None,
                 lock: Optional[_builtins.bool] = None,
                 transfer: Optional[_builtins.bool] = None,
                 unlock: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool deactivate_all: Whether you can deactivate the API client's credentials.
        :param _builtins.bool delete: Whether you can remove the API client.
        :param _builtins.bool edit: Whether you can update the API client.
        :param _builtins.bool edit_apis: Whether you can update the `apis` the API client can access, same as `edit_auth`.
        :param _builtins.bool edit_auth: Whether you can update the `apis` the API client can access, same as `edit_apis`.
        :param _builtins.bool edit_groups: Whether you can update the `groups` the API client can access.
        :param _builtins.bool edit_ip_acl: Whether you can update the 'ip acl' the API client can access.
        :param _builtins.bool edit_switch_account: Whether you can update the API client's option to manage many accounts.
        :param _builtins.bool lock: Whether you can lock the API client.
        :param _builtins.bool transfer: Whether you can transfer the API client to a new owner.
        :param _builtins.bool unlock: Whether you can unlock the API client.
        """
        if deactivate_all is not None:
            pulumi.set(__self__, "deactivate_all", deactivate_all)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit is not None:
            pulumi.set(__self__, "edit", edit)
        if edit_apis is not None:
            pulumi.set(__self__, "edit_apis", edit_apis)
        if edit_auth is not None:
            pulumi.set(__self__, "edit_auth", edit_auth)
        if edit_groups is not None:
            pulumi.set(__self__, "edit_groups", edit_groups)
        if edit_ip_acl is not None:
            pulumi.set(__self__, "edit_ip_acl", edit_ip_acl)
        if edit_switch_account is not None:
            pulumi.set(__self__, "edit_switch_account", edit_switch_account)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if transfer is not None:
            pulumi.set(__self__, "transfer", transfer)
        if unlock is not None:
            pulumi.set(__self__, "unlock", unlock)

    @_builtins.property
    @pulumi.getter(name="deactivateAll")
    def deactivate_all(self) -> Optional[_builtins.bool]:
        """
        Whether you can deactivate the API client's credentials.
        """
        return pulumi.get(self, "deactivate_all")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        Whether you can remove the API client.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the API client.
        """
        return pulumi.get(self, "edit")

    @_builtins.property
    @pulumi.getter(name="editApis")
    def edit_apis(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the `apis` the API client can access, same as `edit_auth`.
        """
        return pulumi.get(self, "edit_apis")

    @_builtins.property
    @pulumi.getter(name="editAuth")
    def edit_auth(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the `apis` the API client can access, same as `edit_apis`.
        """
        return pulumi.get(self, "edit_auth")

    @_builtins.property
    @pulumi.getter(name="editGroups")
    def edit_groups(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the `groups` the API client can access.
        """
        return pulumi.get(self, "edit_groups")

    @_builtins.property
    @pulumi.getter(name="editIpAcl")
    def edit_ip_acl(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the 'ip acl' the API client can access.
        """
        return pulumi.get(self, "edit_ip_acl")

    @_builtins.property
    @pulumi.getter(name="editSwitchAccount")
    def edit_switch_account(self) -> Optional[_builtins.bool]:
        """
        Whether you can update the API client's option to manage many accounts.
        """
        return pulumi.get(self, "edit_switch_account")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> Optional[_builtins.bool]:
        """
        Whether you can lock the API client.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter
    def transfer(self) -> Optional[_builtins.bool]:
        """
        Whether you can transfer the API client to a new owner.
        """
        return pulumi.get(self, "transfer")

    @_builtins.property
    @pulumi.getter
    def unlock(self) -> Optional[_builtins.bool]:
        """
        Whether you can unlock the API client.
        """
        return pulumi.get(self, "unlock")


@pulumi.output_type
class IamApiClientApiAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allAccessibleApis":
            suggest = "all_accessible_apis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientApiAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientApiAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientApiAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_accessible_apis: _builtins.bool,
                 apis: Optional[Sequence['outputs.IamApiClientApiAccessApi']] = None):
        """
        :param _builtins.bool all_accessible_apis: Enables the API client to access a full set of available APIs.
        :param Sequence['IamApiClientApiAccessApiArgs'] apis: The set of APIs the API client can access when `all_accessible_apis` is `false`.
        """
        pulumi.set(__self__, "all_accessible_apis", all_accessible_apis)
        if apis is not None:
            pulumi.set(__self__, "apis", apis)

    @_builtins.property
    @pulumi.getter(name="allAccessibleApis")
    def all_accessible_apis(self) -> _builtins.bool:
        """
        Enables the API client to access a full set of available APIs.
        """
        return pulumi.get(self, "all_accessible_apis")

    @_builtins.property
    @pulumi.getter
    def apis(self) -> Optional[Sequence['outputs.IamApiClientApiAccessApi']]:
        """
        The set of APIs the API client can access when `all_accessible_apis` is `false`.
        """
        return pulumi.get(self, "apis")


@pulumi.output_type
class IamApiClientApiAccessApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "apiId":
            suggest = "api_id"
        elif key == "apiName":
            suggest = "api_name"
        elif key == "documentationUrl":
            suggest = "documentation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientApiAccessApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientApiAccessApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientApiAccessApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: _builtins.str,
                 api_id: _builtins.int,
                 api_name: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 documentation_url: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_level: The API client's access level on an API basis, either 'READ-ONLY', 'READ-WRITE', 'CREDENTIAL-READ-ONLY', or 'CREDENTIAL-READ-WRITE'.
        :param _builtins.int api_id: A unique identifier of the API.
        :param _builtins.str api_name: A human-readable name for the API.
        :param _builtins.str description: A human-readable description for the API.
        :param _builtins.str documentation_url: A link to more information about the API.
        :param _builtins.str endpoint: Specifies where the API can access resources.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "api_id", api_id)
        if api_name is not None:
            pulumi.set(__self__, "api_name", api_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        The API client's access level on an API basis, either 'READ-ONLY', 'READ-WRITE', 'CREDENTIAL-READ-ONLY', or 'CREDENTIAL-READ-WRITE'.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> _builtins.int:
        """
        A unique identifier of the API.
        """
        return pulumi.get(self, "api_id")

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the API.
        """
        return pulumi.get(self, "api_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A human-readable description for the API.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[_builtins.str]:
        """
        A link to more information about the API.
        """
        return pulumi.get(self, "documentation_url")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Specifies where the API can access resources.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class IamApiClientCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientToken":
            suggest = "client_token"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "credentialId":
            suggest = "credential_id"
        elif key == "expiresOn":
            suggest = "expires_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional['outputs.IamApiClientCredentialActions'] = None,
                 client_secret: Optional[_builtins.str] = None,
                 client_token: Optional[_builtins.str] = None,
                 created_on: Optional[_builtins.str] = None,
                 credential_id: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 expires_on: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param 'IamApiClientCredentialActionsArgs' actions: Actions available on the API client's credentials.
        :param _builtins.str client_secret: The client secret.
        :param _builtins.str client_token: The part of the credential that identifies the API client.
        :param _builtins.str created_on: The ISO 8601 timestamp indicating when the credential was created.
        :param _builtins.int credential_id: A unique identifier of the credential.
        :param _builtins.str description: A human-readable description for the credential.
        :param _builtins.str expires_on: The ISO 8601 timestamp indicating when the credential expires. The default expiration date is two years from the creation date.
        :param _builtins.str status: Whether a credential is 'ACTIVE', 'INACTIVE', or 'DELETED'. Can be updated to 'ACTIVE' or 'INACTIVE' only.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expires_on is not None:
            pulumi.set(__self__, "expires_on", expires_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.IamApiClientCredentialActions']:
        """
        Actions available on the API client's credentials.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[_builtins.str]:
        """
        The part of the credential that identifies the API client.
        """
        return pulumi.get(self, "client_token")

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 timestamp indicating when the credential was created.
        """
        return pulumi.get(self, "created_on")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.int]:
        """
        A unique identifier of the credential.
        """
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A human-readable description for the credential.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> Optional[_builtins.str]:
        """
        The ISO 8601 timestamp indicating when the credential expires. The default expiration date is two years from the creation date.
        """
        return pulumi.get(self, "expires_on")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Whether a credential is 'ACTIVE', 'INACTIVE', or 'DELETED'. Can be updated to 'ACTIVE' or 'INACTIVE' only.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class IamApiClientCredentialActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "editDescription":
            suggest = "edit_description"
        elif key == "editExpiration":
            suggest = "edit_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientCredentialActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientCredentialActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientCredentialActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activate: Optional[_builtins.bool] = None,
                 deactivate: Optional[_builtins.bool] = None,
                 delete: Optional[_builtins.bool] = None,
                 edit_description: Optional[_builtins.bool] = None,
                 edit_expiration: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool activate: Whether you can activate the credential.
        :param _builtins.bool deactivate: Whether you can deactivate the credential.
        :param _builtins.bool delete: Whether you can remove the credential.
        :param _builtins.bool edit_description: Whether you can modify the credential's description.
        :param _builtins.bool edit_expiration: Whether you can modify the credential's expiration date.
        """
        if activate is not None:
            pulumi.set(__self__, "activate", activate)
        if deactivate is not None:
            pulumi.set(__self__, "deactivate", deactivate)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit_description is not None:
            pulumi.set(__self__, "edit_description", edit_description)
        if edit_expiration is not None:
            pulumi.set(__self__, "edit_expiration", edit_expiration)

    @_builtins.property
    @pulumi.getter
    def activate(self) -> Optional[_builtins.bool]:
        """
        Whether you can activate the credential.
        """
        return pulumi.get(self, "activate")

    @_builtins.property
    @pulumi.getter
    def deactivate(self) -> Optional[_builtins.bool]:
        """
        Whether you can deactivate the credential.
        """
        return pulumi.get(self, "deactivate")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        Whether you can remove the credential.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter(name="editDescription")
    def edit_description(self) -> Optional[_builtins.bool]:
        """
        Whether you can modify the credential's description.
        """
        return pulumi.get(self, "edit_description")

    @_builtins.property
    @pulumi.getter(name="editExpiration")
    def edit_expiration(self) -> Optional[_builtins.bool]:
        """
        Whether you can modify the credential's expiration date.
        """
        return pulumi.get(self, "edit_expiration")


@pulumi.output_type
class IamApiClientGroupAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloneAuthorizedUserGroups":
            suggest = "clone_authorized_user_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientGroupAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientGroupAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientGroupAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clone_authorized_user_groups: _builtins.bool,
                 groups: Optional[Sequence['outputs.IamApiClientGroupAccessGroup']] = None):
        """
        :param _builtins.bool clone_authorized_user_groups: Sets the API client's group access the same as the authorized user.
        :param Sequence['IamApiClientGroupAccessGroupArgs'] groups: Groups the API client can access.
        """
        pulumi.set(__self__, "clone_authorized_user_groups", clone_authorized_user_groups)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="cloneAuthorizedUserGroups")
    def clone_authorized_user_groups(self) -> _builtins.bool:
        """
        Sets the API client's group access the same as the authorized user.
        """
        return pulumi.get(self, "clone_authorized_user_groups")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.IamApiClientGroupAccessGroup']]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class IamApiClientGroupAccessGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "isBlocked":
            suggest = "is_blocked"
        elif key == "parentGroupId":
            suggest = "parent_group_id"
        elif key == "roleDescription":
            suggest = "role_description"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "subGroups":
            suggest = "sub_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientGroupAccessGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientGroupAccessGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientGroupAccessGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: _builtins.int,
                 role_id: _builtins.int,
                 group_name: Optional[_builtins.str] = None,
                 is_blocked: Optional[_builtins.bool] = None,
                 parent_group_id: Optional[_builtins.int] = None,
                 role_description: Optional[_builtins.str] = None,
                 role_name: Optional[_builtins.str] = None,
                 sub_groups: Optional[Sequence['outputs.IamApiClientGroupAccessGroupSubGroup']] = None):
        """
        :param _builtins.int group_id: A unique identifier for the group.
        :param _builtins.int role_id: A unique identifier for the role.
        :param _builtins.str group_name: A human-readable name for the group.
        :param _builtins.bool is_blocked: Blocks the API client access to the group's child groups.
        :param _builtins.int parent_group_id: A unique identifier for the parent group within the group tree.
        :param _builtins.str role_description: A human-readable description for the role to convey its use.
        :param _builtins.str role_name: A human-readable name for the role.
        :param Sequence['IamApiClientGroupAccessGroupSubGroupArgs'] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "role_id", role_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_blocked is not None:
            pulumi.set(__self__, "is_blocked", is_blocked)
        if parent_group_id is not None:
            pulumi.set(__self__, "parent_group_id", parent_group_id)
        if role_description is not None:
            pulumi.set(__self__, "role_description", role_description)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if sub_groups is not None:
            pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        A unique identifier for the group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.int:
        """
        A unique identifier for the role.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> Optional[_builtins.bool]:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> Optional[_builtins.int]:
        """
        A unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> Optional[_builtins.str]:
        """
        A human-readable description for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the role.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Optional[Sequence['outputs.IamApiClientGroupAccessGroupSubGroup']]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")


@pulumi.output_type
class IamApiClientGroupAccessGroupSubGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "isBlocked":
            suggest = "is_blocked"
        elif key == "parentGroupId":
            suggest = "parent_group_id"
        elif key == "roleDescription":
            suggest = "role_description"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "subGroups":
            suggest = "sub_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientGroupAccessGroupSubGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientGroupAccessGroupSubGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientGroupAccessGroupSubGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: _builtins.int,
                 role_id: _builtins.int,
                 group_name: Optional[_builtins.str] = None,
                 is_blocked: Optional[_builtins.bool] = None,
                 parent_group_id: Optional[_builtins.int] = None,
                 role_description: Optional[_builtins.str] = None,
                 role_name: Optional[_builtins.str] = None,
                 sub_groups: Optional[Sequence['outputs.IamApiClientGroupAccessGroupSubGroup']] = None):
        """
        :param _builtins.int group_id: A unique identifier for the group.
        :param _builtins.int role_id: A unique identifier for the role.
        :param _builtins.str group_name: A human-readable name for the group.
        :param _builtins.bool is_blocked: Blocks the API client access to the group's child groups.
        :param _builtins.int parent_group_id: A unique identifier for the parent group within the group tree.
        :param _builtins.str role_description: A human-readable description for the role to convey its use.
        :param _builtins.str role_name: A human-readable name for the role.
        :param Sequence['IamApiClientGroupAccessGroupSubGroupArgs'] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "role_id", role_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_blocked is not None:
            pulumi.set(__self__, "is_blocked", is_blocked)
        if parent_group_id is not None:
            pulumi.set(__self__, "parent_group_id", parent_group_id)
        if role_description is not None:
            pulumi.set(__self__, "role_description", role_description)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if sub_groups is not None:
            pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        A unique identifier for the group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.int:
        """
        A unique identifier for the role.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> Optional[_builtins.bool]:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> Optional[_builtins.int]:
        """
        A unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> Optional[_builtins.str]:
        """
        A human-readable description for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[_builtins.str]:
        """
        A human-readable name for the role.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Optional[Sequence['outputs.IamApiClientGroupAccessGroupSubGroup']]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")


@pulumi.output_type
class IamApiClientIpAcl(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 cidrs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable: Enables the API client to access the IP access control list (ACL).
        :param Sequence[_builtins.str] cidrs: IP addresses or CIDR blocks the API client can access.
        """
        pulumi.set(__self__, "enable", enable)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Enables the API client to access the IP access control list (ACL).
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        IP addresses or CIDR blocks the API client can access.
        """
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class IamApiClientPurgeOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canPurgeByCacheTag":
            suggest = "can_purge_by_cache_tag"
        elif key == "canPurgeByCpCode":
            suggest = "can_purge_by_cp_code"
        elif key == "cpCodeAccess":
            suggest = "cp_code_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientPurgeOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientPurgeOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientPurgeOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_purge_by_cache_tag: _builtins.bool,
                 can_purge_by_cp_code: _builtins.bool,
                 cp_code_access: 'outputs.IamApiClientPurgeOptionsCpCodeAccess'):
        """
        :param _builtins.bool can_purge_by_cache_tag: Whether the API client can purge content by cache tag.
        :param _builtins.bool can_purge_by_cp_code: Whether the API client can purge content by CP code.
        :param 'IamApiClientPurgeOptionsCpCodeAccessArgs' cp_code_access: CP codes the API client can purge.
        """
        pulumi.set(__self__, "can_purge_by_cache_tag", can_purge_by_cache_tag)
        pulumi.set(__self__, "can_purge_by_cp_code", can_purge_by_cp_code)
        pulumi.set(__self__, "cp_code_access", cp_code_access)

    @_builtins.property
    @pulumi.getter(name="canPurgeByCacheTag")
    def can_purge_by_cache_tag(self) -> _builtins.bool:
        """
        Whether the API client can purge content by cache tag.
        """
        return pulumi.get(self, "can_purge_by_cache_tag")

    @_builtins.property
    @pulumi.getter(name="canPurgeByCpCode")
    def can_purge_by_cp_code(self) -> _builtins.bool:
        """
        Whether the API client can purge content by CP code.
        """
        return pulumi.get(self, "can_purge_by_cp_code")

    @_builtins.property
    @pulumi.getter(name="cpCodeAccess")
    def cp_code_access(self) -> 'outputs.IamApiClientPurgeOptionsCpCodeAccess':
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_code_access")


@pulumi.output_type
class IamApiClientPurgeOptionsCpCodeAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allCurrentAndNewCpCodes":
            suggest = "all_current_and_new_cp_codes"
        elif key == "cpCodes":
            suggest = "cp_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamApiClientPurgeOptionsCpCodeAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamApiClientPurgeOptionsCpCodeAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamApiClientPurgeOptionsCpCodeAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_current_and_new_cp_codes: _builtins.bool,
                 cp_codes: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.bool all_current_and_new_cp_codes: Whether the API can purge content by all current and new CP codes.
        :param Sequence[_builtins.int] cp_codes: CP codes the API client can purge.
        """
        pulumi.set(__self__, "all_current_and_new_cp_codes", all_current_and_new_cp_codes)
        if cp_codes is not None:
            pulumi.set(__self__, "cp_codes", cp_codes)

    @_builtins.property
    @pulumi.getter(name="allCurrentAndNewCpCodes")
    def all_current_and_new_cp_codes(self) -> _builtins.bool:
        """
        Whether the API can purge content by all current and new CP codes.
        """
        return pulumi.get(self, "all_current_and_new_cp_codes")

    @_builtins.property
    @pulumi.getter(name="cpCodes")
    def cp_codes(self) -> Optional[Sequence[_builtins.int]]:
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_codes")


@pulumi.output_type
class IamCidrBlockActions(dict):
    def __init__(__self__, *,
                 delete: Optional[_builtins.bool] = None,
                 edit: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool delete: Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        :param _builtins.bool edit: Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit is not None:
            pulumi.set(__self__, "edit", edit)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> Optional[_builtins.bool]:
        """
        Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        return pulumi.get(self, "edit")


@pulumi.output_type
class IamUserUserNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEmailNotifications":
            suggest = "enable_email_notifications"
        elif key == "passwordExpiry":
            suggest = "password_expiry"
        elif key == "apiClientCredentialExpiryNotification":
            suggest = "api_client_credential_expiry_notification"
        elif key == "newUserNotification":
            suggest = "new_user_notification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamUserUserNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamUserUserNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamUserUserNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_email_notifications: _builtins.bool,
                 password_expiry: _builtins.bool,
                 proactives: Sequence[_builtins.str],
                 upgrades: Sequence[_builtins.str],
                 api_client_credential_expiry_notification: Optional[_builtins.bool] = None,
                 new_user_notification: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_email_notifications: Enables email notifications.
        :param _builtins.bool password_expiry: Enables notifications for expiring passwords.
        :param Sequence[_builtins.str] proactives: Products for which the user gets notifications for service issues.
        :param Sequence[_builtins.str] upgrades: Products for which the user receives notifications for upgrades.
        :param _builtins.bool api_client_credential_expiry_notification: Enables notifications for expiring API client credentials.
        :param _builtins.bool new_user_notification: Enables notifications for group administrators when the user creates other new users.
        """
        pulumi.set(__self__, "enable_email_notifications", enable_email_notifications)
        pulumi.set(__self__, "password_expiry", password_expiry)
        pulumi.set(__self__, "proactives", proactives)
        pulumi.set(__self__, "upgrades", upgrades)
        if api_client_credential_expiry_notification is not None:
            pulumi.set(__self__, "api_client_credential_expiry_notification", api_client_credential_expiry_notification)
        if new_user_notification is not None:
            pulumi.set(__self__, "new_user_notification", new_user_notification)

    @_builtins.property
    @pulumi.getter(name="enableEmailNotifications")
    def enable_email_notifications(self) -> _builtins.bool:
        """
        Enables email notifications.
        """
        return pulumi.get(self, "enable_email_notifications")

    @_builtins.property
    @pulumi.getter(name="passwordExpiry")
    def password_expiry(self) -> _builtins.bool:
        """
        Enables notifications for expiring passwords.
        """
        return pulumi.get(self, "password_expiry")

    @_builtins.property
    @pulumi.getter
    def proactives(self) -> Sequence[_builtins.str]:
        """
        Products for which the user gets notifications for service issues.
        """
        return pulumi.get(self, "proactives")

    @_builtins.property
    @pulumi.getter
    def upgrades(self) -> Sequence[_builtins.str]:
        """
        Products for which the user receives notifications for upgrades.
        """
        return pulumi.get(self, "upgrades")

    @_builtins.property
    @pulumi.getter(name="apiClientCredentialExpiryNotification")
    def api_client_credential_expiry_notification(self) -> Optional[_builtins.bool]:
        """
        Enables notifications for expiring API client credentials.
        """
        return pulumi.get(self, "api_client_credential_expiry_notification")

    @_builtins.property
    @pulumi.getter(name="newUserNotification")
    def new_user_notification(self) -> Optional[_builtins.bool]:
        """
        Enables notifications for group administrators when the user creates other new users.
        """
        return pulumi.get(self, "new_user_notification")


@pulumi.output_type
class PropertyActivationComplianceRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noncomplianceReasonEmergency":
            suggest = "noncompliance_reason_emergency"
        elif key == "noncomplianceReasonNoProductionTraffic":
            suggest = "noncompliance_reason_no_production_traffic"
        elif key == "noncomplianceReasonNone":
            suggest = "noncompliance_reason_none"
        elif key == "noncomplianceReasonOther":
            suggest = "noncompliance_reason_other"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationComplianceRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationComplianceRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 noncompliance_reason_emergency: Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonEmergency'] = None,
                 noncompliance_reason_no_production_traffic: Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic'] = None,
                 noncompliance_reason_none: Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonNone'] = None,
                 noncompliance_reason_other: Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonOther'] = None):
        """
        :param 'PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs' noncompliance_reason_emergency: Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        :param 'PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs' noncompliance_reason_no_production_traffic: Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        :param 'PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs' noncompliance_reason_none: Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        :param 'PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs' noncompliance_reason_other: Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        if noncompliance_reason_emergency is not None:
            pulumi.set(__self__, "noncompliance_reason_emergency", noncompliance_reason_emergency)
        if noncompliance_reason_no_production_traffic is not None:
            pulumi.set(__self__, "noncompliance_reason_no_production_traffic", noncompliance_reason_no_production_traffic)
        if noncompliance_reason_none is not None:
            pulumi.set(__self__, "noncompliance_reason_none", noncompliance_reason_none)
        if noncompliance_reason_other is not None:
            pulumi.set(__self__, "noncompliance_reason_other", noncompliance_reason_other)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonEmergency")
    def noncompliance_reason_emergency(self) -> Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonEmergency']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        return pulumi.get(self, "noncompliance_reason_emergency")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNoProductionTraffic")
    def noncompliance_reason_no_production_traffic(self) -> Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        return pulumi.get(self, "noncompliance_reason_no_production_traffic")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNone")
    def noncompliance_reason_none(self) -> Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonNone']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        return pulumi.get(self, "noncompliance_reason_none")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonOther")
    def noncompliance_reason_other(self) -> Optional['outputs.PropertyActivationComplianceRecordNoncomplianceReasonOther']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        return pulumi.get(self, "noncompliance_reason_other")


@pulumi.output_type
class PropertyActivationComplianceRecordNoncomplianceReasonEmergency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecordNoncomplianceReasonEmergency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonEmergency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonEmergency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTraffic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyActivationComplianceRecordNoncomplianceReasonNone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerEmail":
            suggest = "customer_email"
        elif key == "peerReviewedBy":
            suggest = "peer_reviewed_by"
        elif key == "ticketId":
            suggest = "ticket_id"
        elif key == "unitTested":
            suggest = "unit_tested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecordNoncomplianceReasonNone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonNone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonNone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_email: Optional[_builtins.str] = None,
                 peer_reviewed_by: Optional[_builtins.str] = None,
                 ticket_id: Optional[_builtins.str] = None,
                 unit_tested: Optional[_builtins.bool] = None):
        """
        :param _builtins.str customer_email: Identifies the customer
        :param _builtins.str peer_reviewed_by: Identifies person who has independently approved the activation request
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        :param _builtins.bool unit_tested: Whether the metadata to activate has been fully tested
        """
        if customer_email is not None:
            pulumi.set(__self__, "customer_email", customer_email)
        if peer_reviewed_by is not None:
            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)
        if unit_tested is not None:
            pulumi.set(__self__, "unit_tested", unit_tested)

    @_builtins.property
    @pulumi.getter(name="customerEmail")
    def customer_email(self) -> Optional[_builtins.str]:
        """
        Identifies the customer
        """
        return pulumi.get(self, "customer_email")

    @_builtins.property
    @pulumi.getter(name="peerReviewedBy")
    def peer_reviewed_by(self) -> Optional[_builtins.str]:
        """
        Identifies person who has independently approved the activation request
        """
        return pulumi.get(self, "peer_reviewed_by")

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @_builtins.property
    @pulumi.getter(name="unitTested")
    def unit_tested(self) -> Optional[_builtins.bool]:
        """
        Whether the metadata to activate has been fully tested
        """
        return pulumi.get(self, "unit_tested")


@pulumi.output_type
class PropertyActivationComplianceRecordNoncomplianceReasonOther(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "otherNoncomplianceReason":
            suggest = "other_noncompliance_reason"
        elif key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecordNoncomplianceReasonOther. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonOther.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationComplianceRecordNoncomplianceReasonOther.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 other_noncompliance_reason: Optional[_builtins.str] = None,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str other_noncompliance_reason: Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if other_noncompliance_reason is not None:
            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="otherNoncomplianceReason")
    def other_noncompliance_reason(self) -> Optional[_builtins.str]:
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        return pulumi.get(self, "other_noncompliance_reason")

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyActivationRuleError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "behaviorName":
            suggest = "behavior_name"
        elif key == "errorLocation":
            suggest = "error_location"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationRuleError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyActivationRuleError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyActivationRuleError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior_name: Optional[_builtins.str] = None,
                 detail: Optional[_builtins.str] = None,
                 error_location: Optional[_builtins.str] = None,
                 instance: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "behavior_name")

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error_location")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "status_code")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PropertyActivationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class PropertyHostname(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certProvisioningType":
            suggest = "cert_provisioning_type"
        elif key == "cnameFrom":
            suggest = "cname_from"
        elif key == "cnameTo":
            suggest = "cname_to"
        elif key == "certStatuses":
            suggest = "cert_statuses"
        elif key == "cnameType":
            suggest = "cname_type"
        elif key == "edgeHostnameId":
            suggest = "edge_hostname_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyHostname. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyHostname.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyHostname.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_provisioning_type: _builtins.str,
                 cname_from: _builtins.str,
                 cname_to: _builtins.str,
                 cert_statuses: Optional[Sequence['outputs.PropertyHostnameCertStatus']] = None,
                 cname_type: Optional[_builtins.str] = None,
                 edge_hostname_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_to", cname_to)
        if cert_statuses is not None:
            pulumi.set(__self__, "cert_statuses", cert_statuses)
        if cname_type is not None:
            pulumi.set(__self__, "cname_type", cname_type)
        if edge_hostname_id is not None:
            pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> _builtins.str:
        return pulumi.get(self, "cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> _builtins.str:
        return pulumi.get(self, "cname_from")

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> _builtins.str:
        return pulumi.get(self, "cname_to")

    @_builtins.property
    @pulumi.getter(name="certStatuses")
    def cert_statuses(self) -> Optional[Sequence['outputs.PropertyHostnameCertStatus']]:
        return pulumi.get(self, "cert_statuses")

    @_builtins.property
    @pulumi.getter(name="cnameType")
    def cname_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cname_type")

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "edge_hostname_id")


@pulumi.output_type
class PropertyHostnameBucketHostnames(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certProvisioningType":
            suggest = "cert_provisioning_type"
        elif key == "edgeHostnameId":
            suggest = "edge_hostname_id"
        elif key == "cnameTo":
            suggest = "cname_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyHostnameBucketHostnames. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyHostnameBucketHostnames.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyHostnameBucketHostnames.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_provisioning_type: _builtins.str,
                 edge_hostname_id: _builtins.str,
                 cname_to: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert_provisioning_type: Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
        :param _builtins.str edge_hostname_id: Identifies the edge hostname you mapped your traffic to on the production network.
        :param _builtins.str cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)
        if cname_to is not None:
            pulumi.set(__self__, "cname_to", cname_to)

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> _builtins.str:
        """
        Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
        """
        return pulumi.get(self, "cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> _builtins.str:
        """
        Identifies the edge hostname you mapped your traffic to on the production network.
        """
        return pulumi.get(self, "edge_hostname_id")

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> Optional[_builtins.str]:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "cname_to")


@pulumi.output_type
class PropertyHostnameCertStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productionStatus":
            suggest = "production_status"
        elif key == "stagingStatus":
            suggest = "staging_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyHostnameCertStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyHostnameCertStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyHostnameCertStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[_builtins.str] = None,
                 production_status: Optional[_builtins.str] = None,
                 staging_status: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The hostname part of the CNAME record used to validate the certificate's domain.
        :param _builtins.str production_status: The certificate's deployment status on the production network.
        :param _builtins.str staging_status: The certificate's deployment status on the staging network.
        :param _builtins.str target: The destination part of the CNAME record used to validate the certificate's domain.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if production_status is not None:
            pulumi.set(__self__, "production_status", production_status)
        if staging_status is not None:
            pulumi.set(__self__, "staging_status", staging_status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The hostname part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> Optional[_builtins.str]:
        """
        The certificate's deployment status on the production network.
        """
        return pulumi.get(self, "production_status")

    @_builtins.property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> Optional[_builtins.str]:
        """
        The certificate's deployment status on the staging network.
        """
        return pulumi.get(self, "staging_status")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The destination part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class PropertyIncludeActivationComplianceRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noncomplianceReasonEmergency":
            suggest = "noncompliance_reason_emergency"
        elif key == "noncomplianceReasonNoProductionTraffic":
            suggest = "noncompliance_reason_no_production_traffic"
        elif key == "noncomplianceReasonNone":
            suggest = "noncompliance_reason_none"
        elif key == "noncomplianceReasonOther":
            suggest = "noncompliance_reason_other"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyIncludeActivationComplianceRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyIncludeActivationComplianceRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyIncludeActivationComplianceRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 noncompliance_reason_emergency: Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency'] = None,
                 noncompliance_reason_no_production_traffic: Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic'] = None,
                 noncompliance_reason_none: Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone'] = None,
                 noncompliance_reason_other: Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther'] = None):
        """
        :param 'PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs' noncompliance_reason_emergency: Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        :param 'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs' noncompliance_reason_no_production_traffic: Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        :param 'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs' noncompliance_reason_none: Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        :param 'PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs' noncompliance_reason_other: Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        if noncompliance_reason_emergency is not None:
            pulumi.set(__self__, "noncompliance_reason_emergency", noncompliance_reason_emergency)
        if noncompliance_reason_no_production_traffic is not None:
            pulumi.set(__self__, "noncompliance_reason_no_production_traffic", noncompliance_reason_no_production_traffic)
        if noncompliance_reason_none is not None:
            pulumi.set(__self__, "noncompliance_reason_none", noncompliance_reason_none)
        if noncompliance_reason_other is not None:
            pulumi.set(__self__, "noncompliance_reason_other", noncompliance_reason_other)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonEmergency")
    def noncompliance_reason_emergency(self) -> Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        return pulumi.get(self, "noncompliance_reason_emergency")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNoProductionTraffic")
    def noncompliance_reason_no_production_traffic(self) -> Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        return pulumi.get(self, "noncompliance_reason_no_production_traffic")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNone")
    def noncompliance_reason_none(self) -> Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        return pulumi.get(self, "noncompliance_reason_none")

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonOther")
    def noncompliance_reason_other(self) -> Optional['outputs.PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther']:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        return pulumi.get(self, "noncompliance_reason_other")


@pulumi.output_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTraffic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerEmail":
            suggest = "customer_email"
        elif key == "peerReviewedBy":
            suggest = "peer_reviewed_by"
        elif key == "ticketId":
            suggest = "ticket_id"
        elif key == "unitTested":
            suggest = "unit_tested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonNone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_email: Optional[_builtins.str] = None,
                 peer_reviewed_by: Optional[_builtins.str] = None,
                 ticket_id: Optional[_builtins.str] = None,
                 unit_tested: Optional[_builtins.bool] = None):
        """
        :param _builtins.str customer_email: Identifies the customer
        :param _builtins.str peer_reviewed_by: Identifies person who has independently approved the activation request
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        :param _builtins.bool unit_tested: Whether the metadata to activate has been fully tested
        """
        if customer_email is not None:
            pulumi.set(__self__, "customer_email", customer_email)
        if peer_reviewed_by is not None:
            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)
        if unit_tested is not None:
            pulumi.set(__self__, "unit_tested", unit_tested)

    @_builtins.property
    @pulumi.getter(name="customerEmail")
    def customer_email(self) -> Optional[_builtins.str]:
        """
        Identifies the customer
        """
        return pulumi.get(self, "customer_email")

    @_builtins.property
    @pulumi.getter(name="peerReviewedBy")
    def peer_reviewed_by(self) -> Optional[_builtins.str]:
        """
        Identifies person who has independently approved the activation request
        """
        return pulumi.get(self, "peer_reviewed_by")

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @_builtins.property
    @pulumi.getter(name="unitTested")
    def unit_tested(self) -> Optional[_builtins.bool]:
        """
        Whether the metadata to activate has been fully tested
        """
        return pulumi.get(self, "unit_tested")


@pulumi.output_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "otherNoncomplianceReason":
            suggest = "other_noncompliance_reason"
        elif key == "ticketId":
            suggest = "ticket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyIncludeActivationComplianceRecordNoncomplianceReasonOther.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 other_noncompliance_reason: Optional[_builtins.str] = None,
                 ticket_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str other_noncompliance_reason: Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        :param _builtins.str ticket_id: Identifies the ticket that describes the need for the activation
        """
        if other_noncompliance_reason is not None:
            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="otherNoncomplianceReason")
    def other_noncompliance_reason(self) -> Optional[_builtins.str]:
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        return pulumi.get(self, "other_noncompliance_reason")

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[_builtins.str]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")


@pulumi.output_type
class PropertyIncludeActivationTimeouts(dict):
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")


@pulumi.output_type
class PropertyRuleError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "behaviorName":
            suggest = "behavior_name"
        elif key == "errorLocation":
            suggest = "error_location"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyRuleError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyRuleError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyRuleError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior_name: Optional[_builtins.str] = None,
                 detail: Optional[_builtins.str] = None,
                 error_location: Optional[_builtins.str] = None,
                 instance: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "behavior_name")

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error_location")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "status_code")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PropertyRuleWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "behaviorName":
            suggest = "behavior_name"
        elif key == "errorLocation":
            suggest = "error_location"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyRuleWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyRuleWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyRuleWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior_name: Optional[_builtins.str] = None,
                 detail: Optional[_builtins.str] = None,
                 error_location: Optional[_builtins.str] = None,
                 instance: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "behavior_name")

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error_location")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "status_code")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAppsecRapidRulesRapidRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 attack_group: _builtins.str,
                 attack_group_exception: _builtins.str,
                 condition_exception: _builtins.str,
                 id: _builtins.int,
                 lock: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str action: The rapid rule action.
        :param _builtins.str attack_group: The unique identifier of attack group, rapid rule belongs to.
        :param _builtins.str attack_group_exception: The attack group exception.
        :param _builtins.str condition_exception: The rapid rule exception.
        :param _builtins.int id: The unique identifier of rapid rule.
        :param _builtins.bool lock: The the rapid rule action lock.
        :param _builtins.str name: The rapid rule name.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "attack_group", attack_group)
        pulumi.set(__self__, "attack_group_exception", attack_group_exception)
        pulumi.set(__self__, "condition_exception", condition_exception)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lock", lock)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The rapid rule action.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="attackGroup")
    def attack_group(self) -> _builtins.str:
        """
        The unique identifier of attack group, rapid rule belongs to.
        """
        return pulumi.get(self, "attack_group")

    @_builtins.property
    @pulumi.getter(name="attackGroupException")
    def attack_group_exception(self) -> _builtins.str:
        """
        The attack group exception.
        """
        return pulumi.get(self, "attack_group_exception")

    @_builtins.property
    @pulumi.getter(name="conditionException")
    def condition_exception(self) -> _builtins.str:
        """
        The rapid rule exception.
        """
        return pulumi.get(self, "condition_exception")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The unique identifier of rapid rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> _builtins.bool:
        """
        The the rapid rule action lock.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The rapid rule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCPSEnrollmentAdminContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetCPSEnrollmentCsrResult(dict):
    def __init__(__self__, *,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 organization: _builtins.str,
                 organizational_unit: _builtins.str,
                 preferred_trust_chain: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: The code of the country where organization is located
        :param _builtins.str organization: Name of organization used in all legal documents
        :param _builtins.str organizational_unit: Organizational unit of organization
        :param _builtins.str preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param _builtins.str state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> _builtins.str:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> _builtins.str:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCPSEnrollmentDnsChallengeResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 full_path: _builtins.str,
                 response_body: _builtins.str):
        """
        :param _builtins.str domain: Domain for which the challenges were completed
        :param _builtins.str full_path: The domain name where Akamai publishes the response body to validate
        :param _builtins.str response_body: The unique content of the challenge
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "full_path", full_path)
        pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> _builtins.str:
        """
        The domain name where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> _builtins.str:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")


@pulumi.output_type
class GetCPSEnrollmentHttpChallengeResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 full_path: _builtins.str,
                 response_body: _builtins.str):
        """
        :param _builtins.str domain: Domain for which the challenges were completed
        :param _builtins.str full_path: The URL where Akamai publishes the response body to validate
        :param _builtins.str response_body: The unique content of the challenge
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "full_path", full_path)
        pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> _builtins.str:
        """
        The URL where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> _builtins.str:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")


@pulumi.output_type
class GetCPSEnrollmentNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 client_mutual_authentications: Sequence['outputs.GetCPSEnrollmentNetworkConfigurationClientMutualAuthenticationResult'],
                 clone_dns_names: _builtins.bool,
                 disallowed_tls_versions: Sequence[_builtins.str],
                 geography: _builtins.str,
                 must_have_ciphers: _builtins.str,
                 ocsp_stapling: _builtins.str,
                 preferred_ciphers: _builtins.str,
                 quic_enabled: _builtins.bool):
        """
        :param Sequence['GetCPSEnrollmentNetworkConfigurationClientMutualAuthenticationArgs'] client_mutual_authentications: The trust chain configuration used for client mutual authentication
        :param _builtins.bool clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
        :param Sequence[_builtins.str] disallowed_tls_versions: TLS versions which are disallowed
        :param _builtins.str geography: Geography type used for enrollment
        :param _builtins.str must_have_ciphers: Mandatory Ciphers which are included for enrollment
        :param _builtins.str ocsp_stapling: Enable OCSP stapling
        :param _builtins.str preferred_ciphers: Preferred Ciphers which are included for enrollment
        :param _builtins.bool quic_enabled: Enable QUIC protocol
        """
        pulumi.set(__self__, "client_mutual_authentications", client_mutual_authentications)
        pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        pulumi.set(__self__, "geography", geography)
        pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentications")
    def client_mutual_authentications(self) -> Sequence['outputs.GetCPSEnrollmentNetworkConfigurationClientMutualAuthenticationResult']:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentications")

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> _builtins.bool:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
        """
        return pulumi.get(self, "clone_dns_names")

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Sequence[_builtins.str]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @_builtins.property
    @pulumi.getter
    def geography(self) -> _builtins.str:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> _builtins.str:
        """
        Mandatory Ciphers which are included for enrollment
        """
        return pulumi.get(self, "must_have_ciphers")

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> _builtins.str:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_stapling")

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> _builtins.str:
        """
        Preferred Ciphers which are included for enrollment
        """
        return pulumi.get(self, "preferred_ciphers")

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> _builtins.bool:
        """
        Enable QUIC protocol
        """
        return pulumi.get(self, "quic_enabled")


@pulumi.output_type
class GetCPSEnrollmentNetworkConfigurationClientMutualAuthenticationResult(dict):
    def __init__(__self__, *,
                 ocsp_enabled: _builtins.bool,
                 send_ca_list_to_client: _builtins.bool,
                 set_id: _builtins.str):
        """
        :param _builtins.bool ocsp_enabled: Enable the OCSP stapling
        :param _builtins.bool send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param _builtins.str set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> _builtins.bool:
        """
        Enable the OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> _builtins.bool:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> _builtins.str:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")


@pulumi.output_type
class GetCPSEnrollmentOrganizationResult(dict):
    def __init__(__self__, *,
                 address_line_one: _builtins.str,
                 address_line_two: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 name: _builtins.str,
                 phone: _builtins.str,
                 postal_code: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str address_line_one: The address of organization
        :param _builtins.str address_line_two: The address of organization
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: Country code of country where organization is located
        :param _builtins.str name: Name of organization
        :param _builtins.str phone: The phone number of the administrator who is organization contact
        :param _builtins.str postal_code: The postal code of organization
        :param _builtins.str region: The region where organization resides
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "address_line_two", address_line_two)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        Country code of country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        The phone number of the administrator who is organization contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> _builtins.str:
        """
        The postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region where organization resides
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetCPSEnrollmentTechContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentResult(dict):
    def __init__(__self__, *,
                 admin_contacts: Sequence['outputs.GetCPSEnrollmentsEnrollmentAdminContactResult'],
                 assigned_slots: Sequence[_builtins.int],
                 certificate_chain_type: _builtins.str,
                 certificate_type: _builtins.str,
                 common_name: _builtins.str,
                 csrs: Sequence['outputs.GetCPSEnrollmentsEnrollmentCsrResult'],
                 enable_multi_stacked_certificates: _builtins.bool,
                 enrollment_id: _builtins.int,
                 network_configurations: Sequence['outputs.GetCPSEnrollmentsEnrollmentNetworkConfigurationResult'],
                 org_id: _builtins.int,
                 organizations: Sequence['outputs.GetCPSEnrollmentsEnrollmentOrganizationResult'],
                 pending_changes: _builtins.bool,
                 production_slots: Sequence[_builtins.int],
                 registration_authority: _builtins.str,
                 sans: Sequence[_builtins.str],
                 secure_network: _builtins.str,
                 signature_algorithm: _builtins.str,
                 sni_only: _builtins.bool,
                 staging_slots: Sequence[_builtins.int],
                 tech_contacts: Sequence['outputs.GetCPSEnrollmentsEnrollmentTechContactResult'],
                 validation_type: _builtins.str):
        """
        :param Sequence['GetCPSEnrollmentsEnrollmentAdminContactArgs'] admin_contacts: Contact information for the certificate administrator used at organization
        :param Sequence[_builtins.int] assigned_slots: Slots where the certificate either will be deployed or is already deployed
        :param _builtins.str certificate_chain_type: Certificate trust chain type
        :param _builtins.str certificate_type: Certificate type of enrollment
        :param _builtins.str common_name: Common name used for enrollment
        :param Sequence['GetCPSEnrollmentsEnrollmentCsrArgs'] csrs: Data used for generation of Certificate Signing Request
        :param _builtins.bool enable_multi_stacked_certificates: Enable Dual-Stacked certificate deployment for enrollment
        :param _builtins.int enrollment_id: The unique identifier of enrollment
        :param Sequence['GetCPSEnrollmentsEnrollmentNetworkConfigurationArgs'] network_configurations: Settings containing network information and TLS metadata used by CPS
        :param _builtins.int org_id: The Digicert unique identifier for the organization
        :param Sequence['GetCPSEnrollmentsEnrollmentOrganizationArgs'] organizations: Organization information
        :param _builtins.bool pending_changes: Whether some changes are pending
        :param Sequence[_builtins.int] production_slots: Slots where the certificate is deployed on the production network
        :param _builtins.str registration_authority: The registration authority or certificate authority (CA) used to obtain a certificate
        :param Sequence[_builtins.str] sans: List of SANs
        :param _builtins.str secure_network: Type of TLS deployment network
        :param _builtins.str signature_algorithm: SHA algorithm type
        :param _builtins.bool sni_only: Whether Server Name Indication is used for enrollment
        :param Sequence[_builtins.int] staging_slots: Slots where the certificate is deployed on the staging network
        :param Sequence['GetCPSEnrollmentsEnrollmentTechContactArgs'] tech_contacts: Contact information for an administrator at Akamai
        :param _builtins.str validation_type: Enrolment validation type
        """
        pulumi.set(__self__, "admin_contacts", admin_contacts)
        pulumi.set(__self__, "assigned_slots", assigned_slots)
        pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "csrs", csrs)
        pulumi.set(__self__, "enable_multi_stacked_certificates", enable_multi_stacked_certificates)
        pulumi.set(__self__, "enrollment_id", enrollment_id)
        pulumi.set(__self__, "network_configurations", network_configurations)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "organizations", organizations)
        pulumi.set(__self__, "pending_changes", pending_changes)
        pulumi.set(__self__, "production_slots", production_slots)
        pulumi.set(__self__, "registration_authority", registration_authority)
        pulumi.set(__self__, "sans", sans)
        pulumi.set(__self__, "secure_network", secure_network)
        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        pulumi.set(__self__, "sni_only", sni_only)
        pulumi.set(__self__, "staging_slots", staging_slots)
        pulumi.set(__self__, "tech_contacts", tech_contacts)
        pulumi.set(__self__, "validation_type", validation_type)

    @_builtins.property
    @pulumi.getter(name="adminContacts")
    def admin_contacts(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentAdminContactResult']:
        """
        Contact information for the certificate administrator used at organization
        """
        return pulumi.get(self, "admin_contacts")

    @_builtins.property
    @pulumi.getter(name="assignedSlots")
    def assigned_slots(self) -> Sequence[_builtins.int]:
        """
        Slots where the certificate either will be deployed or is already deployed
        """
        return pulumi.get(self, "assigned_slots")

    @_builtins.property
    @pulumi.getter(name="certificateChainType")
    def certificate_chain_type(self) -> _builtins.str:
        """
        Certificate trust chain type
        """
        return pulumi.get(self, "certificate_chain_type")

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> _builtins.str:
        """
        Certificate type of enrollment
        """
        return pulumi.get(self, "certificate_type")

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> _builtins.str:
        """
        Common name used for enrollment
        """
        return pulumi.get(self, "common_name")

    @_builtins.property
    @pulumi.getter
    def csrs(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentCsrResult']:
        """
        Data used for generation of Certificate Signing Request
        """
        return pulumi.get(self, "csrs")

    @_builtins.property
    @pulumi.getter(name="enableMultiStackedCertificates")
    def enable_multi_stacked_certificates(self) -> _builtins.bool:
        """
        Enable Dual-Stacked certificate deployment for enrollment
        """
        return pulumi.get(self, "enable_multi_stacked_certificates")

    @_builtins.property
    @pulumi.getter(name="enrollmentId")
    def enrollment_id(self) -> _builtins.int:
        """
        The unique identifier of enrollment
        """
        return pulumi.get(self, "enrollment_id")

    @_builtins.property
    @pulumi.getter(name="networkConfigurations")
    def network_configurations(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentNetworkConfigurationResult']:
        """
        Settings containing network information and TLS metadata used by CPS
        """
        return pulumi.get(self, "network_configurations")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.int:
        """
        The Digicert unique identifier for the organization
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def organizations(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentOrganizationResult']:
        """
        Organization information
        """
        return pulumi.get(self, "organizations")

    @_builtins.property
    @pulumi.getter(name="pendingChanges")
    def pending_changes(self) -> _builtins.bool:
        """
        Whether some changes are pending
        """
        return pulumi.get(self, "pending_changes")

    @_builtins.property
    @pulumi.getter(name="productionSlots")
    def production_slots(self) -> Sequence[_builtins.int]:
        """
        Slots where the certificate is deployed on the production network
        """
        return pulumi.get(self, "production_slots")

    @_builtins.property
    @pulumi.getter(name="registrationAuthority")
    def registration_authority(self) -> _builtins.str:
        """
        The registration authority or certificate authority (CA) used to obtain a certificate
        """
        return pulumi.get(self, "registration_authority")

    @_builtins.property
    @pulumi.getter
    def sans(self) -> Sequence[_builtins.str]:
        """
        List of SANs
        """
        return pulumi.get(self, "sans")

    @_builtins.property
    @pulumi.getter(name="secureNetwork")
    def secure_network(self) -> _builtins.str:
        """
        Type of TLS deployment network
        """
        return pulumi.get(self, "secure_network")

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> _builtins.str:
        """
        SHA algorithm type
        """
        return pulumi.get(self, "signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="sniOnly")
    def sni_only(self) -> _builtins.bool:
        """
        Whether Server Name Indication is used for enrollment
        """
        return pulumi.get(self, "sni_only")

    @_builtins.property
    @pulumi.getter(name="stagingSlots")
    def staging_slots(self) -> Sequence[_builtins.int]:
        """
        Slots where the certificate is deployed on the staging network
        """
        return pulumi.get(self, "staging_slots")

    @_builtins.property
    @pulumi.getter(name="techContacts")
    def tech_contacts(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentTechContactResult']:
        """
        Contact information for an administrator at Akamai
        """
        return pulumi.get(self, "tech_contacts")

    @_builtins.property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> _builtins.str:
        """
        Enrolment validation type
        """
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentAdminContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentCsrResult(dict):
    def __init__(__self__, *,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 organization: _builtins.str,
                 organizational_unit: _builtins.str,
                 preferred_trust_chain: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: The code of the country where organization is located
        :param _builtins.str organization: Name of organization used in all legal documents
        :param _builtins.str organizational_unit: Organizational unit of organization
        :param _builtins.str preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param _builtins.str state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> _builtins.str:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> _builtins.str:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 client_mutual_authentications: Sequence['outputs.GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthenticationResult'],
                 clone_dns_names: _builtins.bool,
                 disallowed_tls_versions: Sequence[_builtins.str],
                 geography: _builtins.str,
                 must_have_ciphers: _builtins.str,
                 ocsp_stapling: _builtins.str,
                 preferred_ciphers: _builtins.str,
                 quic_enabled: _builtins.bool):
        """
        :param Sequence['GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthenticationArgs'] client_mutual_authentications: The trust chain configuration used for client mutual authentication
        :param _builtins.bool clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
        :param Sequence[_builtins.str] disallowed_tls_versions: TLS versions which are disallowed
        :param _builtins.str geography: Geography type used for enrollment
        :param _builtins.str must_have_ciphers: Mandatory Ciphers which are included for enrollment
        :param _builtins.str ocsp_stapling: Enable OCSP stapling
        :param _builtins.str preferred_ciphers: Preferred Ciphers which are included for enrollment
        :param _builtins.bool quic_enabled: Enable QUIC protocol
        """
        pulumi.set(__self__, "client_mutual_authentications", client_mutual_authentications)
        pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        pulumi.set(__self__, "geography", geography)
        pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentications")
    def client_mutual_authentications(self) -> Sequence['outputs.GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthenticationResult']:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentications")

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> _builtins.bool:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created
        """
        return pulumi.get(self, "clone_dns_names")

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Sequence[_builtins.str]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @_builtins.property
    @pulumi.getter
    def geography(self) -> _builtins.str:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> _builtins.str:
        """
        Mandatory Ciphers which are included for enrollment
        """
        return pulumi.get(self, "must_have_ciphers")

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> _builtins.str:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_stapling")

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> _builtins.str:
        """
        Preferred Ciphers which are included for enrollment
        """
        return pulumi.get(self, "preferred_ciphers")

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> _builtins.bool:
        """
        Enable QUIC protocol
        """
        return pulumi.get(self, "quic_enabled")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthenticationResult(dict):
    def __init__(__self__, *,
                 ocsp_enabled: _builtins.bool,
                 send_ca_list_to_client: _builtins.bool,
                 set_id: _builtins.str):
        """
        :param _builtins.bool ocsp_enabled: Enable the OCSP stapling
        :param _builtins.bool send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param _builtins.str set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> _builtins.bool:
        """
        Enable the OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> _builtins.bool:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> _builtins.str:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentOrganizationResult(dict):
    def __init__(__self__, *,
                 address_line_one: _builtins.str,
                 address_line_two: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 name: _builtins.str,
                 phone: _builtins.str,
                 postal_code: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str address_line_one: The address of organization
        :param _builtins.str address_line_two: The address of organization
        :param _builtins.str city: City where organization is located
        :param _builtins.str country_code: Country code of country where organization is located
        :param _builtins.str name: Name of organization
        :param _builtins.str phone: The phone number of the administrator who is organization contact
        :param _builtins.str postal_code: The postal code of organization
        :param _builtins.str region: The region where organization resides
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "address_line_two", address_line_two)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> _builtins.str:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        Country code of country where organization is located
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        The phone number of the administrator who is organization contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> _builtins.str:
        """
        The postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region where organization resides
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetCPSEnrollmentsEnrollmentTechContactResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 phone: _builtins.str,
                 address_line_one: Optional[_builtins.str] = None,
                 address_line_two: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country_code: Optional[_builtins.str] = None,
                 organization: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: E-mail address of the contact
        :param _builtins.str first_name: First name of the contact
        :param _builtins.str last_name: Last name of the contact
        :param _builtins.str phone: Phone number of the contact
        :param _builtins.str address_line_one: The address of the contact
        :param _builtins.str address_line_two: The address of the contact
        :param _builtins.str city: City of residence of the contact
        :param _builtins.str country_code: Country code of the contact
        :param _builtins.str organization: Organization where contact is hired
        :param _builtins.str postal_code: Postal code of the contact
        :param _builtins.str region: The region of the contact
        :param _builtins.str title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> _builtins.str:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[_builtins.str]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[_builtins.str]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[_builtins.str]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetClientlistListsListResult(dict):
    def __init__(__self__, *,
                 create_date: _builtins.str,
                 created_by: _builtins.str,
                 deprecated: _builtins.bool,
                 items_count: _builtins.int,
                 list_id: _builtins.str,
                 list_type: _builtins.str,
                 notes: _builtins.str,
                 production_activation_status: _builtins.str,
                 read_only: _builtins.bool,
                 shared: _builtins.bool,
                 staging_activation_status: _builtins.str,
                 tags: Sequence[_builtins.str],
                 update_date: _builtins.str,
                 updated_by: _builtins.str,
                 version: _builtins.int,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_date: The client list creation date.
        :param _builtins.str created_by: The username of the user who created the client list.
        :param _builtins.bool deprecated: Whether the client list was removed.
        :param _builtins.int items_count: The number of items that a client list contains.
        :param _builtins.str list_id: The ID of the client list.
        :param _builtins.str list_type: The client list type.
        :param _builtins.str notes: The client list notes
        :param _builtins.str production_activation_status: The activation status in production environment.
        :param _builtins.bool read_only: Whether the client is editable for the authenticated user.
        :param _builtins.bool shared: Whether the client list is shared.
        :param _builtins.str staging_activation_status: The activation status in staging environment.
        :param Sequence[_builtins.str] tags: The client list tags
        :param _builtins.str update_date: The date of last update.
        :param _builtins.str updated_by: The username of the user that updated the client list last.
        :param _builtins.int version: The current version of the client list.
        :param _builtins.str name: The name of the client list
        :param _builtins.str type: The type of the client list
        """
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "deprecated", deprecated)
        pulumi.set(__self__, "items_count", items_count)
        pulumi.set(__self__, "list_id", list_id)
        pulumi.set(__self__, "list_type", list_type)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "production_activation_status", production_activation_status)
        pulumi.set(__self__, "read_only", read_only)
        pulumi.set(__self__, "shared", shared)
        pulumi.set(__self__, "staging_activation_status", staging_activation_status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "update_date", update_date)
        pulumi.set(__self__, "updated_by", updated_by)
        pulumi.set(__self__, "version", version)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createDate")
    def create_date(self) -> _builtins.str:
        """
        The client list creation date.
        """
        return pulumi.get(self, "create_date")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username of the user who created the client list.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def deprecated(self) -> _builtins.bool:
        """
        Whether the client list was removed.
        """
        return pulumi.get(self, "deprecated")

    @_builtins.property
    @pulumi.getter(name="itemsCount")
    def items_count(self) -> _builtins.int:
        """
        The number of items that a client list contains.
        """
        return pulumi.get(self, "items_count")

    @_builtins.property
    @pulumi.getter(name="listId")
    def list_id(self) -> _builtins.str:
        """
        The ID of the client list.
        """
        return pulumi.get(self, "list_id")

    @_builtins.property
    @pulumi.getter(name="listType")
    def list_type(self) -> _builtins.str:
        """
        The client list type.
        """
        return pulumi.get(self, "list_type")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        """
        The client list notes
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="productionActivationStatus")
    def production_activation_status(self) -> _builtins.str:
        """
        The activation status in production environment.
        """
        return pulumi.get(self, "production_activation_status")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> _builtins.bool:
        """
        Whether the client is editable for the authenticated user.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def shared(self) -> _builtins.bool:
        """
        Whether the client list is shared.
        """
        return pulumi.get(self, "shared")

    @_builtins.property
    @pulumi.getter(name="stagingActivationStatus")
    def staging_activation_status(self) -> _builtins.str:
        """
        The activation status in staging environment.
        """
        return pulumi.get(self, "staging_activation_status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        The client list tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updateDate")
    def update_date(self) -> _builtins.str:
        """
        The date of last update.
        """
        return pulumi.get(self, "update_date")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> _builtins.str:
        """
        The username of the user that updated the client list last.
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The current version of the client list.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the client list
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the client list
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudaccessKeyGroupResult(dict):
    def __init__(__self__, *,
                 contracts_ids: Sequence[_builtins.str],
                 group_id: _builtins.int,
                 group_name: _builtins.str):
        """
        :param Sequence[_builtins.str] contracts_ids: The Akamai contracts that are associated with this access key for the group_id.
        :param _builtins.int group_id: The unique identifier of Akamai group that's associated with the access key.
        :param _builtins.str group_name: The name of Akamai group that's associated with the access key.
        """
        pulumi.set(__self__, "contracts_ids", contracts_ids)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="contractsIds")
    def contracts_ids(self) -> Sequence[_builtins.str]:
        """
        The Akamai contracts that are associated with this access key for the group_id.
        """
        return pulumi.get(self, "contracts_ids")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The unique identifier of Akamai group that's associated with the access key.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        The name of Akamai group that's associated with the access key.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GetCloudaccessKeyNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 additional_cdn: _builtins.str,
                 security_network: _builtins.str):
        """
        :param _builtins.str additional_cdn: The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
        :param _builtins.str security_network: Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
        """
        pulumi.set(__self__, "additional_cdn", additional_cdn)
        pulumi.set(__self__, "security_network", security_network)

    @_builtins.property
    @pulumi.getter(name="additionalCdn")
    def additional_cdn(self) -> _builtins.str:
        """
        The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
        """
        return pulumi.get(self, "additional_cdn")

    @_builtins.property
    @pulumi.getter(name="securityNetwork")
    def security_network(self) -> _builtins.str:
        """
        Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
        """
        return pulumi.get(self, "security_network")


@pulumi.output_type
class GetCloudaccessKeyPropertiesPropertyResult(dict):
    def __init__(__self__, *,
                 access_key_version: _builtins.int,
                 production_version: _builtins.int,
                 property_id: _builtins.str,
                 property_name: _builtins.str,
                 staging_version: _builtins.int):
        """
        :param _builtins.int access_key_version: Version of the access key.
        :param _builtins.int production_version: Identifies the specific property version whose production status is either active or activating.
        :param _builtins.str property_id: The unique identifier Akamai assigned to the matching property.
        :param _builtins.str property_name: Identifies the specific property name whose Origin Characteristics behavior uses the access key version.
        :param _builtins.int staging_version: Identifies the specific property version whose staging status is either active or activating.
        """
        pulumi.set(__self__, "access_key_version", access_key_version)
        pulumi.set(__self__, "production_version", production_version)
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "staging_version", staging_version)

    @_builtins.property
    @pulumi.getter(name="accessKeyVersion")
    def access_key_version(self) -> _builtins.int:
        """
        Version of the access key.
        """
        return pulumi.get(self, "access_key_version")

    @_builtins.property
    @pulumi.getter(name="productionVersion")
    def production_version(self) -> _builtins.int:
        """
        Identifies the specific property version whose production status is either active or activating.
        """
        return pulumi.get(self, "production_version")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.str:
        """
        The unique identifier Akamai assigned to the matching property.
        """
        return pulumi.get(self, "property_id")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        """
        Identifies the specific property name whose Origin Characteristics behavior uses the access key version.
        """
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="stagingVersion")
    def staging_version(self) -> _builtins.int:
        """
        Identifies the specific property version whose staging status is either active or activating.
        """
        return pulumi.get(self, "staging_version")


@pulumi.output_type
class GetCloudaccessKeyVersionsAccessKeyVersionResult(dict):
    def __init__(__self__, *,
                 cloud_access_key_id: _builtins.str,
                 created_by: _builtins.str,
                 created_time: _builtins.str,
                 deployment_status: _builtins.str,
                 version: _builtins.int,
                 version_guid: _builtins.str):
        """
        :param _builtins.str cloud_access_key_id: The unique identifier assigned to the access key assigned from AWS or GCS.
        :param _builtins.str created_by: The username of the person who created the access key.
        :param _builtins.str created_time: The time the access key was created, in ISO 8601 format.
        :param _builtins.str deployment_status: Indicates if the version has been activated to the Akamai networks. Available statuses are: PENDING_DELETION, ACTIVE and PENDING_ACTIVATION.
        :param _builtins.int version: Version of the access key.
        :param _builtins.str version_guid: The unique identifier assigned to an access key version.
        """
        pulumi.set(__self__, "cloud_access_key_id", cloud_access_key_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "deployment_status", deployment_status)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="cloudAccessKeyId")
    def cloud_access_key_id(self) -> _builtins.str:
        """
        The unique identifier assigned to the access key assigned from AWS or GCS.
        """
        return pulumi.get(self, "cloud_access_key_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username of the person who created the access key.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        The time the access key was created, in ISO 8601 format.
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="deploymentStatus")
    def deployment_status(self) -> _builtins.str:
        """
        Indicates if the version has been activated to the Akamai networks. Available statuses are: PENDING_DELETION, ACTIVE and PENDING_ACTIVATION.
        """
        return pulumi.get(self, "deployment_status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        Version of the access key.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> _builtins.str:
        """
        The unique identifier assigned to an access key version.
        """
        return pulumi.get(self, "version_guid")


@pulumi.output_type
class GetCloudaccessKeysAccessKeyResult(dict):
    def __init__(__self__, *,
                 access_key_name: _builtins.str,
                 access_key_uid: _builtins.int,
                 authentication_method: _builtins.str,
                 created_by: _builtins.str,
                 created_time: _builtins.str,
                 groups: Sequence['outputs.GetCloudaccessKeysAccessKeyGroupResult'],
                 latest_version: _builtins.int,
                 network_configuration: 'outputs.GetCloudaccessKeysAccessKeyNetworkConfigurationResult'):
        """
        :param _builtins.str access_key_name: Name of the access key.
        :param _builtins.int access_key_uid: Identifier of the retrieved access key.
        :param _builtins.str authentication_method: The type of signing process used to authenticate API requests: AWS4_HMAC_SHA256 for Amazon Web Services or GOOG4_HMAC_SHA256 for Google Cloud Services in interoperability mode.
        :param _builtins.str created_by: The username of the person who created the access key.
        :param _builtins.str created_time: The time the access key was created, in ISO 8601 format.
        :param Sequence['GetCloudaccessKeysAccessKeyGroupArgs'] groups: A list of groups to which the access key is assigned.
        :param _builtins.int latest_version: The most recent version of the access key.
        :param 'GetCloudaccessKeysAccessKeyNetworkConfigurationArgs' network_configuration: The API deploys the access key to this secure network.
        """
        pulumi.set(__self__, "access_key_name", access_key_name)
        pulumi.set(__self__, "access_key_uid", access_key_uid)
        pulumi.set(__self__, "authentication_method", authentication_method)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "network_configuration", network_configuration)

    @_builtins.property
    @pulumi.getter(name="accessKeyName")
    def access_key_name(self) -> _builtins.str:
        """
        Name of the access key.
        """
        return pulumi.get(self, "access_key_name")

    @_builtins.property
    @pulumi.getter(name="accessKeyUid")
    def access_key_uid(self) -> _builtins.int:
        """
        Identifier of the retrieved access key.
        """
        return pulumi.get(self, "access_key_uid")

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> _builtins.str:
        """
        The type of signing process used to authenticate API requests: AWS4_HMAC_SHA256 for Amazon Web Services or GOOG4_HMAC_SHA256 for Google Cloud Services in interoperability mode.
        """
        return pulumi.get(self, "authentication_method")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username of the person who created the access key.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        The time the access key was created, in ISO 8601 format.
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetCloudaccessKeysAccessKeyGroupResult']:
        """
        A list of groups to which the access key is assigned.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.int:
        """
        The most recent version of the access key.
        """
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> 'outputs.GetCloudaccessKeysAccessKeyNetworkConfigurationResult':
        """
        The API deploys the access key to this secure network.
        """
        return pulumi.get(self, "network_configuration")


@pulumi.output_type
class GetCloudaccessKeysAccessKeyGroupResult(dict):
    def __init__(__self__, *,
                 contracts_ids: Sequence[_builtins.str],
                 group_id: _builtins.int,
                 group_name: _builtins.str):
        """
        :param Sequence[_builtins.str] contracts_ids: The Akamai contracts that are associated with this access key for the group_id.
        :param _builtins.int group_id: The unique identifier of Akamai group that's associated with the access key.
        :param _builtins.str group_name: The name of Akamai group that's associated with the access key.
        """
        pulumi.set(__self__, "contracts_ids", contracts_ids)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="contractsIds")
    def contracts_ids(self) -> Sequence[_builtins.str]:
        """
        The Akamai contracts that are associated with this access key for the group_id.
        """
        return pulumi.get(self, "contracts_ids")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The unique identifier of Akamai group that's associated with the access key.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        The name of Akamai group that's associated with the access key.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GetCloudaccessKeysAccessKeyNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 additional_cdn: _builtins.str,
                 security_network: _builtins.str):
        """
        :param _builtins.str additional_cdn: The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
        :param _builtins.str security_network: Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
        """
        pulumi.set(__self__, "additional_cdn", additional_cdn)
        pulumi.set(__self__, "security_network", security_network)

    @_builtins.property
    @pulumi.getter(name="additionalCdn")
    def additional_cdn(self) -> _builtins.str:
        """
        The access key can be deployed to the Akamai’s  additional networks. Available options are RUSSIA_CDN and CHINA_CDN.
        """
        return pulumi.get(self, "additional_cdn")

    @_builtins.property
    @pulumi.getter(name="securityNetwork")
    def security_network(self) -> _builtins.str:
        """
        Attribute defines the type of secure network to which access key is deployed. Two options are available: STANDARD_TLS and ENHANCED_TLS.
        """
        return pulumi.get(self, "security_network")


@pulumi.output_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 pass_through_percent: _builtins.float,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchResult']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.float pass_through_percent: The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> _builtins.float:
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        return pulumi.get(self, "pass_through_percent")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerDataCenterResult(dict):
    def __init__(__self__, *,
                 city: _builtins.str,
                 cloud_server_host_header_override: _builtins.bool,
                 cloud_service: _builtins.bool,
                 continent: _builtins.str,
                 country: _builtins.str,
                 hostname: _builtins.str,
                 latitude: _builtins.float,
                 liveness_hosts: Sequence[_builtins.str],
                 longitude: _builtins.float,
                 origin_id: _builtins.str,
                 percent: _builtins.float,
                 state_or_province: _builtins.str):
        """
        :param _builtins.str city: The city in which the data center is located.
        :param _builtins.bool cloud_server_host_header_override: Describes if cloud server host header is overridden
        :param _builtins.bool cloud_service: Describes if this datacenter is a cloud service
        :param _builtins.str continent: The continent on which the data center is located
        :param _builtins.str country: The country in which the data center is located
        :param _builtins.str hostname: This should match the 'hostname' value defined for this datacenter in Property Manager
        :param _builtins.float latitude: The latitude value for the data center. This member supports six decimal places of precision.
        :param Sequence[_builtins.str] liveness_hosts: An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        :param _builtins.float longitude: The longitude value for the data center. This member supports six decimal places of precision.
        :param _builtins.str origin_id: The id of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        :param _builtins.float percent: The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        :param _builtins.str state_or_province: The state, province, or region where the data center is located
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        pulumi.set(__self__, "cloud_service", cloud_service)
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "liveness_hosts", liveness_hosts)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "state_or_province", state_or_province)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The city in which the data center is located.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> _builtins.bool:
        """
        Describes if cloud server host header is overridden
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @_builtins.property
    @pulumi.getter(name="cloudService")
    def cloud_service(self) -> _builtins.bool:
        """
        Describes if this datacenter is a cloud service
        """
        return pulumi.get(self, "cloud_service")

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        The continent on which the data center is located
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        The country in which the data center is located
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        This should match the 'hostname' value defined for this datacenter in Property Manager
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        The latitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter(name="livenessHosts")
    def liveness_hosts(self) -> Sequence[_builtins.str]:
        """
        An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        """
        return pulumi.get(self, "liveness_hosts")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        The longitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The id of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.float:
        """
        The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        """
        return pulumi.get(self, "percent")

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> _builtins.str:
        """
        The state, province, or region where the data center is located
        """
        return pulumi.get(self, "state_or_province")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerLivenessSettingResult(dict):
    def __init__(__self__, *,
                 additional_headers: Mapping[str, _builtins.str],
                 host_header: _builtins.str,
                 interval: _builtins.int,
                 path: _builtins.str,
                 peer_certificate_verification: _builtins.bool,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 request_string: _builtins.str,
                 response_string: _builtins.str,
                 status3xx_failure: _builtins.bool,
                 status4xx_failure: _builtins.bool,
                 status5xx_failure: _builtins.bool,
                 timeout: _builtins.float):
        """
        :param Mapping[str, _builtins.str] additional_headers: Maps additional case-insensitive HTTP header names included to the liveness testing requests
        :param _builtins.str host_header: The Host header for the liveness HTTP request
        :param _builtins.int interval: Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        :param _builtins.str path: The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        :param _builtins.bool peer_certificate_verification: Describes whether or not to validate the origin certificate for an HTTPS request
        :param _builtins.int port: The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        :param _builtins.str protocol: The protocol or scheme for the database, either HTTP or HTTPS.
        :param _builtins.str request_string: The request which will be used for TCP(S) tests
        :param _builtins.str response_string: The response which will be used for TCP(S) tests
        :param _builtins.bool status3xx_failure: Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        :param _builtins.bool status4xx_failure: Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        :param _builtins.bool status5xx_failure: Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        :param _builtins.float timeout: The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        pulumi.set(__self__, "additional_headers", additional_headers)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "request_string", request_string)
        pulumi.set(__self__, "response_string", response_string)
        pulumi.set(__self__, "status3xx_failure", status3xx_failure)
        pulumi.set(__self__, "status4xx_failure", status4xx_failure)
        pulumi.set(__self__, "status5xx_failure", status5xx_failure)
        pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Mapping[str, _builtins.str]:
        """
        Maps additional case-insensitive HTTP header names included to the liveness testing requests
        """
        return pulumi.get(self, "additional_headers")

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> _builtins.str:
        """
        The Host header for the liveness HTTP request
        """
        return pulumi.get(self, "host_header")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> _builtins.bool:
        """
        Describes whether or not to validate the origin certificate for an HTTPS request
        """
        return pulumi.get(self, "peer_certificate_verification")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol or scheme for the database, either HTTP or HTTPS.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> _builtins.str:
        """
        The request which will be used for TCP(S) tests
        """
        return pulumi.get(self, "request_string")

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> _builtins.str:
        """
        The response which will be used for TCP(S) tests
        """
        return pulumi.get(self, "response_string")

    @_builtins.property
    @pulumi.getter(name="status3xxFailure")
    def status3xx_failure(self) -> _builtins.bool:
        """
        Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        """
        return pulumi.get(self, "status3xx_failure")

    @_builtins.property
    @pulumi.getter(name="status4xxFailure")
    def status4xx_failure(self) -> _builtins.bool:
        """
        Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        """
        return pulumi.get(self, "status4xx_failure")

    @_builtins.property
    @pulumi.getter(name="status5xxFailure")
    def status5xx_failure(self) -> _builtins.bool:
        """
        Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        """
        return pulumi.get(self, "status5xx_failure")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.float:
        """
        The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 forward_settings: Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingResult'],
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchResult']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs'] forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.int id: Akamai internal use only
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingResult']:
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Akamai internal use only
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingResult(dict):
    def __init__(__self__, *,
                 origin_id: _builtins.str):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        """
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 forward_settings: 'outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsResult',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchResult']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsResult':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsResult(dict):
    def __init__(__self__, *,
                 origin_id: Optional[_builtins.str] = None,
                 path_and_qs: Optional[_builtins.str] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.str path_and_qs: If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[_builtins.str]:
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        return pulumi.get(self, "path_and_qs")

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")


@pulumi.output_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 redirect_url: _builtins.str,
                 status_code: _builtins.int,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchResult']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None,
                 use_relative_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str redirect_url: The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
        :param _builtins.int status_code: The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
        :param _builtins.str use_relative_url: If set to relative_url, takes the path entered for the redirectUrl and sets it in the response’s Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirect_url should be fully-qualified URL
        """
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)
        if use_relative_url is not None:
            pulumi.set(__self__, "use_relative_url", use_relative_url)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.int:
        """
        The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
        """
        return pulumi.get(self, "status_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
        """
        return pulumi.get(self, "use_incoming_query_string")

    @_builtins.property
    @pulumi.getter(name="useRelativeUrl")
    def use_relative_url(self) -> Optional[_builtins.str]:
        """
        If set to relative_url, takes the path entered for the redirectUrl and sets it in the response’s Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirect_url should be fully-qualified URL
        """
        return pulumi.get(self, "use_relative_url")


@pulumi.output_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 forward_settings: 'outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsResult',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchResult']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsResult':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsResult(dict):
    def __init__(__self__, *,
                 origin_id: Optional[_builtins.str] = None,
                 path_and_qs: Optional[_builtins.str] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.str path_and_qs: If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[_builtins.str]:
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        return pulumi.get(self, "path_and_qs")

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")


@pulumi.output_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 forward_settings: 'outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsResult',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchResult']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsResult':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsResult(dict):
    def __init__(__self__, *,
                 origin_id: _builtins.str,
                 percent: _builtins.int):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.int percent: The percent of traffic that is sent to the data center.
        """
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The percent of traffic that is sent to the data center.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsPolicyActivationResult(dict):
    def __init__(__self__, *,
                 api_version: _builtins.str,
                 network: _builtins.str,
                 policy_infos: Sequence['outputs.GetCloudletsPolicyActivationPolicyInfoResult'],
                 property_infos: Sequence['outputs.GetCloudletsPolicyActivationPropertyInfoResult']):
        """
        :param _builtins.str api_version: The specific version of this API.
        :param _builtins.str network: The network type, either 'staging' or 'prod' where a property or a Cloudlet policy has been activated.
        :param Sequence['GetCloudletsPolicyActivationPolicyInfoArgs'] policy_infos: The object containing Cloudlet policy information.
        :param Sequence['GetCloudletsPolicyActivationPropertyInfoArgs'] property_infos: A set containing information about the property associated with a particular Cloudlet policy.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "policy_infos", policy_infos)
        pulumi.set(__self__, "property_infos", property_infos)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        """
        The specific version of this API.
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network type, either 'staging' or 'prod' where a property or a Cloudlet policy has been activated.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="policyInfos")
    def policy_infos(self) -> Sequence['outputs.GetCloudletsPolicyActivationPolicyInfoResult']:
        """
        The object containing Cloudlet policy information.
        """
        return pulumi.get(self, "policy_infos")

    @_builtins.property
    @pulumi.getter(name="propertyInfos")
    def property_infos(self) -> Sequence['outputs.GetCloudletsPolicyActivationPropertyInfoResult']:
        """
        A set containing information about the property associated with a particular Cloudlet policy.
        """
        return pulumi.get(self, "property_infos")


@pulumi.output_type
class GetCloudletsPolicyActivationPolicyInfoResult(dict):
    def __init__(__self__, *,
                 activated_by: _builtins.str,
                 activation_date: _builtins.int,
                 name: _builtins.str,
                 policy_id: _builtins.int,
                 status: _builtins.str,
                 status_detail: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str activated_by: The name of the user who activated the policy.
        :param _builtins.int activation_date: The date on which the policy was activated (in milliseconds since Epoch).
        :param _builtins.str name: The name of the policy.
        :param _builtins.int policy_id: An integer ID that is associated with all versions of a policy.
        :param _builtins.str status: The activation status for the policy: active, inactive, deactivated, pending or failed.
        :param _builtins.str status_detail: Information about the status of an activation operation.
        :param _builtins.int version: The version number of the activated policy.
        """
        pulumi.set(__self__, "activated_by", activated_by)
        pulumi.set(__self__, "activation_date", activation_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_detail", status_detail)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="activatedBy")
    def activated_by(self) -> _builtins.str:
        """
        The name of the user who activated the policy.
        """
        return pulumi.get(self, "activated_by")

    @_builtins.property
    @pulumi.getter(name="activationDate")
    def activation_date(self) -> _builtins.int:
        """
        The date on which the policy was activated (in milliseconds since Epoch).
        """
        return pulumi.get(self, "activation_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        An integer ID that is associated with all versions of a policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The activation status for the policy: active, inactive, deactivated, pending or failed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusDetail")
    def status_detail(self) -> _builtins.str:
        """
        Information about the status of an activation operation.
        """
        return pulumi.get(self, "status_detail")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The version number of the activated policy.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetCloudletsPolicyActivationPropertyInfoResult(dict):
    def __init__(__self__, *,
                 activated_by: _builtins.str,
                 activation_date: _builtins.int,
                 group_id: _builtins.int,
                 name: _builtins.str,
                 status: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str activated_by: The name of the user who activated the property.
        :param _builtins.int activation_date: The date on which the property was activated (in milliseconds since Epoch).
        :param _builtins.int group_id: Defines the group association for the policy or property.
        :param _builtins.str name: The name of the property.
        :param _builtins.str status: The activation status for the property. Can be active, inactive, deactivated, pending or failed.
        :param _builtins.int version: The version number of the activated property.
        """
        pulumi.set(__self__, "activated_by", activated_by)
        pulumi.set(__self__, "activation_date", activation_date)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="activatedBy")
    def activated_by(self) -> _builtins.str:
        """
        The name of the user who activated the property.
        """
        return pulumi.get(self, "activated_by")

    @_builtins.property
    @pulumi.getter(name="activationDate")
    def activation_date(self) -> _builtins.int:
        """
        The date on which the property was activated (in milliseconds since Epoch).
        """
        return pulumi.get(self, "activation_date")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        Defines the group association for the policy or property.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The activation status for the property. Can be active, inactive, deactivated, pending or failed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The version number of the activated property.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetCloudletsRequestControlMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 allow_deny: _builtins.str,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchResult']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.str allow_deny: If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "allow_deny", allow_deny)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="allowDeny")
    def allow_deny(self) -> _builtins.str:
        """
        If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
        """
        return pulumi.get(self, "allow_deny")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsResult(dict):
    def __init__(__self__, *,
                 production: Optional['outputs.GetCloudletsSharedPolicyActivationsProductionResult'] = None,
                 staging: Optional['outputs.GetCloudletsSharedPolicyActivationsStagingResult'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsProductionArgs' production: The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        :param 'GetCloudletsSharedPolicyActivationsStagingArgs' staging: The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        if production is not None:
            pulumi.set(__self__, "production", production)
        if staging is not None:
            pulumi.set(__self__, "staging", staging)

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsProductionResult']:
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        return pulumi.get(self, "production")

    @_builtins.property
    @pulumi.getter
    def staging(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsStagingResult']:
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        return pulumi.get(self, "staging")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsProductionResult(dict):
    def __init__(__self__, *,
                 effective: Optional['outputs.GetCloudletsSharedPolicyActivationsProductionEffectiveResult'] = None,
                 latest: Optional['outputs.GetCloudletsSharedPolicyActivationsProductionLatestResult'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsProductionEffectiveArgs' effective: The status of the activation that's currently in use on this network, or null if the policy has no activations.
        :param 'GetCloudletsSharedPolicyActivationsProductionLatestArgs' latest: The status of the latest activation or null if the policy has no activations.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsProductionEffectiveResult']:
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        return pulumi.get(self, "effective")

    @_builtins.property
    @pulumi.getter
    def latest(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsProductionLatestResult']:
        """
        The status of the latest activation or null if the policy has no activations.
        """
        return pulumi.get(self, "latest")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsProductionEffectiveResult(dict):
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsProductionLatestResult(dict):
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsStagingResult(dict):
    def __init__(__self__, *,
                 effective: Optional['outputs.GetCloudletsSharedPolicyActivationsStagingEffectiveResult'] = None,
                 latest: Optional['outputs.GetCloudletsSharedPolicyActivationsStagingLatestResult'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsStagingEffectiveArgs' effective: The status of the activation that's currently in use on this network, or null if the policy has no activations.
        :param 'GetCloudletsSharedPolicyActivationsStagingLatestArgs' latest: The status of the latest activation or null if the policy has no activations.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsStagingEffectiveResult']:
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        return pulumi.get(self, "effective")

    @_builtins.property
    @pulumi.getter
    def latest(self) -> Optional['outputs.GetCloudletsSharedPolicyActivationsStagingLatestResult']:
        """
        The status of the latest activation or null if the policy has no activations.
        """
        return pulumi.get(self, "latest")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsStagingEffectiveResult(dict):
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCloudletsSharedPolicyActivationsStagingLatestResult(dict):
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleResult(dict):
    def __init__(__self__, *,
                 pass_through_percent: _builtins.float,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchResult']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.float pass_through_percent: The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> _builtins.float:
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        return pulumi.get(self, "pass_through_percent")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchResult']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchResult(dict):
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")


@pulumi.output_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsResult(dict):
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCloudwrapperCapacitiesCapacityResult(dict):
    def __init__(__self__, *,
                 approved: 'outputs.GetCloudwrapperCapacitiesCapacityApprovedResult',
                 assigned: 'outputs.GetCloudwrapperCapacitiesCapacityAssignedResult',
                 contract_id: _builtins.str,
                 location_id: _builtins.int,
                 location_name: _builtins.str,
                 type: _builtins.str,
                 unassigned: 'outputs.GetCloudwrapperCapacitiesCapacityUnassignedResult'):
        """
        :param 'GetCloudwrapperCapacitiesCapacityApprovedArgs' approved: Capacity allocated for the location.
        :param 'GetCloudwrapperCapacitiesCapacityAssignedArgs' assigned: Capacity already assigned to Cloud Wrapper configurations.
        :param _builtins.str contract_id: Contract ID having Cloud Wrapper entitlement.
        :param _builtins.int location_id: Unique identifier of the configured location.
        :param _builtins.str location_name: Name of the location.
        :param _builtins.str type: The type of property this capacity is related to.
        :param 'GetCloudwrapperCapacitiesCapacityUnassignedArgs' unassigned: Capacity value that can be assigned to Cloud Wrapper configurations.
        """
        pulumi.set(__self__, "approved", approved)
        pulumi.set(__self__, "assigned", assigned)
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "location_name", location_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unassigned", unassigned)

    @_builtins.property
    @pulumi.getter
    def approved(self) -> 'outputs.GetCloudwrapperCapacitiesCapacityApprovedResult':
        """
        Capacity allocated for the location.
        """
        return pulumi.get(self, "approved")

    @_builtins.property
    @pulumi.getter
    def assigned(self) -> 'outputs.GetCloudwrapperCapacitiesCapacityAssignedResult':
        """
        Capacity already assigned to Cloud Wrapper configurations.
        """
        return pulumi.get(self, "assigned")

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.int:
        """
        Unique identifier of the configured location.
        """
        return pulumi.get(self, "location_id")

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        Name of the location.
        """
        return pulumi.get(self, "location_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of property this capacity is related to.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unassigned(self) -> 'outputs.GetCloudwrapperCapacitiesCapacityUnassignedResult':
        """
        Capacity value that can be assigned to Cloud Wrapper configurations.
        """
        return pulumi.get(self, "unassigned")


@pulumi.output_type
class GetCloudwrapperCapacitiesCapacityApprovedResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudwrapperCapacitiesCapacityAssignedResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudwrapperCapacitiesCapacityUnassignedResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudwrapperConfigurationLocationResult(dict):
    def __init__(__self__, *,
                 capacity: 'outputs.GetCloudwrapperConfigurationLocationCapacityResult',
                 comments: _builtins.str,
                 map_name: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param 'GetCloudwrapperConfigurationLocationCapacityArgs' capacity: The capacity assigned to this configuration's location.
        :param _builtins.str comments: Additional comments provided by user.
        :param _builtins.str map_name: The name of the map.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> 'outputs.GetCloudwrapperConfigurationLocationCapacityResult':
        """
        The capacity assigned to this configuration's location.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional comments provided by user.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        The name of the map.
        """
        return pulumi.get(self, "map_name")

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")


@pulumi.output_type
class GetCloudwrapperConfigurationLocationCapacityResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsResult(dict):
    def __init__(__self__, *,
                 enable_soft_alerts: _builtins.bool,
                 bocc: Optional['outputs.GetCloudwrapperConfigurationMultiCdnSettingsBoccResult'] = None,
                 cdns: Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdnResult']] = None,
                 data_streams: Optional['outputs.GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsResult'] = None,
                 origins: Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsOriginResult']] = None):
        """
        :param _builtins.bool enable_soft_alerts: Option to opt out of alerts based on soft limits of bandwidth usage.
        :param 'GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs' bocc: Specify diagnostic data beacons details.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs'] cdns: List of CDN added for the configuration.
        :param 'GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs' data_streams: Specifies data streams details.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs'] origins: List of origins corresponding to the properties selected in the configuration.
        """
        pulumi.set(__self__, "enable_soft_alerts", enable_soft_alerts)
        if bocc is not None:
            pulumi.set(__self__, "bocc", bocc)
        if cdns is not None:
            pulumi.set(__self__, "cdns", cdns)
        if data_streams is not None:
            pulumi.set(__self__, "data_streams", data_streams)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)

    @_builtins.property
    @pulumi.getter(name="enableSoftAlerts")
    def enable_soft_alerts(self) -> _builtins.bool:
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        return pulumi.get(self, "enable_soft_alerts")

    @_builtins.property
    @pulumi.getter
    def bocc(self) -> Optional['outputs.GetCloudwrapperConfigurationMultiCdnSettingsBoccResult']:
        """
        Specify diagnostic data beacons details.
        """
        return pulumi.get(self, "bocc")

    @_builtins.property
    @pulumi.getter
    def cdns(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdnResult']]:
        """
        List of CDN added for the configuration.
        """
        return pulumi.get(self, "cdns")

    @_builtins.property
    @pulumi.getter(name="dataStreams")
    def data_streams(self) -> Optional['outputs.GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsResult']:
        """
        Specifies data streams details.
        """
        return pulumi.get(self, "data_streams")

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsOriginResult']]:
        """
        List of origins corresponding to the properties selected in the configuration.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsBoccResult(dict):
    def __init__(__self__, *,
                 conditional_sampling_frequency: _builtins.str,
                 enabled: _builtins.bool,
                 forward_type: _builtins.str,
                 request_type: _builtins.str,
                 sampling_frequency: _builtins.str):
        """
        :param _builtins.str conditional_sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        :param _builtins.bool enabled: Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        :param _builtins.str forward_type: Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        :param _builtins.str request_type: Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        :param _builtins.str sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        pulumi.set(__self__, "conditional_sampling_frequency", conditional_sampling_frequency)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "forward_type", forward_type)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "sampling_frequency", sampling_frequency)

    @_builtins.property
    @pulumi.getter(name="conditionalSamplingFrequency")
    def conditional_sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "conditional_sampling_frequency")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="forwardType")
    def forward_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        return pulumi.get(self, "forward_type")

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        return pulumi.get(self, "request_type")

    @_builtins.property
    @pulumi.getter(name="samplingFrequency")
    def sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "sampling_frequency")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsCdnResult(dict):
    def __init__(__self__, *,
                 cdn_code: _builtins.str,
                 enabled: _builtins.bool,
                 https_only: _builtins.bool,
                 ip_acl_cidrs: Sequence[_builtins.str],
                 cdn_auth_keys: Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyResult']] = None):
        """
        :param _builtins.str cdn_code: Unique identifier for the CDN.
        :param _builtins.bool enabled: Enable CDN.
        :param _builtins.bool https_only: Specify whether CDN communication is HTTPS only.
        :param Sequence[_builtins.str] ip_acl_cidrs: Configure an access control list using IP addresses in CIDR notation.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs'] cdn_auth_keys: List of auth keys configured for the CDN.
        """
        pulumi.set(__self__, "cdn_code", cdn_code)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "https_only", https_only)
        pulumi.set(__self__, "ip_acl_cidrs", ip_acl_cidrs)
        if cdn_auth_keys is not None:
            pulumi.set(__self__, "cdn_auth_keys", cdn_auth_keys)

    @_builtins.property
    @pulumi.getter(name="cdnCode")
    def cdn_code(self) -> _builtins.str:
        """
        Unique identifier for the CDN.
        """
        return pulumi.get(self, "cdn_code")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable CDN.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> _builtins.bool:
        """
        Specify whether CDN communication is HTTPS only.
        """
        return pulumi.get(self, "https_only")

    @_builtins.property
    @pulumi.getter(name="ipAclCidrs")
    def ip_acl_cidrs(self) -> Sequence[_builtins.str]:
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        return pulumi.get(self, "ip_acl_cidrs")

    @_builtins.property
    @pulumi.getter(name="cdnAuthKeys")
    def cdn_auth_keys(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyResult']]:
        """
        List of auth keys configured for the CDN.
        """
        return pulumi.get(self, "cdn_auth_keys")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyResult(dict):
    def __init__(__self__, *,
                 auth_key_name: _builtins.str,
                 expiry_date: _builtins.str,
                 header_name: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str auth_key_name: The name of the auth key.
        :param _builtins.str expiry_date: The expirty date of an auth key.
        :param _builtins.str header_name: The header name of an auth key.
        :param _builtins.str secret: The secret of an auth key.
        """
        pulumi.set(__self__, "auth_key_name", auth_key_name)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="authKeyName")
    def auth_key_name(self) -> _builtins.str:
        """
        The name of the auth key.
        """
        return pulumi.get(self, "auth_key_name")

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> _builtins.str:
        """
        The expirty date of an auth key.
        """
        return pulumi.get(self, "expiry_date")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header name of an auth key.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret of an auth key.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsResult(dict):
    def __init__(__self__, *,
                 data_stream_ids: Sequence[_builtins.int],
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.int):
        """
        :param Sequence[_builtins.int] data_stream_ids: Unique identifiers of the Data Streams.
        :param _builtins.bool enabled: Enables DataStream reporting.
        :param _builtins.int sampling_rate: Specifies the percentage of log data you want to collect for this configuration.
        """
        pulumi.set(__self__, "data_stream_ids", data_stream_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter(name="dataStreamIds")
    def data_stream_ids(self) -> Sequence[_builtins.int]:
        """
        Unique identifiers of the Data Streams.
        """
        return pulumi.get(self, "data_stream_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables DataStream reporting.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.int:
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class GetCloudwrapperConfigurationMultiCdnSettingsOriginResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 origin_id: _builtins.str,
                 property_id: _builtins.int):
        """
        :param _builtins.str hostname: Origins hostname corresponding to the Akamai Delivery Property.
        :param _builtins.str origin_id: Origin identifier and will be used to generated Multi CDN host names.
        :param _builtins.int property_id: Property ID of the property that origin belongs to.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "property_id", property_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property that origin belongs to.
        """
        return pulumi.get(self, "property_id")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationResult(dict):
    def __init__(__self__, *,
                 capacity_alerts_threshold: _builtins.int,
                 comments: _builtins.str,
                 config_name: _builtins.str,
                 contract_id: _builtins.str,
                 id: _builtins.int,
                 last_activated_by: _builtins.str,
                 last_activated_date: _builtins.str,
                 last_updated_by: _builtins.str,
                 last_updated_date: _builtins.str,
                 notification_emails: Sequence[_builtins.str],
                 property_ids: Sequence[_builtins.str],
                 retain_idle_objects: _builtins.bool,
                 status: _builtins.str,
                 locations: Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationLocationResult']] = None,
                 multi_cdn_settings: Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsResult'] = None):
        """
        :param _builtins.int capacity_alerts_threshold: Represents the threshold for sending alerts.
        :param _builtins.str comments: Additional information provided by user which can help to differentiate or track changes of the configuration.
        :param _builtins.str config_name: Name of the configuration.
        :param _builtins.str contract_id: Contract ID with Cloud Wrapper entitlement.
        :param _builtins.int id: Unique identifier of a Cloud Wrapper configuration.
        :param _builtins.str last_activated_by: User to last activate the configuration.
        :param _builtins.str last_activated_date: ISO format date that represents when the configuration was last activated successfully.
        :param _builtins.str last_updated_by: User to last modify the configuration.
        :param _builtins.str last_updated_date: ISO format date that represents when the configuration was last edited.
        :param Sequence[_builtins.str] notification_emails: Email addresses to receive notifications.
        :param Sequence[_builtins.str] property_ids: List of properties belonging to media delivery products. Properties need to be unique across configurations.
        :param _builtins.bool retain_idle_objects: Retain idle objects beyond their max idle lifetime.
        :param _builtins.str status: Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgs'] locations: List of all unused properties.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs' multi_cdn_settings: Specify details about the Multi CDN settings.
        """
        pulumi.set(__self__, "capacity_alerts_threshold", capacity_alerts_threshold)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "config_name", config_name)
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_activated_by", last_activated_by)
        pulumi.set(__self__, "last_activated_date", last_activated_date)
        pulumi.set(__self__, "last_updated_by", last_updated_by)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "notification_emails", notification_emails)
        pulumi.set(__self__, "property_ids", property_ids)
        pulumi.set(__self__, "retain_idle_objects", retain_idle_objects)
        pulumi.set(__self__, "status", status)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if multi_cdn_settings is not None:
            pulumi.set(__self__, "multi_cdn_settings", multi_cdn_settings)

    @_builtins.property
    @pulumi.getter(name="capacityAlertsThreshold")
    def capacity_alerts_threshold(self) -> _builtins.int:
        """
        Represents the threshold for sending alerts.
        """
        return pulumi.get(self, "capacity_alerts_threshold")

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional information provided by user which can help to differentiate or track changes of the configuration.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="configName")
    def config_name(self) -> _builtins.str:
        """
        Name of the configuration.
        """
        return pulumi.get(self, "config_name")

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID with Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        Unique identifier of a Cloud Wrapper configuration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastActivatedBy")
    def last_activated_by(self) -> _builtins.str:
        """
        User to last activate the configuration.
        """
        return pulumi.get(self, "last_activated_by")

    @_builtins.property
    @pulumi.getter(name="lastActivatedDate")
    def last_activated_date(self) -> _builtins.str:
        """
        ISO format date that represents when the configuration was last activated successfully.
        """
        return pulumi.get(self, "last_activated_date")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedBy")
    def last_updated_by(self) -> _builtins.str:
        """
        User to last modify the configuration.
        """
        return pulumi.get(self, "last_updated_by")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> _builtins.str:
        """
        ISO format date that represents when the configuration was last edited.
        """
        return pulumi.get(self, "last_updated_date")

    @_builtins.property
    @pulumi.getter(name="notificationEmails")
    def notification_emails(self) -> Sequence[_builtins.str]:
        """
        Email addresses to receive notifications.
        """
        return pulumi.get(self, "notification_emails")

    @_builtins.property
    @pulumi.getter(name="propertyIds")
    def property_ids(self) -> Sequence[_builtins.str]:
        """
        List of properties belonging to media delivery products. Properties need to be unique across configurations.
        """
        return pulumi.get(self, "property_ids")

    @_builtins.property
    @pulumi.getter(name="retainIdleObjects")
    def retain_idle_objects(self) -> _builtins.bool:
        """
        Retain idle objects beyond their max idle lifetime.
        """
        return pulumi.get(self, "retain_idle_objects")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationLocationResult']]:
        """
        List of all unused properties.
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="multiCdnSettings")
    def multi_cdn_settings(self) -> Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsResult']:
        """
        Specify details about the Multi CDN settings.
        """
        return pulumi.get(self, "multi_cdn_settings")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationLocationResult(dict):
    def __init__(__self__, *,
                 capacity: 'outputs.GetCloudwrapperConfigurationsConfigurationLocationCapacityResult',
                 comments: _builtins.str,
                 map_name: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs' capacity: The capacity assigned to this configuration's location.
        :param _builtins.str comments: Additional comments provided by user.
        :param _builtins.str map_name: The name of the map.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> 'outputs.GetCloudwrapperConfigurationsConfigurationLocationCapacityResult':
        """
        The capacity assigned to this configuration's location.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional comments provided by user.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        The name of the map.
        """
        return pulumi.get(self, "map_name")

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationLocationCapacityResult(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsResult(dict):
    def __init__(__self__, *,
                 enable_soft_alerts: _builtins.bool,
                 bocc: Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccResult'] = None,
                 cdns: Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnResult']] = None,
                 data_streams: Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsResult'] = None,
                 origins: Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginResult']] = None):
        """
        :param _builtins.bool enable_soft_alerts: Option to opt out of alerts based on soft limits of bandwidth usage.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs' bocc: Specify diagnostic data beacons details.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs'] cdns: List of CDN added for the configuration.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs' data_streams: Specifies data streams details.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs'] origins: List of origins corresponding to the properties selected in the configuration.
        """
        pulumi.set(__self__, "enable_soft_alerts", enable_soft_alerts)
        if bocc is not None:
            pulumi.set(__self__, "bocc", bocc)
        if cdns is not None:
            pulumi.set(__self__, "cdns", cdns)
        if data_streams is not None:
            pulumi.set(__self__, "data_streams", data_streams)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)

    @_builtins.property
    @pulumi.getter(name="enableSoftAlerts")
    def enable_soft_alerts(self) -> _builtins.bool:
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        return pulumi.get(self, "enable_soft_alerts")

    @_builtins.property
    @pulumi.getter
    def bocc(self) -> Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccResult']:
        """
        Specify diagnostic data beacons details.
        """
        return pulumi.get(self, "bocc")

    @_builtins.property
    @pulumi.getter
    def cdns(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnResult']]:
        """
        List of CDN added for the configuration.
        """
        return pulumi.get(self, "cdns")

    @_builtins.property
    @pulumi.getter(name="dataStreams")
    def data_streams(self) -> Optional['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsResult']:
        """
        Specifies data streams details.
        """
        return pulumi.get(self, "data_streams")

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginResult']]:
        """
        List of origins corresponding to the properties selected in the configuration.
        """
        return pulumi.get(self, "origins")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccResult(dict):
    def __init__(__self__, *,
                 conditional_sampling_frequency: _builtins.str,
                 enabled: _builtins.bool,
                 forward_type: _builtins.str,
                 request_type: _builtins.str,
                 sampling_frequency: _builtins.str):
        """
        :param _builtins.str conditional_sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        :param _builtins.bool enabled: Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        :param _builtins.str forward_type: Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        :param _builtins.str request_type: Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        :param _builtins.str sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        pulumi.set(__self__, "conditional_sampling_frequency", conditional_sampling_frequency)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "forward_type", forward_type)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "sampling_frequency", sampling_frequency)

    @_builtins.property
    @pulumi.getter(name="conditionalSamplingFrequency")
    def conditional_sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "conditional_sampling_frequency")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="forwardType")
    def forward_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        return pulumi.get(self, "forward_type")

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        return pulumi.get(self, "request_type")

    @_builtins.property
    @pulumi.getter(name="samplingFrequency")
    def sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "sampling_frequency")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnResult(dict):
    def __init__(__self__, *,
                 cdn_code: _builtins.str,
                 enabled: _builtins.bool,
                 https_only: _builtins.bool,
                 ip_acl_cidrs: Sequence[_builtins.str],
                 cdn_auth_keys: Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyResult']] = None):
        """
        :param _builtins.str cdn_code: Unique identifier for the CDN.
        :param _builtins.bool enabled: Enable CDN.
        :param _builtins.bool https_only: Specify whether CDN communication is HTTPS only.
        :param Sequence[_builtins.str] ip_acl_cidrs: Configure an access control list using IP addresses in CIDR notation.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs'] cdn_auth_keys: List of auth keys configured for the CDN.
        """
        pulumi.set(__self__, "cdn_code", cdn_code)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "https_only", https_only)
        pulumi.set(__self__, "ip_acl_cidrs", ip_acl_cidrs)
        if cdn_auth_keys is not None:
            pulumi.set(__self__, "cdn_auth_keys", cdn_auth_keys)

    @_builtins.property
    @pulumi.getter(name="cdnCode")
    def cdn_code(self) -> _builtins.str:
        """
        Unique identifier for the CDN.
        """
        return pulumi.get(self, "cdn_code")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable CDN.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> _builtins.bool:
        """
        Specify whether CDN communication is HTTPS only.
        """
        return pulumi.get(self, "https_only")

    @_builtins.property
    @pulumi.getter(name="ipAclCidrs")
    def ip_acl_cidrs(self) -> Sequence[_builtins.str]:
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        return pulumi.get(self, "ip_acl_cidrs")

    @_builtins.property
    @pulumi.getter(name="cdnAuthKeys")
    def cdn_auth_keys(self) -> Optional[Sequence['outputs.GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyResult']]:
        """
        List of auth keys configured for the CDN.
        """
        return pulumi.get(self, "cdn_auth_keys")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyResult(dict):
    def __init__(__self__, *,
                 auth_key_name: _builtins.str,
                 expiry_date: _builtins.str,
                 header_name: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str auth_key_name: The name of the auth key.
        :param _builtins.str expiry_date: The expirty date of an auth key.
        :param _builtins.str header_name: The header name of an auth key.
        :param _builtins.str secret: The secret of an auth key.
        """
        pulumi.set(__self__, "auth_key_name", auth_key_name)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="authKeyName")
    def auth_key_name(self) -> _builtins.str:
        """
        The name of the auth key.
        """
        return pulumi.get(self, "auth_key_name")

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> _builtins.str:
        """
        The expirty date of an auth key.
        """
        return pulumi.get(self, "expiry_date")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header name of an auth key.
        """
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret of an auth key.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsResult(dict):
    def __init__(__self__, *,
                 data_stream_ids: Sequence[_builtins.int],
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.int):
        """
        :param Sequence[_builtins.int] data_stream_ids: Unique identifiers of the Data Streams.
        :param _builtins.bool enabled: Enables DataStream reporting.
        :param _builtins.int sampling_rate: Specifies the percentage of log data you want to collect for this configuration.
        """
        pulumi.set(__self__, "data_stream_ids", data_stream_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter(name="dataStreamIds")
    def data_stream_ids(self) -> Sequence[_builtins.int]:
        """
        Unique identifiers of the Data Streams.
        """
        return pulumi.get(self, "data_stream_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables DataStream reporting.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.int:
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 origin_id: _builtins.str,
                 property_id: _builtins.int):
        """
        :param _builtins.str hostname: Origins hostname corresponding to the Akamai Delivery Property.
        :param _builtins.str origin_id: Origin identifier and will be used to generated Multi CDN host names.
        :param _builtins.int property_id: Property ID of the property that origin belongs to.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "property_id", property_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property that origin belongs to.
        """
        return pulumi.get(self, "property_id")


@pulumi.output_type
class GetCloudwrapperLocationsLocationResult(dict):
    def __init__(__self__, *,
                 location_id: _builtins.int,
                 location_name: _builtins.str,
                 multi_cdn_location_id: _builtins.str,
                 traffic_types: Optional[Sequence['outputs.GetCloudwrapperLocationsLocationTrafficTypeResult']] = None):
        """
        :param _builtins.int location_id: Unique identifier of the location.
        :param _builtins.str location_name: Name of the location.
        :param _builtins.str multi_cdn_location_id: Unique identifier of the multi CDN location.
        :param Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgs'] traffic_types: List of traffic types for the location.
        """
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "location_name", location_name)
        pulumi.set(__self__, "multi_cdn_location_id", multi_cdn_location_id)
        if traffic_types is not None:
            pulumi.set(__self__, "traffic_types", traffic_types)

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.int:
        """
        Unique identifier of the location.
        """
        return pulumi.get(self, "location_id")

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        Name of the location.
        """
        return pulumi.get(self, "location_name")

    @_builtins.property
    @pulumi.getter(name="multiCdnLocationId")
    def multi_cdn_location_id(self) -> _builtins.str:
        """
        Unique identifier of the multi CDN location.
        """
        return pulumi.get(self, "multi_cdn_location_id")

    @_builtins.property
    @pulumi.getter(name="trafficTypes")
    def traffic_types(self) -> Optional[Sequence['outputs.GetCloudwrapperLocationsLocationTrafficTypeResult']]:
        """
        List of traffic types for the location.
        """
        return pulumi.get(self, "traffic_types")


@pulumi.output_type
class GetCloudwrapperLocationsLocationTrafficTypeResult(dict):
    def __init__(__self__, *,
                 location_id: _builtins.str,
                 traffic_type: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param _builtins.str location_id: Represents the failover map.
        :param _builtins.str traffic_type: Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "traffic_type", traffic_type)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.str:
        """
        Represents the failover map.
        """
        return pulumi.get(self, "location_id")

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> _builtins.str:
        """
        Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
        """
        return pulumi.get(self, "traffic_type")

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")


@pulumi.output_type
class GetCloudwrapperPropertiesPropertyResult(dict):
    def __init__(__self__, *,
                 contract_id: _builtins.str,
                 group_id: _builtins.int,
                 property_id: _builtins.int,
                 property_name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str contract_id: Contract ID having Cloud Wrapper entitlement.
        :param _builtins.int group_id: ID of the group which the property belongs to.
        :param _builtins.int property_id: Property ID of the property.
        :param _builtins.str property_name: Name of the property belonging to the origin.
        :param _builtins.str type: The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
        """
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        ID of the group which the property belongs to.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property.
        """
        return pulumi.get(self, "property_id")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        """
        Name of the property belonging to the origin.
        """
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetContractsContractResult(dict):
    def __init__(__self__, *,
                 contract_id: _builtins.str,
                 contract_type_name: _builtins.str):
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "contract_type_name", contract_type_name)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="contractTypeName")
    def contract_type_name(self) -> _builtins.str:
        return pulumi.get(self, "contract_type_name")


@pulumi.output_type
class GetCpCodesCpCodeResult(dict):
    def __init__(__self__, *,
                 cp_code_id: _builtins.str,
                 created_date: _builtins.str,
                 name: _builtins.str,
                 product_ids: Sequence[_builtins.str]):
        """
        :param _builtins.str cp_code_id: The ID of a specific CP code.
        :param _builtins.str created_date: The date and time when the CP code was created.
        :param _builtins.str name: Name of the CP code.
        :param Sequence[_builtins.str] product_ids: A list of of product IDs for a given CP code.
        """
        pulumi.set(__self__, "cp_code_id", cp_code_id)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product_ids", product_ids)

    @_builtins.property
    @pulumi.getter(name="cpCodeId")
    def cp_code_id(self) -> _builtins.str:
        """
        The ID of a specific CP code.
        """
        return pulumi.get(self, "cp_code_id")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        The date and time when the CP code was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the CP code.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productIds")
    def product_ids(self) -> Sequence[_builtins.str]:
        """
        A list of of product IDs for a given CP code.
        """
        return pulumi.get(self, "product_ids")


@pulumi.output_type
class GetDatastreamActivationHistoryActivationResult(dict):
    def __init__(__self__, *,
                 modified_by: _builtins.str,
                 modified_date: _builtins.str,
                 status: _builtins.str,
                 stream_id: _builtins.int,
                 stream_version: _builtins.int):
        """
        :param _builtins.str modified_by: The username who activated or deactivated the stream
        :param _builtins.str modified_date: The date and time when activation status was modified
        :param _builtins.str status: Stream Status
        :param _builtins.int stream_id: Identifies the stream
        :param _builtins.int stream_version: Identifies the version of the stream
        """
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_date", modified_date)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "stream_version", stream_version)

    @_builtins.property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> _builtins.str:
        """
        The username who activated or deactivated the stream
        """
        return pulumi.get(self, "modified_by")

    @_builtins.property
    @pulumi.getter(name="modifiedDate")
    def modified_date(self) -> _builtins.str:
        """
        The date and time when activation status was modified
        """
        return pulumi.get(self, "modified_date")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Stream Status
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.int:
        """
        Identifies the stream
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamVersion")
    def stream_version(self) -> _builtins.int:
        """
        Identifies the version of the stream
        """
        return pulumi.get(self, "stream_version")


@pulumi.output_type
class GetDatastreamDatasetFieldsDatasetFieldResult(dict):
    def __init__(__self__, *,
                 dataset_field_description: _builtins.str,
                 dataset_field_group: _builtins.str,
                 dataset_field_id: _builtins.int,
                 dataset_field_json_key: _builtins.str,
                 dataset_field_name: _builtins.str):
        """
        :param _builtins.str dataset_field_description: Describes the data set field
        :param _builtins.str dataset_field_group: A name of the group for data set field
        :param _builtins.int dataset_field_id: Identifies the field
        :param _builtins.str dataset_field_json_key: Specifies the JSON key for the field in a log line
        :param _builtins.str dataset_field_name: A name of the data set field
        """
        pulumi.set(__self__, "dataset_field_description", dataset_field_description)
        pulumi.set(__self__, "dataset_field_group", dataset_field_group)
        pulumi.set(__self__, "dataset_field_id", dataset_field_id)
        pulumi.set(__self__, "dataset_field_json_key", dataset_field_json_key)
        pulumi.set(__self__, "dataset_field_name", dataset_field_name)

    @_builtins.property
    @pulumi.getter(name="datasetFieldDescription")
    def dataset_field_description(self) -> _builtins.str:
        """
        Describes the data set field
        """
        return pulumi.get(self, "dataset_field_description")

    @_builtins.property
    @pulumi.getter(name="datasetFieldGroup")
    def dataset_field_group(self) -> _builtins.str:
        """
        A name of the group for data set field
        """
        return pulumi.get(self, "dataset_field_group")

    @_builtins.property
    @pulumi.getter(name="datasetFieldId")
    def dataset_field_id(self) -> _builtins.int:
        """
        Identifies the field
        """
        return pulumi.get(self, "dataset_field_id")

    @_builtins.property
    @pulumi.getter(name="datasetFieldJsonKey")
    def dataset_field_json_key(self) -> _builtins.str:
        """
        Specifies the JSON key for the field in a log line
        """
        return pulumi.get(self, "dataset_field_json_key")

    @_builtins.property
    @pulumi.getter(name="datasetFieldName")
    def dataset_field_name(self) -> _builtins.str:
        """
        A name of the data set field
        """
        return pulumi.get(self, "dataset_field_name")


@pulumi.output_type
class GetDatastreamsStreamsDetailResult(dict):
    def __init__(__self__, *,
                 contract_id: _builtins.str,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 group_id: _builtins.int,
                 latest_version: _builtins.int,
                 modified_by: _builtins.str,
                 modified_date: _builtins.str,
                 product_id: _builtins.str,
                 properties: Sequence['outputs.GetDatastreamsStreamsDetailPropertyResult'],
                 stream_id: _builtins.int,
                 stream_name: _builtins.str,
                 stream_status: _builtins.str,
                 stream_version: _builtins.int):
        """
        :param _builtins.str contract_id: Identifies the contract that the stream is associated with.
        :param _builtins.str created_by: The username who created the stream.
        :param _builtins.str created_date: The date and time when the stream was created.
        :param _builtins.int group_id: Identifies the group where the stream is created.
        :param _builtins.int latest_version: Identifies the latestVersion version of the stream.
        :param _builtins.str modified_by: The username who activated or deactivated the stream
        :param _builtins.str modified_date: The date and time when activation status was modified
        :param _builtins.str product_id: The productId.
        :param Sequence['GetDatastreamsStreamsDetailPropertyArgs'] properties: List of properties associated with the stream.
        :param _builtins.int stream_id: Identifies the stream.
        :param _builtins.str stream_name: The name of the stream.
        :param _builtins.str stream_status: The activation status of the stream.
        :param _builtins.int stream_version: Identifies the current version of the stream.
        """
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_date", modified_date)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "stream_name", stream_name)
        pulumi.set(__self__, "stream_status", stream_status)
        pulumi.set(__self__, "stream_version", stream_version)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Identifies the contract that the stream is associated with.
        """
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the stream.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        The date and time when the stream was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        Identifies the group where the stream is created.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.int:
        """
        Identifies the latestVersion version of the stream.
        """
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> _builtins.str:
        """
        The username who activated or deactivated the stream
        """
        return pulumi.get(self, "modified_by")

    @_builtins.property
    @pulumi.getter(name="modifiedDate")
    def modified_date(self) -> _builtins.str:
        """
        The date and time when activation status was modified
        """
        return pulumi.get(self, "modified_date")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        The productId.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetDatastreamsStreamsDetailPropertyResult']:
        """
        List of properties associated with the stream.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.int:
        """
        Identifies the stream.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter(name="streamStatus")
    def stream_status(self) -> _builtins.str:
        """
        The activation status of the stream.
        """
        return pulumi.get(self, "stream_status")

    @_builtins.property
    @pulumi.getter(name="streamVersion")
    def stream_version(self) -> _builtins.int:
        """
        Identifies the current version of the stream.
        """
        return pulumi.get(self, "stream_version")


@pulumi.output_type
class GetDatastreamsStreamsDetailPropertyResult(dict):
    def __init__(__self__, *,
                 property_id: _builtins.int,
                 property_name: _builtins.str):
        """
        :param _builtins.int property_id: The identifier of the property.
        :param _builtins.str property_name: The descriptive label for the property.
        """
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        The identifier of the property.
        """
        return pulumi.get(self, "property_id")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        """
        The descriptive label for the property.
        """
        return pulumi.get(self, "property_name")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 contract_ids: Sequence[_builtins.str],
                 group_id: _builtins.str,
                 group_name: _builtins.str,
                 parent_group_id: _builtins.str):
        pulumi.set(__self__, "contract_ids", contract_ids)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "parent_group_id", parent_group_id)

    @_builtins.property
    @pulumi.getter(name="contractIds")
    def contract_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "contract_ids")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> _builtins.str:
        return pulumi.get(self, "parent_group_id")


@pulumi.output_type
class GetGtmAsmapAssignmentResult(dict):
    def __init__(__self__, *,
                 as_numbers: Sequence[_builtins.int],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.int] as_numbers: Specifies an array of AS numbers.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> Sequence[_builtins.int]:
        """
        Specifies an array of AS numbers.
        """
        return pulumi.get(self, "as_numbers")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmAsmapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other AS zones
        :param _builtins.str nickname: A descriptive label for all other AS zones
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other AS zones
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmAsmapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmCidrmapAssignmentResult(dict):
    def __init__(__self__, *,
                 blocks: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] blocks: Specifies an array of CIDR blocks.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the CIDR zone group.
        """
        pulumi.set(__self__, "blocks", blocks)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of CIDR blocks.
        """
        return pulumi.get(self, "blocks")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the CIDR zone group.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmCidrmapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other CIDR zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other CIDR blocks.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other CIDR blocks.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmCidrmapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDatacenterDefaultLoadObjectResult(dict):
    def __init__(__self__, *,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str load_object: Specifies the load object that GTM requests.
        :param _builtins.int load_object_port: Specifies the TCP port to connect to when requesting the load object.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        """
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Specifies the load object that GTM requests.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")


@pulumi.output_type
class GetGtmDatacenterLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDatacentersDatacenterResult(dict):
    def __init__(__self__, *,
                 city: _builtins.str,
                 clone_of: _builtins.int,
                 cloud_server_host_header_override: _builtins.bool,
                 cloud_server_targeting: _builtins.bool,
                 continent: _builtins.str,
                 country: _builtins.str,
                 datacenter_id: _builtins.int,
                 default_load_objects: Sequence['outputs.GetGtmDatacentersDatacenterDefaultLoadObjectResult'],
                 latitude: _builtins.float,
                 links: Sequence['outputs.GetGtmDatacentersDatacenterLinkResult'],
                 longitude: _builtins.float,
                 nickname: _builtins.str,
                 score_penalty: _builtins.int,
                 servermonitor_pool: _builtins.str,
                 state_or_province: _builtins.str,
                 virtual: _builtins.bool):
        """
        :param _builtins.str city: The name of the city where the data center is located.
        :param _builtins.int clone_of: Identifies the data center's ID of which this data center is a clone.
        :param _builtins.bool cloud_server_host_header_override: Balances load between two or more servers in a cloud environment.
        :param _builtins.bool cloud_server_targeting: Balances load between two or more servers in a cloud environment.
        :param _builtins.str continent: A two-letter code that specifies the continent where the data center maps to.
        :param _builtins.str country: A two-letter ISO 3166 country code that specifies the country where the data center is located.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param Sequence['GetGtmDatacentersDatacenterDefaultLoadObjectArgs'] default_load_objects: Specifies the load reporting interface between you and the GTM system.
        :param _builtins.float latitude: Specifies the geographic latitude of the data center's position.
        :param Sequence['GetGtmDatacentersDatacenterLinkArgs'] links: Provides a URL path that allows direct navigation to a data center.
        :param _builtins.float longitude: Specifies the geographic longitude of the data center's position.
        :param _builtins.str nickname: A descriptive label for the datacenter.
        :param _builtins.int score_penalty: Influences the score for a datacenter.
        :param _builtins.str servermonitor_pool: The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.)
        :param _builtins.str state_or_province: Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        :param _builtins.bool virtual: Indicates whether or not the data center is virtual or physical.
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "clone_of", clone_of)
        pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "default_load_objects", default_load_objects)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "nickname", nickname)
        pulumi.set(__self__, "score_penalty", score_penalty)
        pulumi.set(__self__, "servermonitor_pool", servermonitor_pool)
        pulumi.set(__self__, "state_or_province", state_or_province)
        pulumi.set(__self__, "virtual", virtual)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The name of the city where the data center is located.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="cloneOf")
    def clone_of(self) -> _builtins.int:
        """
        Identifies the data center's ID of which this data center is a clone.
        """
        return pulumi.get(self, "clone_of")

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @_builtins.property
    @pulumi.getter(name="cloudServerTargeting")
    def cloud_server_targeting(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_targeting")

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        A two-letter code that specifies the continent where the data center maps to.
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        A two-letter ISO 3166 country code that specifies the country where the data center is located.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter(name="defaultLoadObjects")
    def default_load_objects(self) -> Sequence['outputs.GetGtmDatacentersDatacenterDefaultLoadObjectResult']:
        """
        Specifies the load reporting interface between you and the GTM system.
        """
        return pulumi.get(self, "default_load_objects")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        Specifies the geographic latitude of the data center's position.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetGtmDatacentersDatacenterLinkResult']:
        """
        Provides a URL path that allows direct navigation to a data center.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        Specifies the geographic longitude of the data center's position.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the datacenter.
        """
        return pulumi.get(self, "nickname")

    @_builtins.property
    @pulumi.getter(name="scorePenalty")
    def score_penalty(self) -> _builtins.int:
        """
        Influences the score for a datacenter.
        """
        return pulumi.get(self, "score_penalty")

    @_builtins.property
    @pulumi.getter(name="servermonitorPool")
    def servermonitor_pool(self) -> _builtins.str:
        """
        The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.)
        """
        return pulumi.get(self, "servermonitor_pool")

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> _builtins.str:
        """
        Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        """
        return pulumi.get(self, "state_or_province")

    @_builtins.property
    @pulumi.getter
    def virtual(self) -> _builtins.bool:
        """
        Indicates whether or not the data center is virtual or physical.
        """
        return pulumi.get(self, "virtual")


@pulumi.output_type
class GetGtmDatacentersDatacenterDefaultLoadObjectResult(dict):
    def __init__(__self__, *,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str load_object: Specifies the load object that GTM requests.
        :param _builtins.int load_object_port: Specifies the TCP port to connect to when requesting the load object.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        """
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Specifies the load object that GTM requests.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")


@pulumi.output_type
class GetGtmDatacentersDatacenterLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainAsMapResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['outputs.GetGtmDomainAsMapAssignmentResult']] = None,
                 default_datacenter: Optional['outputs.GetGtmDomainAsMapDefaultDatacenterResult'] = None,
                 links: Optional[Sequence['outputs.GetGtmDomainAsMapLinkResult']] = None):
        """
        :param _builtins.str name: A descriptive label for the AS map.
        :param Sequence['GetGtmDomainAsMapAssignmentArgs'] assignments: Contains information about the AS zone groupings of AS IDs.
        :param 'GetGtmDomainAsMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other AS zones, AS IDs not found in these AS zones.
        :param Sequence['GetGtmDomainAsMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the As map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the AS map.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['outputs.GetGtmDomainAsMapAssignmentResult']]:
        """
        Contains information about the AS zone groupings of AS IDs.
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['outputs.GetGtmDomainAsMapDefaultDatacenterResult']:
        """
        A placeholder for all other AS zones, AS IDs not found in these AS zones.
        """
        return pulumi.get(self, "default_datacenter")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainAsMapLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the As map.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainAsMapAssignmentResult(dict):
    def __init__(__self__, *,
                 as_numbers: Sequence[_builtins.int],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.int] as_numbers: Specifies an array of AS numbers.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> Sequence[_builtins.int]:
        """
        Specifies an array of AS numbers.
        """
        return pulumi.get(self, "as_numbers")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainAsMapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other AS zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other AS zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainAsMapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainCidrMapResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['outputs.GetGtmDomainCidrMapAssignmentResult']] = None,
                 default_datacenter: Optional['outputs.GetGtmDomainCidrMapDefaultDatacenterResult'] = None,
                 links: Optional[Sequence['outputs.GetGtmDomainCidrMapLinkResult']] = None):
        """
        :param _builtins.str name: Unique name for the CIDR map.
        :param Sequence['GetGtmDomainCidrMapAssignmentArgs'] assignments: Contains information about the CIDR zone groupings of CIDR blocks.
        :param 'GetGtmDomainCidrMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
        :param Sequence['GetGtmDomainCidrMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the CIDR map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for the CIDR map.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['outputs.GetGtmDomainCidrMapAssignmentResult']]:
        """
        Contains information about the CIDR zone groupings of CIDR blocks.
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['outputs.GetGtmDomainCidrMapDefaultDatacenterResult']:
        """
        A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
        """
        return pulumi.get(self, "default_datacenter")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainCidrMapLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the CIDR map.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainCidrMapAssignmentResult(dict):
    def __init__(__self__, *,
                 blocks: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] blocks: Specifies an array of CIDR blocks.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "blocks", blocks)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of CIDR blocks.
        """
        return pulumi.get(self, "blocks")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainCidrMapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other CIDR zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other CIDR blocks.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other CIDR blocks.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainCidrMapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainDatacenterResult(dict):
    def __init__(__self__, *,
                 city: _builtins.str,
                 clone_of: _builtins.int,
                 cloud_server_host_header_override: _builtins.bool,
                 cloud_server_targeting: _builtins.bool,
                 continent: _builtins.str,
                 country: _builtins.str,
                 datacenter_id: _builtins.int,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 nickname: _builtins.str,
                 score_penalty: _builtins.int,
                 server_monitor_pool: _builtins.str,
                 state_or_province: _builtins.str,
                 virtual: _builtins.bool,
                 default_load_objects: Optional[Sequence['outputs.GetGtmDomainDatacenterDefaultLoadObjectResult']] = None,
                 links: Optional[Sequence['outputs.GetGtmDomainDatacenterLinkResult']] = None):
        """
        :param _builtins.str city: The name of the city where the data center is located.
        :param _builtins.int clone_of: Identifies the data center's ID of which this data center is a clone.
        :param _builtins.bool cloud_server_host_header_override: Balances load between two or more servers in a cloud environment.
        :param _builtins.bool cloud_server_targeting: Balances load between two or more servers in a cloud environment.
        :param _builtins.str continent: A two-letter code that specifies the continent where the data center maps to.
        :param _builtins.str country: A two-letter ISO 3166 country code that specifies the country where the data center is located.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.float latitude: Specifies the geographic latitude of the data center's position.
        :param _builtins.float longitude: Specifies the geographic longitude of the data center's position.
        :param _builtins.str nickname: A descriptive label for the datacenter.
        :param _builtins.int score_penalty: Influences the score for a datacenter.
        :param _builtins.str server_monitor_pool: The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
        :param _builtins.str state_or_province: Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        :param _builtins.bool virtual: Indicates whether or not the data center is virtual or physical.
        :param Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgs'] default_load_objects: Specifies the load reporting interface between you and the GTM system.
        :param Sequence['GetGtmDomainDatacenterLinkArgs'] links: Provides a URL path that allows direct navigation to a data center.
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "clone_of", clone_of)
        pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "nickname", nickname)
        pulumi.set(__self__, "score_penalty", score_penalty)
        pulumi.set(__self__, "server_monitor_pool", server_monitor_pool)
        pulumi.set(__self__, "state_or_province", state_or_province)
        pulumi.set(__self__, "virtual", virtual)
        if default_load_objects is not None:
            pulumi.set(__self__, "default_load_objects", default_load_objects)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The name of the city where the data center is located.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="cloneOf")
    def clone_of(self) -> _builtins.int:
        """
        Identifies the data center's ID of which this data center is a clone.
        """
        return pulumi.get(self, "clone_of")

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @_builtins.property
    @pulumi.getter(name="cloudServerTargeting")
    def cloud_server_targeting(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_targeting")

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        A two-letter code that specifies the continent where the data center maps to.
        """
        return pulumi.get(self, "continent")

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        A two-letter ISO 3166 country code that specifies the country where the data center is located.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        Specifies the geographic latitude of the data center's position.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        Specifies the geographic longitude of the data center's position.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the datacenter.
        """
        return pulumi.get(self, "nickname")

    @_builtins.property
    @pulumi.getter(name="scorePenalty")
    def score_penalty(self) -> _builtins.int:
        """
        Influences the score for a datacenter.
        """
        return pulumi.get(self, "score_penalty")

    @_builtins.property
    @pulumi.getter(name="serverMonitorPool")
    def server_monitor_pool(self) -> _builtins.str:
        """
        The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
        """
        return pulumi.get(self, "server_monitor_pool")

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> _builtins.str:
        """
        Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        """
        return pulumi.get(self, "state_or_province")

    @_builtins.property
    @pulumi.getter
    def virtual(self) -> _builtins.bool:
        """
        Indicates whether or not the data center is virtual or physical.
        """
        return pulumi.get(self, "virtual")

    @_builtins.property
    @pulumi.getter(name="defaultLoadObjects")
    def default_load_objects(self) -> Optional[Sequence['outputs.GetGtmDomainDatacenterDefaultLoadObjectResult']]:
        """
        Specifies the load reporting interface between you and the GTM system.
        """
        return pulumi.get(self, "default_load_objects")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainDatacenterLinkResult']]:
        """
        Provides a URL path that allows direct navigation to a data center.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainDatacenterDefaultLoadObjectResult(dict):
    def __init__(__self__, *,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str load_object: Specifies the load object that GTM requests.
        :param _builtins.int load_object_port: Specifies the TCP port to connect to when requesting the load object.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        """
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Specifies the load object that GTM requests.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")


@pulumi.output_type
class GetGtmDomainDatacenterLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainGeographicMapResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['outputs.GetGtmDomainGeographicMapAssignmentResult']] = None,
                 default_datacenter: Optional['outputs.GetGtmDomainGeographicMapDefaultDatacenterResult'] = None,
                 links: Optional[Sequence['outputs.GetGtmDomainGeographicMapLinkResult']] = None):
        """
        :param _builtins.str name: A descriptive label for the geographic map.
        :param Sequence['GetGtmDomainGeographicMapAssignmentArgs'] assignments: Contains information about the geographic zone groupings of countries.
        :param 'GetGtmDomainGeographicMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other geographic zones, countries not found in these geographic zones.
        :param Sequence['GetGtmDomainGeographicMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the geographic map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the geographic map.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['outputs.GetGtmDomainGeographicMapAssignmentResult']]:
        """
        Contains information about the geographic zone groupings of countries.
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['outputs.GetGtmDomainGeographicMapDefaultDatacenterResult']:
        """
        A placeholder for all other geographic zones, countries not found in these geographic zones.
        """
        return pulumi.get(self, "default_datacenter")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainGeographicMapLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the geographic map.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainGeographicMapAssignmentResult(dict):
    def __init__(__self__, *,
                 countries: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] countries: Specifies an array of two-letter ISO 3166 `country` codes.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "countries", countries)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of two-letter ISO 3166 `country` codes.
        """
        return pulumi.get(self, "countries")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainGeographicMapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: An identifier for all other geographic zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other geographic zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        An identifier for all other geographic zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other geographic zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmDomainGeographicMapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainPropertyResult(dict):
    def __init__(__self__, *,
                 backup_cname: _builtins.str,
                 backup_ip: _builtins.str,
                 balance_by_download_score: _builtins.bool,
                 cname: _builtins.str,
                 comments: _builtins.str,
                 dynamic_ttl: _builtins.int,
                 failback_delay: _builtins.int,
                 failover_delay: _builtins.int,
                 ghost_demand_reporting: _builtins.bool,
                 handout_limit: _builtins.int,
                 handout_mode: _builtins.str,
                 health_max: _builtins.float,
                 health_multiplier: _builtins.float,
                 health_threshold: _builtins.float,
                 ipv6: _builtins.bool,
                 last_modified: _builtins.str,
                 load_imbalance_percentage: _builtins.float,
                 map_name: _builtins.str,
                 max_unreachable_penalty: _builtins.int,
                 min_live_fraction: _builtins.float,
                 name: _builtins.str,
                 score_aggregation_type: _builtins.str,
                 static_ttl: _builtins.int,
                 stickness_bonus_constant: _builtins.int,
                 stickness_bonus_percentage: _builtins.int,
                 type: _builtins.str,
                 unreachable_threshold: _builtins.float,
                 use_computed_targets: _builtins.bool,
                 weighted_hash_bits_for_ipv4: _builtins.int,
                 weighted_hash_bits_for_ipv6: _builtins.int,
                 links: Optional[Sequence['outputs.GetGtmDomainPropertyLinkResult']] = None,
                 liveness_tests: Optional[Sequence['outputs.GetGtmDomainPropertyLivenessTestResult']] = None,
                 static_rr_sets: Optional[Sequence['outputs.GetGtmDomainPropertyStaticRrSetResult']] = None,
                 traffic_targets: Optional[Sequence['outputs.GetGtmDomainPropertyTrafficTargetResult']] = None):
        """
        :param _builtins.str backup_cname: Specifies a backup CNAME.
        :param _builtins.str backup_ip: Specifies a backup IP.
        :param _builtins.bool balance_by_download_score: Indicates whether download score based load balancing is enabled.
        :param _builtins.str cname: Indicates the fully qualified name aliased to a particular property.
        :param _builtins.str comments: Descriptive comments for the property.
        :param _builtins.int dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        :param _builtins.int failback_delay: Specifies the failback delay in seconds.
        :param _builtins.int failover_delay: Specifies the failover delay in seconds.
        :param _builtins.bool ghost_demand_reporting: Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        :param _builtins.int handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param _builtins.str handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param _builtins.float health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param _builtins.float health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param _builtins.float health_threshold: Configures a cutoff value that is computed from the median scores.
        :param _builtins.bool ipv6: Indicates the type of IP address handed out by a property.
        :param _builtins.str last_modified: An ISO 8601 timestamp that indicates when the property was last changed.
        :param _builtins.float load_imbalance_percentage: Indicates the percent of load imbalance factor for the domain.
        :param _builtins.str map_name: A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        :param _builtins.int max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param _builtins.float min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param _builtins.str name: A descriptive label for the property.
        :param _builtins.str score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param _builtins.int static_ttl: Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        :param _builtins.int stickness_bonus_constant: Specifies a percentage used to configure data center affinity.
        :param _builtins.int stickness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param _builtins.str type: Specifies the load balancing behvior for the property.
        :param _builtins.float unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param _builtins.bool use_computed_targets: For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        :param _builtins.int weighted_hash_bits_for_ipv4: For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        :param _builtins.int weighted_hash_bits_for_ipv6: For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        :param Sequence['GetGtmDomainPropertyLinkArgs'] links: Provides a URL path that allows direct navigation to the property.
        :param Sequence['GetGtmDomainPropertyLivenessTestArgs'] liveness_tests: Contains information about liveness tests.
        :param Sequence['GetGtmDomainPropertyStaticRrSetArgs'] static_rr_sets: Contains static recordsets.
        :param Sequence['GetGtmDomainPropertyTrafficTargetArgs'] traffic_targets: Traffic targets for the property.
        """
        pulumi.set(__self__, "backup_cname", backup_cname)
        pulumi.set(__self__, "backup_ip", backup_ip)
        pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        pulumi.set(__self__, "failback_delay", failback_delay)
        pulumi.set(__self__, "failover_delay", failover_delay)
        pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        pulumi.set(__self__, "handout_limit", handout_limit)
        pulumi.set(__self__, "handout_mode", handout_mode)
        pulumi.set(__self__, "health_max", health_max)
        pulumi.set(__self__, "health_multiplier", health_multiplier)
        pulumi.set(__self__, "health_threshold", health_threshold)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        pulumi.set(__self__, "static_ttl", static_ttl)
        pulumi.set(__self__, "stickness_bonus_constant", stickness_bonus_constant)
        pulumi.set(__self__, "stickness_bonus_percentage", stickness_bonus_percentage)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        pulumi.set(__self__, "weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
        pulumi.set(__self__, "weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)

    @_builtins.property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> _builtins.str:
        """
        Specifies a backup CNAME.
        """
        return pulumi.get(self, "backup_cname")

    @_builtins.property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> _builtins.str:
        """
        Specifies a backup IP.
        """
        return pulumi.get(self, "backup_ip")

    @_builtins.property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> _builtins.bool:
        """
        Indicates whether download score based load balancing is enabled.
        """
        return pulumi.get(self, "balance_by_download_score")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Descriptive comments for the property.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> _builtins.int:
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        """
        return pulumi.get(self, "dynamic_ttl")

    @_builtins.property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> _builtins.int:
        """
        Specifies the failback delay in seconds.
        """
        return pulumi.get(self, "failback_delay")

    @_builtins.property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> _builtins.int:
        """
        Specifies the failover delay in seconds.
        """
        return pulumi.get(self, "failover_delay")

    @_builtins.property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> _builtins.bool:
        """
        Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        """
        return pulumi.get(self, "ghost_demand_reporting")

    @_builtins.property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> _builtins.int:
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        return pulumi.get(self, "handout_limit")

    @_builtins.property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> _builtins.str:
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        return pulumi.get(self, "handout_mode")

    @_builtins.property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> _builtins.float:
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        return pulumi.get(self, "health_max")

    @_builtins.property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> _builtins.float:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_multiplier")

    @_builtins.property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> _builtins.float:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_threshold")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        Indicates the type of IP address handed out by a property.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> _builtins.str:
        """
        An ISO 8601 timestamp that indicates when the property was last changed.
        """
        return pulumi.get(self, "last_modified")

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        """
        return pulumi.get(self, "map_name")

    @_builtins.property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> _builtins.int:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        return pulumi.get(self, "max_unreachable_penalty")

    @_builtins.property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> _builtins.float:
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        return pulumi.get(self, "min_live_fraction")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        return pulumi.get(self, "score_aggregation_type")

    @_builtins.property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> _builtins.int:
        """
        Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        """
        return pulumi.get(self, "static_ttl")

    @_builtins.property
    @pulumi.getter(name="sticknessBonusConstant")
    def stickness_bonus_constant(self) -> _builtins.int:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickness_bonus_constant")

    @_builtins.property
    @pulumi.getter(name="sticknessBonusPercentage")
    def stickness_bonus_percentage(self) -> _builtins.int:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickness_bonus_percentage")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the load balancing behvior for the property.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> _builtins.float:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        return pulumi.get(self, "unreachable_threshold")

    @_builtins.property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> _builtins.bool:
        """
        For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        """
        return pulumi.get(self, "use_computed_targets")

    @_builtins.property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> _builtins.int:
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        """
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @_builtins.property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> _builtins.int:
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        """
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainPropertyLinkResult']]:
        """
        Provides a URL path that allows direct navigation to the property.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[Sequence['outputs.GetGtmDomainPropertyLivenessTestResult']]:
        """
        Contains information about liveness tests.
        """
        return pulumi.get(self, "liveness_tests")

    @_builtins.property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[Sequence['outputs.GetGtmDomainPropertyStaticRrSetResult']]:
        """
        Contains static recordsets.
        """
        return pulumi.get(self, "static_rr_sets")

    @_builtins.property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[Sequence['outputs.GetGtmDomainPropertyTrafficTargetResult']]:
        """
        Traffic targets for the property.
        """
        return pulumi.get(self, "traffic_targets")


@pulumi.output_type
class GetGtmDomainPropertyLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainPropertyLivenessTestResult(dict):
    def __init__(__self__, *,
                 alternate_ca_certificates: Sequence[_builtins.str],
                 answers_required: _builtins.bool,
                 disable_nonstandard_port_warning: _builtins.bool,
                 disabled: _builtins.bool,
                 error_penalty: _builtins.float,
                 http_error3xx: _builtins.bool,
                 http_error4xx: _builtins.bool,
                 http_error5xx: _builtins.bool,
                 http_method: _builtins.str,
                 http_request_body: _builtins.str,
                 name: _builtins.str,
                 peer_certificate_verification: _builtins.bool,
                 pre2023_security_posture: _builtins.bool,
                 recursion_requested: _builtins.bool,
                 request_string: _builtins.str,
                 resource_type: _builtins.str,
                 response_string: _builtins.str,
                 ssl_client_certificate: _builtins.str,
                 ssl_client_private_key: _builtins.str,
                 test_interval: _builtins.int,
                 test_object: _builtins.str,
                 test_object_password: _builtins.str,
                 test_object_port: _builtins.int,
                 test_object_protocol: _builtins.str,
                 test_object_username: _builtins.str,
                 test_timeout: _builtins.float,
                 timeout_penalty: _builtins.float,
                 http_headers: Optional[Sequence['outputs.GetGtmDomainPropertyLivenessTestHttpHeaderResult']] = None):
        """
        :param Sequence[_builtins.str] alternate_ca_certificates: List of alternate trust anchors (CA certificates)
        :param _builtins.bool answers_required: If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
        :param _builtins.bool disable_nonstandard_port_warning: Disables warnings when non-standard ports are used.
        :param _builtins.bool disabled: Disables the liveness test.
        :param _builtins.float error_penalty: Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        :param _builtins.bool http_error3xx: Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.bool http_error4xx: Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.bool http_error5xx: Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.str http_method: Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
        :param _builtins.str http_request_body: Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
        :param _builtins.str name: A descriptive name for the liveness test.
        :param _builtins.bool peer_certificate_verification: Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
        :param _builtins.bool pre2023_security_posture: Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        :param _builtins.bool recursion_requested: Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
        :param _builtins.str request_string: Specifies a request string.
        :param _builtins.str resource_type: Specifies the query type, if testObjectProtocol is DNS.
        :param _builtins.str response_string: Specifies a response string.
        :param _builtins.str ssl_client_certificate: Indicates a base64-encoded certificate.
        :param _builtins.str ssl_client_private_key: Indicates a base64-encoded private key.
        :param _builtins.int test_interval: Indicates the interval at which the liveness test is run, in seconds.
        :param _builtins.str test_object: Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        :param _builtins.str test_object_password: Specifies the test object's password.
        :param _builtins.int test_object_port: Specifies the port number for the testObject.
        :param _builtins.str test_object_protocol: Specifies the test protocol.
        :param _builtins.str test_object_username: A descriptive name for the testObject.
        :param _builtins.float test_timeout: Specifies the duration of the liveness test before it fails.
        :param _builtins.float timeout_penalty: Specifies the timeout penalty score.
        :param Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgs'] http_headers: List of HTTP headers for the liveness test.
        """
        pulumi.set(__self__, "alternate_ca_certificates", alternate_ca_certificates)
        pulumi.set(__self__, "answers_required", answers_required)
        pulumi.set(__self__, "disable_nonstandard_port_warning", disable_nonstandard_port_warning)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "error_penalty", error_penalty)
        pulumi.set(__self__, "http_error3xx", http_error3xx)
        pulumi.set(__self__, "http_error4xx", http_error4xx)
        pulumi.set(__self__, "http_error5xx", http_error5xx)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "http_request_body", http_request_body)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        pulumi.set(__self__, "pre2023_security_posture", pre2023_security_posture)
        pulumi.set(__self__, "recursion_requested", recursion_requested)
        pulumi.set(__self__, "request_string", request_string)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "response_string", response_string)
        pulumi.set(__self__, "ssl_client_certificate", ssl_client_certificate)
        pulumi.set(__self__, "ssl_client_private_key", ssl_client_private_key)
        pulumi.set(__self__, "test_interval", test_interval)
        pulumi.set(__self__, "test_object", test_object)
        pulumi.set(__self__, "test_object_password", test_object_password)
        pulumi.set(__self__, "test_object_port", test_object_port)
        pulumi.set(__self__, "test_object_protocol", test_object_protocol)
        pulumi.set(__self__, "test_object_username", test_object_username)
        pulumi.set(__self__, "test_timeout", test_timeout)
        pulumi.set(__self__, "timeout_penalty", timeout_penalty)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter(name="alternateCaCertificates")
    def alternate_ca_certificates(self) -> Sequence[_builtins.str]:
        """
        List of alternate trust anchors (CA certificates)
        """
        return pulumi.get(self, "alternate_ca_certificates")

    @_builtins.property
    @pulumi.getter(name="answersRequired")
    def answers_required(self) -> _builtins.bool:
        """
        If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
        """
        return pulumi.get(self, "answers_required")

    @_builtins.property
    @pulumi.getter(name="disableNonstandardPortWarning")
    def disable_nonstandard_port_warning(self) -> _builtins.bool:
        """
        Disables warnings when non-standard ports are used.
        """
        return pulumi.get(self, "disable_nonstandard_port_warning")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Disables the liveness test.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="errorPenalty")
    def error_penalty(self) -> _builtins.float:
        """
        Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        """
        return pulumi.get(self, "error_penalty")

    @_builtins.property
    @pulumi.getter(name="httpError3xx")
    def http_error3xx(self) -> _builtins.bool:
        """
        Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error3xx")

    @_builtins.property
    @pulumi.getter(name="httpError4xx")
    def http_error4xx(self) -> _builtins.bool:
        """
        Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error4xx")

    @_builtins.property
    @pulumi.getter(name="httpError5xx")
    def http_error5xx(self) -> _builtins.bool:
        """
        Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error5xx")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> _builtins.str:
        """
        Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="httpRequestBody")
    def http_request_body(self) -> _builtins.str:
        """
        Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
        """
        return pulumi.get(self, "http_request_body")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive name for the liveness test.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> _builtins.bool:
        """
        Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
        """
        return pulumi.get(self, "peer_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="pre2023SecurityPosture")
    def pre2023_security_posture(self) -> _builtins.bool:
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        return pulumi.get(self, "pre2023_security_posture")

    @_builtins.property
    @pulumi.getter(name="recursionRequested")
    def recursion_requested(self) -> _builtins.bool:
        """
        Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
        """
        return pulumi.get(self, "recursion_requested")

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> _builtins.str:
        """
        Specifies a request string.
        """
        return pulumi.get(self, "request_string")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Specifies the query type, if testObjectProtocol is DNS.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> _builtins.str:
        """
        Specifies a response string.
        """
        return pulumi.get(self, "response_string")

    @_builtins.property
    @pulumi.getter(name="sslClientCertificate")
    def ssl_client_certificate(self) -> _builtins.str:
        """
        Indicates a base64-encoded certificate.
        """
        return pulumi.get(self, "ssl_client_certificate")

    @_builtins.property
    @pulumi.getter(name="sslClientPrivateKey")
    def ssl_client_private_key(self) -> _builtins.str:
        """
        Indicates a base64-encoded private key.
        """
        return pulumi.get(self, "ssl_client_private_key")

    @_builtins.property
    @pulumi.getter(name="testInterval")
    def test_interval(self) -> _builtins.int:
        """
        Indicates the interval at which the liveness test is run, in seconds.
        """
        return pulumi.get(self, "test_interval")

    @_builtins.property
    @pulumi.getter(name="testObject")
    def test_object(self) -> _builtins.str:
        """
        Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        """
        return pulumi.get(self, "test_object")

    @_builtins.property
    @pulumi.getter(name="testObjectPassword")
    def test_object_password(self) -> _builtins.str:
        """
        Specifies the test object's password.
        """
        return pulumi.get(self, "test_object_password")

    @_builtins.property
    @pulumi.getter(name="testObjectPort")
    def test_object_port(self) -> _builtins.int:
        """
        Specifies the port number for the testObject.
        """
        return pulumi.get(self, "test_object_port")

    @_builtins.property
    @pulumi.getter(name="testObjectProtocol")
    def test_object_protocol(self) -> _builtins.str:
        """
        Specifies the test protocol.
        """
        return pulumi.get(self, "test_object_protocol")

    @_builtins.property
    @pulumi.getter(name="testObjectUsername")
    def test_object_username(self) -> _builtins.str:
        """
        A descriptive name for the testObject.
        """
        return pulumi.get(self, "test_object_username")

    @_builtins.property
    @pulumi.getter(name="testTimeout")
    def test_timeout(self) -> _builtins.float:
        """
        Specifies the duration of the liveness test before it fails.
        """
        return pulumi.get(self, "test_timeout")

    @_builtins.property
    @pulumi.getter(name="timeoutPenalty")
    def timeout_penalty(self) -> _builtins.float:
        """
        Specifies the timeout penalty score.
        """
        return pulumi.get(self, "timeout_penalty")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetGtmDomainPropertyLivenessTestHttpHeaderResult']]:
        """
        List of HTTP headers for the liveness test.
        """
        return pulumi.get(self, "http_headers")


@pulumi.output_type
class GetGtmDomainPropertyLivenessTestHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of the HTTP header.
        :param _builtins.str value: Value of the HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the HTTP header.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the HTTP header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGtmDomainPropertyStaticRrSetResult(dict):
    def __init__(__self__, *,
                 rdatas: Sequence[_builtins.str],
                 ttl: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] rdatas: An array of data strings, representing multiple records within a set.
        :param _builtins.int ttl: The number of seconds that this record should live in a resolver's cache before being refetched.
        :param _builtins.str type: The record type.
        """
        pulumi.set(__self__, "rdatas", rdatas)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def rdatas(self) -> Sequence[_builtins.str]:
        """
        An array of data strings, representing multiple records within a set.
        """
        return pulumi.get(self, "rdatas")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The number of seconds that this record should live in a resolver's cache before being refetched.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The record type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGtmDomainPropertyTrafficTargetResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 enabled: _builtins.bool,
                 handout_cname: _builtins.str,
                 name: _builtins.str,
                 precedence: _builtins.int,
                 servers: Sequence[_builtins.str],
                 weight: _builtins.float):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.bool enabled: Indicates whether the traffic target is used.
        :param _builtins.str handout_cname: Specifies an optional data center for the property.
        :param _builtins.str name: An alternative label for the traffic target.
        :param _builtins.int precedence: Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
        :param Sequence[_builtins.str] servers: Identifies the IP address or the hostnames of the servers.
        :param _builtins.float weight: Specifies the traffic target weight for the target.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "handout_cname", handout_cname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether the traffic target is used.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="handoutCname")
    def handout_cname(self) -> _builtins.str:
        """
        Specifies an optional data center for the property.
        """
        return pulumi.get(self, "handout_cname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An alternative label for the traffic target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> _builtins.int:
        """
        Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
        """
        return pulumi.get(self, "precedence")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence[_builtins.str]:
        """
        Identifies the IP address or the hostnames of the servers.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        """
        Specifies the traffic target weight for the target.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetGtmDomainResourceResult(dict):
    def __init__(__self__, *,
                 aggregation_type: _builtins.str,
                 constrained_property: _builtins.str,
                 decay_rate: _builtins.float,
                 description: _builtins.str,
                 host_header: _builtins.str,
                 leader_string: _builtins.str,
                 least_squares_decay: _builtins.float,
                 load_imbalance_percentage: _builtins.float,
                 max_u_multiplicative_increment: _builtins.float,
                 name: _builtins.str,
                 type: _builtins.str,
                 upper_bound: _builtins.int,
                 links: Optional[Sequence['outputs.GetGtmDomainResourceLinkResult']] = None,
                 resource_instances: Optional[Sequence['outputs.GetGtmDomainResourceResourceInstanceResult']] = None):
        """
        :param _builtins.str aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        :param _builtins.str constrained_property: Specifies the name of the property that this resource constraints.
        :param _builtins.float decay_rate: For internal use only.
        :param _builtins.str description: A descriptive note to help you track what the resource constraints.
        :param _builtins.str host_header: Specifies the host header used when fetching the load object.
        :param _builtins.str leader_string: Specifies the text that comes before the loadObject.
        :param _builtins.float least_squares_decay: For internal use only.
        :param _builtins.float load_imbalance_percentage: Indicates the percent of load imbalance factor for the domain.
        :param _builtins.float max_u_multiplicative_increment: For internal use only.
        :param _builtins.str name: A descriptive label for the resource.
        :param _builtins.str type: Indicates the kind of loadObject format used to determine the load on the resource.
        :param _builtins.int upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
        :param Sequence['GetGtmDomainResourceLinkArgs'] links: Specifies the URL path that allows direct navigation to the resource.
        :param Sequence['GetGtmDomainResourceResourceInstanceArgs'] resource_instances: List of resource instances.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "constrained_property", constrained_property)
        pulumi.set(__self__, "decay_rate", decay_rate)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "leader_string", leader_string)
        pulumi.set(__self__, "least_squares_decay", least_squares_decay)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upper_bound", upper_bound)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if resource_instances is not None:
            pulumi.set(__self__, "resource_instances", resource_instances)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="constrainedProperty")
    def constrained_property(self) -> _builtins.str:
        """
        Specifies the name of the property that this resource constraints.
        """
        return pulumi.get(self, "constrained_property")

    @_builtins.property
    @pulumi.getter(name="decayRate")
    def decay_rate(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "decay_rate")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A descriptive note to help you track what the resource constraints.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> _builtins.str:
        """
        Specifies the host header used when fetching the load object.
        """
        return pulumi.get(self, "host_header")

    @_builtins.property
    @pulumi.getter(name="leaderString")
    def leader_string(self) -> _builtins.str:
        """
        Specifies the text that comes before the loadObject.
        """
        return pulumi.get(self, "leader_string")

    @_builtins.property
    @pulumi.getter(name="leastSquaresDecay")
    def least_squares_decay(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "least_squares_decay")

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @_builtins.property
    @pulumi.getter(name="maxUMultiplicativeIncrement")
    def max_u_multiplicative_increment(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "max_u_multiplicative_increment")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the kind of loadObject format used to determine the load on the resource.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> _builtins.int:
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        return pulumi.get(self, "upper_bound")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainResourceLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="resourceInstances")
    def resource_instances(self) -> Optional[Sequence['outputs.GetGtmDomainResourceResourceInstanceResult']]:
        """
        List of resource instances.
        """
        return pulumi.get(self, "resource_instances")


@pulumi.output_type
class GetGtmDomainResourceLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainResourceResourceInstanceResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")


@pulumi.output_type
class GetGtmDomainStatusResult(dict):
    def __init__(__self__, *,
                 change_id: _builtins.str,
                 message: _builtins.str,
                 passing_validation: _builtins.bool,
                 propagation_status: _builtins.str,
                 propagation_status_date: _builtins.str,
                 links: Optional[Sequence['outputs.GetGtmDomainStatusLinkResult']] = None):
        """
        :param _builtins.str change_id: A unique identifier generated when a change occurs to the domain.
        :param _builtins.str message: A notification generated when a change occurs to the domain.
        :param _builtins.bool passing_validation: Indicates if the domain validates.
        :param _builtins.str propagation_status: Tracks the status of the domain's propagation state.
        :param _builtins.str propagation_status_date: An ISO 8601 timestamp indicating when a change occurs to the domain.
        :param Sequence['GetGtmDomainStatusLinkArgs'] links: Specifies the URL path that allows direct navigation to the domain.
        """
        pulumi.set(__self__, "change_id", change_id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "passing_validation", passing_validation)
        pulumi.set(__self__, "propagation_status", propagation_status)
        pulumi.set(__self__, "propagation_status_date", propagation_status_date)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter(name="changeId")
    def change_id(self) -> _builtins.str:
        """
        A unique identifier generated when a change occurs to the domain.
        """
        return pulumi.get(self, "change_id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A notification generated when a change occurs to the domain.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="passingValidation")
    def passing_validation(self) -> _builtins.bool:
        """
        Indicates if the domain validates.
        """
        return pulumi.get(self, "passing_validation")

    @_builtins.property
    @pulumi.getter(name="propagationStatus")
    def propagation_status(self) -> _builtins.str:
        """
        Tracks the status of the domain's propagation state.
        """
        return pulumi.get(self, "propagation_status")

    @_builtins.property
    @pulumi.getter(name="propagationStatusDate")
    def propagation_status_date(self) -> _builtins.str:
        """
        An ISO 8601 timestamp indicating when a change occurs to the domain.
        """
        return pulumi.get(self, "propagation_status_date")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainStatusLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the domain.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainStatusLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmDomainsDomainResult(dict):
    def __init__(__self__, *,
                 acg_id: _builtins.str,
                 activation_state: _builtins.str,
                 change_id: _builtins.str,
                 delete_request_id: _builtins.str,
                 last_modified: _builtins.str,
                 last_modified_by: _builtins.str,
                 modification_comments: _builtins.str,
                 name: _builtins.str,
                 sign_and_serve: _builtins.bool,
                 sign_and_serve_algorithm: _builtins.str,
                 status: _builtins.str,
                 links: Optional[Sequence['outputs.GetGtmDomainsDomainLinkResult']] = None):
        """
        :param _builtins.str acg_id: The contract's identifier, with which the domain is associated.
        :param _builtins.str activation_state: 'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
        :param _builtins.str change_id: UUID that identifies a version of the domain configuration.
        :param _builtins.str delete_request_id: UUID for delete request during domain deletion. Null if the domain is not being deleted.
        :param _builtins.str last_modified: An ISO 8601 timestamp that indicates the time of the last domain change.
        :param _builtins.str last_modified_by: The email address of the administrator who made the last change to the domain.
        :param _builtins.str modification_comments: A descriptive note about changes to the domain.
        :param _builtins.str name: A unique domain name.
        :param _builtins.bool sign_and_serve: If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
        :param _builtins.str sign_and_serve_algorithm: The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
        :param _builtins.str status: The current status of the domain.
        :param Sequence['GetGtmDomainsDomainLinkArgs'] links: Provides a URL path that allows direct navigation to the domain.
        """
        pulumi.set(__self__, "acg_id", acg_id)
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "change_id", change_id)
        pulumi.set(__self__, "delete_request_id", delete_request_id)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "last_modified_by", last_modified_by)
        pulumi.set(__self__, "modification_comments", modification_comments)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sign_and_serve", sign_and_serve)
        pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
        pulumi.set(__self__, "status", status)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter(name="acgId")
    def acg_id(self) -> _builtins.str:
        """
        The contract's identifier, with which the domain is associated.
        """
        return pulumi.get(self, "acg_id")

    @_builtins.property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> _builtins.str:
        """
        'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
        """
        return pulumi.get(self, "activation_state")

    @_builtins.property
    @pulumi.getter(name="changeId")
    def change_id(self) -> _builtins.str:
        """
        UUID that identifies a version of the domain configuration.
        """
        return pulumi.get(self, "change_id")

    @_builtins.property
    @pulumi.getter(name="deleteRequestId")
    def delete_request_id(self) -> _builtins.str:
        """
        UUID for delete request during domain deletion. Null if the domain is not being deleted.
        """
        return pulumi.get(self, "delete_request_id")

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> _builtins.str:
        """
        An ISO 8601 timestamp that indicates the time of the last domain change.
        """
        return pulumi.get(self, "last_modified")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> _builtins.str:
        """
        The email address of the administrator who made the last change to the domain.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="modificationComments")
    def modification_comments(self) -> _builtins.str:
        """
        A descriptive note about changes to the domain.
        """
        return pulumi.get(self, "modification_comments")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A unique domain name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="signAndServe")
    def sign_and_serve(self) -> _builtins.bool:
        """
        If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
        """
        return pulumi.get(self, "sign_and_serve")

    @_builtins.property
    @pulumi.getter(name="signAndServeAlgorithm")
    def sign_and_serve_algorithm(self) -> _builtins.str:
        """
        The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
        """
        return pulumi.get(self, "sign_and_serve_algorithm")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the domain.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmDomainsDomainLinkResult']]:
        """
        Provides a URL path that allows direct navigation to the domain.
        """
        return pulumi.get(self, "links")


@pulumi.output_type
class GetGtmDomainsDomainLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmGeomapAssignmentResult(dict):
    def __init__(__self__, *,
                 countries: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] countries: Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "countries", countries)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
        """
        return pulumi.get(self, "countries")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmGeomapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other geographic zones.
        :param _builtins.str nickname: A descriptive label for all other geographic zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other geographic zones.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other geographic zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmGeomapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmGeomapsGeoMapResult(dict):
    def __init__(__self__, *,
                 assignments: Sequence['outputs.GetGtmGeomapsGeoMapAssignmentResult'],
                 default_datacenter: 'outputs.GetGtmGeomapsGeoMapDefaultDatacenterResult',
                 links: Sequence['outputs.GetGtmGeomapsGeoMapLinkResult'],
                 name: _builtins.str):
        """
        :param Sequence['GetGtmGeomapsGeoMapAssignmentArgs'] assignments: Contains information about the geographic zone groupings of countries.
        :param 'GetGtmGeomapsGeoMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other geographic zones, countries not found in these geographic zones.
        :param Sequence['GetGtmGeomapsGeoMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the Geographic maps.
        :param _builtins.str name: A descriptive label for the Geographic map.
        """
        pulumi.set(__self__, "assignments", assignments)
        pulumi.set(__self__, "default_datacenter", default_datacenter)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Sequence['outputs.GetGtmGeomapsGeoMapAssignmentResult']:
        """
        Contains information about the geographic zone groupings of countries.
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> 'outputs.GetGtmGeomapsGeoMapDefaultDatacenterResult':
        """
        A placeholder for all other geographic zones, countries not found in these geographic zones.
        """
        return pulumi.get(self, "default_datacenter")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetGtmGeomapsGeoMapLinkResult']:
        """
        Specifies the URL path that allows direct navigation to the Geographic maps.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the Geographic map.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGtmGeomapsGeoMapAssignmentResult(dict):
    def __init__(__self__, *,
                 countries: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] countries: Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "countries", countries)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter state or province code separated by a forward slash.
        """
        return pulumi.get(self, "countries")

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmGeomapsGeoMapDefaultDatacenterResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other geographic zones.
        :param _builtins.str nickname: A descriptive label for all other geographic zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other geographic zones.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other geographic zones.
        """
        return pulumi.get(self, "nickname")


@pulumi.output_type
class GetGtmGeomapsGeoMapLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmResourceLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmResourceResourceInstanceResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")


@pulumi.output_type
class GetGtmResourcesResourceResult(dict):
    def __init__(__self__, *,
                 aggregation_type: _builtins.str,
                 constrained_property: _builtins.str,
                 decay_rate: _builtins.float,
                 description: _builtins.str,
                 host_header: _builtins.str,
                 leader_string: _builtins.str,
                 least_squares_decay: _builtins.float,
                 load_imbalance_percentage: _builtins.float,
                 max_u_multiplicative_increment: _builtins.float,
                 name: _builtins.str,
                 type: _builtins.str,
                 upper_bound: _builtins.int,
                 links: Optional[Sequence['outputs.GetGtmResourcesResourceLinkResult']] = None,
                 resource_instances: Optional[Sequence['outputs.GetGtmResourcesResourceResourceInstanceResult']] = None):
        """
        :param _builtins.str aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        :param _builtins.str constrained_property: Specifies the name of the property that this resource constraints.
        :param _builtins.float decay_rate: For internal use only.
        :param _builtins.str description: A descriptive note which allows to track what is constrained by this resource.
        :param _builtins.str host_header: Specifies the host header used when fetching the load object.
        :param _builtins.str leader_string: Specifies the text that comes before the load object.
        :param _builtins.float least_squares_decay: For internal use only.
        :param _builtins.float load_imbalance_percentage: Indicates the percentage of load imbalance for the domain.
        :param _builtins.float max_u_multiplicative_increment: For internal use only.
        :param _builtins.str name: A descriptive label for the resource.
        :param _builtins.str type: Indicates the type of load object used to determine the load on the resource.
        :param _builtins.int upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
        :param Sequence['GetGtmResourcesResourceLinkArgs'] links: Specifies the URL path that allows direct navigation to the resource.
        :param Sequence['GetGtmResourcesResourceResourceInstanceArgs'] resource_instances: Instances of the resource.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "constrained_property", constrained_property)
        pulumi.set(__self__, "decay_rate", decay_rate)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "leader_string", leader_string)
        pulumi.set(__self__, "least_squares_decay", least_squares_decay)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upper_bound", upper_bound)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if resource_instances is not None:
            pulumi.set(__self__, "resource_instances", resource_instances)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="constrainedProperty")
    def constrained_property(self) -> _builtins.str:
        """
        Specifies the name of the property that this resource constraints.
        """
        return pulumi.get(self, "constrained_property")

    @_builtins.property
    @pulumi.getter(name="decayRate")
    def decay_rate(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "decay_rate")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A descriptive note which allows to track what is constrained by this resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> _builtins.str:
        """
        Specifies the host header used when fetching the load object.
        """
        return pulumi.get(self, "host_header")

    @_builtins.property
    @pulumi.getter(name="leaderString")
    def leader_string(self) -> _builtins.str:
        """
        Specifies the text that comes before the load object.
        """
        return pulumi.get(self, "leader_string")

    @_builtins.property
    @pulumi.getter(name="leastSquaresDecay")
    def least_squares_decay(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "least_squares_decay")

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percentage of load imbalance for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @_builtins.property
    @pulumi.getter(name="maxUMultiplicativeIncrement")
    def max_u_multiplicative_increment(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "max_u_multiplicative_increment")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the type of load object used to determine the load on the resource.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> _builtins.int:
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        return pulumi.get(self, "upper_bound")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetGtmResourcesResourceLinkResult']]:
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="resourceInstances")
    def resource_instances(self) -> Optional[Sequence['outputs.GetGtmResourcesResourceResourceInstanceResult']]:
        """
        Instances of the resource.
        """
        return pulumi.get(self, "resource_instances")


@pulumi.output_type
class GetGtmResourcesResourceLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetGtmResourcesResourceResourceInstanceResult(dict):
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")


@pulumi.output_type
class GetIamAccountSwitchKeysAccountSwitchKeyResult(dict):
    def __init__(__self__, *,
                 account_name: _builtins.str,
                 account_switch_key: _builtins.str):
        """
        :param _builtins.str account_name: Descriptive label for the account.
        :param _builtins.str account_switch_key: The identifier for an account other than your API client's default.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "account_switch_key", account_switch_key)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> _builtins.str:
        """
        Descriptive label for the account.
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="accountSwitchKey")
    def account_switch_key(self) -> _builtins.str:
        """
        The identifier for an account other than your API client's default.
        """
        return pulumi.get(self, "account_switch_key")


@pulumi.output_type
class GetIamAllowedApisAllowedApiResult(dict):
    def __init__(__self__, *,
                 access_levels: Sequence[_builtins.str],
                 api_id: _builtins.int,
                 api_name: _builtins.str,
                 description: _builtins.str,
                 documentation_url: _builtins.str,
                 endpoint: _builtins.str,
                 has_access: _builtins.bool,
                 service_provider_id: _builtins.int):
        """
        :param Sequence[_builtins.str] access_levels: API access levels, possible values are READ-ONLY, READ-WRITE, CREDENTIAL-READ-ONLY and CREDENTIAL-READ-WRITE.
        :param _builtins.int api_id: A unique identifier for each API.
        :param _builtins.str api_name: Name of the API.
        :param _builtins.str description: A human-readable name for the API.
        :param _builtins.str documentation_url: A link to more information about the API.
        :param _builtins.str endpoint: Specifies where the API can access resources.
        :param _builtins.bool has_access: Confirms access to the API.
        :param _builtins.int service_provider_id: Unique identifier for the API's service provider.
        """
        pulumi.set(__self__, "access_levels", access_levels)
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "api_name", api_name)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "documentation_url", documentation_url)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "has_access", has_access)
        pulumi.set(__self__, "service_provider_id", service_provider_id)

    @_builtins.property
    @pulumi.getter(name="accessLevels")
    def access_levels(self) -> Sequence[_builtins.str]:
        """
        API access levels, possible values are READ-ONLY, READ-WRITE, CREDENTIAL-READ-ONLY and CREDENTIAL-READ-WRITE.
        """
        return pulumi.get(self, "access_levels")

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> _builtins.int:
        """
        A unique identifier for each API.
        """
        return pulumi.get(self, "api_id")

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> _builtins.str:
        """
        Name of the API.
        """
        return pulumi.get(self, "api_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A human-readable name for the API.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> _builtins.str:
        """
        A link to more information about the API.
        """
        return pulumi.get(self, "documentation_url")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Specifies where the API can access resources.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="hasAccess")
    def has_access(self) -> _builtins.bool:
        """
        Confirms access to the API.
        """
        return pulumi.get(self, "has_access")

    @_builtins.property
    @pulumi.getter(name="serviceProviderId")
    def service_provider_id(self) -> _builtins.int:
        """
        Unique identifier for the API's service provider.
        """
        return pulumi.get(self, "service_provider_id")


@pulumi.output_type
class GetIamApiClientActionsResult(dict):
    def __init__(__self__, *,
                 deactivate_all: _builtins.bool,
                 delete: _builtins.bool,
                 edit: _builtins.bool,
                 edit_apis: _builtins.bool,
                 edit_auth: _builtins.bool,
                 edit_groups: _builtins.bool,
                 edit_ip_acl: _builtins.bool,
                 edit_switch_account: _builtins.bool,
                 lock: _builtins.bool,
                 transfer: _builtins.bool,
                 unlock: _builtins.bool):
        """
        :param _builtins.bool deactivate_all: Whether you can deactivate the API client's credentials.
        :param _builtins.bool delete: Whether you can remove the API client.
        :param _builtins.bool edit: Whether you can update the API client.
        :param _builtins.bool edit_apis: Whether you can update the `apis` the API client can access, same as `edit_auth`.
        :param _builtins.bool edit_auth: Whether you can update the `apis` the API client can access, same as `edit_apis`.
        :param _builtins.bool edit_groups: Whether you can update the `groups` the API client can access.
        :param _builtins.bool edit_ip_acl: Whether you can update the `ip_acl` the API client can access.
        :param _builtins.bool edit_switch_account: Whether you can update the API client's option to manage many accounts.
        :param _builtins.bool lock: Whether you can lock the API client.
        :param _builtins.bool transfer: Whether you can transfer the API client to a new owner.
        :param _builtins.bool unlock: Whether you can unlock the API client.
        """
        pulumi.set(__self__, "deactivate_all", deactivate_all)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit", edit)
        pulumi.set(__self__, "edit_apis", edit_apis)
        pulumi.set(__self__, "edit_auth", edit_auth)
        pulumi.set(__self__, "edit_groups", edit_groups)
        pulumi.set(__self__, "edit_ip_acl", edit_ip_acl)
        pulumi.set(__self__, "edit_switch_account", edit_switch_account)
        pulumi.set(__self__, "lock", lock)
        pulumi.set(__self__, "transfer", transfer)
        pulumi.set(__self__, "unlock", unlock)

    @_builtins.property
    @pulumi.getter(name="deactivateAll")
    def deactivate_all(self) -> _builtins.bool:
        """
        Whether you can deactivate the API client's credentials.
        """
        return pulumi.get(self, "deactivate_all")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can remove the API client.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Whether you can update the API client.
        """
        return pulumi.get(self, "edit")

    @_builtins.property
    @pulumi.getter(name="editApis")
    def edit_apis(self) -> _builtins.bool:
        """
        Whether you can update the `apis` the API client can access, same as `edit_auth`.
        """
        return pulumi.get(self, "edit_apis")

    @_builtins.property
    @pulumi.getter(name="editAuth")
    def edit_auth(self) -> _builtins.bool:
        """
        Whether you can update the `apis` the API client can access, same as `edit_apis`.
        """
        return pulumi.get(self, "edit_auth")

    @_builtins.property
    @pulumi.getter(name="editGroups")
    def edit_groups(self) -> _builtins.bool:
        """
        Whether you can update the `groups` the API client can access.
        """
        return pulumi.get(self, "edit_groups")

    @_builtins.property
    @pulumi.getter(name="editIpAcl")
    def edit_ip_acl(self) -> _builtins.bool:
        """
        Whether you can update the `ip_acl` the API client can access.
        """
        return pulumi.get(self, "edit_ip_acl")

    @_builtins.property
    @pulumi.getter(name="editSwitchAccount")
    def edit_switch_account(self) -> _builtins.bool:
        """
        Whether you can update the API client's option to manage many accounts.
        """
        return pulumi.get(self, "edit_switch_account")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> _builtins.bool:
        """
        Whether you can lock the API client.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter
    def transfer(self) -> _builtins.bool:
        """
        Whether you can transfer the API client to a new owner.
        """
        return pulumi.get(self, "transfer")

    @_builtins.property
    @pulumi.getter
    def unlock(self) -> _builtins.bool:
        """
        Whether you can unlock the API client.
        """
        return pulumi.get(self, "unlock")


@pulumi.output_type
class GetIamApiClientApiAccessResult(dict):
    def __init__(__self__, *,
                 all_accessible_apis: _builtins.bool,
                 apis: Sequence['outputs.GetIamApiClientApiAccessApiResult']):
        """
        :param _builtins.bool all_accessible_apis: Whether the API client has access to a full set of available APIs.
        :param Sequence['GetIamApiClientApiAccessApiArgs'] apis: The set of APIs the API client can access when `all_accessible_apis` is disabled.
        """
        pulumi.set(__self__, "all_accessible_apis", all_accessible_apis)
        pulumi.set(__self__, "apis", apis)

    @_builtins.property
    @pulumi.getter(name="allAccessibleApis")
    def all_accessible_apis(self) -> _builtins.bool:
        """
        Whether the API client has access to a full set of available APIs.
        """
        return pulumi.get(self, "all_accessible_apis")

    @_builtins.property
    @pulumi.getter
    def apis(self) -> Sequence['outputs.GetIamApiClientApiAccessApiResult']:
        """
        The set of APIs the API client can access when `all_accessible_apis` is disabled.
        """
        return pulumi.get(self, "apis")


@pulumi.output_type
class GetIamApiClientApiAccessApiResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 api_id: _builtins.int,
                 api_name: _builtins.str,
                 description: _builtins.str,
                 documentation_url: _builtins.str,
                 endpoint: _builtins.str):
        """
        :param _builtins.str access_level: The API client's access level on an API basis, either `READ-ONLY`, `READ-WRITE`, `CREDENTIAL-READ-ONLY`, or `CREDENTIAL-READ-WRITE`.
        :param _builtins.int api_id: A unique identifier for each API.
        :param _builtins.str api_name: A human-readable name for the API.
        :param _builtins.str description: A human-readable description for the API.
        :param _builtins.str documentation_url: A link to more information about the API.
        :param _builtins.str endpoint: Specifies where the API can access resources.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "api_name", api_name)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "documentation_url", documentation_url)
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        The API client's access level on an API basis, either `READ-ONLY`, `READ-WRITE`, `CREDENTIAL-READ-ONLY`, or `CREDENTIAL-READ-WRITE`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> _builtins.int:
        """
        A unique identifier for each API.
        """
        return pulumi.get(self, "api_id")

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> _builtins.str:
        """
        A human-readable name for the API.
        """
        return pulumi.get(self, "api_name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A human-readable description for the API.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> _builtins.str:
        """
        A link to more information about the API.
        """
        return pulumi.get(self, "documentation_url")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Specifies where the API can access resources.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetIamApiClientCredentialResult(dict):
    def __init__(__self__, *,
                 actions: 'outputs.GetIamApiClientCredentialActionsResult',
                 client_token: _builtins.str,
                 created_on: _builtins.str,
                 credential_id: _builtins.int,
                 description: _builtins.str,
                 expires_on: _builtins.str,
                 status: _builtins.str):
        """
        :param 'GetIamApiClientCredentialActionsArgs' actions: Specifies activities available on the API client's credentials.
        :param _builtins.str client_token: The part of the credential that identifies the API client.
        :param _builtins.str created_on: The ISO 8601 timestamp indicating when the credential was created.
        :param _builtins.int credential_id: A unique identifier for each credential.
        :param _builtins.str description: A human-readable description for the API client.
        :param _builtins.str expires_on: The ISO 8601 timestamp indicating when the credential expires.
        :param _builtins.str status: Whether a credential is `ACTIVE`, `INACTIVE`, or `DELETED`.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "client_token", client_token)
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "credential_id", credential_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_on", expires_on)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.GetIamApiClientCredentialActionsResult':
        """
        Specifies activities available on the API client's credentials.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> _builtins.str:
        """
        The part of the credential that identifies the API client.
        """
        return pulumi.get(self, "client_token")

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> _builtins.str:
        """
        The ISO 8601 timestamp indicating when the credential was created.
        """
        return pulumi.get(self, "created_on")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> _builtins.int:
        """
        A unique identifier for each credential.
        """
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A human-readable description for the API client.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> _builtins.str:
        """
        The ISO 8601 timestamp indicating when the credential expires.
        """
        return pulumi.get(self, "expires_on")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Whether a credential is `ACTIVE`, `INACTIVE`, or `DELETED`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetIamApiClientCredentialActionsResult(dict):
    def __init__(__self__, *,
                 activate: _builtins.bool,
                 deactivate: _builtins.bool,
                 delete: _builtins.bool,
                 edit_description: _builtins.bool,
                 edit_expiration: _builtins.bool):
        """
        :param _builtins.bool activate: Whether you can activate the credential.
        :param _builtins.bool deactivate: Whether you can deactivate the credential.
        :param _builtins.bool delete: Whether you can remove the credential.
        :param _builtins.bool edit_description: Whether you can modify the credential's description.
        :param _builtins.bool edit_expiration: Whether you can modify the credential's expiration date.
        """
        pulumi.set(__self__, "activate", activate)
        pulumi.set(__self__, "deactivate", deactivate)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit_description", edit_description)
        pulumi.set(__self__, "edit_expiration", edit_expiration)

    @_builtins.property
    @pulumi.getter
    def activate(self) -> _builtins.bool:
        """
        Whether you can activate the credential.
        """
        return pulumi.get(self, "activate")

    @_builtins.property
    @pulumi.getter
    def deactivate(self) -> _builtins.bool:
        """
        Whether you can deactivate the credential.
        """
        return pulumi.get(self, "deactivate")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can remove the credential.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter(name="editDescription")
    def edit_description(self) -> _builtins.bool:
        """
        Whether you can modify the credential's description.
        """
        return pulumi.get(self, "edit_description")

    @_builtins.property
    @pulumi.getter(name="editExpiration")
    def edit_expiration(self) -> _builtins.bool:
        """
        Whether you can modify the credential's expiration date.
        """
        return pulumi.get(self, "edit_expiration")


@pulumi.output_type
class GetIamApiClientGroupAccessResult(dict):
    def __init__(__self__, *,
                 clone_authorized_user_groups: _builtins.bool,
                 groups: Sequence['outputs.GetIamApiClientGroupAccessGroupResult']):
        """
        :param _builtins.bool clone_authorized_user_groups: Sets the API client's group access the same as the authorized user.
        :param Sequence['GetIamApiClientGroupAccessGroupArgs'] groups: Groups the API client can access.
        """
        pulumi.set(__self__, "clone_authorized_user_groups", clone_authorized_user_groups)
        pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="cloneAuthorizedUserGroups")
    def clone_authorized_user_groups(self) -> _builtins.bool:
        """
        Sets the API client's group access the same as the authorized user.
        """
        return pulumi.get(self, "clone_authorized_user_groups")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetIamApiClientGroupAccessGroupResult']:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class GetIamApiClientGroupAccessGroupResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.int,
                 group_name: _builtins.str,
                 is_blocked: _builtins.bool,
                 parent_group_id: _builtins.int,
                 role_description: _builtins.str,
                 role_id: _builtins.int,
                 role_name: _builtins.str,
                 sub_groups: Sequence['outputs.GetIamApiClientGroupAccessGroupSubGroupResult']):
        """
        :param _builtins.int group_id: Unique identifier for each group.
        :param _builtins.str group_name: Descriptive label for the group.
        :param _builtins.bool is_blocked: Blocks the API client access to the group's child groups.
        :param _builtins.int parent_group_id: Unique identifier for the parent group within the group tree.
        :param _builtins.str role_description: Descriptive label for the role to convey its use.
        :param _builtins.int role_id: Unique identifier for each role.
        :param _builtins.str role_name: Descriptive label for the role.
        :param Sequence['GetIamApiClientGroupAccessGroupSubGroupArgs'] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "is_blocked", is_blocked)
        pulumi.set(__self__, "parent_group_id", parent_group_id)
        pulumi.set(__self__, "role_description", role_description)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        Unique identifier for each group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Descriptive label for the group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> _builtins.bool:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> _builtins.int:
        """
        Unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> _builtins.str:
        """
        Descriptive label for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.int:
        """
        Unique identifier for each role.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Descriptive label for the role.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Sequence['outputs.GetIamApiClientGroupAccessGroupSubGroupResult']:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")


@pulumi.output_type
class GetIamApiClientGroupAccessGroupSubGroupResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.int,
                 group_name: _builtins.str,
                 is_blocked: _builtins.bool,
                 parent_group_id: _builtins.int,
                 role_description: _builtins.str,
                 role_id: _builtins.int,
                 role_name: _builtins.str,
                 sub_groups: Sequence['outputs.GetIamApiClientGroupAccessGroupSubGroupResult']):
        """
        :param _builtins.int group_id: Unique identifier for each group.
        :param _builtins.str group_name: Descriptive label for the group.
        :param _builtins.bool is_blocked: Blocks the API client access to the group's child groups.
        :param _builtins.int parent_group_id: Unique identifier for the parent group within the group tree.
        :param _builtins.str role_description: Descriptive label for the role to convey its use.
        :param _builtins.int role_id: Unique identifier for each role.
        :param _builtins.str role_name: Descriptive label for the role.
        :param Sequence['GetIamApiClientGroupAccessGroupSubGroupArgs'] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "is_blocked", is_blocked)
        pulumi.set(__self__, "parent_group_id", parent_group_id)
        pulumi.set(__self__, "role_description", role_description)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_name", role_name)
        pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        Unique identifier for each group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Descriptive label for the group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> _builtins.bool:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> _builtins.int:
        """
        Unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> _builtins.str:
        """
        Descriptive label for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.int:
        """
        Unique identifier for each role.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Descriptive label for the role.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Sequence['outputs.GetIamApiClientGroupAccessGroupSubGroupResult']:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")


@pulumi.output_type
class GetIamApiClientIpAclResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence[_builtins.str],
                 enable: _builtins.bool):
        """
        :param Sequence[_builtins.str] cidrs: IP addresses or CIDR blocks the API client can access.
        :param _builtins.bool enable: Enables the API client to access the IP access control list (ACL).
        """
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Sequence[_builtins.str]:
        """
        IP addresses or CIDR blocks the API client can access.
        """
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Enables the API client to access the IP access control list (ACL).
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetIamApiClientPurgeOptionsResult(dict):
    def __init__(__self__, *,
                 can_purge_by_cache_tag: _builtins.bool,
                 can_purge_by_cp_code: _builtins.bool,
                 cp_code_access: 'outputs.GetIamApiClientPurgeOptionsCpCodeAccessResult'):
        """
        :param _builtins.bool can_purge_by_cache_tag: Whether the API client can purge content by cache tag.
        :param _builtins.bool can_purge_by_cp_code: Whether the API client can purge content by CP code.
        :param 'GetIamApiClientPurgeOptionsCpCodeAccessArgs' cp_code_access: CP codes the API client can purge.
        """
        pulumi.set(__self__, "can_purge_by_cache_tag", can_purge_by_cache_tag)
        pulumi.set(__self__, "can_purge_by_cp_code", can_purge_by_cp_code)
        pulumi.set(__self__, "cp_code_access", cp_code_access)

    @_builtins.property
    @pulumi.getter(name="canPurgeByCacheTag")
    def can_purge_by_cache_tag(self) -> _builtins.bool:
        """
        Whether the API client can purge content by cache tag.
        """
        return pulumi.get(self, "can_purge_by_cache_tag")

    @_builtins.property
    @pulumi.getter(name="canPurgeByCpCode")
    def can_purge_by_cp_code(self) -> _builtins.bool:
        """
        Whether the API client can purge content by CP code.
        """
        return pulumi.get(self, "can_purge_by_cp_code")

    @_builtins.property
    @pulumi.getter(name="cpCodeAccess")
    def cp_code_access(self) -> 'outputs.GetIamApiClientPurgeOptionsCpCodeAccessResult':
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_code_access")


@pulumi.output_type
class GetIamApiClientPurgeOptionsCpCodeAccessResult(dict):
    def __init__(__self__, *,
                 all_current_and_new_cp_codes: _builtins.bool,
                 cp_codes: Sequence[_builtins.int]):
        """
        :param _builtins.bool all_current_and_new_cp_codes: Whether the API can purge content by all current and new CP codes.
        :param Sequence[_builtins.int] cp_codes: CP codes the API client can purge.
        """
        pulumi.set(__self__, "all_current_and_new_cp_codes", all_current_and_new_cp_codes)
        pulumi.set(__self__, "cp_codes", cp_codes)

    @_builtins.property
    @pulumi.getter(name="allCurrentAndNewCpCodes")
    def all_current_and_new_cp_codes(self) -> _builtins.bool:
        """
        Whether the API can purge content by all current and new CP codes.
        """
        return pulumi.get(self, "all_current_and_new_cp_codes")

    @_builtins.property
    @pulumi.getter(name="cpCodes")
    def cp_codes(self) -> Sequence[_builtins.int]:
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_codes")


@pulumi.output_type
class GetIamApiClientsApiClientResult(dict):
    def __init__(__self__, *,
                 access_token: _builtins.str,
                 actions: 'outputs.GetIamApiClientsApiClientActionsResult',
                 active_credential_count: _builtins.int,
                 allow_account_switch: _builtins.bool,
                 authorized_users: Sequence[_builtins.str],
                 can_auto_create_credential: _builtins.bool,
                 client_description: _builtins.str,
                 client_id: _builtins.str,
                 client_name: _builtins.str,
                 client_type: _builtins.str,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 is_locked: _builtins.bool,
                 notification_emails: Sequence[_builtins.str],
                 service_consumer_token: _builtins.str):
        """
        :param _builtins.str access_token: The part of the client secret that identifies your API client and lets you access applications and resources.
        :param 'GetIamApiClientsApiClientActionsArgs' actions: Specifies activities available for the API client.
        :param _builtins.int active_credential_count: The number of credentials active for the API client.
        :param _builtins.bool allow_account_switch: Whether the API client can manage more than one account.
        :param Sequence[_builtins.str] authorized_users: The API client's valid users.
        :param _builtins.bool can_auto_create_credential: Whether the API client can create a credential for a new API client.
        :param _builtins.str client_description: A human-readable description of the API client.
        :param _builtins.str client_id: A unique identifier for the API client.
        :param _builtins.str client_name: A human-readable name for the API client.
        :param _builtins.str client_type: Specifies the API client's ownership and credential management.
        :param _builtins.str created_by: The user who created the API client.
        :param _builtins.str created_date: The ISO 8601 timestamp indicating when the API client was created.
        :param _builtins.bool is_locked: Whether the API client is locked.
        :param Sequence[_builtins.str] notification_emails: Email addresses to notify users when credentials expire.
        :param _builtins.str service_consumer_token: Unique identifier for the service hostname.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "active_credential_count", active_credential_count)
        pulumi.set(__self__, "allow_account_switch", allow_account_switch)
        pulumi.set(__self__, "authorized_users", authorized_users)
        pulumi.set(__self__, "can_auto_create_credential", can_auto_create_credential)
        pulumi.set(__self__, "client_description", client_description)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_name", client_name)
        pulumi.set(__self__, "client_type", client_type)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "is_locked", is_locked)
        pulumi.set(__self__, "notification_emails", notification_emails)
        pulumi.set(__self__, "service_consumer_token", service_consumer_token)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> _builtins.str:
        """
        The part of the client secret that identifies your API client and lets you access applications and resources.
        """
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.GetIamApiClientsApiClientActionsResult':
        """
        Specifies activities available for the API client.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="activeCredentialCount")
    def active_credential_count(self) -> _builtins.int:
        """
        The number of credentials active for the API client.
        """
        return pulumi.get(self, "active_credential_count")

    @_builtins.property
    @pulumi.getter(name="allowAccountSwitch")
    def allow_account_switch(self) -> _builtins.bool:
        """
        Whether the API client can manage more than one account.
        """
        return pulumi.get(self, "allow_account_switch")

    @_builtins.property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Sequence[_builtins.str]:
        """
        The API client's valid users.
        """
        return pulumi.get(self, "authorized_users")

    @_builtins.property
    @pulumi.getter(name="canAutoCreateCredential")
    def can_auto_create_credential(self) -> _builtins.bool:
        """
        Whether the API client can create a credential for a new API client.
        """
        return pulumi.get(self, "can_auto_create_credential")

    @_builtins.property
    @pulumi.getter(name="clientDescription")
    def client_description(self) -> _builtins.str:
        """
        A human-readable description of the API client.
        """
        return pulumi.get(self, "client_description")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        A unique identifier for the API client.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientName")
    def client_name(self) -> _builtins.str:
        """
        A human-readable name for the API client.
        """
        return pulumi.get(self, "client_name")

    @_builtins.property
    @pulumi.getter(name="clientType")
    def client_type(self) -> _builtins.str:
        """
        Specifies the API client's ownership and credential management.
        """
        return pulumi.get(self, "client_type")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The user who created the API client.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        The ISO 8601 timestamp indicating when the API client was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="isLocked")
    def is_locked(self) -> _builtins.bool:
        """
        Whether the API client is locked.
        """
        return pulumi.get(self, "is_locked")

    @_builtins.property
    @pulumi.getter(name="notificationEmails")
    def notification_emails(self) -> Sequence[_builtins.str]:
        """
        Email addresses to notify users when credentials expire.
        """
        return pulumi.get(self, "notification_emails")

    @_builtins.property
    @pulumi.getter(name="serviceConsumerToken")
    def service_consumer_token(self) -> _builtins.str:
        """
        Unique identifier for the service hostname.
        """
        return pulumi.get(self, "service_consumer_token")


@pulumi.output_type
class GetIamApiClientsApiClientActionsResult(dict):
    def __init__(__self__, *,
                 deactivate_all: _builtins.bool,
                 delete: _builtins.bool,
                 edit: _builtins.bool,
                 lock: _builtins.bool,
                 transfer: _builtins.bool,
                 unlock: _builtins.bool):
        """
        :param _builtins.bool deactivate_all: Whether you can deactivate the API client's credentials.
        :param _builtins.bool delete: Whether you can remove the API client.
        :param _builtins.bool edit: Whether you can update the API client.
        :param _builtins.bool lock: Whether you can lock the API client.
        :param _builtins.bool transfer: Whether you can transfer the API client to a new owner.
        :param _builtins.bool unlock: Whether you can unlock the API client.
        """
        pulumi.set(__self__, "deactivate_all", deactivate_all)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit", edit)
        pulumi.set(__self__, "lock", lock)
        pulumi.set(__self__, "transfer", transfer)
        pulumi.set(__self__, "unlock", unlock)

    @_builtins.property
    @pulumi.getter(name="deactivateAll")
    def deactivate_all(self) -> _builtins.bool:
        """
        Whether you can deactivate the API client's credentials.
        """
        return pulumi.get(self, "deactivate_all")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can remove the API client.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Whether you can update the API client.
        """
        return pulumi.get(self, "edit")

    @_builtins.property
    @pulumi.getter
    def lock(self) -> _builtins.bool:
        """
        Whether you can lock the API client.
        """
        return pulumi.get(self, "lock")

    @_builtins.property
    @pulumi.getter
    def transfer(self) -> _builtins.bool:
        """
        Whether you can transfer the API client to a new owner.
        """
        return pulumi.get(self, "transfer")

    @_builtins.property
    @pulumi.getter
    def unlock(self) -> _builtins.bool:
        """
        Whether you can unlock the API client.
        """
        return pulumi.get(self, "unlock")


@pulumi.output_type
class GetIamBlockedPropertiesBlockedPropertyResult(dict):
    def __init__(__self__, *,
                 asset_id: _builtins.int,
                 property_id: _builtins.str):
        """
        :param _builtins.int asset_id: IAM's blocked property ID.
        :param _builtins.str property_id: PAPI's blocked property ID.
        """
        pulumi.set(__self__, "asset_id", asset_id)
        pulumi.set(__self__, "property_id", property_id)

    @_builtins.property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> _builtins.int:
        """
        IAM's blocked property ID.
        """
        return pulumi.get(self, "asset_id")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.str:
        """
        PAPI's blocked property ID.
        """
        return pulumi.get(self, "property_id")


@pulumi.output_type
class GetIamCidrBlockActionsResult(dict):
    def __init__(__self__, *,
                 delete: _builtins.bool,
                 edit: _builtins.bool):
        """
        :param _builtins.bool delete: Whether you can delete this CIDR block.
        :param _builtins.bool edit: Whether you can edit this CIDR block.
        """
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit", edit)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can delete this CIDR block.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Whether you can edit this CIDR block.
        """
        return pulumi.get(self, "edit")


@pulumi.output_type
class GetIamCidrBlocksCidrBlockResult(dict):
    def __init__(__self__, *,
                 actions: 'outputs.GetIamCidrBlocksCidrBlockActionsResult',
                 cidr_block: _builtins.str,
                 cidr_block_id: _builtins.int,
                 comments: _builtins.str,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 enabled: _builtins.bool,
                 modified_by: _builtins.str,
                 modified_date: _builtins.str):
        """
        :param 'GetIamCidrBlocksCidrBlockActionsArgs' actions: Specifies activities available for the CIDR block.
        :param _builtins.str cidr_block: The value of an IP address or IP address range.
        :param _builtins.int cidr_block_id: Unique identifier for each CIDR block.
        :param _builtins.str comments: Descriptive label you provide for the CIDR block.
        :param _builtins.str created_by: The user who created the CIDR block.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the CIDR block was created.
        :param _builtins.bool enabled: Whether the CIDR block is enabled.
        :param _builtins.str modified_by: The user who last edited the CIDR block.
        :param _builtins.str modified_date: ISO 8601 timestamp indicating when the CIDR block was last modified.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "cidr_block_id", cidr_block_id)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_date", modified_date)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.GetIamCidrBlocksCidrBlockActionsResult':
        """
        Specifies activities available for the CIDR block.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        The value of an IP address or IP address range.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="cidrBlockId")
    def cidr_block_id(self) -> _builtins.int:
        """
        Unique identifier for each CIDR block.
        """
        return pulumi.get(self, "cidr_block_id")

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Descriptive label you provide for the CIDR block.
        """
        return pulumi.get(self, "comments")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The user who created the CIDR block.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the CIDR block was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the CIDR block is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> _builtins.str:
        """
        The user who last edited the CIDR block.
        """
        return pulumi.get(self, "modified_by")

    @_builtins.property
    @pulumi.getter(name="modifiedDate")
    def modified_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the CIDR block was last modified.
        """
        return pulumi.get(self, "modified_date")


@pulumi.output_type
class GetIamCidrBlocksCidrBlockActionsResult(dict):
    def __init__(__self__, *,
                 delete: _builtins.bool,
                 edit: _builtins.bool):
        """
        :param _builtins.bool delete: Whether you can delete this CIDR block.
        :param _builtins.bool edit: Whether you can edit this CIDR block.
        """
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit", edit)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can delete this CIDR block.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Whether you can edit this CIDR block.
        """
        return pulumi.get(self, "edit")


@pulumi.output_type
class GetIamGrantableRolesGrantableRoleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 granted_role_id: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str description: Granted role description.
        :param _builtins.int granted_role_id: Granted role ID.
        :param _builtins.str name: Granted role name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "granted_role_id", granted_role_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Granted role description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="grantedRoleId")
    def granted_role_id(self) -> _builtins.int:
        """
        Granted role ID.
        """
        return pulumi.get(self, "granted_role_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Granted role name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetIamPropertyUsersUserResult(dict):
    def __init__(__self__, *,
                 first_name: _builtins.str,
                 is_blocked: _builtins.bool,
                 last_name: _builtins.str,
                 ui_identity_id: _builtins.str,
                 ui_user_name: _builtins.str):
        """
        :param _builtins.str first_name: The user's first name.
        :param _builtins.bool is_blocked: Whether a user's access to a property is blocked.
        :param _builtins.str last_name: The user's surname.
        :param _builtins.str ui_identity_id: Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        :param _builtins.str ui_user_name: The user's username in Control Center.
        """
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "is_blocked", is_blocked)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "ui_identity_id", ui_identity_id)
        pulumi.set(__self__, "ui_user_name", ui_user_name)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        The user's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> _builtins.bool:
        """
        Whether a user's access to a property is blocked.
        """
        return pulumi.get(self, "is_blocked")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        The user's surname.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="uiIdentityId")
    def ui_identity_id(self) -> _builtins.str:
        """
        Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        """
        return pulumi.get(self, "ui_identity_id")

    @_builtins.property
    @pulumi.getter(name="uiUserName")
    def ui_user_name(self) -> _builtins.str:
        """
        The user's username in Control Center.
        """
        return pulumi.get(self, "ui_user_name")


@pulumi.output_type
class GetIamRoleActionsResult(dict):
    def __init__(__self__, *,
                 delete: _builtins.bool,
                 edit: _builtins.bool):
        """
        :param _builtins.bool delete: Whether you can remove the role.
        :param _builtins.bool edit: Whether you can modify the role.
        """
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "edit", edit)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Whether you can remove the role.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def edit(self) -> _builtins.bool:
        """
        Whether you can modify the role.
        """
        return pulumi.get(self, "edit")


@pulumi.output_type
class GetIamRoleGrantedRoleResult(dict):
    def __init__(__self__, *,
                 granted_role_description: _builtins.str,
                 granted_role_id: _builtins.int,
                 granted_role_name: _builtins.str):
        """
        :param _builtins.str granted_role_description: Descriptive label for the role to convey its use.
        :param _builtins.int granted_role_id: Unique identifier for each granted role.
        :param _builtins.str granted_role_name: Descriptive label for the granted role.
        """
        pulumi.set(__self__, "granted_role_description", granted_role_description)
        pulumi.set(__self__, "granted_role_id", granted_role_id)
        pulumi.set(__self__, "granted_role_name", granted_role_name)

    @_builtins.property
    @pulumi.getter(name="grantedRoleDescription")
    def granted_role_description(self) -> _builtins.str:
        """
        Descriptive label for the role to convey its use.
        """
        return pulumi.get(self, "granted_role_description")

    @_builtins.property
    @pulumi.getter(name="grantedRoleId")
    def granted_role_id(self) -> _builtins.int:
        """
        Unique identifier for each granted role.
        """
        return pulumi.get(self, "granted_role_id")

    @_builtins.property
    @pulumi.getter(name="grantedRoleName")
    def granted_role_name(self) -> _builtins.str:
        """
        Descriptive label for the granted role.
        """
        return pulumi.get(self, "granted_role_name")


@pulumi.output_type
class GetIamRoleUserResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_login_date: _builtins.str,
                 last_name: _builtins.str,
                 ui_identity_id: _builtins.str):
        """
        :param _builtins.str account_id: Unique identifier for each account.
        :param _builtins.str email: The user's email address.
        :param _builtins.str first_name: The user's first name.
        :param _builtins.str last_login_date: ISO 8601 timestamp indicating when the user last logged in.
        :param _builtins.str last_name: The user's surname.
        :param _builtins.str ui_identity_id: Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_login_date", last_login_date)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "ui_identity_id", ui_identity_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        Unique identifier for each account.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The user's email address.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        The user's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastLoginDate")
    def last_login_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the user last logged in.
        """
        return pulumi.get(self, "last_login_date")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        The user's surname.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="uiIdentityId")
    def ui_identity_id(self) -> _builtins.str:
        """
        Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        """
        return pulumi.get(self, "ui_identity_id")


@pulumi.output_type
class GetIamRolesRoleResult(dict):
    def __init__(__self__, *,
                 created_by: _builtins.str,
                 description: _builtins.str,
                 modified_by: _builtins.str,
                 name: _builtins.str,
                 role_id: _builtins.str,
                 time_created: _builtins.str,
                 time_modified: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str created_by: The user name or email of the person who created the role.
        :param _builtins.str description: The role's description.
        :param _builtins.str modified_by: The username or email of the last person to edit the role.
        :param _builtins.str name: The role's name.
        :param _builtins.str role_id: A unique identifier for each role.
        :param _builtins.str time_created: ISO 8601 timestamp indicating when the role was originally created.
        :param _builtins.str time_modified: ISO 8601 timestamp indicating when the role was last updated.
        :param _builtins.str type: Whether the role is a standard role or a custom role.
        """
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_modified", time_modified)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The user name or email of the person who created the role.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The role's description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> _builtins.str:
        """
        The username or email of the last person to edit the role.
        """
        return pulumi.get(self, "modified_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The role's name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        A unique identifier for each role.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the role was originally created.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the role was last updated.
        """
        return pulumi.get(self, "time_modified")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Whether the role is a standard role or a custom role.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIamTimezonesTimezoneResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 offset: _builtins.str,
                 posix: _builtins.str,
                 timezone: _builtins.str):
        """
        :param _builtins.str description: The description of a time zone, including the GMT +/-.
        :param _builtins.str offset: The time zone offset from GMT.
        :param _builtins.str posix: The time zone posix.
        :param _builtins.str timezone: The time zone ID.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "posix", posix)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of a time zone, including the GMT +/-.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.str:
        """
        The time zone offset from GMT.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def posix(self) -> _builtins.str:
        """
        The time zone posix.
        """
        return pulumi.get(self, "posix")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The time zone ID.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetIamUsersAffectedByMovingGroupUserResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_login_date: _builtins.str,
                 last_name: _builtins.str,
                 ui_identity_id: _builtins.str,
                 ui_username: _builtins.str):
        """
        :param _builtins.str account_id: Unique identifier for each account.
        :param _builtins.str email: The user's email address.
        :param _builtins.str first_name: The user's first name.
        :param _builtins.str last_login_date: ISO 8601 timestamp indicating when the user last logged in.
        :param _builtins.str last_name: The user's surname.
        :param _builtins.str ui_identity_id: Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        :param _builtins.str ui_username: The user's username in Control Center.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_login_date", last_login_date)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "ui_identity_id", ui_identity_id)
        pulumi.set(__self__, "ui_username", ui_username)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        Unique identifier for each account.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The user's email address.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        The user's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastLoginDate")
    def last_login_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the user last logged in.
        """
        return pulumi.get(self, "last_login_date")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        The user's surname.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="uiIdentityId")
    def ui_identity_id(self) -> _builtins.str:
        """
        Unique identifier for each user, which corresponds to their Control Center profile or client ID. Also known as a contactId in other APIs.
        """
        return pulumi.get(self, "ui_identity_id")

    @_builtins.property
    @pulumi.getter(name="uiUsername")
    def ui_username(self) -> _builtins.str:
        """
        The user's username in Control Center.
        """
        return pulumi.get(self, "ui_username")


@pulumi.output_type
class GetImagingPolicyImagePolicyResult(dict):
    def __init__(__self__, *,
                 breakpoints: Optional['outputs.GetImagingPolicyImagePolicyBreakpointsResult'] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 output: Optional['outputs.GetImagingPolicyImagePolicyOutputResult'] = None,
                 post_breakpoint_transformations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']] = None,
                 rollout_duration: Optional[_builtins.str] = None,
                 serve_stale_duration: Optional[_builtins.str] = None,
                 transformations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResult']] = None,
                 variables: Optional[Sequence['outputs.GetImagingPolicyImagePolicyVariableResult']] = None):
        """
        :param 'GetImagingPolicyImagePolicyBreakpointsArgs' breakpoints: The breakpoint widths (in pixels) to use to create derivative images/videos.
        :param Sequence[_builtins.str] hosts: Hosts that are allowed for image/video URLs within transformations or variables.
        :param 'GetImagingPolicyImagePolicyOutputArgs' output: Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] post_breakpoint_transformations: Post-processing Transformations are applied to the image after image and quality settings have been applied.
        :param _builtins.str rollout_duration: The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        :param _builtins.str serve_stale_duration: The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
        :param Sequence['GetImagingPolicyImagePolicyTransformationArgs'] transformations: Set of image transformations to apply to the source image. If unspecified, no operations are performed.
        :param Sequence['GetImagingPolicyImagePolicyVariableArgs'] variables: Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        if breakpoints is not None:
            pulumi.set(__self__, "breakpoints", breakpoints)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if post_breakpoint_transformations is not None:
            pulumi.set(__self__, "post_breakpoint_transformations", post_breakpoint_transformations)
        if rollout_duration is not None:
            pulumi.set(__self__, "rollout_duration", rollout_duration)
        if serve_stale_duration is not None:
            pulumi.set(__self__, "serve_stale_duration", serve_stale_duration)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def breakpoints(self) -> Optional['outputs.GetImagingPolicyImagePolicyBreakpointsResult']:
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        return pulumi.get(self, "breakpoints")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.GetImagingPolicyImagePolicyOutputResult']:
        """
        Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="postBreakpointTransformations")
    def post_breakpoint_transformations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']]:
        """
        Post-processing Transformations are applied to the image after image and quality settings have been applied.
        """
        return pulumi.get(self, "post_breakpoint_transformations")

    @_builtins.property
    @pulumi.getter(name="rolloutDuration")
    def rollout_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        return pulumi.get(self, "rollout_duration")

    @_builtins.property
    @pulumi.getter(name="serveStaleDuration")
    def serve_stale_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
        """
        return pulumi.get(self, "serve_stale_duration")

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResult']]:
        """
        Set of image transformations to apply to the source image. If unspecified, no operations are performed.
        """
        return pulumi.get(self, "transformations")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyVariableResult']]:
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetImagingPolicyImagePolicyBreakpointsResult(dict):
    def __init__(__self__, *,
                 widths: Optional[Sequence[_builtins.int]] = None):
        if widths is not None:
            pulumi.set(__self__, "widths", widths)

    @_builtins.property
    @pulumi.getter
    def widths(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "widths")


@pulumi.output_type
class GetImagingPolicyImagePolicyOutputResult(dict):
    def __init__(__self__, *,
                 adaptive_quality: Optional[_builtins.str] = None,
                 allow_pristine_on_downsize: Optional[_builtins.str] = None,
                 allowed_formats: Optional[Sequence[_builtins.str]] = None,
                 forced_formats: Optional[Sequence[_builtins.str]] = None,
                 perceptual_quality: Optional[_builtins.str] = None,
                 perceptual_quality_floor: Optional[_builtins.str] = None,
                 perceptual_quality_var: Optional[_builtins.str] = None,
                 prefer_modern_formats: Optional[_builtins.str] = None,
                 quality: Optional[_builtins.str] = None,
                 quality_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str adaptive_quality: Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
        :param _builtins.str allow_pristine_on_downsize: Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
        :param Sequence[_builtins.str] allowed_formats: The graphics file formats allowed for browser specific results.
        :param Sequence[_builtins.str] forced_formats: The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
        :param _builtins.str perceptual_quality: Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        :param _builtins.str perceptual_quality_floor: Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
        :param _builtins.str perceptual_quality_var: Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        :param _builtins.str prefer_modern_formats: Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
        :param _builtins.str quality: Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        :param _builtins.str quality_var: Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        if adaptive_quality is not None:
            pulumi.set(__self__, "adaptive_quality", adaptive_quality)
        if allow_pristine_on_downsize is not None:
            pulumi.set(__self__, "allow_pristine_on_downsize", allow_pristine_on_downsize)
        if allowed_formats is not None:
            pulumi.set(__self__, "allowed_formats", allowed_formats)
        if forced_formats is not None:
            pulumi.set(__self__, "forced_formats", forced_formats)
        if perceptual_quality is not None:
            pulumi.set(__self__, "perceptual_quality", perceptual_quality)
        if perceptual_quality_floor is not None:
            pulumi.set(__self__, "perceptual_quality_floor", perceptual_quality_floor)
        if perceptual_quality_var is not None:
            pulumi.set(__self__, "perceptual_quality_var", perceptual_quality_var)
        if prefer_modern_formats is not None:
            pulumi.set(__self__, "prefer_modern_formats", prefer_modern_formats)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if quality_var is not None:
            pulumi.set(__self__, "quality_var", quality_var)

    @_builtins.property
    @pulumi.getter(name="adaptiveQuality")
    def adaptive_quality(self) -> Optional[_builtins.str]:
        """
        Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
        """
        return pulumi.get(self, "adaptive_quality")

    @_builtins.property
    @pulumi.getter(name="allowPristineOnDownsize")
    def allow_pristine_on_downsize(self) -> Optional[_builtins.str]:
        """
        Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
        """
        return pulumi.get(self, "allow_pristine_on_downsize")

    @_builtins.property
    @pulumi.getter(name="allowedFormats")
    def allowed_formats(self) -> Optional[Sequence[_builtins.str]]:
        """
        The graphics file formats allowed for browser specific results.
        """
        return pulumi.get(self, "allowed_formats")

    @_builtins.property
    @pulumi.getter(name="forcedFormats")
    def forced_formats(self) -> Optional[Sequence[_builtins.str]]:
        """
        The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
        """
        return pulumi.get(self, "forced_formats")

    @_builtins.property
    @pulumi.getter(name="perceptualQuality")
    def perceptual_quality(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        return pulumi.get(self, "perceptual_quality")

    @_builtins.property
    @pulumi.getter(name="perceptualQualityFloor")
    def perceptual_quality_floor(self) -> Optional[_builtins.str]:
        """
        Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
        """
        return pulumi.get(self, "perceptual_quality_floor")

    @_builtins.property
    @pulumi.getter(name="perceptualQualityVar")
    def perceptual_quality_var(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        return pulumi.get(self, "perceptual_quality_var")

    @_builtins.property
    @pulumi.getter(name="preferModernFormats")
    def prefer_modern_formats(self) -> Optional[_builtins.str]:
        """
        Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
        """
        return pulumi.get(self, "prefer_modern_formats")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter(name="qualityVar")
    def quality_var(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        return pulumi.get(self, "quality_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationResult(dict):
    def __init__(__self__, *,
                 background_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorResult']] = None,
                 blurs: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBlurResult']] = None,
                 chroma_keys: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyResult']] = None,
                 composites: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeResult']] = None,
                 compounds: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundResult']] = None,
                 contrasts: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationContrastResult']] = None,
                 goops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGoopResult']] = None,
                 grayscales: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleResult']] = None,
                 hsls: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHslResult']] = None,
                 hsvs: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHsvResult']] = None,
                 if_dimensions: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionResult']] = None,
                 if_orientations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationResult']] = None,
                 max_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorResult']] = None,
                 mirrors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorResult']] = None,
                 mono_hues: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueResult']] = None,
                 opacities: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityResult']] = None,
                 remove_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorResult']] = None,
                 unsharp_masks: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs'] background_colors: Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs'] blurs: Applies a Gaussian blur to the image.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs'] chroma_keys: Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs'] composites: Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs'] contrasts: Adjusts both the contrast and brightness of an image.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs'] goops: Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs'] grayscales: Restricts image color to shades of gray only.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs'] hsls: Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs'] hsvs: Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs'] max_colors: Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs'] mirrors: Flips an image horizontally, vertically, or both.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs'] mono_hues: Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs'] opacities: Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs'] remove_colors: Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs'] unsharp_masks: Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        if background_colors is not None:
            pulumi.set(__self__, "background_colors", background_colors)
        if blurs is not None:
            pulumi.set(__self__, "blurs", blurs)
        if chroma_keys is not None:
            pulumi.set(__self__, "chroma_keys", chroma_keys)
        if composites is not None:
            pulumi.set(__self__, "composites", composites)
        if compounds is not None:
            pulumi.set(__self__, "compounds", compounds)
        if contrasts is not None:
            pulumi.set(__self__, "contrasts", contrasts)
        if goops is not None:
            pulumi.set(__self__, "goops", goops)
        if grayscales is not None:
            pulumi.set(__self__, "grayscales", grayscales)
        if hsls is not None:
            pulumi.set(__self__, "hsls", hsls)
        if hsvs is not None:
            pulumi.set(__self__, "hsvs", hsvs)
        if if_dimensions is not None:
            pulumi.set(__self__, "if_dimensions", if_dimensions)
        if if_orientations is not None:
            pulumi.set(__self__, "if_orientations", if_orientations)
        if max_colors is not None:
            pulumi.set(__self__, "max_colors", max_colors)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)
        if mono_hues is not None:
            pulumi.set(__self__, "mono_hues", mono_hues)
        if opacities is not None:
            pulumi.set(__self__, "opacities", opacities)
        if remove_colors is not None:
            pulumi.set(__self__, "remove_colors", remove_colors)
        if unsharp_masks is not None:
            pulumi.set(__self__, "unsharp_masks", unsharp_masks)

    @_builtins.property
    @pulumi.getter(name="backgroundColors")
    def background_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorResult']]:
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        return pulumi.get(self, "background_colors")

    @_builtins.property
    @pulumi.getter
    def blurs(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationBlurResult']]:
        """
        Applies a Gaussian blur to the image.
        """
        return pulumi.get(self, "blurs")

    @_builtins.property
    @pulumi.getter(name="chromaKeys")
    def chroma_keys(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyResult']]:
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        return pulumi.get(self, "chroma_keys")

    @_builtins.property
    @pulumi.getter
    def composites(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeResult']]:
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        return pulumi.get(self, "composites")

    @_builtins.property
    @pulumi.getter
    def compounds(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundResult']]:
        return pulumi.get(self, "compounds")

    @_builtins.property
    @pulumi.getter
    def contrasts(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationContrastResult']]:
        """
        Adjusts both the contrast and brightness of an image.
        """
        return pulumi.get(self, "contrasts")

    @_builtins.property
    @pulumi.getter
    def goops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGoopResult']]:
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        return pulumi.get(self, "goops")

    @_builtins.property
    @pulumi.getter
    def grayscales(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleResult']]:
        """
        Restricts image color to shades of gray only.
        """
        return pulumi.get(self, "grayscales")

    @_builtins.property
    @pulumi.getter
    def hsls(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHslResult']]:
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        return pulumi.get(self, "hsls")

    @_builtins.property
    @pulumi.getter
    def hsvs(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationHsvResult']]:
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        return pulumi.get(self, "hsvs")

    @_builtins.property
    @pulumi.getter(name="ifDimensions")
    def if_dimensions(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionResult']]:
        return pulumi.get(self, "if_dimensions")

    @_builtins.property
    @pulumi.getter(name="ifOrientations")
    def if_orientations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationResult']]:
        return pulumi.get(self, "if_orientations")

    @_builtins.property
    @pulumi.getter(name="maxColors")
    def max_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorResult']]:
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        return pulumi.get(self, "max_colors")

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorResult']]:
        """
        Flips an image horizontally, vertically, or both.
        """
        return pulumi.get(self, "mirrors")

    @_builtins.property
    @pulumi.getter(name="monoHues")
    def mono_hues(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueResult']]:
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        return pulumi.get(self, "mono_hues")

    @_builtins.property
    @pulumi.getter
    def opacities(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityResult']]:
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        return pulumi.get(self, "opacities")

    @_builtins.property
    @pulumi.getter(name="removeColors")
    def remove_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorResult']]:
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        return pulumi.get(self, "remove_colors")

    @_builtins.property
    @pulumi.getter(name="unsharpMasks")
    def unsharp_masks(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskResult']]:
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        return pulumi.get(self, "unsharp_masks")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value for the background.
        :param _builtins.str color_var: The hexadecimal CSS color value for the background.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationBlurResult(dict):
    def __init__(__self__, *,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str sigma: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        :param _builtins.str sigma_var: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma")

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_feather: Optional[_builtins.str] = None,
                 hue_feather_var: Optional[_builtins.str] = None,
                 hue_tolerance: Optional[_builtins.str] = None,
                 hue_tolerance_var: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness_feather: Optional[_builtins.str] = None,
                 lightness_feather_var: Optional[_builtins.str] = None,
                 lightness_tolerance: Optional[_builtins.str] = None,
                 lightness_tolerance_var: Optional[_builtins.str] = None,
                 saturation_feather: Optional[_builtins.str] = None,
                 saturation_feather_var: Optional[_builtins.str] = None,
                 saturation_tolerance: Optional[_builtins.str] = None,
                 saturation_tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        :param _builtins.str hue_feather: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        :param _builtins.str hue_feather_var: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        :param _builtins.str hue_tolerance: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        :param _builtins.str hue_tolerance_var: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        :param _builtins.str hue_var: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        :param _builtins.str lightness_feather: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_feather_var: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_tolerance: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str lightness_tolerance_var: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str saturation_feather: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_feather_var: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_tolerance: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        :param _builtins.str saturation_tolerance_var: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_feather is not None:
            pulumi.set(__self__, "hue_feather", hue_feather)
        if hue_feather_var is not None:
            pulumi.set(__self__, "hue_feather_var", hue_feather_var)
        if hue_tolerance is not None:
            pulumi.set(__self__, "hue_tolerance", hue_tolerance)
        if hue_tolerance_var is not None:
            pulumi.set(__self__, "hue_tolerance_var", hue_tolerance_var)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness_feather is not None:
            pulumi.set(__self__, "lightness_feather", lightness_feather)
        if lightness_feather_var is not None:
            pulumi.set(__self__, "lightness_feather_var", lightness_feather_var)
        if lightness_tolerance is not None:
            pulumi.set(__self__, "lightness_tolerance", lightness_tolerance)
        if lightness_tolerance_var is not None:
            pulumi.set(__self__, "lightness_tolerance_var", lightness_tolerance_var)
        if saturation_feather is not None:
            pulumi.set(__self__, "saturation_feather", saturation_feather)
        if saturation_feather_var is not None:
            pulumi.set(__self__, "saturation_feather_var", saturation_feather_var)
        if saturation_tolerance is not None:
            pulumi.set(__self__, "saturation_tolerance", saturation_tolerance)
        if saturation_tolerance_var is not None:
            pulumi.set(__self__, "saturation_tolerance_var", saturation_tolerance_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueFeather")
    def hue_feather(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather")

    @_builtins.property
    @pulumi.getter(name="hueFeatherVar")
    def hue_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather_var")

    @_builtins.property
    @pulumi.getter(name="hueTolerance")
    def hue_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance")

    @_builtins.property
    @pulumi.getter(name="hueToleranceVar")
    def hue_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance_var")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter(name="lightnessFeather")
    def lightness_feather(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather")

    @_builtins.property
    @pulumi.getter(name="lightnessFeatherVar")
    def lightness_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather_var")

    @_builtins.property
    @pulumi.getter(name="lightnessTolerance")
    def lightness_tolerance(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance")

    @_builtins.property
    @pulumi.getter(name="lightnessToleranceVar")
    def lightness_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance_var")

    @_builtins.property
    @pulumi.getter(name="saturationFeather")
    def saturation_feather(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather")

    @_builtins.property
    @pulumi.getter(name="saturationFeatherVar")
    def saturation_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather_var")

    @_builtins.property
    @pulumi.getter(name="saturationTolerance")
    def saturation_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance")

    @_builtins.property
    @pulumi.getter(name="saturationToleranceVar")
    def saturation_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeResult(dict):
    def __init__(__self__, *,
                 image: 'outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageResult',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 placement: Optional[_builtins.str] = None,
                 placement_var: Optional[_builtins.str] = None,
                 scale: Optional[_builtins.str] = None,
                 scale_dimension: Optional[_builtins.str] = None,
                 scale_dimension_var: Optional[_builtins.str] = None,
                 scale_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str gravity_var: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str placement: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str placement_var: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str scale: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str scale_dimension: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_dimension_var: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_var: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str x_position: The x-axis position of the image to apply.
        :param _builtins.str x_position_var: The x-axis position of the image to apply.
        :param _builtins.str y_position: The y-axis position of the image to apply.
        :param _builtins.str y_position_var: The y-axis position of the image to apply.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if placement_var is not None:
            pulumi.set(__self__, "placement_var", placement_var)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if scale_dimension is not None:
            pulumi.set(__self__, "scale_dimension", scale_dimension)
        if scale_dimension_var is not None:
            pulumi.set(__self__, "scale_dimension_var", scale_dimension_var)
        if scale_var is not None:
            pulumi.set(__self__, "scale_var", scale_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageResult':
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter(name="placementVar")
    def placement_var(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement_var")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="scaleDimension")
    def scale_dimension(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension")

    @_builtins.property
    @pulumi.getter(name="scaleDimensionVar")
    def scale_dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension_var")

    @_builtins.property
    @pulumi.getter(name="scaleVar")
    def scale_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale_var")

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position")

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position_var")

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position")

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageResult(dict):
    def __init__(__self__, *,
                 box_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageResult']] = None,
                 circle_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageResult']] = None,
                 text_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageResult']] = None,
                 url_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageResult']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageResult']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageResult(dict):
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageResult(dict):
    def __init__(__self__, *,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundResult(dict):
    def __init__(__self__, *,
                 transformations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']] = None):
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']]:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationContrastResult(dict):
    def __init__(__self__, *,
                 brightness: Optional[_builtins.str] = None,
                 brightness_var: Optional[_builtins.str] = None,
                 contrast: Optional[_builtins.str] = None,
                 contrast_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str brightness: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str brightness_var: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str contrast: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        :param _builtins.str contrast_var: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if brightness_var is not None:
            pulumi.set(__self__, "brightness_var", brightness_var)
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if contrast_var is not None:
            pulumi.set(__self__, "contrast_var", contrast_var)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness")

    @_builtins.property
    @pulumi.getter(name="brightnessVar")
    def brightness_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness_var")

    @_builtins.property
    @pulumi.getter
    def contrast(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast")

    @_builtins.property
    @pulumi.getter(name="contrastVar")
    def contrast_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationGoopResult(dict):
    def __init__(__self__, *,
                 chaos: Optional[_builtins.str] = None,
                 chaos_var: Optional[_builtins.str] = None,
                 density: Optional[_builtins.str] = None,
                 density_var: Optional[_builtins.str] = None,
                 power: Optional[_builtins.str] = None,
                 power_var: Optional[_builtins.str] = None,
                 seed: Optional[_builtins.str] = None,
                 seed_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str chaos: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str chaos_var: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str density: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str density_var: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str power: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str power_var: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str seed: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        :param _builtins.str seed_var: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        if chaos is not None:
            pulumi.set(__self__, "chaos", chaos)
        if chaos_var is not None:
            pulumi.set(__self__, "chaos_var", chaos_var)
        if density is not None:
            pulumi.set(__self__, "density", density)
        if density_var is not None:
            pulumi.set(__self__, "density_var", density_var)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_var is not None:
            pulumi.set(__self__, "power_var", power_var)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)
        if seed_var is not None:
            pulumi.set(__self__, "seed_var", seed_var)

    @_builtins.property
    @pulumi.getter
    def chaos(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos")

    @_builtins.property
    @pulumi.getter(name="chaosVar")
    def chaos_var(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos_var")

    @_builtins.property
    @pulumi.getter
    def density(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density")

    @_builtins.property
    @pulumi.getter(name="densityVar")
    def density_var(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density_var")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerVar")
    def power_var(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power_var")

    @_builtins.property
    @pulumi.getter
    def seed(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed")

    @_builtins.property
    @pulumi.getter(name="seedVar")
    def seed_var(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleResult(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        :param _builtins.str type_var: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationHslResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness: Optional[_builtins.str] = None,
                 lightness_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str lightness: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str lightness_var: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness is not None:
            pulumi.set(__self__, "lightness", lightness)
        if lightness_var is not None:
            pulumi.set(__self__, "lightness_var", lightness_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter
    def lightness(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness")

    @_builtins.property
    @pulumi.getter(name="lightnessVar")
    def lightness_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness_var")

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationHsvResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str value: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        :param _builtins.str value_var: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionResult(dict):
    def __init__(__self__, *,
                 default: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 dimension: Optional[_builtins.str] = None,
                 dimension_var: Optional[_builtins.str] = None,
                 equal: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 greater_than: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 less_than: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str dimension: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str dimension_var: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str value: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        :param _builtins.str value_var: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_var is not None:
            pulumi.set(__self__, "dimension_var", dimension_var)
        if equal is not None:
            pulumi.set(__self__, "equal", equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="dimensionVar")
    def dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension_var")

    @_builtins.property
    @pulumi.getter
    def equal(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "equal")

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "greater_than")

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "less_than")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationResult(dict):
    def __init__(__self__, *,
                 default: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 landscape: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 portrait: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None,
                 square: Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult'] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if landscape is not None:
            pulumi.set(__self__, "landscape", landscape)
        if portrait is not None:
            pulumi.set(__self__, "portrait", portrait)
        if square is not None:
            pulumi.set(__self__, "square", square)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def landscape(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "landscape")

    @_builtins.property
    @pulumi.getter
    def portrait(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "portrait")

    @_builtins.property
    @pulumi.getter
    def square(self) -> Optional['outputs.GetImagingPolicyImagePolicyPostBreakpointTransformationResult']:
        return pulumi.get(self, "square")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorResult(dict):
    def __init__(__self__, *,
                 colors: Optional[_builtins.str] = None,
                 colors_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str colors: The value representing the maximum number of colors to use with the source image.
        :param _builtins.str colors_var: The value representing the maximum number of colors to use with the source image.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if colors_var is not None:
            pulumi.set(__self__, "colors_var", colors_var)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="colorsVar")
    def colors_var(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorResult(dict):
    def __init__(__self__, *,
                 horizontal: Optional[_builtins.str] = None,
                 horizontal_var: Optional[_builtins.str] = None,
                 vertical: Optional[_builtins.str] = None,
                 vertical_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str horizontal: Flips the image horizontally.
        :param _builtins.str horizontal_var: Flips the image horizontally.
        :param _builtins.str vertical: Flips the image vertically.
        :param _builtins.str vertical_var: Flips the image vertically.
        """
        if horizontal is not None:
            pulumi.set(__self__, "horizontal", horizontal)
        if horizontal_var is not None:
            pulumi.set(__self__, "horizontal_var", horizontal_var)
        if vertical is not None:
            pulumi.set(__self__, "vertical", vertical)
        if vertical_var is not None:
            pulumi.set(__self__, "vertical_var", vertical_var)

    @_builtins.property
    @pulumi.getter
    def horizontal(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal")

    @_builtins.property
    @pulumi.getter(name="horizontalVar")
    def horizontal_var(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal_var")

    @_builtins.property
    @pulumi.getter
    def vertical(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical")

    @_builtins.property
    @pulumi.getter(name="verticalVar")
    def vertical_var(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        :param _builtins.str hue_var: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityResult(dict):
    def __init__(__self__, *,
                 opacity: Optional[_builtins.str] = None,
                 opacity_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str opacity: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        :param _builtins.str opacity_var: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if opacity_var is not None:
            pulumi.set(__self__, "opacity_var", opacity_var)

    @_builtins.property
    @pulumi.getter
    def opacity(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity")

    @_builtins.property
    @pulumi.getter(name="opacityVar")
    def opacity_var(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 feather: Optional[_builtins.str] = None,
                 feather_var: Optional[_builtins.str] = None,
                 tolerance: Optional[_builtins.str] = None,
                 tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value to remove.
        :param _builtins.str color_var: The hexadecimal CSS color value to remove.
        :param _builtins.str feather: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str feather_var: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str tolerance: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        :param _builtins.str tolerance_var: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if feather is not None:
            pulumi.set(__self__, "feather", feather)
        if feather_var is not None:
            pulumi.set(__self__, "feather_var", feather_var)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)
        if tolerance_var is not None:
            pulumi.set(__self__, "tolerance_var", tolerance_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def feather(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather")

    @_builtins.property
    @pulumi.getter(name="featherVar")
    def feather_var(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather_var")

    @_builtins.property
    @pulumi.getter
    def tolerance(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance")

    @_builtins.property
    @pulumi.getter(name="toleranceVar")
    def tolerance_var(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskResult(dict):
    def __init__(__self__, *,
                 gain: Optional[_builtins.str] = None,
                 gain_var: Optional[_builtins.str] = None,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 threshold_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gain: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str gain_var: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str sigma: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str sigma_var: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str threshold: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        :param _builtins.str threshold_var: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        if gain is not None:
            pulumi.set(__self__, "gain", gain)
        if gain_var is not None:
            pulumi.set(__self__, "gain_var", gain_var)
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_var is not None:
            pulumi.set(__self__, "threshold_var", threshold_var)

    @_builtins.property
    @pulumi.getter
    def gain(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain")

    @_builtins.property
    @pulumi.getter(name="gainVar")
    def gain_var(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain_var")

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma")

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma_var")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="thresholdVar")
    def threshold_var(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationResult(dict):
    def __init__(__self__, *,
                 appends: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendResult']] = None,
                 aspect_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAspectCropResult']] = None,
                 background_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationBackgroundColorResult']] = None,
                 blurs: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationBlurResult']] = None,
                 chroma_keys: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationChromaKeyResult']] = None,
                 composites: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeResult']] = None,
                 compounds: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompoundResult']] = None,
                 contrasts: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationContrastResult']] = None,
                 crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCropResult']] = None,
                 face_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFaceCropResult']] = None,
                 feature_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFeatureCropResult']] = None,
                 fit_and_fills: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFitAndFillResult']] = None,
                 goops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationGoopResult']] = None,
                 grayscales: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationGrayscaleResult']] = None,
                 hsls: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationHslResult']] = None,
                 hsvs: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationHsvResult']] = None,
                 if_dimensions: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationIfDimensionResult']] = None,
                 if_orientations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationIfOrientationResult']] = None,
                 im_queries: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationImQueryResult']] = None,
                 max_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMaxColorResult']] = None,
                 mirrors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMirrorResult']] = None,
                 mono_hues: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMonoHueResult']] = None,
                 opacities: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationOpacityResult']] = None,
                 region_of_interest_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropResult']] = None,
                 relative_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRelativeCropResult']] = None,
                 remove_colors: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRemoveColorResult']] = None,
                 resizes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResizeResult']] = None,
                 rotates: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRotateResult']] = None,
                 scales: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationScaleResult']] = None,
                 shears: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationShearsResult']] = None,
                 smart_crops: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationSmartCropResult']] = None,
                 trims: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationTrimResult']] = None,
                 unsharp_masks: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationUnsharpMaskResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendArgs'] appends: Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgs'] aspect_crops: Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
        :param Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgs'] background_colors: Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        :param Sequence['GetImagingPolicyImagePolicyTransformationBlurArgs'] blurs: Applies a Gaussian blur to the image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgs'] chroma_keys: Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgs'] composites: Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        :param Sequence['GetImagingPolicyImagePolicyTransformationContrastArgs'] contrasts: Adjusts both the contrast and brightness of an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCropArgs'] crops: Crops an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgs'] face_crops: Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgs'] feature_crops: Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgs'] fit_and_fills: Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
        :param Sequence['GetImagingPolicyImagePolicyTransformationGoopArgs'] goops: Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        :param Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgs'] grayscales: Restricts image color to shades of gray only.
        :param Sequence['GetImagingPolicyImagePolicyTransformationHslArgs'] hsls: Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        :param Sequence['GetImagingPolicyImagePolicyTransformationHsvArgs'] hsvs: Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        :param Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgs'] im_queries: Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgs'] max_colors: Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgs'] mirrors: Flips an image horizontally, vertically, or both.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgs'] mono_hues: Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        :param Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgs'] opacities: Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs'] region_of_interest_crops: Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgs'] relative_crops: Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgs'] remove_colors: Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        :param Sequence['GetImagingPolicyImagePolicyTransformationResizeArgs'] resizes: Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRotateArgs'] rotates: Rotate the image around its center by indicating the degrees of rotation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationScaleArgs'] scales: Changes the image's size to different dimensions relative to its starting size.
        :param Sequence['GetImagingPolicyImagePolicyTransformationShearsArgs'] shears: Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
        :param Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgs'] smart_crops: Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
        :param Sequence['GetImagingPolicyImagePolicyTransformationTrimArgs'] trims: Automatically crops uniform backgrounds from the edges of an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs'] unsharp_masks: Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if aspect_crops is not None:
            pulumi.set(__self__, "aspect_crops", aspect_crops)
        if background_colors is not None:
            pulumi.set(__self__, "background_colors", background_colors)
        if blurs is not None:
            pulumi.set(__self__, "blurs", blurs)
        if chroma_keys is not None:
            pulumi.set(__self__, "chroma_keys", chroma_keys)
        if composites is not None:
            pulumi.set(__self__, "composites", composites)
        if compounds is not None:
            pulumi.set(__self__, "compounds", compounds)
        if contrasts is not None:
            pulumi.set(__self__, "contrasts", contrasts)
        if crops is not None:
            pulumi.set(__self__, "crops", crops)
        if face_crops is not None:
            pulumi.set(__self__, "face_crops", face_crops)
        if feature_crops is not None:
            pulumi.set(__self__, "feature_crops", feature_crops)
        if fit_and_fills is not None:
            pulumi.set(__self__, "fit_and_fills", fit_and_fills)
        if goops is not None:
            pulumi.set(__self__, "goops", goops)
        if grayscales is not None:
            pulumi.set(__self__, "grayscales", grayscales)
        if hsls is not None:
            pulumi.set(__self__, "hsls", hsls)
        if hsvs is not None:
            pulumi.set(__self__, "hsvs", hsvs)
        if if_dimensions is not None:
            pulumi.set(__self__, "if_dimensions", if_dimensions)
        if if_orientations is not None:
            pulumi.set(__self__, "if_orientations", if_orientations)
        if im_queries is not None:
            pulumi.set(__self__, "im_queries", im_queries)
        if max_colors is not None:
            pulumi.set(__self__, "max_colors", max_colors)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)
        if mono_hues is not None:
            pulumi.set(__self__, "mono_hues", mono_hues)
        if opacities is not None:
            pulumi.set(__self__, "opacities", opacities)
        if region_of_interest_crops is not None:
            pulumi.set(__self__, "region_of_interest_crops", region_of_interest_crops)
        if relative_crops is not None:
            pulumi.set(__self__, "relative_crops", relative_crops)
        if remove_colors is not None:
            pulumi.set(__self__, "remove_colors", remove_colors)
        if resizes is not None:
            pulumi.set(__self__, "resizes", resizes)
        if rotates is not None:
            pulumi.set(__self__, "rotates", rotates)
        if scales is not None:
            pulumi.set(__self__, "scales", scales)
        if shears is not None:
            pulumi.set(__self__, "shears", shears)
        if smart_crops is not None:
            pulumi.set(__self__, "smart_crops", smart_crops)
        if trims is not None:
            pulumi.set(__self__, "trims", trims)
        if unsharp_masks is not None:
            pulumi.set(__self__, "unsharp_masks", unsharp_masks)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendResult']]:
        """
        Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
        """
        return pulumi.get(self, "appends")

    @_builtins.property
    @pulumi.getter(name="aspectCrops")
    def aspect_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAspectCropResult']]:
        """
        Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
        """
        return pulumi.get(self, "aspect_crops")

    @_builtins.property
    @pulumi.getter(name="backgroundColors")
    def background_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationBackgroundColorResult']]:
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        return pulumi.get(self, "background_colors")

    @_builtins.property
    @pulumi.getter
    def blurs(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationBlurResult']]:
        """
        Applies a Gaussian blur to the image.
        """
        return pulumi.get(self, "blurs")

    @_builtins.property
    @pulumi.getter(name="chromaKeys")
    def chroma_keys(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationChromaKeyResult']]:
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        return pulumi.get(self, "chroma_keys")

    @_builtins.property
    @pulumi.getter
    def composites(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeResult']]:
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        return pulumi.get(self, "composites")

    @_builtins.property
    @pulumi.getter
    def compounds(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompoundResult']]:
        return pulumi.get(self, "compounds")

    @_builtins.property
    @pulumi.getter
    def contrasts(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationContrastResult']]:
        """
        Adjusts both the contrast and brightness of an image.
        """
        return pulumi.get(self, "contrasts")

    @_builtins.property
    @pulumi.getter
    def crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCropResult']]:
        """
        Crops an image.
        """
        return pulumi.get(self, "crops")

    @_builtins.property
    @pulumi.getter(name="faceCrops")
    def face_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFaceCropResult']]:
        """
        Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
        """
        return pulumi.get(self, "face_crops")

    @_builtins.property
    @pulumi.getter(name="featureCrops")
    def feature_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFeatureCropResult']]:
        """
        Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "feature_crops")

    @_builtins.property
    @pulumi.getter(name="fitAndFills")
    def fit_and_fills(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationFitAndFillResult']]:
        """
        Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
        """
        return pulumi.get(self, "fit_and_fills")

    @_builtins.property
    @pulumi.getter
    def goops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationGoopResult']]:
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        return pulumi.get(self, "goops")

    @_builtins.property
    @pulumi.getter
    def grayscales(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationGrayscaleResult']]:
        """
        Restricts image color to shades of gray only.
        """
        return pulumi.get(self, "grayscales")

    @_builtins.property
    @pulumi.getter
    def hsls(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationHslResult']]:
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        return pulumi.get(self, "hsls")

    @_builtins.property
    @pulumi.getter
    def hsvs(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationHsvResult']]:
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        return pulumi.get(self, "hsvs")

    @_builtins.property
    @pulumi.getter(name="ifDimensions")
    def if_dimensions(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationIfDimensionResult']]:
        return pulumi.get(self, "if_dimensions")

    @_builtins.property
    @pulumi.getter(name="ifOrientations")
    def if_orientations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationIfOrientationResult']]:
        return pulumi.get(self, "if_orientations")

    @_builtins.property
    @pulumi.getter(name="imQueries")
    def im_queries(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationImQueryResult']]:
        """
        Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
        """
        return pulumi.get(self, "im_queries")

    @_builtins.property
    @pulumi.getter(name="maxColors")
    def max_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMaxColorResult']]:
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        return pulumi.get(self, "max_colors")

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMirrorResult']]:
        """
        Flips an image horizontally, vertically, or both.
        """
        return pulumi.get(self, "mirrors")

    @_builtins.property
    @pulumi.getter(name="monoHues")
    def mono_hues(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationMonoHueResult']]:
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original color’s lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        return pulumi.get(self, "mono_hues")

    @_builtins.property
    @pulumi.getter
    def opacities(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationOpacityResult']]:
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        return pulumi.get(self, "opacities")

    @_builtins.property
    @pulumi.getter(name="regionOfInterestCrops")
    def region_of_interest_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropResult']]:
        """
        Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "region_of_interest_crops")

    @_builtins.property
    @pulumi.getter(name="relativeCrops")
    def relative_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRelativeCropResult']]:
        """
        Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
        """
        return pulumi.get(self, "relative_crops")

    @_builtins.property
    @pulumi.getter(name="removeColors")
    def remove_colors(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRemoveColorResult']]:
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        return pulumi.get(self, "remove_colors")

    @_builtins.property
    @pulumi.getter
    def resizes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResizeResult']]:
        """
        Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
        """
        return pulumi.get(self, "resizes")

    @_builtins.property
    @pulumi.getter
    def rotates(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRotateResult']]:
        """
        Rotate the image around its center by indicating the degrees of rotation.
        """
        return pulumi.get(self, "rotates")

    @_builtins.property
    @pulumi.getter
    def scales(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationScaleResult']]:
        """
        Changes the image's size to different dimensions relative to its starting size.
        """
        return pulumi.get(self, "scales")

    @_builtins.property
    @pulumi.getter
    def shears(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationShearsResult']]:
        """
        Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
        """
        return pulumi.get(self, "shears")

    @_builtins.property
    @pulumi.getter(name="smartCrops")
    def smart_crops(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationSmartCropResult']]:
        """
        Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
        """
        return pulumi.get(self, "smart_crops")

    @_builtins.property
    @pulumi.getter
    def trims(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationTrimResult']]:
        """
        Automatically crops uniform backgrounds from the edges of an image.
        """
        return pulumi.get(self, "trims")

    @_builtins.property
    @pulumi.getter(name="unsharpMasks")
    def unsharp_masks(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationUnsharpMaskResult']]:
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        return pulumi.get(self, "unsharp_masks")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendResult(dict):
    def __init__(__self__, *,
                 image: 'outputs.GetImagingPolicyImagePolicyTransformationAppendImageResult',
                 gravity: Optional[_builtins.str] = None,
                 gravity_priority: Optional[_builtins.str] = None,
                 gravity_priority_var: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 preserve_minor_dimension: Optional[_builtins.str] = None,
                 preserve_minor_dimension_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        :param _builtins.str gravity_priority: Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        :param _builtins.str gravity_priority_var: Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        :param _builtins.str gravity_var: Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        :param _builtins.str preserve_minor_dimension: Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        :param _builtins.str preserve_minor_dimension_var: Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_priority is not None:
            pulumi.set(__self__, "gravity_priority", gravity_priority)
        if gravity_priority_var is not None:
            pulumi.set(__self__, "gravity_priority_var", gravity_priority_var)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if preserve_minor_dimension is not None:
            pulumi.set(__self__, "preserve_minor_dimension", preserve_minor_dimension)
        if preserve_minor_dimension_var is not None:
            pulumi.set(__self__, "preserve_minor_dimension_var", preserve_minor_dimension_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationAppendImageResult':
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityPriority")
    def gravity_priority(self) -> Optional[_builtins.str]:
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        return pulumi.get(self, "gravity_priority")

    @_builtins.property
    @pulumi.getter(name="gravityPriorityVar")
    def gravity_priority_var(self) -> Optional[_builtins.str]:
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        return pulumi.get(self, "gravity_priority_var")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter(name="preserveMinorDimension")
    def preserve_minor_dimension(self) -> Optional[_builtins.str]:
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        return pulumi.get(self, "preserve_minor_dimension")

    @_builtins.property
    @pulumi.getter(name="preserveMinorDimensionVar")
    def preserve_minor_dimension_var(self) -> Optional[_builtins.str]:
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        return pulumi.get(self, "preserve_minor_dimension_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendImageResult(dict):
    def __init__(__self__, *,
                 box_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageBoxImageResult']] = None,
                 circle_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageCircleImageResult']] = None,
                 text_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageTextImageResult']] = None,
                 url_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageUrlImageResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageBoxImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageCircleImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageTextImageResult']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationAppendImageUrlImageResult']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendImageBoxImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendImageCircleImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendImageTextImageResult(dict):
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAppendImageUrlImageResult(dict):
    def __init__(__self__, *,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationAspectCropResult(dict):
    def __init__(__self__, *,
                 allow_expansion: Optional[_builtins.str] = None,
                 allow_expansion_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_expansion: Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        :param _builtins.str allow_expansion_var: Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        :param _builtins.str height: The height term of the aspect ratio to crop.
        :param _builtins.str height_var: The height term of the aspect ratio to crop.
        :param _builtins.str width: The width term of the aspect ratio to crop.
        :param _builtins.str width_var: The width term of the aspect ratio to crop.
        :param _builtins.str x_position: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str x_position_var: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str y_position: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str y_position_var: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        if allow_expansion is not None:
            pulumi.set(__self__, "allow_expansion", allow_expansion)
        if allow_expansion_var is not None:
            pulumi.set(__self__, "allow_expansion_var", allow_expansion_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter(name="allowExpansion")
    def allow_expansion(self) -> Optional[_builtins.str]:
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        return pulumi.get(self, "allow_expansion")

    @_builtins.property
    @pulumi.getter(name="allowExpansionVar")
    def allow_expansion_var(self) -> Optional[_builtins.str]:
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        return pulumi.get(self, "allow_expansion_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height term of the aspect ratio to crop.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height term of the aspect ratio to crop.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width term of the aspect ratio to crop.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width term of the aspect ratio to crop.
        """
        return pulumi.get(self, "width_var")

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "x_position")

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "x_position_var")

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "y_position")

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "y_position_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationBackgroundColorResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value for the background.
        :param _builtins.str color_var: The hexadecimal CSS color value for the background.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationBlurResult(dict):
    def __init__(__self__, *,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str sigma: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        :param _builtins.str sigma_var: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma")

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationChromaKeyResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_feather: Optional[_builtins.str] = None,
                 hue_feather_var: Optional[_builtins.str] = None,
                 hue_tolerance: Optional[_builtins.str] = None,
                 hue_tolerance_var: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness_feather: Optional[_builtins.str] = None,
                 lightness_feather_var: Optional[_builtins.str] = None,
                 lightness_tolerance: Optional[_builtins.str] = None,
                 lightness_tolerance_var: Optional[_builtins.str] = None,
                 saturation_feather: Optional[_builtins.str] = None,
                 saturation_feather_var: Optional[_builtins.str] = None,
                 saturation_tolerance: Optional[_builtins.str] = None,
                 saturation_tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        :param _builtins.str hue_feather: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        :param _builtins.str hue_feather_var: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        :param _builtins.str hue_tolerance: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        :param _builtins.str hue_tolerance_var: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        :param _builtins.str hue_var: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        :param _builtins.str lightness_feather: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_feather_var: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_tolerance: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str lightness_tolerance_var: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str saturation_feather: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_feather_var: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_tolerance: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        :param _builtins.str saturation_tolerance_var: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_feather is not None:
            pulumi.set(__self__, "hue_feather", hue_feather)
        if hue_feather_var is not None:
            pulumi.set(__self__, "hue_feather_var", hue_feather_var)
        if hue_tolerance is not None:
            pulumi.set(__self__, "hue_tolerance", hue_tolerance)
        if hue_tolerance_var is not None:
            pulumi.set(__self__, "hue_tolerance_var", hue_tolerance_var)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness_feather is not None:
            pulumi.set(__self__, "lightness_feather", lightness_feather)
        if lightness_feather_var is not None:
            pulumi.set(__self__, "lightness_feather_var", lightness_feather_var)
        if lightness_tolerance is not None:
            pulumi.set(__self__, "lightness_tolerance", lightness_tolerance)
        if lightness_tolerance_var is not None:
            pulumi.set(__self__, "lightness_tolerance_var", lightness_tolerance_var)
        if saturation_feather is not None:
            pulumi.set(__self__, "saturation_feather", saturation_feather)
        if saturation_feather_var is not None:
            pulumi.set(__self__, "saturation_feather_var", saturation_feather_var)
        if saturation_tolerance is not None:
            pulumi.set(__self__, "saturation_tolerance", saturation_tolerance)
        if saturation_tolerance_var is not None:
            pulumi.set(__self__, "saturation_tolerance_var", saturation_tolerance_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueFeather")
    def hue_feather(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather")

    @_builtins.property
    @pulumi.getter(name="hueFeatherVar")
    def hue_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather_var")

    @_builtins.property
    @pulumi.getter(name="hueTolerance")
    def hue_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance")

    @_builtins.property
    @pulumi.getter(name="hueToleranceVar")
    def hue_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance_var")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter(name="lightnessFeather")
    def lightness_feather(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather")

    @_builtins.property
    @pulumi.getter(name="lightnessFeatherVar")
    def lightness_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather_var")

    @_builtins.property
    @pulumi.getter(name="lightnessTolerance")
    def lightness_tolerance(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance")

    @_builtins.property
    @pulumi.getter(name="lightnessToleranceVar")
    def lightness_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance_var")

    @_builtins.property
    @pulumi.getter(name="saturationFeather")
    def saturation_feather(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather")

    @_builtins.property
    @pulumi.getter(name="saturationFeatherVar")
    def saturation_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather_var")

    @_builtins.property
    @pulumi.getter(name="saturationTolerance")
    def saturation_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance")

    @_builtins.property
    @pulumi.getter(name="saturationToleranceVar")
    def saturation_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeResult(dict):
    def __init__(__self__, *,
                 image: 'outputs.GetImagingPolicyImagePolicyTransformationCompositeImageResult',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 placement: Optional[_builtins.str] = None,
                 placement_var: Optional[_builtins.str] = None,
                 scale: Optional[_builtins.str] = None,
                 scale_dimension: Optional[_builtins.str] = None,
                 scale_dimension_var: Optional[_builtins.str] = None,
                 scale_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str gravity_var: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str placement: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str placement_var: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str scale: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str scale_dimension: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_dimension_var: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_var: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str x_position: The x-axis position of the image to apply.
        :param _builtins.str x_position_var: The x-axis position of the image to apply.
        :param _builtins.str y_position: The y-axis position of the image to apply.
        :param _builtins.str y_position_var: The y-axis position of the image to apply.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if placement_var is not None:
            pulumi.set(__self__, "placement_var", placement_var)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if scale_dimension is not None:
            pulumi.set(__self__, "scale_dimension", scale_dimension)
        if scale_dimension_var is not None:
            pulumi.set(__self__, "scale_dimension_var", scale_dimension_var)
        if scale_var is not None:
            pulumi.set(__self__, "scale_var", scale_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationCompositeImageResult':
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter(name="placementVar")
    def placement_var(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement_var")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="scaleDimension")
    def scale_dimension(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension")

    @_builtins.property
    @pulumi.getter(name="scaleDimensionVar")
    def scale_dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension_var")

    @_builtins.property
    @pulumi.getter(name="scaleVar")
    def scale_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale_var")

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position")

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position_var")

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position")

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeImageResult(dict):
    def __init__(__self__, *,
                 box_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageResult']] = None,
                 circle_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageResult']] = None,
                 text_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageTextImageResult']] = None,
                 url_images: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageResult']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageTextImageResult']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageResult']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeImageTextImageResult(dict):
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageResult(dict):
    def __init__(__self__, *,
                 transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "transformation")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCompoundResult(dict):
    def __init__(__self__, *,
                 transformations: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResult']] = None):
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationResult']]:
        return pulumi.get(self, "transformations")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationContrastResult(dict):
    def __init__(__self__, *,
                 brightness: Optional[_builtins.str] = None,
                 brightness_var: Optional[_builtins.str] = None,
                 contrast: Optional[_builtins.str] = None,
                 contrast_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str brightness: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str brightness_var: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str contrast: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        :param _builtins.str contrast_var: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if brightness_var is not None:
            pulumi.set(__self__, "brightness_var", brightness_var)
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if contrast_var is not None:
            pulumi.set(__self__, "contrast_var", contrast_var)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness")

    @_builtins.property
    @pulumi.getter(name="brightnessVar")
    def brightness_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness_var")

    @_builtins.property
    @pulumi.getter
    def contrast(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast")

    @_builtins.property
    @pulumi.getter(name="contrastVar")
    def contrast_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationCropResult(dict):
    def __init__(__self__, *,
                 allow_expansion: Optional[_builtins.str] = None,
                 allow_expansion_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_expansion: If cropping an area outside of the existing canvas, expands the image canvas.
        :param _builtins.str allow_expansion_var: If cropping an area outside of the existing canvas, expands the image canvas.
        :param _builtins.str gravity: Frame of reference for X and Y Positions.
        :param _builtins.str gravity_var: Frame of reference for X and Y Positions.
        :param _builtins.str height: The number of pixels to crop along the y-axis.
        :param _builtins.str height_var: The number of pixels to crop along the y-axis.
        :param _builtins.str width: The number of pixels to crop along the x-axis.
        :param _builtins.str width_var: The number of pixels to crop along the x-axis.
        :param _builtins.str x_position: The x-axis position of the image to crop from.
        :param _builtins.str x_position_var: The x-axis position of the image to crop from.
        :param _builtins.str y_position: The y-axis position of the image to crop from.
        :param _builtins.str y_position_var: The y-axis position of the image to crop from.
        """
        if allow_expansion is not None:
            pulumi.set(__self__, "allow_expansion", allow_expansion)
        if allow_expansion_var is not None:
            pulumi.set(__self__, "allow_expansion_var", allow_expansion_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter(name="allowExpansion")
    def allow_expansion(self) -> Optional[_builtins.str]:
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        return pulumi.get(self, "allow_expansion")

    @_builtins.property
    @pulumi.getter(name="allowExpansionVar")
    def allow_expansion_var(self) -> Optional[_builtins.str]:
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        return pulumi.get(self, "allow_expansion_var")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Frame of reference for X and Y Positions.
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Frame of reference for X and Y Positions.
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the y-axis.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the y-axis.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the x-axis.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the x-axis.
        """
        return pulumi.get(self, "width_var")

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to crop from.
        """
        return pulumi.get(self, "x_position")

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to crop from.
        """
        return pulumi.get(self, "x_position_var")

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to crop from.
        """
        return pulumi.get(self, "y_position")

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to crop from.
        """
        return pulumi.get(self, "y_position_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationFaceCropResult(dict):
    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 algorithm_var: Optional[_builtins.str] = None,
                 confidence: Optional[_builtins.str] = None,
                 confidence_var: Optional[_builtins.str] = None,
                 fail_gravity: Optional[_builtins.str] = None,
                 fail_gravity_var: Optional[_builtins.str] = None,
                 focus: Optional[_builtins.str] = None,
                 focus_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str algorithm: Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        :param _builtins.str algorithm_var: Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        :param _builtins.str confidence: With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        :param _builtins.str confidence_var: With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        :param _builtins.str fail_gravity: Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str fail_gravity_var: Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str focus: Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        :param _builtins.str focus_var: Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        :param _builtins.str gravity: Controls placement of the crop. Directions are relative to the face(s) plus padding.
        :param _builtins.str gravity_var: Controls placement of the crop. Directions are relative to the face(s) plus padding.
        :param _builtins.str height: The height of the output image in pixels relative to the specified `style` value.
        :param _builtins.str height_var: The height of the output image in pixels relative to the specified `style` value.
        :param _builtins.str padding: The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        :param _builtins.str padding_var: The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str width: The width of the output image in pixels relative to the specified `style` value.
        :param _builtins.str width_var: The width of the output image in pixels relative to the specified `style` value.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if algorithm_var is not None:
            pulumi.set(__self__, "algorithm_var", algorithm_var)
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if confidence_var is not None:
            pulumi.set(__self__, "confidence_var", confidence_var)
        if fail_gravity is not None:
            pulumi.set(__self__, "fail_gravity", fail_gravity)
        if fail_gravity_var is not None:
            pulumi.set(__self__, "fail_gravity_var", fail_gravity_var)
        if focus is not None:
            pulumi.set(__self__, "focus", focus)
        if focus_var is not None:
            pulumi.set(__self__, "focus_var", focus_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="algorithmVar")
    def algorithm_var(self) -> Optional[_builtins.str]:
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        return pulumi.get(self, "algorithm_var")

    @_builtins.property
    @pulumi.getter
    def confidence(self) -> Optional[_builtins.str]:
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        return pulumi.get(self, "confidence")

    @_builtins.property
    @pulumi.getter(name="confidenceVar")
    def confidence_var(self) -> Optional[_builtins.str]:
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        return pulumi.get(self, "confidence_var")

    @_builtins.property
    @pulumi.getter(name="failGravity")
    def fail_gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity")

    @_builtins.property
    @pulumi.getter(name="failGravityVar")
    def fail_gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity_var")

    @_builtins.property
    @pulumi.getter
    def focus(self) -> Optional[_builtins.str]:
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        return pulumi.get(self, "focus")

    @_builtins.property
    @pulumi.getter(name="focusVar")
    def focus_var(self) -> Optional[_builtins.str]:
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        return pulumi.get(self, "focus_var")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        return pulumi.get(self, "padding")

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        return pulumi.get(self, "padding_var")

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style")

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationFeatureCropResult(dict):
    def __init__(__self__, *,
                 fail_gravity: Optional[_builtins.str] = None,
                 fail_gravity_var: Optional[_builtins.str] = None,
                 feature_radius: Optional[_builtins.str] = None,
                 feature_radius_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 max_features: Optional[_builtins.str] = None,
                 max_features_var: Optional[_builtins.str] = None,
                 min_feature_quality: Optional[_builtins.str] = None,
                 min_feature_quality_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fail_gravity: Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str fail_gravity_var: Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str feature_radius: The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        :param _builtins.str feature_radius_var: The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        :param _builtins.str gravity: Controls placement of the crop. Directions are relative to the region of interest plus padding.
        :param _builtins.str gravity_var: Controls placement of the crop. Directions are relative to the region of interest plus padding.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str max_features: The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        :param _builtins.str max_features_var: The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        :param _builtins.str min_feature_quality: Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        :param _builtins.str min_feature_quality_var: Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        :param _builtins.str padding: Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        :param _builtins.str padding_var: Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        if fail_gravity is not None:
            pulumi.set(__self__, "fail_gravity", fail_gravity)
        if fail_gravity_var is not None:
            pulumi.set(__self__, "fail_gravity_var", fail_gravity_var)
        if feature_radius is not None:
            pulumi.set(__self__, "feature_radius", feature_radius)
        if feature_radius_var is not None:
            pulumi.set(__self__, "feature_radius_var", feature_radius_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if max_features is not None:
            pulumi.set(__self__, "max_features", max_features)
        if max_features_var is not None:
            pulumi.set(__self__, "max_features_var", max_features_var)
        if min_feature_quality is not None:
            pulumi.set(__self__, "min_feature_quality", min_feature_quality)
        if min_feature_quality_var is not None:
            pulumi.set(__self__, "min_feature_quality_var", min_feature_quality_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="failGravity")
    def fail_gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity")

    @_builtins.property
    @pulumi.getter(name="failGravityVar")
    def fail_gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity_var")

    @_builtins.property
    @pulumi.getter(name="featureRadius")
    def feature_radius(self) -> Optional[_builtins.str]:
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        return pulumi.get(self, "feature_radius")

    @_builtins.property
    @pulumi.getter(name="featureRadiusVar")
    def feature_radius_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        return pulumi.get(self, "feature_radius_var")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter(name="maxFeatures")
    def max_features(self) -> Optional[_builtins.str]:
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        return pulumi.get(self, "max_features")

    @_builtins.property
    @pulumi.getter(name="maxFeaturesVar")
    def max_features_var(self) -> Optional[_builtins.str]:
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        return pulumi.get(self, "max_features_var")

    @_builtins.property
    @pulumi.getter(name="minFeatureQuality")
    def min_feature_quality(self) -> Optional[_builtins.str]:
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        return pulumi.get(self, "min_feature_quality")

    @_builtins.property
    @pulumi.getter(name="minFeatureQualityVar")
    def min_feature_quality_var(self) -> Optional[_builtins.str]:
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        return pulumi.get(self, "min_feature_quality_var")

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        return pulumi.get(self, "padding")

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        return pulumi.get(self, "padding_var")

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style")

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationFitAndFillResult(dict):
    def __init__(__self__, *,
                 fill_transformation: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: The height value of the resized image.
        :param _builtins.str height_var: The height value of the resized image.
        :param _builtins.str width: The width value of the resized image.
        :param _builtins.str width_var: The width value of the resized image.
        """
        if fill_transformation is not None:
            pulumi.set(__self__, "fill_transformation", fill_transformation)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="fillTransformation")
    def fill_transformation(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "fill_transformation")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height value of the resized image.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height value of the resized image.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width value of the resized image.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width value of the resized image.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationGoopResult(dict):
    def __init__(__self__, *,
                 chaos: Optional[_builtins.str] = None,
                 chaos_var: Optional[_builtins.str] = None,
                 density: Optional[_builtins.str] = None,
                 density_var: Optional[_builtins.str] = None,
                 power: Optional[_builtins.str] = None,
                 power_var: Optional[_builtins.str] = None,
                 seed: Optional[_builtins.str] = None,
                 seed_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str chaos: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str chaos_var: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str density: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str density_var: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str power: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str power_var: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str seed: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        :param _builtins.str seed_var: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        if chaos is not None:
            pulumi.set(__self__, "chaos", chaos)
        if chaos_var is not None:
            pulumi.set(__self__, "chaos_var", chaos_var)
        if density is not None:
            pulumi.set(__self__, "density", density)
        if density_var is not None:
            pulumi.set(__self__, "density_var", density_var)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_var is not None:
            pulumi.set(__self__, "power_var", power_var)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)
        if seed_var is not None:
            pulumi.set(__self__, "seed_var", seed_var)

    @_builtins.property
    @pulumi.getter
    def chaos(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos")

    @_builtins.property
    @pulumi.getter(name="chaosVar")
    def chaos_var(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos_var")

    @_builtins.property
    @pulumi.getter
    def density(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density")

    @_builtins.property
    @pulumi.getter(name="densityVar")
    def density_var(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density_var")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerVar")
    def power_var(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power_var")

    @_builtins.property
    @pulumi.getter
    def seed(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed")

    @_builtins.property
    @pulumi.getter(name="seedVar")
    def seed_var(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationGrayscaleResult(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        :param _builtins.str type_var: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationHslResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness: Optional[_builtins.str] = None,
                 lightness_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str lightness: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str lightness_var: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness is not None:
            pulumi.set(__self__, "lightness", lightness)
        if lightness_var is not None:
            pulumi.set(__self__, "lightness_var", lightness_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter
    def lightness(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness")

    @_builtins.property
    @pulumi.getter(name="lightnessVar")
    def lightness_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness_var")

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationHsvResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str value: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        :param _builtins.str value_var: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue_var")

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationIfDimensionResult(dict):
    def __init__(__self__, *,
                 default: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 dimension: Optional[_builtins.str] = None,
                 dimension_var: Optional[_builtins.str] = None,
                 equal: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 greater_than: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 less_than: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str dimension: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str dimension_var: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str value: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        :param _builtins.str value_var: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_var is not None:
            pulumi.set(__self__, "dimension_var", dimension_var)
        if equal is not None:
            pulumi.set(__self__, "equal", equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="dimensionVar")
    def dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension_var")

    @_builtins.property
    @pulumi.getter
    def equal(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "equal")

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "greater_than")

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "less_than")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationIfOrientationResult(dict):
    def __init__(__self__, *,
                 default: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 landscape: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 portrait: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None,
                 square: Optional['outputs.GetImagingPolicyImagePolicyTransformationResult'] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if landscape is not None:
            pulumi.set(__self__, "landscape", landscape)
        if portrait is not None:
            pulumi.set(__self__, "portrait", portrait)
        if square is not None:
            pulumi.set(__self__, "square", square)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def landscape(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "landscape")

    @_builtins.property
    @pulumi.getter
    def portrait(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "portrait")

    @_builtins.property
    @pulumi.getter
    def square(self) -> Optional['outputs.GetImagingPolicyImagePolicyTransformationResult']:
        return pulumi.get(self, "square")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationImQueryResult(dict):
    def __init__(__self__, *,
                 allowed_transformations: Sequence[_builtins.str],
                 query_var: _builtins.str):
        """
        :param Sequence[_builtins.str] allowed_transformations: Specifies the transformations that can be applied using the query string parameter.
        """
        pulumi.set(__self__, "allowed_transformations", allowed_transformations)
        pulumi.set(__self__, "query_var", query_var)

    @_builtins.property
    @pulumi.getter(name="allowedTransformations")
    def allowed_transformations(self) -> Sequence[_builtins.str]:
        """
        Specifies the transformations that can be applied using the query string parameter.
        """
        return pulumi.get(self, "allowed_transformations")

    @_builtins.property
    @pulumi.getter(name="queryVar")
    def query_var(self) -> _builtins.str:
        return pulumi.get(self, "query_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationMaxColorResult(dict):
    def __init__(__self__, *,
                 colors: Optional[_builtins.str] = None,
                 colors_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str colors: The value representing the maximum number of colors to use with the source image.
        :param _builtins.str colors_var: The value representing the maximum number of colors to use with the source image.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if colors_var is not None:
            pulumi.set(__self__, "colors_var", colors_var)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors")

    @_builtins.property
    @pulumi.getter(name="colorsVar")
    def colors_var(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationMirrorResult(dict):
    def __init__(__self__, *,
                 horizontal: Optional[_builtins.str] = None,
                 horizontal_var: Optional[_builtins.str] = None,
                 vertical: Optional[_builtins.str] = None,
                 vertical_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str horizontal: Flips the image horizontally.
        :param _builtins.str horizontal_var: Flips the image horizontally.
        :param _builtins.str vertical: Flips the image vertically.
        :param _builtins.str vertical_var: Flips the image vertically.
        """
        if horizontal is not None:
            pulumi.set(__self__, "horizontal", horizontal)
        if horizontal_var is not None:
            pulumi.set(__self__, "horizontal_var", horizontal_var)
        if vertical is not None:
            pulumi.set(__self__, "vertical", vertical)
        if vertical_var is not None:
            pulumi.set(__self__, "vertical_var", vertical_var)

    @_builtins.property
    @pulumi.getter
    def horizontal(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal")

    @_builtins.property
    @pulumi.getter(name="horizontalVar")
    def horizontal_var(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal_var")

    @_builtins.property
    @pulumi.getter
    def vertical(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical")

    @_builtins.property
    @pulumi.getter(name="verticalVar")
    def vertical_var(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationMonoHueResult(dict):
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        :param _builtins.str hue_var: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationOpacityResult(dict):
    def __init__(__self__, *,
                 opacity: Optional[_builtins.str] = None,
                 opacity_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str opacity: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        :param _builtins.str opacity_var: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if opacity_var is not None:
            pulumi.set(__self__, "opacity_var", opacity_var)

    @_builtins.property
    @pulumi.getter
    def opacity(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity")

    @_builtins.property
    @pulumi.getter(name="opacityVar")
    def opacity_var(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropResult(dict):
    def __init__(__self__, *,
                 region_of_interest: 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestResult',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: The placement of the crop area relative to the specified area of interest.
        :param _builtins.str gravity_var: The placement of the crop area relative to the specified area of interest.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        pulumi.set(__self__, "region_of_interest", region_of_interest)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="regionOfInterest")
    def region_of_interest(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestResult':
        return pulumi.get(self, "region_of_interest")

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        The placement of the crop area relative to the specified area of interest.
        """
        return pulumi.get(self, "gravity")

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        The placement of the crop area relative to the specified area of interest.
        """
        return pulumi.get(self, "gravity_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style")

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestResult(dict):
    def __init__(__self__, *,
                 circle_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeResult']] = None,
                 point_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeResult']] = None,
                 polygon_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeResult']] = None,
                 rectangle_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeResult']] = None,
                 union_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs'] circle_shapes: Defines a circle with a specified `radius` from its `center` point.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs'] polygon_shapes: Defines a polygon from a series of connected points.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs'] rectangle_shapes: Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs'] union_shapes: Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        if circle_shapes is not None:
            pulumi.set(__self__, "circle_shapes", circle_shapes)
        if point_shapes is not None:
            pulumi.set(__self__, "point_shapes", point_shapes)
        if polygon_shapes is not None:
            pulumi.set(__self__, "polygon_shapes", polygon_shapes)
        if rectangle_shapes is not None:
            pulumi.set(__self__, "rectangle_shapes", rectangle_shapes)
        if union_shapes is not None:
            pulumi.set(__self__, "union_shapes", union_shapes)

    @_builtins.property
    @pulumi.getter(name="circleShapes")
    def circle_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeResult']]:
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        return pulumi.get(self, "circle_shapes")

    @_builtins.property
    @pulumi.getter(name="pointShapes")
    def point_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeResult']]:
        return pulumi.get(self, "point_shapes")

    @_builtins.property
    @pulumi.getter(name="polygonShapes")
    def polygon_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeResult']]:
        """
        Defines a polygon from a series of connected points.
        """
        return pulumi.get(self, "polygon_shapes")

    @_builtins.property
    @pulumi.getter(name="rectangleShapes")
    def rectangle_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeResult']]:
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        return pulumi.get(self, "rectangle_shapes")

    @_builtins.property
    @pulumi.getter(name="unionShapes")
    def union_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeResult']]:
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        return pulumi.get(self, "union_shapes")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeResult(dict):
    def __init__(__self__, *,
                 center: 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterResult',
                 radius: Optional[_builtins.str] = None,
                 radius_var: Optional[_builtins.str] = None):
        """
        :param 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs' center: Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        :param _builtins.str radius: The radius of the circle measured in pixels.
        :param _builtins.str radius_var: The radius of the circle measured in pixels.
        """
        pulumi.set(__self__, "center", center)
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if radius_var is not None:
            pulumi.set(__self__, "radius_var", radius_var)

    @_builtins.property
    @pulumi.getter
    def center(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterResult':
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        return pulumi.get(self, "center")

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius")

    @_builtins.property
    @pulumi.getter(name="radiusVar")
    def radius_var(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeResult(dict):
    def __init__(__self__, *,
                 points: Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointResult']):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs'] points: Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        pulumi.set(__self__, "points", points)

    @_builtins.property
    @pulumi.getter
    def points(self) -> Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointResult']:
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        return pulumi.get(self, "points")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeResult(dict):
    def __init__(__self__, *,
                 anchor: 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorResult',
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Extends the rectangle down from the `anchor` point.
        :param _builtins.str height_var: Extends the rectangle down from the `anchor` point.
        :param _builtins.str width: Extends the rectangle right from the `anchor` point.
        :param _builtins.str width_var: Extends the rectangle right from the `anchor` point.
        """
        pulumi.set(__self__, "anchor", anchor)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def anchor(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorResult':
        return pulumi.get(self, "anchor")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeResult(dict):
    def __init__(__self__, *,
                 shapes: Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeResult']):
        pulumi.set(__self__, "shapes", shapes)

    @_builtins.property
    @pulumi.getter
    def shapes(self) -> Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeResult']:
        return pulumi.get(self, "shapes")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeResult(dict):
    def __init__(__self__, *,
                 circle_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeResult']] = None,
                 point_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeResult']] = None,
                 polygon_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeResult']] = None,
                 rectangle_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeResult']] = None,
                 union_shapes: Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeResult']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs'] circle_shapes: Defines a circle with a specified `radius` from its `center` point.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs'] polygon_shapes: Defines a polygon from a series of connected points.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs'] rectangle_shapes: Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs'] union_shapes: Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        if circle_shapes is not None:
            pulumi.set(__self__, "circle_shapes", circle_shapes)
        if point_shapes is not None:
            pulumi.set(__self__, "point_shapes", point_shapes)
        if polygon_shapes is not None:
            pulumi.set(__self__, "polygon_shapes", polygon_shapes)
        if rectangle_shapes is not None:
            pulumi.set(__self__, "rectangle_shapes", rectangle_shapes)
        if union_shapes is not None:
            pulumi.set(__self__, "union_shapes", union_shapes)

    @_builtins.property
    @pulumi.getter(name="circleShapes")
    def circle_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeResult']]:
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        return pulumi.get(self, "circle_shapes")

    @_builtins.property
    @pulumi.getter(name="pointShapes")
    def point_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeResult']]:
        return pulumi.get(self, "point_shapes")

    @_builtins.property
    @pulumi.getter(name="polygonShapes")
    def polygon_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeResult']]:
        """
        Defines a polygon from a series of connected points.
        """
        return pulumi.get(self, "polygon_shapes")

    @_builtins.property
    @pulumi.getter(name="rectangleShapes")
    def rectangle_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeResult']]:
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        return pulumi.get(self, "rectangle_shapes")

    @_builtins.property
    @pulumi.getter(name="unionShapes")
    def union_shapes(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeResult']]:
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        return pulumi.get(self, "union_shapes")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeResult(dict):
    def __init__(__self__, *,
                 center: 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterResult',
                 radius: Optional[_builtins.str] = None,
                 radius_var: Optional[_builtins.str] = None):
        """
        :param 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs' center: Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        :param _builtins.str radius: The radius of the circle measured in pixels.
        :param _builtins.str radius_var: The radius of the circle measured in pixels.
        """
        pulumi.set(__self__, "center", center)
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if radius_var is not None:
            pulumi.set(__self__, "radius_var", radius_var)

    @_builtins.property
    @pulumi.getter
    def center(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterResult':
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        return pulumi.get(self, "center")

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius")

    @_builtins.property
    @pulumi.getter(name="radiusVar")
    def radius_var(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeResult(dict):
    def __init__(__self__, *,
                 points: Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointResult']):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs'] points: Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        pulumi.set(__self__, "points", points)

    @_builtins.property
    @pulumi.getter
    def points(self) -> Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointResult']:
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        return pulumi.get(self, "points")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeResult(dict):
    def __init__(__self__, *,
                 anchor: 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorResult',
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Extends the rectangle down from the `anchor` point.
        :param _builtins.str height_var: Extends the rectangle down from the `anchor` point.
        :param _builtins.str width: Extends the rectangle right from the `anchor` point.
        :param _builtins.str width_var: Extends the rectangle right from the `anchor` point.
        """
        pulumi.set(__self__, "anchor", anchor)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def anchor(self) -> 'outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorResult':
        return pulumi.get(self, "anchor")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorResult(dict):
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeResult(dict):
    def __init__(__self__, *,
                 shapes: Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeResult']):
        pulumi.set(__self__, "shapes", shapes)

    @_builtins.property
    @pulumi.getter
    def shapes(self) -> Sequence['outputs.GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeResult']:
        return pulumi.get(self, "shapes")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRelativeCropResult(dict):
    def __init__(__self__, *,
                 east: Optional[_builtins.str] = None,
                 east_var: Optional[_builtins.str] = None,
                 north: Optional[_builtins.str] = None,
                 north_var: Optional[_builtins.str] = None,
                 south: Optional[_builtins.str] = None,
                 south_var: Optional[_builtins.str] = None,
                 west: Optional[_builtins.str] = None,
                 west_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str east: The number of pixels to shrink or expand the right side of the image.
        :param _builtins.str east_var: The number of pixels to shrink or expand the right side of the image.
        :param _builtins.str north: The number of pixels to shrink or expand the top side of the image.
        :param _builtins.str north_var: The number of pixels to shrink or expand the top side of the image.
        :param _builtins.str south: The number of pixels to shrink or expand the bottom side of the image.
        :param _builtins.str south_var: The number of pixels to shrink or expand the bottom side of the image.
        :param _builtins.str west: The number of pixels to shrink or expand the left side of the image.
        :param _builtins.str west_var: The number of pixels to shrink or expand the left side of the image.
        """
        if east is not None:
            pulumi.set(__self__, "east", east)
        if east_var is not None:
            pulumi.set(__self__, "east_var", east_var)
        if north is not None:
            pulumi.set(__self__, "north", north)
        if north_var is not None:
            pulumi.set(__self__, "north_var", north_var)
        if south is not None:
            pulumi.set(__self__, "south", south)
        if south_var is not None:
            pulumi.set(__self__, "south_var", south_var)
        if west is not None:
            pulumi.set(__self__, "west", west)
        if west_var is not None:
            pulumi.set(__self__, "west_var", west_var)

    @_builtins.property
    @pulumi.getter
    def east(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        return pulumi.get(self, "east")

    @_builtins.property
    @pulumi.getter(name="eastVar")
    def east_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        return pulumi.get(self, "east_var")

    @_builtins.property
    @pulumi.getter
    def north(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        return pulumi.get(self, "north")

    @_builtins.property
    @pulumi.getter(name="northVar")
    def north_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        return pulumi.get(self, "north_var")

    @_builtins.property
    @pulumi.getter
    def south(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        return pulumi.get(self, "south")

    @_builtins.property
    @pulumi.getter(name="southVar")
    def south_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        return pulumi.get(self, "south_var")

    @_builtins.property
    @pulumi.getter
    def west(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the left side of the image.
        """
        return pulumi.get(self, "west")

    @_builtins.property
    @pulumi.getter(name="westVar")
    def west_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the left side of the image.
        """
        return pulumi.get(self, "west_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRemoveColorResult(dict):
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 feather: Optional[_builtins.str] = None,
                 feather_var: Optional[_builtins.str] = None,
                 tolerance: Optional[_builtins.str] = None,
                 tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value to remove.
        :param _builtins.str color_var: The hexadecimal CSS color value to remove.
        :param _builtins.str feather: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str feather_var: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str tolerance: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        :param _builtins.str tolerance_var: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if feather is not None:
            pulumi.set(__self__, "feather", feather)
        if feather_var is not None:
            pulumi.set(__self__, "feather_var", feather_var)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)
        if tolerance_var is not None:
            pulumi.set(__self__, "tolerance_var", tolerance_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color_var")

    @_builtins.property
    @pulumi.getter
    def feather(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather")

    @_builtins.property
    @pulumi.getter(name="featherVar")
    def feather_var(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather_var")

    @_builtins.property
    @pulumi.getter
    def tolerance(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance")

    @_builtins.property
    @pulumi.getter(name="toleranceVar")
    def tolerance_var(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationResizeResult(dict):
    def __init__(__self__, *,
                 aspect: Optional[_builtins.str] = None,
                 aspect_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str aspect: Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        :param _builtins.str aspect_var: Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        :param _builtins.str height: The height to resize the source image to. Must be set if height is not specified.
        :param _builtins.str height_var: The height to resize the source image to. Must be set if height is not specified.
        :param _builtins.str type: Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        :param _builtins.str type_var: Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        :param _builtins.str width: The width to resize the source image to. Must be set if width is not specified.
        :param _builtins.str width_var: The width to resize the source image to. Must be set if width is not specified.
        """
        if aspect is not None:
            pulumi.set(__self__, "aspect", aspect)
        if aspect_var is not None:
            pulumi.set(__self__, "aspect_var", aspect_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def aspect(self) -> Optional[_builtins.str]:
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        return pulumi.get(self, "aspect")

    @_builtins.property
    @pulumi.getter(name="aspectVar")
    def aspect_var(self) -> Optional[_builtins.str]:
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        return pulumi.get(self, "aspect_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        return pulumi.get(self, "type_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationRotateResult(dict):
    def __init__(__self__, *,
                 degrees: Optional[_builtins.str] = None,
                 degrees_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str degrees: The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        :param _builtins.str degrees_var: The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        if degrees is not None:
            pulumi.set(__self__, "degrees", degrees)
        if degrees_var is not None:
            pulumi.set(__self__, "degrees_var", degrees_var)

    @_builtins.property
    @pulumi.getter
    def degrees(self) -> Optional[_builtins.str]:
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        return pulumi.get(self, "degrees")

    @_builtins.property
    @pulumi.getter(name="degreesVar")
    def degrees_var(self) -> Optional[_builtins.str]:
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        return pulumi.get(self, "degrees_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationScaleResult(dict):
    def __init__(__self__, *,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str height_var: Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str width: Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str width_var: Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationShearsResult(dict):
    def __init__(__self__, *,
                 x_shear: Optional[_builtins.str] = None,
                 x_shear_var: Optional[_builtins.str] = None,
                 y_shear: Optional[_builtins.str] = None,
                 y_shear_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x_shear: The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        :param _builtins.str x_shear_var: The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        :param _builtins.str y_shear: The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        :param _builtins.str y_shear_var: The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        if x_shear is not None:
            pulumi.set(__self__, "x_shear", x_shear)
        if x_shear_var is not None:
            pulumi.set(__self__, "x_shear_var", x_shear_var)
        if y_shear is not None:
            pulumi.set(__self__, "y_shear", y_shear)
        if y_shear_var is not None:
            pulumi.set(__self__, "y_shear_var", y_shear_var)

    @_builtins.property
    @pulumi.getter(name="xShear")
    def x_shear(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        return pulumi.get(self, "x_shear")

    @_builtins.property
    @pulumi.getter(name="xShearVar")
    def x_shear_var(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        return pulumi.get(self, "x_shear_var")

    @_builtins.property
    @pulumi.getter(name="yShear")
    def y_shear(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        return pulumi.get(self, "y_shear")

    @_builtins.property
    @pulumi.getter(name="yShearVar")
    def y_shear_var(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        return pulumi.get(self, "y_shear_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationSmartCropResult(dict):
    def __init__(__self__, *,
                 debug: Optional[_builtins.str] = None,
                 debug_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 sloppy: Optional[_builtins.str] = None,
                 sloppy_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str debug: When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        :param _builtins.str debug_var: When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str sloppy: Whether to sacrifice any image fidelity for transformation performance.
        :param _builtins.str sloppy_var: Whether to sacrifice any image fidelity for transformation performance.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if debug_var is not None:
            pulumi.set(__self__, "debug_var", debug_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if sloppy is not None:
            pulumi.set(__self__, "sloppy", sloppy)
        if sloppy_var is not None:
            pulumi.set(__self__, "sloppy_var", sloppy_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.str]:
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="debugVar")
    def debug_var(self) -> Optional[_builtins.str]:
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        return pulumi.get(self, "debug_var")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @_builtins.property
    @pulumi.getter
    def sloppy(self) -> Optional[_builtins.str]:
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        return pulumi.get(self, "sloppy")

    @_builtins.property
    @pulumi.getter(name="sloppyVar")
    def sloppy_var(self) -> Optional[_builtins.str]:
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        return pulumi.get(self, "sloppy_var")

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style")

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style_var")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationTrimResult(dict):
    def __init__(__self__, *,
                 fuzz: Optional[_builtins.str] = None,
                 fuzz_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fuzz: The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        :param _builtins.str fuzz_var: The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        :param _builtins.str padding: The amount of padding in pixels to add to the trimmed image.
        :param _builtins.str padding_var: The amount of padding in pixels to add to the trimmed image.
        """
        if fuzz is not None:
            pulumi.set(__self__, "fuzz", fuzz)
        if fuzz_var is not None:
            pulumi.set(__self__, "fuzz_var", fuzz_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)

    @_builtins.property
    @pulumi.getter
    def fuzz(self) -> Optional[_builtins.str]:
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        return pulumi.get(self, "fuzz")

    @_builtins.property
    @pulumi.getter(name="fuzzVar")
    def fuzz_var(self) -> Optional[_builtins.str]:
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        return pulumi.get(self, "fuzz_var")

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        The amount of padding in pixels to add to the trimmed image.
        """
        return pulumi.get(self, "padding")

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        The amount of padding in pixels to add to the trimmed image.
        """
        return pulumi.get(self, "padding_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyTransformationUnsharpMaskResult(dict):
    def __init__(__self__, *,
                 gain: Optional[_builtins.str] = None,
                 gain_var: Optional[_builtins.str] = None,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 threshold_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gain: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str gain_var: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str sigma: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str sigma_var: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str threshold: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        :param _builtins.str threshold_var: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        if gain is not None:
            pulumi.set(__self__, "gain", gain)
        if gain_var is not None:
            pulumi.set(__self__, "gain_var", gain_var)
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_var is not None:
            pulumi.set(__self__, "threshold_var", threshold_var)

    @_builtins.property
    @pulumi.getter
    def gain(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain")

    @_builtins.property
    @pulumi.getter(name="gainVar")
    def gain_var(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain_var")

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma")

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma_var")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="thresholdVar")
    def threshold_var(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold_var")


@pulumi.output_type
class GetImagingPolicyImagePolicyVariableResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 enum_options: Optional[Sequence['outputs.GetImagingPolicyImagePolicyVariableEnumOptionResult']] = None,
                 postfix: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_value: The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        :param _builtins.str name: The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        :param _builtins.str type: The type of value for the variable.
        :param _builtins.str postfix: A postfix added to the value provided for the variable, or to the default value.
        :param _builtins.str prefix: A prefix added to the value provided for the variable, or to the default value.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if postfix is not None:
            pulumi.set(__self__, "postfix", postfix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of value for the variable.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[Sequence['outputs.GetImagingPolicyImagePolicyVariableEnumOptionResult']]:
        return pulumi.get(self, "enum_options")

    @_builtins.property
    @pulumi.getter
    def postfix(self) -> Optional[_builtins.str]:
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "postfix")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetImagingPolicyImagePolicyVariableEnumOptionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for each enum value, up to 50 alphanumeric characters.
        :param _builtins.str value: The value of the variable when the `id` is provided.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable when the `id` is provided.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetImagingPolicyVideoPolicyResult(dict):
    def __init__(__self__, *,
                 breakpoints: Optional['outputs.GetImagingPolicyVideoPolicyBreakpointsResult'] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 output: Optional['outputs.GetImagingPolicyVideoPolicyOutputResult'] = None,
                 rollout_duration: Optional[_builtins.str] = None,
                 variables: Optional[Sequence['outputs.GetImagingPolicyVideoPolicyVariableResult']] = None):
        """
        :param 'GetImagingPolicyVideoPolicyBreakpointsArgs' breakpoints: The breakpoint widths (in pixels) to use to create derivative images/videos.
        :param Sequence[_builtins.str] hosts: Hosts that are allowed for image/video URLs within transformations or variables.
        :param 'GetImagingPolicyVideoPolicyOutputArgs' output: Dictates the output quality that are created for each resized video.
        :param _builtins.str rollout_duration: The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        :param Sequence['GetImagingPolicyVideoPolicyVariableArgs'] variables: Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        if breakpoints is not None:
            pulumi.set(__self__, "breakpoints", breakpoints)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if rollout_duration is not None:
            pulumi.set(__self__, "rollout_duration", rollout_duration)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def breakpoints(self) -> Optional['outputs.GetImagingPolicyVideoPolicyBreakpointsResult']:
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        return pulumi.get(self, "breakpoints")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.GetImagingPolicyVideoPolicyOutputResult']:
        """
        Dictates the output quality that are created for each resized video.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="rolloutDuration")
    def rollout_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        return pulumi.get(self, "rollout_duration")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.GetImagingPolicyVideoPolicyVariableResult']]:
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetImagingPolicyVideoPolicyBreakpointsResult(dict):
    def __init__(__self__, *,
                 widths: Optional[Sequence[_builtins.int]] = None):
        if widths is not None:
            pulumi.set(__self__, "widths", widths)

    @_builtins.property
    @pulumi.getter
    def widths(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "widths")


@pulumi.output_type
class GetImagingPolicyVideoPolicyOutputResult(dict):
    def __init__(__self__, *,
                 perceptual_quality: Optional[_builtins.str] = None,
                 perceptual_quality_var: Optional[_builtins.str] = None,
                 placeholder_video_url: Optional[_builtins.str] = None,
                 placeholder_video_url_var: Optional[_builtins.str] = None,
                 video_adaptive_quality: Optional[_builtins.str] = None,
                 video_adaptive_quality_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str perceptual_quality: The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        :param _builtins.str perceptual_quality_var: The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        :param _builtins.str placeholder_video_url: Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        :param _builtins.str placeholder_video_url_var: Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        :param _builtins.str video_adaptive_quality: Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        :param _builtins.str video_adaptive_quality_var: Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        if perceptual_quality is not None:
            pulumi.set(__self__, "perceptual_quality", perceptual_quality)
        if perceptual_quality_var is not None:
            pulumi.set(__self__, "perceptual_quality_var", perceptual_quality_var)
        if placeholder_video_url is not None:
            pulumi.set(__self__, "placeholder_video_url", placeholder_video_url)
        if placeholder_video_url_var is not None:
            pulumi.set(__self__, "placeholder_video_url_var", placeholder_video_url_var)
        if video_adaptive_quality is not None:
            pulumi.set(__self__, "video_adaptive_quality", video_adaptive_quality)
        if video_adaptive_quality_var is not None:
            pulumi.set(__self__, "video_adaptive_quality_var", video_adaptive_quality_var)

    @_builtins.property
    @pulumi.getter(name="perceptualQuality")
    def perceptual_quality(self) -> Optional[_builtins.str]:
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        return pulumi.get(self, "perceptual_quality")

    @_builtins.property
    @pulumi.getter(name="perceptualQualityVar")
    def perceptual_quality_var(self) -> Optional[_builtins.str]:
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        return pulumi.get(self, "perceptual_quality_var")

    @_builtins.property
    @pulumi.getter(name="placeholderVideoUrl")
    def placeholder_video_url(self) -> Optional[_builtins.str]:
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        return pulumi.get(self, "placeholder_video_url")

    @_builtins.property
    @pulumi.getter(name="placeholderVideoUrlVar")
    def placeholder_video_url_var(self) -> Optional[_builtins.str]:
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        return pulumi.get(self, "placeholder_video_url_var")

    @_builtins.property
    @pulumi.getter(name="videoAdaptiveQuality")
    def video_adaptive_quality(self) -> Optional[_builtins.str]:
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        return pulumi.get(self, "video_adaptive_quality")

    @_builtins.property
    @pulumi.getter(name="videoAdaptiveQualityVar")
    def video_adaptive_quality_var(self) -> Optional[_builtins.str]:
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        return pulumi.get(self, "video_adaptive_quality_var")


@pulumi.output_type
class GetImagingPolicyVideoPolicyVariableResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 enum_options: Optional[Sequence['outputs.GetImagingPolicyVideoPolicyVariableEnumOptionResult']] = None,
                 postfix: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_value: The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        :param _builtins.str name: The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        :param _builtins.str type: The type of value for the variable.
        :param _builtins.str postfix: A postfix added to the value provided for the variable, or to the default value.
        :param _builtins.str prefix: A prefix added to the value provided for the variable, or to the default value.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if postfix is not None:
            pulumi.set(__self__, "postfix", postfix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of value for the variable.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[Sequence['outputs.GetImagingPolicyVideoPolicyVariableEnumOptionResult']]:
        return pulumi.get(self, "enum_options")

    @_builtins.property
    @pulumi.getter
    def postfix(self) -> Optional[_builtins.str]:
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "postfix")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetImagingPolicyVideoPolicyVariableEnumOptionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for each enum value, up to 50 alphanumeric characters.
        :param _builtins.str value: The value of the variable when the `id` is provided.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable when the `id` is provided.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPropertiesPropertyResult(dict):
    def __init__(__self__, *,
                 contract_id: _builtins.str,
                 group_id: _builtins.str,
                 latest_version: _builtins.int,
                 note: _builtins.str,
                 production_version: _builtins.int,
                 property_id: _builtins.str,
                 property_name: _builtins.str,
                 property_type: _builtins.str,
                 staging_version: _builtins.int):
        """
        :param _builtins.str property_type: Specifies the type of the property.
        """
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "production_version", production_version)
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_type", property_type)
        pulumi.set(__self__, "staging_version", staging_version)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.int:
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter
    def note(self) -> _builtins.str:
        return pulumi.get(self, "note")

    @_builtins.property
    @pulumi.getter(name="productionVersion")
    def production_version(self) -> _builtins.int:
        return pulumi.get(self, "production_version")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.str:
        return pulumi.get(self, "property_id")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyType")
    def property_type(self) -> _builtins.str:
        """
        Specifies the type of the property.
        """
        return pulumi.get(self, "property_type")

    @_builtins.property
    @pulumi.getter(name="stagingVersion")
    def staging_version(self) -> _builtins.int:
        return pulumi.get(self, "staging_version")


@pulumi.output_type
class GetPropertiesSearchPropertyResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 asset_id: _builtins.str,
                 contract_id: _builtins.str,
                 edge_hostname: _builtins.str,
                 group_id: _builtins.str,
                 hostname: _builtins.str,
                 production_status: _builtins.str,
                 property_id: _builtins.str,
                 property_name: _builtins.str,
                 property_version: _builtins.int,
                 staging_status: _builtins.str,
                 updated_by_user: _builtins.str,
                 updated_date: _builtins.str):
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "asset_id", asset_id)
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "edge_hostname", edge_hostname)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "production_status", production_status)
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "property_version", property_version)
        pulumi.set(__self__, "staging_status", staging_status)
        pulumi.set(__self__, "updated_by_user", updated_by_user)
        pulumi.set(__self__, "updated_date", updated_date)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> _builtins.str:
        return pulumi.get(self, "asset_id")

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        return pulumi.get(self, "contract_id")

    @_builtins.property
    @pulumi.getter(name="edgeHostname")
    def edge_hostname(self) -> _builtins.str:
        return pulumi.get(self, "edge_hostname")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> _builtins.str:
        return pulumi.get(self, "production_status")

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.str:
        return pulumi.get(self, "property_id")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyVersion")
    def property_version(self) -> _builtins.int:
        return pulumi.get(self, "property_version")

    @_builtins.property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> _builtins.str:
        return pulumi.get(self, "staging_status")

    @_builtins.property
    @pulumi.getter(name="updatedByUser")
    def updated_by_user(self) -> _builtins.str:
        return pulumi.get(self, "updated_by_user")

    @_builtins.property
    @pulumi.getter(name="updatedDate")
    def updated_date(self) -> _builtins.str:
        return pulumi.get(self, "updated_date")


@pulumi.output_type
class GetPropertyHostnameActivationHostnameResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 cert_provisioning_type: _builtins.str,
                 cname_from: _builtins.str,
                 cname_to: _builtins.str,
                 edge_hostname_id: _builtins.str):
        """
        :param _builtins.str action: Specifies whether a given activation adds or removes a hostname item. Available options are `ADD` and `REMOVE`.
        :param _builtins.str cert_provisioning_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str cname_from: The hostname that your end users see, indicated by the Host header in end user requests.
        :param _builtins.str cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers.
        :param _builtins.str edge_hostname_id: Identifies the edge hostname you mapped your traffic to on the production network.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_to", cname_to)
        pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies whether a given activation adds or removes a hostname item. Available options are `ADD` and `REMOVE`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> _builtins.str:
        """
        The hostname that your end users see, indicated by the Host header in end user requests.
        """
        return pulumi.get(self, "cname_from")

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers.
        """
        return pulumi.get(self, "cname_to")

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> _builtins.str:
        """
        Identifies the edge hostname you mapped your traffic to on the production network.
        """
        return pulumi.get(self, "edge_hostname_id")


@pulumi.output_type
class GetPropertyHostnameActivationsHostnameActivationResult(dict):
    def __init__(__self__, *,
                 activation_type: _builtins.str,
                 hostname_activation_id: _builtins.str,
                 network: _builtins.str,
                 note: _builtins.str,
                 notify_emails: Sequence[_builtins.str],
                 status: _builtins.str,
                 submit_date: _builtins.str,
                 update_date: _builtins.str):
        """
        :param _builtins.str activation_type: The activation type, either `ACTIVATE` or `DEACTIVATE`.
        :param _builtins.str hostname_activation_id: The ISO 8601 timestamp property hostname activation's unique identifier.
        :param _builtins.str network: The network of activation, either `STAGING` or `PRODUCTION`.`
        :param _builtins.str note: Assigns a log message to the activation request.
        :param Sequence[_builtins.str] notify_emails: Email addresses to notify when the activation status changes.
        :param _builtins.str status: The activation's status. `ACTIVE` if currently serving traffic. `INACTIVE` if another activation has superseded this one. `PENDING` if not yet active. `ABORTED` if the client followed up with a `DELETE` request in time. `FAILED` if the activation causes a range of edge network errors that may cause a fallback to the previous activation. `PENDING_DEACTIVATION` or `DEACTIVATED` when the `activation_type` is `DEACTIVATE` to no longer serve traffic.
        :param _builtins.str submit_date: The timestamp indicating when the activation was initiated.
        :param _builtins.str update_date: The ISO 8601 timestamp indicating when the status last changed.
        """
        pulumi.set(__self__, "activation_type", activation_type)
        pulumi.set(__self__, "hostname_activation_id", hostname_activation_id)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "notify_emails", notify_emails)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "submit_date", submit_date)
        pulumi.set(__self__, "update_date", update_date)

    @_builtins.property
    @pulumi.getter(name="activationType")
    def activation_type(self) -> _builtins.str:
        """
        The activation type, either `ACTIVATE` or `DEACTIVATE`.
        """
        return pulumi.get(self, "activation_type")

    @_builtins.property
    @pulumi.getter(name="hostnameActivationId")
    def hostname_activation_id(self) -> _builtins.str:
        """
        The ISO 8601 timestamp property hostname activation's unique identifier.
        """
        return pulumi.get(self, "hostname_activation_id")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network of activation, either `STAGING` or `PRODUCTION`.`
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def note(self) -> _builtins.str:
        """
        Assigns a log message to the activation request.
        """
        return pulumi.get(self, "note")

    @_builtins.property
    @pulumi.getter(name="notifyEmails")
    def notify_emails(self) -> Sequence[_builtins.str]:
        """
        Email addresses to notify when the activation status changes.
        """
        return pulumi.get(self, "notify_emails")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The activation's status. `ACTIVE` if currently serving traffic. `INACTIVE` if another activation has superseded this one. `PENDING` if not yet active. `ABORTED` if the client followed up with a `DELETE` request in time. `FAILED` if the activation causes a range of edge network errors that may cause a fallback to the previous activation. `PENDING_DEACTIVATION` or `DEACTIVATED` when the `activation_type` is `DEACTIVATE` to no longer serve traffic.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="submitDate")
    def submit_date(self) -> _builtins.str:
        """
        The timestamp indicating when the activation was initiated.
        """
        return pulumi.get(self, "submit_date")

    @_builtins.property
    @pulumi.getter(name="updateDate")
    def update_date(self) -> _builtins.str:
        """
        The ISO 8601 timestamp indicating when the status last changed.
        """
        return pulumi.get(self, "update_date")


@pulumi.output_type
class GetPropertyHostnamesDiffHostnameResult(dict):
    def __init__(__self__, *,
                 cname_from: _builtins.str,
                 production_cert_provisioning_type: _builtins.str,
                 production_cname_to: _builtins.str,
                 production_cname_type: _builtins.str,
                 production_edge_hostname_id: _builtins.str,
                 staging_cert_provisioning_type: _builtins.str,
                 staging_cname_to: _builtins.str,
                 staging_cname_type: _builtins.str,
                 staging_edge_hostname_id: _builtins.str):
        """
        :param _builtins.str cname_from: The hostname that your end users see, indicated by the Host header in end user requests.
        :param _builtins.str production_cert_provisioning_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str production_cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        :param _builtins.str production_cname_type: A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        :param _builtins.str production_edge_hostname_id: The unique identifier for the edge hostname.
        :param _builtins.str staging_cert_provisioning_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str staging_cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        :param _builtins.str staging_cname_type: A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        :param _builtins.str staging_edge_hostname_id: The unique identifier for the edge hostname.
        """
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "production_cert_provisioning_type", production_cert_provisioning_type)
        pulumi.set(__self__, "production_cname_to", production_cname_to)
        pulumi.set(__self__, "production_cname_type", production_cname_type)
        pulumi.set(__self__, "production_edge_hostname_id", production_edge_hostname_id)
        pulumi.set(__self__, "staging_cert_provisioning_type", staging_cert_provisioning_type)
        pulumi.set(__self__, "staging_cname_to", staging_cname_to)
        pulumi.set(__self__, "staging_cname_type", staging_cname_type)
        pulumi.set(__self__, "staging_edge_hostname_id", staging_edge_hostname_id)

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> _builtins.str:
        """
        The hostname that your end users see, indicated by the Host header in end user requests.
        """
        return pulumi.get(self, "cname_from")

    @_builtins.property
    @pulumi.getter(name="productionCertProvisioningType")
    def production_cert_provisioning_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "production_cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="productionCnameTo")
    def production_cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "production_cname_to")

    @_builtins.property
    @pulumi.getter(name="productionCnameType")
    def production_cname_type(self) -> _builtins.str:
        """
        A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        """
        return pulumi.get(self, "production_cname_type")

    @_builtins.property
    @pulumi.getter(name="productionEdgeHostnameId")
    def production_edge_hostname_id(self) -> _builtins.str:
        """
        The unique identifier for the edge hostname.
        """
        return pulumi.get(self, "production_edge_hostname_id")

    @_builtins.property
    @pulumi.getter(name="stagingCertProvisioningType")
    def staging_cert_provisioning_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "staging_cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="stagingCnameTo")
    def staging_cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "staging_cname_to")

    @_builtins.property
    @pulumi.getter(name="stagingCnameType")
    def staging_cname_type(self) -> _builtins.str:
        """
        A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        """
        return pulumi.get(self, "staging_cname_type")

    @_builtins.property
    @pulumi.getter(name="stagingEdgeHostnameId")
    def staging_edge_hostname_id(self) -> _builtins.str:
        """
        The unique identifier for the edge hostname.
        """
        return pulumi.get(self, "staging_edge_hostname_id")


@pulumi.output_type
class GetPropertyHostnamesHostnameResult(dict):
    def __init__(__self__, *,
                 cert_provisioning_type: _builtins.str,
                 cert_statuses: Sequence['outputs.GetPropertyHostnamesHostnameCertStatusResult'],
                 cname_from: _builtins.str,
                 cname_to: _builtins.str,
                 cname_type: _builtins.str,
                 edge_hostname_id: _builtins.str):
        """
        :param _builtins.str cert_provisioning_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str cname_from: The hostname that your end users see, indicated by the Host header in end user requests.
        :param _builtins.str cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        :param _builtins.str cname_type: A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        :param _builtins.str edge_hostname_id: The unique identifier for the edge hostname.
        """
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "cert_statuses", cert_statuses)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_to", cname_to)
        pulumi.set(__self__, "cname_type", cname_type)
        pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "cert_provisioning_type")

    @_builtins.property
    @pulumi.getter(name="certStatuses")
    def cert_statuses(self) -> Sequence['outputs.GetPropertyHostnamesHostnameCertStatusResult']:
        return pulumi.get(self, "cert_statuses")

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> _builtins.str:
        """
        The hostname that your end users see, indicated by the Host header in end user requests.
        """
        return pulumi.get(self, "cname_from")

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "cname_to")

    @_builtins.property
    @pulumi.getter(name="cnameType")
    def cname_type(self) -> _builtins.str:
        """
        A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        """
        return pulumi.get(self, "cname_type")

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> _builtins.str:
        """
        The unique identifier for the edge hostname.
        """
        return pulumi.get(self, "edge_hostname_id")


@pulumi.output_type
class GetPropertyHostnamesHostnameBucketResult(dict):
    def __init__(__self__, *,
                 cert_statuses: Sequence['outputs.GetPropertyHostnamesHostnameBucketCertStatusResult'],
                 cname_from: _builtins.str,
                 cname_type: _builtins.str,
                 production_cert_type: _builtins.str,
                 production_cname_to: _builtins.str,
                 production_edge_hostname_id: _builtins.str,
                 staging_cert_type: _builtins.str,
                 staging_cname_to: _builtins.str,
                 staging_edge_hostname_id: _builtins.str):
        """
        :param _builtins.str cname_from: The hostname that your end users see, indicated by the Host header in end user requests.
        :param _builtins.str cname_type: A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        :param _builtins.str production_cert_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str production_cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        :param _builtins.str production_edge_hostname_id: The unique identifier for the edge hostname.
        :param _builtins.str staging_cert_type: Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        :param _builtins.str staging_cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        :param _builtins.str staging_edge_hostname_id: The unique identifier for the edge hostname.
        """
        pulumi.set(__self__, "cert_statuses", cert_statuses)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_type", cname_type)
        pulumi.set(__self__, "production_cert_type", production_cert_type)
        pulumi.set(__self__, "production_cname_to", production_cname_to)
        pulumi.set(__self__, "production_edge_hostname_id", production_edge_hostname_id)
        pulumi.set(__self__, "staging_cert_type", staging_cert_type)
        pulumi.set(__self__, "staging_cname_to", staging_cname_to)
        pulumi.set(__self__, "staging_edge_hostname_id", staging_edge_hostname_id)

    @_builtins.property
    @pulumi.getter(name="certStatuses")
    def cert_statuses(self) -> Sequence['outputs.GetPropertyHostnamesHostnameBucketCertStatusResult']:
        return pulumi.get(self, "cert_statuses")

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> _builtins.str:
        """
        The hostname that your end users see, indicated by the Host header in end user requests.
        """
        return pulumi.get(self, "cname_from")

    @_builtins.property
    @pulumi.getter(name="cnameType")
    def cname_type(self) -> _builtins.str:
        """
        A hostname's CNAME type. Supports only the `EDGE_HOSTNAME` value.
        """
        return pulumi.get(self, "cname_type")

    @_builtins.property
    @pulumi.getter(name="productionCertType")
    def production_cert_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "production_cert_type")

    @_builtins.property
    @pulumi.getter(name="productionCnameTo")
    def production_cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "production_cname_to")

    @_builtins.property
    @pulumi.getter(name="productionEdgeHostnameId")
    def production_edge_hostname_id(self) -> _builtins.str:
        """
        The unique identifier for the edge hostname.
        """
        return pulumi.get(self, "production_edge_hostname_id")

    @_builtins.property
    @pulumi.getter(name="stagingCertType")
    def staging_cert_type(self) -> _builtins.str:
        """
        Indicates the certificate's provisioning type. Either `CPS_MANAGED` for the certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for the Domain Validation (DV) certificates created automatically. Note that you can't specify the `DEFAULT` value if your property hostname uses the `akamaized.net` domain suffix.
        """
        return pulumi.get(self, "staging_cert_type")

    @_builtins.property
    @pulumi.getter(name="stagingCnameTo")
    def staging_cname_to(self) -> _builtins.str:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "staging_cname_to")

    @_builtins.property
    @pulumi.getter(name="stagingEdgeHostnameId")
    def staging_edge_hostname_id(self) -> _builtins.str:
        """
        The unique identifier for the edge hostname.
        """
        return pulumi.get(self, "staging_edge_hostname_id")


@pulumi.output_type
class GetPropertyHostnamesHostnameBucketCertStatusResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 production_status: _builtins.str,
                 staging_status: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.str hostname: The hostname part of the CNAME record used to validate the certificate's domain.
        :param _builtins.str production_status: The certificate's deployment status on the production network.
        :param _builtins.str staging_status: The certificate's deployment status on the staging network.
        :param _builtins.str target: The destination part of the CNAME record used to validate the certificate's domain.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "production_status", production_status)
        pulumi.set(__self__, "staging_status", staging_status)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> _builtins.str:
        """
        The certificate's deployment status on the production network.
        """
        return pulumi.get(self, "production_status")

    @_builtins.property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> _builtins.str:
        """
        The certificate's deployment status on the staging network.
        """
        return pulumi.get(self, "staging_status")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The destination part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetPropertyHostnamesHostnameCertStatusResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 production_status: _builtins.str,
                 staging_status: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.str hostname: The hostname part of the CNAME record used to validate the certificate's domain.
        :param _builtins.str production_status: The certificate's deployment status on the production network.
        :param _builtins.str staging_status: The certificate's deployment status on the staging network.
        :param _builtins.str target: The destination part of the CNAME record used to validate the certificate's domain.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "production_status", production_status)
        pulumi.set(__self__, "staging_status", staging_status)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The hostname part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> _builtins.str:
        """
        The certificate's deployment status on the production network.
        """
        return pulumi.get(self, "production_status")

    @_builtins.property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> _builtins.str:
        """
        The certificate's deployment status on the staging network.
        """
        return pulumi.get(self, "staging_status")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The destination part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetPropertyIncludeParentsParentResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 is_include_used_in_production_version: _builtins.bool,
                 is_include_used_in_staging_version: _builtins.bool,
                 name: _builtins.str,
                 production_version: _builtins.str,
                 staging_version: _builtins.str):
        """
        :param _builtins.str id: The property's unique identifier
        :param _builtins.bool is_include_used_in_production_version: Indicates if the include is used in the production network
        :param _builtins.bool is_include_used_in_staging_version: Indicates if the include is used in the staging network
        :param _builtins.str name: A descriptive name for the property
        :param _builtins.str production_version: The most recent property version to be activated to the production network
        :param _builtins.str staging_version: The most recent property version to be activated to the staging network
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_include_used_in_production_version", is_include_used_in_production_version)
        pulumi.set(__self__, "is_include_used_in_staging_version", is_include_used_in_staging_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "production_version", production_version)
        pulumi.set(__self__, "staging_version", staging_version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The property's unique identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isIncludeUsedInProductionVersion")
    def is_include_used_in_production_version(self) -> _builtins.bool:
        """
        Indicates if the include is used in the production network
        """
        return pulumi.get(self, "is_include_used_in_production_version")

    @_builtins.property
    @pulumi.getter(name="isIncludeUsedInStagingVersion")
    def is_include_used_in_staging_version(self) -> _builtins.bool:
        """
        Indicates if the include is used in the staging network
        """
        return pulumi.get(self, "is_include_used_in_staging_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive name for the property
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productionVersion")
    def production_version(self) -> _builtins.str:
        """
        The most recent property version to be activated to the production network
        """
        return pulumi.get(self, "production_version")

    @_builtins.property
    @pulumi.getter(name="stagingVersion")
    def staging_version(self) -> _builtins.str:
        """
        The most recent property version to be activated to the staging network
        """
        return pulumi.get(self, "staging_version")


@pulumi.output_type
class GetPropertyIncludesIncludeResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 latest_version: _builtins.int,
                 name: _builtins.str,
                 production_version: _builtins.str,
                 staging_version: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The include's unique identifier
        :param _builtins.int latest_version: Specifies the most recent version of the include
        :param _builtins.str name: A descriptive name for the include
        :param _builtins.str production_version: The most recent version to be activated to the production network
        :param _builtins.str staging_version: The most recent version to be activated to the staging network
        :param _builtins.str type: Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "production_version", production_version)
        pulumi.set(__self__, "staging_version", staging_version)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The include's unique identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.int:
        """
        Specifies the most recent version of the include
        """
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive name for the include
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productionVersion")
    def production_version(self) -> _builtins.str:
        """
        The most recent version to be activated to the production network
        """
        return pulumi.get(self, "production_version")

    @_builtins.property
    @pulumi.getter(name="stagingVersion")
    def staging_version(self) -> _builtins.str:
        """
        The most recent version to be activated to the staging network
        """
        return pulumi.get(self, "staging_version")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPropertyIncludesParentPropertyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str id: The property's unique identifier
        :param _builtins.int version: The property's version for which the data is requested
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The property's unique identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The property's version for which the data is requested
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPropertyProductsProductResult(dict):
    def __init__(__self__, *,
                 product_id: _builtins.str,
                 product_name: _builtins.str):
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "product_name", product_name)

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> _builtins.str:
        return pulumi.get(self, "product_name")


@pulumi.output_type
class GetPropertyRulesTemplateTemplateResult(dict):
    def __init__(__self__, *,
                 template_data: _builtins.str,
                 template_dir: _builtins.str):
        """
        :param _builtins.str template_data: Content of the template as string
        :param _builtins.str template_dir: Directory points to a folder, which contains snippets to include into template.
        """
        pulumi.set(__self__, "template_data", template_data)
        pulumi.set(__self__, "template_dir", template_dir)

    @_builtins.property
    @pulumi.getter(name="templateData")
    def template_data(self) -> _builtins.str:
        """
        Content of the template as string
        """
        return pulumi.get(self, "template_data")

    @_builtins.property
    @pulumi.getter(name="templateDir")
    def template_dir(self) -> _builtins.str:
        """
        Directory points to a folder, which contains snippets to include into template.
        """
        return pulumi.get(self, "template_dir")


@pulumi.output_type
class GetPropertyRulesTemplateVariableResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetZoneDnssecStatusCurrentRecordsResult(dict):
    def __init__(__self__, *,
                 dnskey_record: _builtins.str,
                 ds_record: _builtins.str,
                 expected_ttl: _builtins.int,
                 last_modified_date: _builtins.str):
        """
        :param _builtins.str dnskey_record: The generated DNSKEY record for this zone.
        :param _builtins.str ds_record: The generated DS record for this zone.
        :param _builtins.int expected_ttl: The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
        :param _builtins.str last_modified_date: The ISO 8601 timestamp on which these records were generated.
        """
        pulumi.set(__self__, "dnskey_record", dnskey_record)
        pulumi.set(__self__, "ds_record", ds_record)
        pulumi.set(__self__, "expected_ttl", expected_ttl)
        pulumi.set(__self__, "last_modified_date", last_modified_date)

    @_builtins.property
    @pulumi.getter(name="dnskeyRecord")
    def dnskey_record(self) -> _builtins.str:
        """
        The generated DNSKEY record for this zone.
        """
        return pulumi.get(self, "dnskey_record")

    @_builtins.property
    @pulumi.getter(name="dsRecord")
    def ds_record(self) -> _builtins.str:
        """
        The generated DS record for this zone.
        """
        return pulumi.get(self, "ds_record")

    @_builtins.property
    @pulumi.getter(name="expectedTtl")
    def expected_ttl(self) -> _builtins.int:
        """
        The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
        """
        return pulumi.get(self, "expected_ttl")

    @_builtins.property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> _builtins.str:
        """
        The ISO 8601 timestamp on which these records were generated.
        """
        return pulumi.get(self, "last_modified_date")


@pulumi.output_type
class GetZoneDnssecStatusNewRecordsResult(dict):
    def __init__(__self__, *,
                 dnskey_record: _builtins.str,
                 ds_record: _builtins.str,
                 expected_ttl: _builtins.int,
                 last_modified_date: _builtins.str):
        """
        :param _builtins.str dnskey_record: The generated DNSKEY record for this zone.
        :param _builtins.str ds_record: The generated DS record for this zone.
        :param _builtins.int expected_ttl: The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
        :param _builtins.str last_modified_date: The ISO 8601 timestamp on which these records were generated.
        """
        pulumi.set(__self__, "dnskey_record", dnskey_record)
        pulumi.set(__self__, "ds_record", ds_record)
        pulumi.set(__self__, "expected_ttl", expected_ttl)
        pulumi.set(__self__, "last_modified_date", last_modified_date)

    @_builtins.property
    @pulumi.getter(name="dnskeyRecord")
    def dnskey_record(self) -> _builtins.str:
        """
        The generated DNSKEY record for this zone.
        """
        return pulumi.get(self, "dnskey_record")

    @_builtins.property
    @pulumi.getter(name="dsRecord")
    def ds_record(self) -> _builtins.str:
        """
        The generated DS record for this zone.
        """
        return pulumi.get(self, "ds_record")

    @_builtins.property
    @pulumi.getter(name="expectedTtl")
    def expected_ttl(self) -> _builtins.int:
        """
        The TTL on the NS record for this zone. This should match the TTL on the DS or DNSKEY record.
        """
        return pulumi.get(self, "expected_ttl")

    @_builtins.property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> _builtins.str:
        """
        The ISO 8601 timestamp on which these records were generated.
        """
        return pulumi.get(self, "last_modified_date")


