# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['GtmPropertyArgs', 'GtmProperty']

@pulumi.input_type
class GtmPropertyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 handout_limit: pulumi.Input[int],
                 handout_mode: pulumi.Input[str],
                 score_aggregation_type: pulumi.Input[str],
                 type: pulumi.Input[str],
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a GtmProperty resource.
        """
        GtmPropertyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            handout_limit=handout_limit,
            handout_mode=handout_mode,
            score_aggregation_type=score_aggregation_type,
            type=type,
            backup_cname=backup_cname,
            backup_ip=backup_ip,
            balance_by_download_score=balance_by_download_score,
            cname=cname,
            comments=comments,
            dynamic_ttl=dynamic_ttl,
            failback_delay=failback_delay,
            failover_delay=failover_delay,
            ghost_demand_reporting=ghost_demand_reporting,
            health_max=health_max,
            health_multiplier=health_multiplier,
            health_threshold=health_threshold,
            ipv6=ipv6,
            liveness_tests=liveness_tests,
            load_imbalance_percentage=load_imbalance_percentage,
            map_name=map_name,
            max_unreachable_penalty=max_unreachable_penalty,
            min_live_fraction=min_live_fraction,
            name=name,
            static_rr_sets=static_rr_sets,
            static_ttl=static_ttl,
            stickiness_bonus_constant=stickiness_bonus_constant,
            stickiness_bonus_percentage=stickiness_bonus_percentage,
            traffic_targets=traffic_targets,
            unreachable_threshold=unreachable_threshold,
            use_computed_targets=use_computed_targets,
            wait_on_complete=wait_on_complete,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             handout_limit: pulumi.Input[int],
             handout_mode: pulumi.Input[str],
             score_aggregation_type: pulumi.Input[str],
             type: pulumi.Input[str],
             backup_cname: Optional[pulumi.Input[str]] = None,
             backup_ip: Optional[pulumi.Input[str]] = None,
             balance_by_download_score: Optional[pulumi.Input[bool]] = None,
             cname: Optional[pulumi.Input[str]] = None,
             comments: Optional[pulumi.Input[str]] = None,
             dynamic_ttl: Optional[pulumi.Input[int]] = None,
             failback_delay: Optional[pulumi.Input[int]] = None,
             failover_delay: Optional[pulumi.Input[int]] = None,
             ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
             health_max: Optional[pulumi.Input[float]] = None,
             health_multiplier: Optional[pulumi.Input[float]] = None,
             health_threshold: Optional[pulumi.Input[float]] = None,
             ipv6: Optional[pulumi.Input[bool]] = None,
             liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
             load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
             map_name: Optional[pulumi.Input[str]] = None,
             max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
             min_live_fraction: Optional[pulumi.Input[float]] = None,
             name: Optional[pulumi.Input[str]] = None,
             static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
             static_ttl: Optional[pulumi.Input[int]] = None,
             stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
             stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
             traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
             unreachable_threshold: Optional[pulumi.Input[float]] = None,
             use_computed_targets: Optional[pulumi.Input[bool]] = None,
             wait_on_complete: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'handoutLimit' in kwargs:
            handout_limit = kwargs['handoutLimit']
        if 'handoutMode' in kwargs:
            handout_mode = kwargs['handoutMode']
        if 'scoreAggregationType' in kwargs:
            score_aggregation_type = kwargs['scoreAggregationType']
        if 'backupCname' in kwargs:
            backup_cname = kwargs['backupCname']
        if 'backupIp' in kwargs:
            backup_ip = kwargs['backupIp']
        if 'balanceByDownloadScore' in kwargs:
            balance_by_download_score = kwargs['balanceByDownloadScore']
        if 'dynamicTtl' in kwargs:
            dynamic_ttl = kwargs['dynamicTtl']
        if 'failbackDelay' in kwargs:
            failback_delay = kwargs['failbackDelay']
        if 'failoverDelay' in kwargs:
            failover_delay = kwargs['failoverDelay']
        if 'ghostDemandReporting' in kwargs:
            ghost_demand_reporting = kwargs['ghostDemandReporting']
        if 'healthMax' in kwargs:
            health_max = kwargs['healthMax']
        if 'healthMultiplier' in kwargs:
            health_multiplier = kwargs['healthMultiplier']
        if 'healthThreshold' in kwargs:
            health_threshold = kwargs['healthThreshold']
        if 'livenessTests' in kwargs:
            liveness_tests = kwargs['livenessTests']
        if 'loadImbalancePercentage' in kwargs:
            load_imbalance_percentage = kwargs['loadImbalancePercentage']
        if 'mapName' in kwargs:
            map_name = kwargs['mapName']
        if 'maxUnreachablePenalty' in kwargs:
            max_unreachable_penalty = kwargs['maxUnreachablePenalty']
        if 'minLiveFraction' in kwargs:
            min_live_fraction = kwargs['minLiveFraction']
        if 'staticRrSets' in kwargs:
            static_rr_sets = kwargs['staticRrSets']
        if 'staticTtl' in kwargs:
            static_ttl = kwargs['staticTtl']
        if 'stickinessBonusConstant' in kwargs:
            stickiness_bonus_constant = kwargs['stickinessBonusConstant']
        if 'stickinessBonusPercentage' in kwargs:
            stickiness_bonus_percentage = kwargs['stickinessBonusPercentage']
        if 'trafficTargets' in kwargs:
            traffic_targets = kwargs['trafficTargets']
        if 'unreachableThreshold' in kwargs:
            unreachable_threshold = kwargs['unreachableThreshold']
        if 'useComputedTargets' in kwargs:
            use_computed_targets = kwargs['useComputedTargets']
        if 'waitOnComplete' in kwargs:
            wait_on_complete = kwargs['waitOnComplete']

        _setter("domain", domain)
        _setter("handout_limit", handout_limit)
        _setter("handout_mode", handout_mode)
        _setter("score_aggregation_type", score_aggregation_type)
        _setter("type", type)
        if backup_cname is not None:
            _setter("backup_cname", backup_cname)
        if backup_ip is not None:
            _setter("backup_ip", backup_ip)
        if balance_by_download_score is not None:
            _setter("balance_by_download_score", balance_by_download_score)
        if cname is not None:
            _setter("cname", cname)
        if comments is not None:
            _setter("comments", comments)
        if dynamic_ttl is not None:
            _setter("dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            _setter("failback_delay", failback_delay)
        if failover_delay is not None:
            _setter("failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            _setter("ghost_demand_reporting", ghost_demand_reporting)
        if health_max is not None:
            _setter("health_max", health_max)
        if health_multiplier is not None:
            _setter("health_multiplier", health_multiplier)
        if health_threshold is not None:
            _setter("health_threshold", health_threshold)
        if ipv6 is not None:
            _setter("ipv6", ipv6)
        if liveness_tests is not None:
            _setter("liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            _setter("load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            _setter("map_name", map_name)
        if max_unreachable_penalty is not None:
            _setter("max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            _setter("min_live_fraction", min_live_fraction)
        if name is not None:
            _setter("name", name)
        if static_rr_sets is not None:
            _setter("static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            _setter("static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            _setter("stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            _setter("stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            _setter("traffic_targets", traffic_targets)
        if unreachable_threshold is not None:
            _setter("unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            _setter("use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            _setter("wait_on_complete", wait_on_complete)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)


@pulumi.input_type
class _GtmPropertyState:
    def __init__(__self__, *,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
                 weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None):
        """
        Input properties used for looking up and filtering GtmProperty resources.
        """
        _GtmPropertyState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_cname=backup_cname,
            backup_ip=backup_ip,
            balance_by_download_score=balance_by_download_score,
            cname=cname,
            comments=comments,
            domain=domain,
            dynamic_ttl=dynamic_ttl,
            failback_delay=failback_delay,
            failover_delay=failover_delay,
            ghost_demand_reporting=ghost_demand_reporting,
            handout_limit=handout_limit,
            handout_mode=handout_mode,
            health_max=health_max,
            health_multiplier=health_multiplier,
            health_threshold=health_threshold,
            ipv6=ipv6,
            liveness_tests=liveness_tests,
            load_imbalance_percentage=load_imbalance_percentage,
            map_name=map_name,
            max_unreachable_penalty=max_unreachable_penalty,
            min_live_fraction=min_live_fraction,
            name=name,
            score_aggregation_type=score_aggregation_type,
            static_rr_sets=static_rr_sets,
            static_ttl=static_ttl,
            stickiness_bonus_constant=stickiness_bonus_constant,
            stickiness_bonus_percentage=stickiness_bonus_percentage,
            traffic_targets=traffic_targets,
            type=type,
            unreachable_threshold=unreachable_threshold,
            use_computed_targets=use_computed_targets,
            wait_on_complete=wait_on_complete,
            weighted_hash_bits_for_ipv4=weighted_hash_bits_for_ipv4,
            weighted_hash_bits_for_ipv6=weighted_hash_bits_for_ipv6,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_cname: Optional[pulumi.Input[str]] = None,
             backup_ip: Optional[pulumi.Input[str]] = None,
             balance_by_download_score: Optional[pulumi.Input[bool]] = None,
             cname: Optional[pulumi.Input[str]] = None,
             comments: Optional[pulumi.Input[str]] = None,
             domain: Optional[pulumi.Input[str]] = None,
             dynamic_ttl: Optional[pulumi.Input[int]] = None,
             failback_delay: Optional[pulumi.Input[int]] = None,
             failover_delay: Optional[pulumi.Input[int]] = None,
             ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
             handout_limit: Optional[pulumi.Input[int]] = None,
             handout_mode: Optional[pulumi.Input[str]] = None,
             health_max: Optional[pulumi.Input[float]] = None,
             health_multiplier: Optional[pulumi.Input[float]] = None,
             health_threshold: Optional[pulumi.Input[float]] = None,
             ipv6: Optional[pulumi.Input[bool]] = None,
             liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
             load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
             map_name: Optional[pulumi.Input[str]] = None,
             max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
             min_live_fraction: Optional[pulumi.Input[float]] = None,
             name: Optional[pulumi.Input[str]] = None,
             score_aggregation_type: Optional[pulumi.Input[str]] = None,
             static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
             static_ttl: Optional[pulumi.Input[int]] = None,
             stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
             stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
             traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             unreachable_threshold: Optional[pulumi.Input[float]] = None,
             use_computed_targets: Optional[pulumi.Input[bool]] = None,
             wait_on_complete: Optional[pulumi.Input[bool]] = None,
             weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
             weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backupCname' in kwargs:
            backup_cname = kwargs['backupCname']
        if 'backupIp' in kwargs:
            backup_ip = kwargs['backupIp']
        if 'balanceByDownloadScore' in kwargs:
            balance_by_download_score = kwargs['balanceByDownloadScore']
        if 'dynamicTtl' in kwargs:
            dynamic_ttl = kwargs['dynamicTtl']
        if 'failbackDelay' in kwargs:
            failback_delay = kwargs['failbackDelay']
        if 'failoverDelay' in kwargs:
            failover_delay = kwargs['failoverDelay']
        if 'ghostDemandReporting' in kwargs:
            ghost_demand_reporting = kwargs['ghostDemandReporting']
        if 'handoutLimit' in kwargs:
            handout_limit = kwargs['handoutLimit']
        if 'handoutMode' in kwargs:
            handout_mode = kwargs['handoutMode']
        if 'healthMax' in kwargs:
            health_max = kwargs['healthMax']
        if 'healthMultiplier' in kwargs:
            health_multiplier = kwargs['healthMultiplier']
        if 'healthThreshold' in kwargs:
            health_threshold = kwargs['healthThreshold']
        if 'livenessTests' in kwargs:
            liveness_tests = kwargs['livenessTests']
        if 'loadImbalancePercentage' in kwargs:
            load_imbalance_percentage = kwargs['loadImbalancePercentage']
        if 'mapName' in kwargs:
            map_name = kwargs['mapName']
        if 'maxUnreachablePenalty' in kwargs:
            max_unreachable_penalty = kwargs['maxUnreachablePenalty']
        if 'minLiveFraction' in kwargs:
            min_live_fraction = kwargs['minLiveFraction']
        if 'scoreAggregationType' in kwargs:
            score_aggregation_type = kwargs['scoreAggregationType']
        if 'staticRrSets' in kwargs:
            static_rr_sets = kwargs['staticRrSets']
        if 'staticTtl' in kwargs:
            static_ttl = kwargs['staticTtl']
        if 'stickinessBonusConstant' in kwargs:
            stickiness_bonus_constant = kwargs['stickinessBonusConstant']
        if 'stickinessBonusPercentage' in kwargs:
            stickiness_bonus_percentage = kwargs['stickinessBonusPercentage']
        if 'trafficTargets' in kwargs:
            traffic_targets = kwargs['trafficTargets']
        if 'unreachableThreshold' in kwargs:
            unreachable_threshold = kwargs['unreachableThreshold']
        if 'useComputedTargets' in kwargs:
            use_computed_targets = kwargs['useComputedTargets']
        if 'waitOnComplete' in kwargs:
            wait_on_complete = kwargs['waitOnComplete']
        if 'weightedHashBitsForIpv4' in kwargs:
            weighted_hash_bits_for_ipv4 = kwargs['weightedHashBitsForIpv4']
        if 'weightedHashBitsForIpv6' in kwargs:
            weighted_hash_bits_for_ipv6 = kwargs['weightedHashBitsForIpv6']

        if backup_cname is not None:
            _setter("backup_cname", backup_cname)
        if backup_ip is not None:
            _setter("backup_ip", backup_ip)
        if balance_by_download_score is not None:
            _setter("balance_by_download_score", balance_by_download_score)
        if cname is not None:
            _setter("cname", cname)
        if comments is not None:
            _setter("comments", comments)
        if domain is not None:
            _setter("domain", domain)
        if dynamic_ttl is not None:
            _setter("dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            _setter("failback_delay", failback_delay)
        if failover_delay is not None:
            _setter("failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            _setter("ghost_demand_reporting", ghost_demand_reporting)
        if handout_limit is not None:
            _setter("handout_limit", handout_limit)
        if handout_mode is not None:
            _setter("handout_mode", handout_mode)
        if health_max is not None:
            _setter("health_max", health_max)
        if health_multiplier is not None:
            _setter("health_multiplier", health_multiplier)
        if health_threshold is not None:
            _setter("health_threshold", health_threshold)
        if ipv6 is not None:
            _setter("ipv6", ipv6)
        if liveness_tests is not None:
            _setter("liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            _setter("load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            _setter("map_name", map_name)
        if max_unreachable_penalty is not None:
            _setter("max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            _setter("min_live_fraction", min_live_fraction)
        if name is not None:
            _setter("name", name)
        if score_aggregation_type is not None:
            _setter("score_aggregation_type", score_aggregation_type)
        if static_rr_sets is not None:
            _setter("static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            _setter("static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            _setter("stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            _setter("stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            _setter("traffic_targets", traffic_targets)
        if type is not None:
            _setter("type", type)
        if unreachable_threshold is not None:
            _setter("unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            _setter("use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            _setter("wait_on_complete", wait_on_complete)
        if weighted_hash_bits_for_ipv4 is not None:
            _setter("weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
        if weighted_hash_bits_for_ipv6 is not None:
            _setter("weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @weighted_hash_bits_for_ipv4.setter
    def weighted_hash_bits_for_ipv4(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv4", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

    @weighted_hash_bits_for_ipv6.setter
    def weighted_hash_bits_for_ipv6(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv6", value)


class GtmProperty(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        Create a GtmProperty resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: GtmPropertyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a GtmProperty resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param GtmPropertyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(GtmPropertyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            GtmPropertyArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = GtmPropertyArgs.__new__(GtmPropertyArgs)

            __props__.__dict__["backup_cname"] = backup_cname
            __props__.__dict__["backup_ip"] = backup_ip
            __props__.__dict__["balance_by_download_score"] = balance_by_download_score
            __props__.__dict__["cname"] = cname
            __props__.__dict__["comments"] = comments
            if domain is None and not opts.urn:
                raise TypeError("Missing required property 'domain'")
            __props__.__dict__["domain"] = domain
            __props__.__dict__["dynamic_ttl"] = dynamic_ttl
            __props__.__dict__["failback_delay"] = failback_delay
            __props__.__dict__["failover_delay"] = failover_delay
            __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
            if handout_limit is None and not opts.urn:
                raise TypeError("Missing required property 'handout_limit'")
            __props__.__dict__["handout_limit"] = handout_limit
            if handout_mode is None and not opts.urn:
                raise TypeError("Missing required property 'handout_mode'")
            __props__.__dict__["handout_mode"] = handout_mode
            __props__.__dict__["health_max"] = health_max
            __props__.__dict__["health_multiplier"] = health_multiplier
            __props__.__dict__["health_threshold"] = health_threshold
            __props__.__dict__["ipv6"] = ipv6
            __props__.__dict__["liveness_tests"] = liveness_tests
            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
            __props__.__dict__["map_name"] = map_name
            __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
            __props__.__dict__["min_live_fraction"] = min_live_fraction
            __props__.__dict__["name"] = name
            if score_aggregation_type is None and not opts.urn:
                raise TypeError("Missing required property 'score_aggregation_type'")
            __props__.__dict__["score_aggregation_type"] = score_aggregation_type
            __props__.__dict__["static_rr_sets"] = static_rr_sets
            __props__.__dict__["static_ttl"] = static_ttl
            __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
            __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
            __props__.__dict__["traffic_targets"] = traffic_targets
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["unreachable_threshold"] = unreachable_threshold
            __props__.__dict__["use_computed_targets"] = use_computed_targets
            __props__.__dict__["wait_on_complete"] = wait_on_complete
            __props__.__dict__["weighted_hash_bits_for_ipv4"] = None
            __props__.__dict__["weighted_hash_bits_for_ipv6"] = None
        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmProperty:GtmProperty")])
        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
        super(GtmProperty, __self__).__init__(
            'akamai:index/gtmProperty:GtmProperty',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            backup_cname: Optional[pulumi.Input[str]] = None,
            backup_ip: Optional[pulumi.Input[str]] = None,
            balance_by_download_score: Optional[pulumi.Input[bool]] = None,
            cname: Optional[pulumi.Input[str]] = None,
            comments: Optional[pulumi.Input[str]] = None,
            domain: Optional[pulumi.Input[str]] = None,
            dynamic_ttl: Optional[pulumi.Input[int]] = None,
            failback_delay: Optional[pulumi.Input[int]] = None,
            failover_delay: Optional[pulumi.Input[int]] = None,
            ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
            handout_limit: Optional[pulumi.Input[int]] = None,
            handout_mode: Optional[pulumi.Input[str]] = None,
            health_max: Optional[pulumi.Input[float]] = None,
            health_multiplier: Optional[pulumi.Input[float]] = None,
            health_threshold: Optional[pulumi.Input[float]] = None,
            ipv6: Optional[pulumi.Input[bool]] = None,
            liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
            map_name: Optional[pulumi.Input[str]] = None,
            max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
            min_live_fraction: Optional[pulumi.Input[float]] = None,
            name: Optional[pulumi.Input[str]] = None,
            score_aggregation_type: Optional[pulumi.Input[str]] = None,
            static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
            static_ttl: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
            traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
            type: Optional[pulumi.Input[str]] = None,
            unreachable_threshold: Optional[pulumi.Input[float]] = None,
            use_computed_targets: Optional[pulumi.Input[bool]] = None,
            wait_on_complete: Optional[pulumi.Input[bool]] = None,
            weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
            weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None) -> 'GtmProperty':
        """
        Get an existing GtmProperty resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _GtmPropertyState.__new__(_GtmPropertyState)

        __props__.__dict__["backup_cname"] = backup_cname
        __props__.__dict__["backup_ip"] = backup_ip
        __props__.__dict__["balance_by_download_score"] = balance_by_download_score
        __props__.__dict__["cname"] = cname
        __props__.__dict__["comments"] = comments
        __props__.__dict__["domain"] = domain
        __props__.__dict__["dynamic_ttl"] = dynamic_ttl
        __props__.__dict__["failback_delay"] = failback_delay
        __props__.__dict__["failover_delay"] = failover_delay
        __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
        __props__.__dict__["handout_limit"] = handout_limit
        __props__.__dict__["handout_mode"] = handout_mode
        __props__.__dict__["health_max"] = health_max
        __props__.__dict__["health_multiplier"] = health_multiplier
        __props__.__dict__["health_threshold"] = health_threshold
        __props__.__dict__["ipv6"] = ipv6
        __props__.__dict__["liveness_tests"] = liveness_tests
        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
        __props__.__dict__["map_name"] = map_name
        __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
        __props__.__dict__["min_live_fraction"] = min_live_fraction
        __props__.__dict__["name"] = name
        __props__.__dict__["score_aggregation_type"] = score_aggregation_type
        __props__.__dict__["static_rr_sets"] = static_rr_sets
        __props__.__dict__["static_ttl"] = static_ttl
        __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
        __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
        __props__.__dict__["traffic_targets"] = traffic_targets
        __props__.__dict__["type"] = type
        __props__.__dict__["unreachable_threshold"] = unreachable_threshold
        __props__.__dict__["use_computed_targets"] = use_computed_targets
        __props__.__dict__["wait_on_complete"] = wait_on_complete
        __props__.__dict__["weighted_hash_bits_for_ipv4"] = weighted_hash_bits_for_ipv4
        __props__.__dict__["weighted_hash_bits_for_ipv6"] = weighted_hash_bits_for_ipv6
        return GtmProperty(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "backup_cname")

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "backup_ip")

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @property
    @pulumi.getter
    def cname(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter
    def comments(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Output[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "failback_delay")

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "failover_delay")

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Output[int]:
        return pulumi.get(self, "handout_limit")

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Output[str]:
        return pulumi.get(self, "handout_mode")

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_max")

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_multiplier")

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_threshold")

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyLivenessTest']]]:
        return pulumi.get(self, "liveness_tests")

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "map_name")

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "min_live_fraction")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Output[str]:
        return pulumi.get(self, "score_aggregation_type")

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyStaticRrSet']]]:
        return pulumi.get(self, "static_rr_sets")

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "static_ttl")

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyTrafficTarget']]]:
        return pulumi.get(self, "traffic_targets")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

