# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['GtmPropertyArgs', 'GtmProperty']

@pulumi.input_type
class GtmPropertyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 handout_limit: pulumi.Input[int],
                 handout_mode: pulumi.Input[str],
                 score_aggregation_type: pulumi.Input[str],
                 type: pulumi.Input[str],
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a GtmProperty resource.
        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this Property.
        :param pulumi.Input[int] handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param pulumi.Input[str] handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param pulumi.Input[str] score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param pulumi.Input[str] type: The record type.
        :param pulumi.Input[str] backup_cname: Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        :param pulumi.Input[str] backup_ip: Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        :param pulumi.Input[bool] balance_by_download_score: A boolean that indicates whether download score based load balancing is enabled.
        :param pulumi.Input[str] cname: Indicates the fully qualified name aliased to a particular property.
        :param pulumi.Input[str] comments: A descriptive note about changes to the domain. The maximum is 4000 characters.
        :param pulumi.Input[int] dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        :param pulumi.Input[int] failback_delay: Specifies the failback delay in seconds.
        :param pulumi.Input[int] failover_delay: Specifies the failover delay in seconds.
        :param pulumi.Input[bool] ghost_demand_reporting: Use load estimates from Akamai Ghost utilization messages.
        :param pulumi.Input[float] health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param pulumi.Input[float] health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[float] health_threshold: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[bool] ipv6: A boolean that indicates the type of IP address handed out by a GTM property.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]] liveness_tests: Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        :param pulumi.Input[float] load_imbalance_percentage: Indicates the percent of load imbalance factor (LIF) for the property.
        :param pulumi.Input[str] map_name: A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        :param pulumi.Input[int] max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param pulumi.Input[float] min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]] static_rr_sets: Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        :param pulumi.Input[int] stickiness_bonus_constant: Specifies a constant used to configure data center affinity.
        :param pulumi.Input[int] stickiness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]] traffic_targets: Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        :param pulumi.Input[float] unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param pulumi.Input[bool] use_computed_targets: For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "handout_limit", handout_limit)
        pulumi.set(__self__, "handout_mode", handout_mode)
        pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        pulumi.set(__self__, "type", type)
        if backup_cname is not None:
            pulumi.set(__self__, "backup_cname", backup_cname)
        if backup_ip is not None:
            pulumi.set(__self__, "backup_ip", backup_ip)
        if balance_by_download_score is not None:
            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if dynamic_ttl is not None:
            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            pulumi.set(__self__, "failback_delay", failback_delay)
        if failover_delay is not None:
            pulumi.set(__self__, "failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        if health_max is not None:
            pulumi.set(__self__, "health_max", health_max)
        if health_multiplier is not None:
            pulumi.set(__self__, "health_multiplier", health_multiplier)
        if health_threshold is not None:
            pulumi.set(__self__, "health_threshold", health_threshold)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            pulumi.set(__self__, "map_name", map_name)
        if max_unreachable_penalty is not None:
            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            pulumi.set(__self__, "static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)
        if unreachable_threshold is not None:
            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            pulumi.set(__self__, "wait_on_complete", wait_on_complete)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        DNS name for the GTM Domain set that includes this Property.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Input[int]:
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Input[str]:
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Input[str]:
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        """
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        """
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that indicates whether download score based load balancing is enabled.
        """
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive note about changes to the domain. The maximum is 4000 characters.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        """
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the failback delay in seconds.
        """
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the failover delay in seconds.
        """
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        """
        Use load estimates from Akamai Ghost utilization messages.
        """
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that indicates the type of IP address handed out by a GTM property.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        """
        Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        """
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the percent of load imbalance factor (LIF) for the property.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        """
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        """
        Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        """
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a constant used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        """
        Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        """
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        """
        For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        """
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)


@pulumi.input_type
class _GtmPropertyState:
    def __init__(__self__, *,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
                 weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None):
        """
        Input properties used for looking up and filtering GtmProperty resources.
        :param pulumi.Input[str] backup_cname: Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        :param pulumi.Input[str] backup_ip: Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        :param pulumi.Input[bool] balance_by_download_score: A boolean that indicates whether download score based load balancing is enabled.
        :param pulumi.Input[str] cname: Indicates the fully qualified name aliased to a particular property.
        :param pulumi.Input[str] comments: A descriptive note about changes to the domain. The maximum is 4000 characters.
        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this Property.
        :param pulumi.Input[int] dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        :param pulumi.Input[int] failback_delay: Specifies the failback delay in seconds.
        :param pulumi.Input[int] failover_delay: Specifies the failover delay in seconds.
        :param pulumi.Input[bool] ghost_demand_reporting: Use load estimates from Akamai Ghost utilization messages.
        :param pulumi.Input[int] handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param pulumi.Input[str] handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param pulumi.Input[float] health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param pulumi.Input[float] health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[float] health_threshold: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[bool] ipv6: A boolean that indicates the type of IP address handed out by a GTM property.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]] liveness_tests: Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        :param pulumi.Input[float] load_imbalance_percentage: Indicates the percent of load imbalance factor (LIF) for the property.
        :param pulumi.Input[str] map_name: A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        :param pulumi.Input[int] max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param pulumi.Input[float] min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[str] score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]] static_rr_sets: Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        :param pulumi.Input[int] stickiness_bonus_constant: Specifies a constant used to configure data center affinity.
        :param pulumi.Input[int] stickiness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]] traffic_targets: Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        :param pulumi.Input[str] type: The record type.
        :param pulumi.Input[float] unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param pulumi.Input[bool] use_computed_targets: For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        if backup_cname is not None:
            pulumi.set(__self__, "backup_cname", backup_cname)
        if backup_ip is not None:
            pulumi.set(__self__, "backup_ip", backup_ip)
        if balance_by_download_score is not None:
            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if dynamic_ttl is not None:
            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            pulumi.set(__self__, "failback_delay", failback_delay)
        if failover_delay is not None:
            pulumi.set(__self__, "failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        if handout_limit is not None:
            pulumi.set(__self__, "handout_limit", handout_limit)
        if handout_mode is not None:
            pulumi.set(__self__, "handout_mode", handout_mode)
        if health_max is not None:
            pulumi.set(__self__, "health_max", health_max)
        if health_multiplier is not None:
            pulumi.set(__self__, "health_multiplier", health_multiplier)
        if health_threshold is not None:
            pulumi.set(__self__, "health_threshold", health_threshold)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            pulumi.set(__self__, "map_name", map_name)
        if max_unreachable_penalty is not None:
            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if score_aggregation_type is not None:
            pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            pulumi.set(__self__, "static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unreachable_threshold is not None:
            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
        if weighted_hash_bits_for_ipv4 is not None:
            pulumi.set(__self__, "weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
        if weighted_hash_bits_for_ipv6 is not None:
            pulumi.set(__self__, "weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        """
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        """
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that indicates whether download score based load balancing is enabled.
        """
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive note about changes to the domain. The maximum is 4000 characters.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name for the GTM Domain set that includes this Property.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        """
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the failback delay in seconds.
        """
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the failover delay in seconds.
        """
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        """
        Use load estimates from Akamai Ghost utilization messages.
        """
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that indicates the type of IP address handed out by a GTM property.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        """
        Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        """
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the percent of load imbalance factor (LIF) for the property.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        """
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        """
        Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        """
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a constant used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        """
        Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        """
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        """
        For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        """
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @weighted_hash_bits_for_ipv4.setter
    def weighted_hash_bits_for_ipv4(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv4", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

    @weighted_hash_bits_for_ipv6.setter
    def weighted_hash_bits_for_ipv6(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv6", value)


class GtmProperty(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        Use the `GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.

        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.

        ## Example Usage

        Basic usage:

        ```python
        import pulumi
        import pulumi_akamai as akamai

        demo_property = akamai.GtmProperty("demoProperty",
            domain="demo_domain.akadns.net",
            handout_limit=5,
            handout_mode="normal",
            score_aggregation_type="median",
            traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(
                datacenter_id=3131,
            )],
            type="weighted-round-robin")
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] backup_cname: Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        :param pulumi.Input[str] backup_ip: Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        :param pulumi.Input[bool] balance_by_download_score: A boolean that indicates whether download score based load balancing is enabled.
        :param pulumi.Input[str] cname: Indicates the fully qualified name aliased to a particular property.
        :param pulumi.Input[str] comments: A descriptive note about changes to the domain. The maximum is 4000 characters.
        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this Property.
        :param pulumi.Input[int] dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        :param pulumi.Input[int] failback_delay: Specifies the failback delay in seconds.
        :param pulumi.Input[int] failover_delay: Specifies the failover delay in seconds.
        :param pulumi.Input[bool] ghost_demand_reporting: Use load estimates from Akamai Ghost utilization messages.
        :param pulumi.Input[int] handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param pulumi.Input[str] handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param pulumi.Input[float] health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param pulumi.Input[float] health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[float] health_threshold: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[bool] ipv6: A boolean that indicates the type of IP address handed out by a GTM property.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]] liveness_tests: Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        :param pulumi.Input[float] load_imbalance_percentage: Indicates the percent of load imbalance factor (LIF) for the property.
        :param pulumi.Input[str] map_name: A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        :param pulumi.Input[int] max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param pulumi.Input[float] min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[str] score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]] static_rr_sets: Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        :param pulumi.Input[int] stickiness_bonus_constant: Specifies a constant used to configure data center affinity.
        :param pulumi.Input[int] stickiness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]] traffic_targets: Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        :param pulumi.Input[str] type: The record type.
        :param pulumi.Input[float] unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param pulumi.Input[bool] use_computed_targets: For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: GtmPropertyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use the `GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.

        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.

        ## Example Usage

        Basic usage:

        ```python
        import pulumi
        import pulumi_akamai as akamai

        demo_property = akamai.GtmProperty("demoProperty",
            domain="demo_domain.akadns.net",
            handout_limit=5,
            handout_mode="normal",
            score_aggregation_type="median",
            traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(
                datacenter_id=3131,
            )],
            type="weighted-round-robin")
        ```

        :param str resource_name: The name of the resource.
        :param GtmPropertyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(GtmPropertyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = GtmPropertyArgs.__new__(GtmPropertyArgs)

            __props__.__dict__["backup_cname"] = backup_cname
            __props__.__dict__["backup_ip"] = backup_ip
            __props__.__dict__["balance_by_download_score"] = balance_by_download_score
            __props__.__dict__["cname"] = cname
            __props__.__dict__["comments"] = comments
            if domain is None and not opts.urn:
                raise TypeError("Missing required property 'domain'")
            __props__.__dict__["domain"] = domain
            __props__.__dict__["dynamic_ttl"] = dynamic_ttl
            __props__.__dict__["failback_delay"] = failback_delay
            __props__.__dict__["failover_delay"] = failover_delay
            __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
            if handout_limit is None and not opts.urn:
                raise TypeError("Missing required property 'handout_limit'")
            __props__.__dict__["handout_limit"] = handout_limit
            if handout_mode is None and not opts.urn:
                raise TypeError("Missing required property 'handout_mode'")
            __props__.__dict__["handout_mode"] = handout_mode
            __props__.__dict__["health_max"] = health_max
            __props__.__dict__["health_multiplier"] = health_multiplier
            __props__.__dict__["health_threshold"] = health_threshold
            __props__.__dict__["ipv6"] = ipv6
            __props__.__dict__["liveness_tests"] = liveness_tests
            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
            __props__.__dict__["map_name"] = map_name
            __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
            __props__.__dict__["min_live_fraction"] = min_live_fraction
            __props__.__dict__["name"] = name
            if score_aggregation_type is None and not opts.urn:
                raise TypeError("Missing required property 'score_aggregation_type'")
            __props__.__dict__["score_aggregation_type"] = score_aggregation_type
            __props__.__dict__["static_rr_sets"] = static_rr_sets
            __props__.__dict__["static_ttl"] = static_ttl
            __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
            __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
            __props__.__dict__["traffic_targets"] = traffic_targets
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["unreachable_threshold"] = unreachable_threshold
            __props__.__dict__["use_computed_targets"] = use_computed_targets
            __props__.__dict__["wait_on_complete"] = wait_on_complete
            __props__.__dict__["weighted_hash_bits_for_ipv4"] = None
            __props__.__dict__["weighted_hash_bits_for_ipv6"] = None
        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmProperty:GtmProperty")])
        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
        super(GtmProperty, __self__).__init__(
            'akamai:index/gtmProperty:GtmProperty',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            backup_cname: Optional[pulumi.Input[str]] = None,
            backup_ip: Optional[pulumi.Input[str]] = None,
            balance_by_download_score: Optional[pulumi.Input[bool]] = None,
            cname: Optional[pulumi.Input[str]] = None,
            comments: Optional[pulumi.Input[str]] = None,
            domain: Optional[pulumi.Input[str]] = None,
            dynamic_ttl: Optional[pulumi.Input[int]] = None,
            failback_delay: Optional[pulumi.Input[int]] = None,
            failover_delay: Optional[pulumi.Input[int]] = None,
            ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
            handout_limit: Optional[pulumi.Input[int]] = None,
            handout_mode: Optional[pulumi.Input[str]] = None,
            health_max: Optional[pulumi.Input[float]] = None,
            health_multiplier: Optional[pulumi.Input[float]] = None,
            health_threshold: Optional[pulumi.Input[float]] = None,
            ipv6: Optional[pulumi.Input[bool]] = None,
            liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
            map_name: Optional[pulumi.Input[str]] = None,
            max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
            min_live_fraction: Optional[pulumi.Input[float]] = None,
            name: Optional[pulumi.Input[str]] = None,
            score_aggregation_type: Optional[pulumi.Input[str]] = None,
            static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
            static_ttl: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
            traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
            type: Optional[pulumi.Input[str]] = None,
            unreachable_threshold: Optional[pulumi.Input[float]] = None,
            use_computed_targets: Optional[pulumi.Input[bool]] = None,
            wait_on_complete: Optional[pulumi.Input[bool]] = None,
            weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
            weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None) -> 'GtmProperty':
        """
        Get an existing GtmProperty resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] backup_cname: Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        :param pulumi.Input[str] backup_ip: Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        :param pulumi.Input[bool] balance_by_download_score: A boolean that indicates whether download score based load balancing is enabled.
        :param pulumi.Input[str] cname: Indicates the fully qualified name aliased to a particular property.
        :param pulumi.Input[str] comments: A descriptive note about changes to the domain. The maximum is 4000 characters.
        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this Property.
        :param pulumi.Input[int] dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        :param pulumi.Input[int] failback_delay: Specifies the failback delay in seconds.
        :param pulumi.Input[int] failover_delay: Specifies the failover delay in seconds.
        :param pulumi.Input[bool] ghost_demand_reporting: Use load estimates from Akamai Ghost utilization messages.
        :param pulumi.Input[int] handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param pulumi.Input[str] handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param pulumi.Input[float] health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param pulumi.Input[float] health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[float] health_threshold: Configures a cutoff value that is computed from the median scores.
        :param pulumi.Input[bool] ipv6: A boolean that indicates the type of IP address handed out by a GTM property.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]] liveness_tests: Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        :param pulumi.Input[float] load_imbalance_percentage: Indicates the percent of load imbalance factor (LIF) for the property.
        :param pulumi.Input[str] map_name: A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        :param pulumi.Input[int] max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param pulumi.Input[float] min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[str] score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]] static_rr_sets: Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        :param pulumi.Input[int] stickiness_bonus_constant: Specifies a constant used to configure data center affinity.
        :param pulumi.Input[int] stickiness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]] traffic_targets: Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        :param pulumi.Input[str] type: The record type.
        :param pulumi.Input[float] unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param pulumi.Input[bool] use_computed_targets: For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _GtmPropertyState.__new__(_GtmPropertyState)

        __props__.__dict__["backup_cname"] = backup_cname
        __props__.__dict__["backup_ip"] = backup_ip
        __props__.__dict__["balance_by_download_score"] = balance_by_download_score
        __props__.__dict__["cname"] = cname
        __props__.__dict__["comments"] = comments
        __props__.__dict__["domain"] = domain
        __props__.__dict__["dynamic_ttl"] = dynamic_ttl
        __props__.__dict__["failback_delay"] = failback_delay
        __props__.__dict__["failover_delay"] = failover_delay
        __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
        __props__.__dict__["handout_limit"] = handout_limit
        __props__.__dict__["handout_mode"] = handout_mode
        __props__.__dict__["health_max"] = health_max
        __props__.__dict__["health_multiplier"] = health_multiplier
        __props__.__dict__["health_threshold"] = health_threshold
        __props__.__dict__["ipv6"] = ipv6
        __props__.__dict__["liveness_tests"] = liveness_tests
        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
        __props__.__dict__["map_name"] = map_name
        __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
        __props__.__dict__["min_live_fraction"] = min_live_fraction
        __props__.__dict__["name"] = name
        __props__.__dict__["score_aggregation_type"] = score_aggregation_type
        __props__.__dict__["static_rr_sets"] = static_rr_sets
        __props__.__dict__["static_ttl"] = static_ttl
        __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
        __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
        __props__.__dict__["traffic_targets"] = traffic_targets
        __props__.__dict__["type"] = type
        __props__.__dict__["unreachable_threshold"] = unreachable_threshold
        __props__.__dict__["use_computed_targets"] = use_computed_targets
        __props__.__dict__["wait_on_complete"] = wait_on_complete
        __props__.__dict__["weighted_hash_bits_for_ipv4"] = weighted_hash_bits_for_ipv4
        __props__.__dict__["weighted_hash_bits_for_ipv6"] = weighted_hash_bits_for_ipv6
        return GtmProperty(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        """
        return pulumi.get(self, "backup_cname")

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        """
        return pulumi.get(self, "backup_ip")

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> pulumi.Output[Optional[bool]]:
        """
        A boolean that indicates whether download score based load balancing is enabled.
        """
        return pulumi.get(self, "balance_by_download_score")

    @property
    @pulumi.getter
    def cname(self) -> pulumi.Output[Optional[str]]:
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter
    def comments(self) -> pulumi.Output[Optional[str]]:
        """
        A descriptive note about changes to the domain. The maximum is 4000 characters.
        """
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Output[str]:
        """
        DNS name for the GTM Domain set that includes this Property.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> pulumi.Output[Optional[int]]:
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        """
        return pulumi.get(self, "dynamic_ttl")

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies the failback delay in seconds.
        """
        return pulumi.get(self, "failback_delay")

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies the failover delay in seconds.
        """
        return pulumi.get(self, "failover_delay")

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> pulumi.Output[Optional[bool]]:
        """
        Use load estimates from Akamai Ghost utilization messages.
        """
        return pulumi.get(self, "ghost_demand_reporting")

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Output[int]:
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        return pulumi.get(self, "handout_limit")

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Output[str]:
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        return pulumi.get(self, "handout_mode")

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> pulumi.Output[Optional[float]]:
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        return pulumi.get(self, "health_max")

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> pulumi.Output[Optional[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_multiplier")

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> pulumi.Output[Optional[float]]:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_threshold")

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Output[Optional[bool]]:
        """
        A boolean that indicates the type of IP address handed out by a GTM property.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyLivenessTest']]]:
        """
        Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
        """
        return pulumi.get(self, "liveness_tests")

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
        """
        Indicates the percent of load imbalance factor (LIF) for the property.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> pulumi.Output[Optional[str]]:
        """
        A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        """
        return pulumi.get(self, "map_name")

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> pulumi.Output[Optional[int]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        return pulumi.get(self, "max_unreachable_penalty")

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> pulumi.Output[Optional[float]]:
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        return pulumi.get(self, "min_live_fraction")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Output[str]:
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        return pulumi.get(self, "score_aggregation_type")

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyStaticRrSet']]]:
        """
        Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
        """
        return pulumi.get(self, "static_rr_sets")

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "static_ttl")

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies a constant used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_constant")

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickiness_bonus_percentage")

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyTrafficTarget']]]:
        """
        Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
        """
        return pulumi.get(self, "traffic_targets")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        The record type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> pulumi.Output[Optional[float]]:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        return pulumi.get(self, "unreachable_threshold")

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> pulumi.Output[Optional[bool]]:
        """
        For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        """
        return pulumi.get(self, "use_computed_targets")

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
        """
        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        """
        return pulumi.get(self, "wait_on_complete")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

