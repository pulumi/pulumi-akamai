# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['GtmPropertyArgs', 'GtmProperty']

@pulumi.input_type
class GtmPropertyArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 handout_limit: pulumi.Input[int],
                 handout_mode: pulumi.Input[str],
                 score_aggregation_type: pulumi.Input[str],
                 type: pulumi.Input[str],
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a GtmProperty resource.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "handout_limit", handout_limit)
        pulumi.set(__self__, "handout_mode", handout_mode)
        pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        pulumi.set(__self__, "type", type)
        if backup_cname is not None:
            pulumi.set(__self__, "backup_cname", backup_cname)
        if backup_ip is not None:
            pulumi.set(__self__, "backup_ip", backup_ip)
        if balance_by_download_score is not None:
            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if dynamic_ttl is not None:
            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            pulumi.set(__self__, "failback_delay", failback_delay)
        if failover_delay is not None:
            pulumi.set(__self__, "failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        if health_max is not None:
            pulumi.set(__self__, "health_max", health_max)
        if health_multiplier is not None:
            pulumi.set(__self__, "health_multiplier", health_multiplier)
        if health_threshold is not None:
            pulumi.set(__self__, "health_threshold", health_threshold)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            pulumi.set(__self__, "map_name", map_name)
        if max_unreachable_penalty is not None:
            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            pulumi.set(__self__, "static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)
        if unreachable_threshold is not None:
            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            pulumi.set(__self__, "wait_on_complete", wait_on_complete)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)


@pulumi.input_type
class _GtmPropertyState:
    def __init__(__self__, *,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
                 weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None):
        """
        Input properties used for looking up and filtering GtmProperty resources.
        """
        if backup_cname is not None:
            pulumi.set(__self__, "backup_cname", backup_cname)
        if backup_ip is not None:
            pulumi.set(__self__, "backup_ip", backup_ip)
        if balance_by_download_score is not None:
            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if dynamic_ttl is not None:
            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        if failback_delay is not None:
            pulumi.set(__self__, "failback_delay", failback_delay)
        if failover_delay is not None:
            pulumi.set(__self__, "failover_delay", failover_delay)
        if ghost_demand_reporting is not None:
            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        if handout_limit is not None:
            pulumi.set(__self__, "handout_limit", handout_limit)
        if handout_mode is not None:
            pulumi.set(__self__, "handout_mode", handout_mode)
        if health_max is not None:
            pulumi.set(__self__, "health_max", health_max)
        if health_multiplier is not None:
            pulumi.set(__self__, "health_multiplier", health_multiplier)
        if health_threshold is not None:
            pulumi.set(__self__, "health_threshold", health_threshold)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if load_imbalance_percentage is not None:
            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        if map_name is not None:
            pulumi.set(__self__, "map_name", map_name)
        if max_unreachable_penalty is not None:
            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        if min_live_fraction is not None:
            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if score_aggregation_type is not None:
            pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if static_ttl is not None:
            pulumi.set(__self__, "static_ttl", static_ttl)
        if stickiness_bonus_constant is not None:
            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
        if stickiness_bonus_percentage is not None:
            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unreachable_threshold is not None:
            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        if use_computed_targets is not None:
            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        if wait_on_complete is not None:
            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
        if weighted_hash_bits_for_ipv4 is not None:
            pulumi.set(__self__, "weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
        if weighted_hash_bits_for_ipv6 is not None:
            pulumi.set(__self__, "weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_cname", value)

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_ip", value)

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_by_download_score", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dynamic_ttl", value)

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failback_delay", value)

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_delay", value)

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ghost_demand_reporting", value)

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "handout_limit", value)

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handout_mode", value)

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_max", value)

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_multiplier", value)

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "health_threshold", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
        pulumi.set(self, "liveness_tests", value)

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_imbalance_percentage", value)

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_name", value)

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unreachable_penalty", value)

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_live_fraction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_aggregation_type", value)

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
        pulumi.set(self, "static_rr_sets", value)

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "static_ttl", value)

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @stickiness_bonus_constant.setter
    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_constant", value)

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @stickiness_bonus_percentage.setter
    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stickiness_bonus_percentage", value)

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
        pulumi.set(self, "traffic_targets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unreachable_threshold", value)

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_computed_targets", value)

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @wait_on_complete.setter
    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wait_on_complete", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @weighted_hash_bits_for_ipv4.setter
    def weighted_hash_bits_for_ipv4(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv4", value)

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

    @weighted_hash_bits_for_ipv6.setter
    def weighted_hash_bits_for_ipv6(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weighted_hash_bits_for_ipv6", value)


class GtmProperty(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        Use the `GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.

        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.

        ## Example Usage

        Basic usage:

        ```python
        import pulumi
        import pulumi_akamai as akamai

        demo_property = akamai.GtmProperty("demoProperty",
            domain="demo_domain.akadns.net",
            handout_limit=5,
            handout_mode="normal",
            score_aggregation_type="median",
            traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(
                datacenter_id=3131,
            )],
            type="weighted-round-robin")
        ```
        ## Argument reference

        This resource supports these arguments:

        * `domain` - (Required) DNS name for the GTM Domain set that includes this Property.
        * `name` - (Required) DNS name for a collection of IP address or CNAME responses. The value, together with the GTM domainName, forms the Property's hostname.
        * `type` - (Required) Specifies the load balancing behavior for the property. Either failover, geographic, cidrmapping, weighted-round-robin, weighted-hashed, weighted-round-robin-load-feedback, qtr, or performance.
        * `score_aggregation_type` - (Required) Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        * `handout_limit` - (Required) Indicates the limit for the number of live IPs handed out to a DNS request.
        * `handout_mode` - (Required) Specifies how IPs are returned when more than one IP is alive and available.
        * `traffic_target` - (Optional) Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
          * `datacenter_id` - (Optional) A unique identifier for an existing data center in the domain.
          * `enabled` - (Optional) A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.
          * `weight` - (Optional) Specifies the traffic weight for the target.
          * `servers` - (Optional) (List) Identifies the IP address or the hostnames of the servers.
          * `name` - (Optional) An alternative label for the traffic target.
          * `handout_cname` - (Optional) Specifies an optional data center for the property. Used when there are no servers configured for the property.
        * `liveness_test` - (Optional) Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
          * `name` - (Required) A descriptive name for the liveness test.
          * `test_interval` - (Required) Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.
          * `test_object_protocol` - (Required) Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.
          * `test_timeout` - (Required) Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.
          * `answers_required` - (Optional) If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.
          * `disabled` - (Optional) A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.
          * `disable_nonstandard_port_warning` - (Optional) A boolean that if set to `true`, disables warnings when non-standard ports are used.
          * `error_penalty` - (Optional) Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
          * `http_header` - (Optional) Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:
            * `name` - (Optional) Name of HTTP header.
            * `value` - (Optional) Value of HTTP header.
          * `http_error3xx` - (Optional) A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `http_error4xx` - (Optional) A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `http_error5xx` - (Optional) A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `peer_certificate_verification` - (Optional) A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.
          * `recursion_requested` - (Optional) A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.
          * `request_string` - (Optional) Specifies a request string.
          * `resource_type` - (Optional) Specifies the query type, if `test_object_protocol` is DNS.
          * `response_string` - (Optional) Specifies a response string.
          * `ssl_client_certificate` - (Optional) Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.
          * `ssl_client_private_key` - (Optional) Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.
          * `test_object` - (Required) Specifies the static text that acts as a stand-in for the data that you're sending on the network.
          * `test_object_password` - (Optional) Specifies the test object's password. It is required if testObjectProtocol is ftp.
          * `test_object_port` - (Required) Specifies the port number for the testObject.
          * `test_object_username` - (Optional) A descriptive name for the testObject.
          * `timeout_penalty`- (Optional) Specifies the score to be reported if the liveness test times out.
        * `wait_on_complete` - (Optional) A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        * `failover_delay` - (Optional) Specifies the failover delay in seconds.
        * `failback_delay` - (Optional) Specifies the failback delay in seconds.
        * `ipv6` - (Optional) A boolean that indicates the type of IP address handed out by a GTM property.
        * `stickiness_bonus_percentage` - (Optional) Specifies a percentage used to configure data center affinity.
        * `stickiness_bonus_constant` - (Optional) Specifies a constant used to configure data center affinity.
        * `health_threshold` - (Optional) Configures a cutoff value that is computed from the median scores.
        * `use_computed_targets` - (Optional) For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        * `backup_ip` - (Optional) Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        * `backup_cname` - (Optional) Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        * `balance_by_download_score` - (Optional) A boolean that indicates whether download score based load balancing is enabled.
        * `unreachable_threshold` - (Optional) For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        * `health_multiplier` - (Optional) Configures a cutoff value that is computed from the median scores.
        * `dynamic_ttl` - (Optional) Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        * `max_unreachable_penalty` - (Optional) For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        * `map_name` - (Optional) A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        * `load_imbalance_percentage` - (Optional) Indicates the percent of load imbalance factor (LIF) for the property.
        * `health_max` - (Optional) Defines the absolute limit beyond which IPs are declared unhealthy.
        * `cname` - (Optional) Indicates the fully qualified name aliased to a particular property.
        * `comments` - (Optional) A descriptive note about changes to the domain. The maximum is 4000 characters.
        * `ghost_demand_reporting` - (Optional) Use load estimates from Akamai Ghost utilization messages.
        * `min_live_fraction` - (Optional) Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        * `static_rr_set` - (Optional) Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
          * `type` - (Optional) The record type.
          * `ttl` - (Optional) The number of seconds that this record should live in a resolver's cache before being refetched.
          * `rdata` - (Optional) (List) An array of data strings, representing multiple records within a set.

        ## Attribute reference

        This resource returns these computed attributes in the state file:

        * `weighted_hash_bits_for_ipv4`
        * `weighted_hash_bits_for_ipv6`

        ## Schema reference

        You can download the GTM Property backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#property) page.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: GtmPropertyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use the `GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.

        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.

        ## Example Usage

        Basic usage:

        ```python
        import pulumi
        import pulumi_akamai as akamai

        demo_property = akamai.GtmProperty("demoProperty",
            domain="demo_domain.akadns.net",
            handout_limit=5,
            handout_mode="normal",
            score_aggregation_type="median",
            traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(
                datacenter_id=3131,
            )],
            type="weighted-round-robin")
        ```
        ## Argument reference

        This resource supports these arguments:

        * `domain` - (Required) DNS name for the GTM Domain set that includes this Property.
        * `name` - (Required) DNS name for a collection of IP address or CNAME responses. The value, together with the GTM domainName, forms the Property's hostname.
        * `type` - (Required) Specifies the load balancing behavior for the property. Either failover, geographic, cidrmapping, weighted-round-robin, weighted-hashed, weighted-round-robin-load-feedback, qtr, or performance.
        * `score_aggregation_type` - (Required) Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        * `handout_limit` - (Required) Indicates the limit for the number of live IPs handed out to a DNS request.
        * `handout_mode` - (Required) Specifies how IPs are returned when more than one IP is alive and available.
        * `traffic_target` - (Optional) Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:
          * `datacenter_id` - (Optional) A unique identifier for an existing data center in the domain.
          * `enabled` - (Optional) A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.
          * `weight` - (Optional) Specifies the traffic weight for the target.
          * `servers` - (Optional) (List) Identifies the IP address or the hostnames of the servers.
          * `name` - (Optional) An alternative label for the traffic target.
          * `handout_cname` - (Optional) Specifies an optional data center for the property. Used when there are no servers configured for the property.
        * `liveness_test` - (Optional) Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:
          * `name` - (Required) A descriptive name for the liveness test.
          * `test_interval` - (Required) Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.
          * `test_object_protocol` - (Required) Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.
          * `test_timeout` - (Required) Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.
          * `answers_required` - (Optional) If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.
          * `disabled` - (Optional) A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.
          * `disable_nonstandard_port_warning` - (Optional) A boolean that if set to `true`, disables warnings when non-standard ports are used.
          * `error_penalty` - (Optional) Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
          * `http_header` - (Optional) Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:
            * `name` - (Optional) Name of HTTP header.
            * `value` - (Optional) Value of HTTP header.
          * `http_error3xx` - (Optional) A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `http_error4xx` - (Optional) A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `http_error5xx` - (Optional) A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
          * `peer_certificate_verification` - (Optional) A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.
          * `recursion_requested` - (Optional) A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.
          * `request_string` - (Optional) Specifies a request string.
          * `resource_type` - (Optional) Specifies the query type, if `test_object_protocol` is DNS.
          * `response_string` - (Optional) Specifies a response string.
          * `ssl_client_certificate` - (Optional) Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.
          * `ssl_client_private_key` - (Optional) Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.
          * `test_object` - (Required) Specifies the static text that acts as a stand-in for the data that you're sending on the network.
          * `test_object_password` - (Optional) Specifies the test object's password. It is required if testObjectProtocol is ftp.
          * `test_object_port` - (Required) Specifies the port number for the testObject.
          * `test_object_username` - (Optional) A descriptive name for the testObject.
          * `timeout_penalty`- (Optional) Specifies the score to be reported if the liveness test times out.
        * `wait_on_complete` - (Optional) A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
        * `failover_delay` - (Optional) Specifies the failover delay in seconds.
        * `failback_delay` - (Optional) Specifies the failback delay in seconds.
        * `ipv6` - (Optional) A boolean that indicates the type of IP address handed out by a GTM property.
        * `stickiness_bonus_percentage` - (Optional) Specifies a percentage used to configure data center affinity.
        * `stickiness_bonus_constant` - (Optional) Specifies a constant used to configure data center affinity.
        * `health_threshold` - (Optional) Configures a cutoff value that is computed from the median scores.
        * `use_computed_targets` - (Optional) For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.
        * `backup_ip` - (Optional) Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.
        * `backup_cname` - (Optional) Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.
        * `balance_by_download_score` - (Optional) A boolean that indicates whether download score based load balancing is enabled.
        * `unreachable_threshold` - (Optional) For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        * `health_multiplier` - (Optional) Configures a cutoff value that is computed from the median scores.
        * `dynamic_ttl` - (Optional) Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.
        * `max_unreachable_penalty` - (Optional) For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        * `map_name` - (Optional) A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.
        * `load_imbalance_percentage` - (Optional) Indicates the percent of load imbalance factor (LIF) for the property.
        * `health_max` - (Optional) Defines the absolute limit beyond which IPs are declared unhealthy.
        * `cname` - (Optional) Indicates the fully qualified name aliased to a particular property.
        * `comments` - (Optional) A descriptive note about changes to the domain. The maximum is 4000 characters.
        * `ghost_demand_reporting` - (Optional) Use load estimates from Akamai Ghost utilization messages.
        * `min_live_fraction` - (Optional) Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        * `static_rr_set` - (Optional) Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:
          * `type` - (Optional) The record type.
          * `ttl` - (Optional) The number of seconds that this record should live in a resolver's cache before being refetched.
          * `rdata` - (Optional) (List) An array of data strings, representing multiple records within a set.

        ## Attribute reference

        This resource returns these computed attributes in the state file:

        * `weighted_hash_bits_for_ipv4`
        * `weighted_hash_bits_for_ipv6`

        ## Schema reference

        You can download the GTM Property backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#property) page.

        :param str resource_name: The name of the resource.
        :param GtmPropertyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(GtmPropertyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backup_cname: Optional[pulumi.Input[str]] = None,
                 backup_ip: Optional[pulumi.Input[str]] = None,
                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 comments: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
                 failback_delay: Optional[pulumi.Input[int]] = None,
                 failover_delay: Optional[pulumi.Input[int]] = None,
                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
                 handout_limit: Optional[pulumi.Input[int]] = None,
                 handout_mode: Optional[pulumi.Input[str]] = None,
                 health_max: Optional[pulumi.Input[float]] = None,
                 health_multiplier: Optional[pulumi.Input[float]] = None,
                 health_threshold: Optional[pulumi.Input[float]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
                 map_name: Optional[pulumi.Input[str]] = None,
                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
                 min_live_fraction: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
                 static_ttl: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = GtmPropertyArgs.__new__(GtmPropertyArgs)

            __props__.__dict__["backup_cname"] = backup_cname
            __props__.__dict__["backup_ip"] = backup_ip
            __props__.__dict__["balance_by_download_score"] = balance_by_download_score
            __props__.__dict__["cname"] = cname
            __props__.__dict__["comments"] = comments
            if domain is None and not opts.urn:
                raise TypeError("Missing required property 'domain'")
            __props__.__dict__["domain"] = domain
            __props__.__dict__["dynamic_ttl"] = dynamic_ttl
            __props__.__dict__["failback_delay"] = failback_delay
            __props__.__dict__["failover_delay"] = failover_delay
            __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
            if handout_limit is None and not opts.urn:
                raise TypeError("Missing required property 'handout_limit'")
            __props__.__dict__["handout_limit"] = handout_limit
            if handout_mode is None and not opts.urn:
                raise TypeError("Missing required property 'handout_mode'")
            __props__.__dict__["handout_mode"] = handout_mode
            __props__.__dict__["health_max"] = health_max
            __props__.__dict__["health_multiplier"] = health_multiplier
            __props__.__dict__["health_threshold"] = health_threshold
            __props__.__dict__["ipv6"] = ipv6
            __props__.__dict__["liveness_tests"] = liveness_tests
            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
            __props__.__dict__["map_name"] = map_name
            __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
            __props__.__dict__["min_live_fraction"] = min_live_fraction
            __props__.__dict__["name"] = name
            if score_aggregation_type is None and not opts.urn:
                raise TypeError("Missing required property 'score_aggregation_type'")
            __props__.__dict__["score_aggregation_type"] = score_aggregation_type
            __props__.__dict__["static_rr_sets"] = static_rr_sets
            __props__.__dict__["static_ttl"] = static_ttl
            __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
            __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
            __props__.__dict__["traffic_targets"] = traffic_targets
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["unreachable_threshold"] = unreachable_threshold
            __props__.__dict__["use_computed_targets"] = use_computed_targets
            __props__.__dict__["wait_on_complete"] = wait_on_complete
            __props__.__dict__["weighted_hash_bits_for_ipv4"] = None
            __props__.__dict__["weighted_hash_bits_for_ipv6"] = None
        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmProperty:GtmProperty")])
        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
        super(GtmProperty, __self__).__init__(
            'akamai:index/gtmProperty:GtmProperty',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            backup_cname: Optional[pulumi.Input[str]] = None,
            backup_ip: Optional[pulumi.Input[str]] = None,
            balance_by_download_score: Optional[pulumi.Input[bool]] = None,
            cname: Optional[pulumi.Input[str]] = None,
            comments: Optional[pulumi.Input[str]] = None,
            domain: Optional[pulumi.Input[str]] = None,
            dynamic_ttl: Optional[pulumi.Input[int]] = None,
            failback_delay: Optional[pulumi.Input[int]] = None,
            failover_delay: Optional[pulumi.Input[int]] = None,
            ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
            handout_limit: Optional[pulumi.Input[int]] = None,
            handout_mode: Optional[pulumi.Input[str]] = None,
            health_max: Optional[pulumi.Input[float]] = None,
            health_multiplier: Optional[pulumi.Input[float]] = None,
            health_threshold: Optional[pulumi.Input[float]] = None,
            ipv6: Optional[pulumi.Input[bool]] = None,
            liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
            map_name: Optional[pulumi.Input[str]] = None,
            max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
            min_live_fraction: Optional[pulumi.Input[float]] = None,
            name: Optional[pulumi.Input[str]] = None,
            score_aggregation_type: Optional[pulumi.Input[str]] = None,
            static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
            static_ttl: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
            stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
            traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
            type: Optional[pulumi.Input[str]] = None,
            unreachable_threshold: Optional[pulumi.Input[float]] = None,
            use_computed_targets: Optional[pulumi.Input[bool]] = None,
            wait_on_complete: Optional[pulumi.Input[bool]] = None,
            weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
            weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None) -> 'GtmProperty':
        """
        Get an existing GtmProperty resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _GtmPropertyState.__new__(_GtmPropertyState)

        __props__.__dict__["backup_cname"] = backup_cname
        __props__.__dict__["backup_ip"] = backup_ip
        __props__.__dict__["balance_by_download_score"] = balance_by_download_score
        __props__.__dict__["cname"] = cname
        __props__.__dict__["comments"] = comments
        __props__.__dict__["domain"] = domain
        __props__.__dict__["dynamic_ttl"] = dynamic_ttl
        __props__.__dict__["failback_delay"] = failback_delay
        __props__.__dict__["failover_delay"] = failover_delay
        __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
        __props__.__dict__["handout_limit"] = handout_limit
        __props__.__dict__["handout_mode"] = handout_mode
        __props__.__dict__["health_max"] = health_max
        __props__.__dict__["health_multiplier"] = health_multiplier
        __props__.__dict__["health_threshold"] = health_threshold
        __props__.__dict__["ipv6"] = ipv6
        __props__.__dict__["liveness_tests"] = liveness_tests
        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
        __props__.__dict__["map_name"] = map_name
        __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
        __props__.__dict__["min_live_fraction"] = min_live_fraction
        __props__.__dict__["name"] = name
        __props__.__dict__["score_aggregation_type"] = score_aggregation_type
        __props__.__dict__["static_rr_sets"] = static_rr_sets
        __props__.__dict__["static_ttl"] = static_ttl
        __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
        __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
        __props__.__dict__["traffic_targets"] = traffic_targets
        __props__.__dict__["type"] = type
        __props__.__dict__["unreachable_threshold"] = unreachable_threshold
        __props__.__dict__["use_computed_targets"] = use_computed_targets
        __props__.__dict__["wait_on_complete"] = wait_on_complete
        __props__.__dict__["weighted_hash_bits_for_ipv4"] = weighted_hash_bits_for_ipv4
        __props__.__dict__["weighted_hash_bits_for_ipv6"] = weighted_hash_bits_for_ipv6
        return GtmProperty(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "backup_cname")

    @property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "backup_ip")

    @property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "balance_by_download_score")

    @property
    @pulumi.getter
    def cname(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter
    def comments(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Output[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "dynamic_ttl")

    @property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "failback_delay")

    @property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "failover_delay")

    @property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "ghost_demand_reporting")

    @property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> pulumi.Output[int]:
        return pulumi.get(self, "handout_limit")

    @property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> pulumi.Output[str]:
        return pulumi.get(self, "handout_mode")

    @property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_max")

    @property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_multiplier")

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "health_threshold")

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyLivenessTest']]]:
        return pulumi.get(self, "liveness_tests")

    @property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "load_imbalance_percentage")

    @property
    @pulumi.getter(name="mapName")
    def map_name(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "map_name")

    @property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "max_unreachable_penalty")

    @property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "min_live_fraction")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> pulumi.Output[str]:
        return pulumi.get(self, "score_aggregation_type")

    @property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyStaticRrSet']]]:
        return pulumi.get(self, "static_rr_sets")

    @property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "static_ttl")

    @property
    @pulumi.getter(name="stickinessBonusConstant")
    def stickiness_bonus_constant(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "stickiness_bonus_constant")

    @property
    @pulumi.getter(name="stickinessBonusPercentage")
    def stickiness_bonus_percentage(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "stickiness_bonus_percentage")

    @property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyTrafficTarget']]]:
        return pulumi.get(self, "traffic_targets")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> pulumi.Output[Optional[float]]:
        return pulumi.get(self, "unreachable_threshold")

    @property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "use_computed_targets")

    @property
    @pulumi.getter(name="waitOnComplete")
    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "wait_on_complete")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> pulumi.Output[int]:
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

