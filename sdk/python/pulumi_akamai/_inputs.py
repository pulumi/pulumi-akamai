# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'CloudletsApplicationLoadBalancerDataCenterArgs',
    'CloudletsApplicationLoadBalancerLivenessSettingsArgs',
    'CpsDvEnrollmentAdminContactArgs',
    'CpsDvEnrollmentCsrArgs',
    'CpsDvEnrollmentDnsChallengeArgs',
    'CpsDvEnrollmentHttpChallengeArgs',
    'CpsDvEnrollmentNetworkConfigurationArgs',
    'CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs',
    'CpsDvEnrollmentOrganizationArgs',
    'CpsDvEnrollmentTechContactArgs',
    'DatastreamAzureConnectorArgs',
    'DatastreamConfigArgs',
    'DatastreamConfigFrequencyArgs',
    'DatastreamDatadogConnectorArgs',
    'DatastreamGcsConnectorArgs',
    'DatastreamHttpsConnectorArgs',
    'DatastreamOracleConnectorArgs',
    'DatastreamS3ConnectorArgs',
    'DatastreamSplunkConnectorArgs',
    'DatastreamSumologicConnectorArgs',
    'DnsZoneTsigKeyArgs',
    'EdgeKvInitialDataArgs',
    'GtmAsmapAssignmentArgs',
    'GtmAsmapDefaultDatacenterArgs',
    'GtmCidrmapAssignmentArgs',
    'GtmCidrmapDefaultDatacenterArgs',
    'GtmDatacenterDefaultLoadObjectArgs',
    'GtmGeomapAssignmentArgs',
    'GtmGeomapDefaultDatacenterArgs',
    'GtmPropertyLivenessTestArgs',
    'GtmPropertyLivenessTestHttpHeaderArgs',
    'GtmPropertyStaticRrSetArgs',
    'GtmPropertyTrafficTargetArgs',
    'GtmResourceResourceInstanceArgs',
    'PropertyActivationRuleErrorArgs',
    'PropertyActivationRuleWarningArgs',
    'PropertyHostnameArgs',
    'PropertyHostnameCertStatusArgs',
    'PropertyOriginArgs',
    'PropertyRuleErrorArgs',
    'PropertyRuleWarningArgs',
    'ProviderAppsecArgs',
    'ProviderConfigArgs',
    'ProviderDnsArgs',
    'ProviderGtmArgs',
    'ProviderNetworkArgs',
    'ProviderPropertyArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetPropertyRulesTemplateTemplateArgs',
    'GetPropertyRulesTemplateVariableArgs',
]

@pulumi.input_type
class CloudletsApplicationLoadBalancerDataCenterArgs:
    def __init__(__self__, *,
                 continent: pulumi.Input[str],
                 country: pulumi.Input[str],
                 latitude: pulumi.Input[float],
                 longitude: pulumi.Input[float],
                 origin_id: pulumi.Input[str],
                 percent: pulumi.Input[float],
                 city: Optional[pulumi.Input[str]] = None,
                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
                 cloud_service: Optional[pulumi.Input[bool]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 liveness_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state_or_province: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] continent: The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
        :param pulumi.Input[str] country: The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
        :param pulumi.Input[float] latitude: The latitude value for the data center. This member supports six decimal places of precision.
        :param pulumi.Input[float] longitude: The longitude value for the data center. This member supports six decimal places of precision.
        :param pulumi.Input[str] origin_id: The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
        :param pulumi.Input[float] percent: The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        :param pulumi.Input[str] city: The city in which the data center is located.
        :param pulumi.Input[bool] cloud_server_host_header_override: Whether to override the cloud server host header.
        :param pulumi.Input[bool] cloud_service: Whether this datacenter is a cloud service.
        :param pulumi.Input[str] hostname: The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] liveness_hosts: A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
        :param pulumi.Input[str] state_or_province: The state, province, or region where the data center is located.
        """
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if cloud_server_host_header_override is not None:
            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        if cloud_service is not None:
            pulumi.set(__self__, "cloud_service", cloud_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if liveness_hosts is not None:
            pulumi.set(__self__, "liveness_hosts", liveness_hosts)
        if state_or_province is not None:
            pulumi.set(__self__, "state_or_province", state_or_province)

    @property
    @pulumi.getter
    def continent(self) -> pulumi.Input[str]:
        """
        The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: pulumi.Input[str]):
        pulumi.set(self, "continent", value)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[float]:
        """
        The latitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[float]):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[float]:
        """
        The longitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[float]):
        pulumi.set(self, "longitude", value)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[str]:
        """
        The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "origin_id", value)

    @property
    @pulumi.getter
    def percent(self) -> pulumi.Input[float]:
        """
        The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: pulumi.Input[float]):
        pulumi.set(self, "percent", value)

    @property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[str]]:
        """
        The city in which the data center is located.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to override the cloud server host header.
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @cloud_server_host_header_override.setter
    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_server_host_header_override", value)

    @property
    @pulumi.getter(name="cloudService")
    def cloud_service(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this datacenter is a cloud service.
        """
        return pulumi.get(self, "cloud_service")

    @cloud_service.setter
    def cloud_service(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_service", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="livenessHosts")
    def liveness_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
        """
        return pulumi.get(self, "liveness_hosts")

    @liveness_hosts.setter
    def liveness_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "liveness_hosts", value)

    @property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> Optional[pulumi.Input[str]]:
        """
        The state, province, or region where the data center is located.
        """
        return pulumi.get(self, "state_or_province")

    @state_or_province.setter
    def state_or_province(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_or_province", value)


@pulumi.input_type
class CloudletsApplicationLoadBalancerLivenessSettingsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 additional_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 peer_certificate_verification: Optional[pulumi.Input[bool]] = None,
                 request_string: Optional[pulumi.Input[str]] = None,
                 response_string: Optional[pulumi.Input[str]] = None,
                 status3xx_failure: Optional[pulumi.Input[bool]] = None,
                 status4xx_failure: Optional[pulumi.Input[bool]] = None,
                 status5xx_failure: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] path: The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        :param pulumi.Input[int] port: The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        :param pulumi.Input[str] protocol: The protocol or scheme for the database, either `HTTP` or `HTTPS`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_headers: Maps additional case-insensitive HTTP header names included to the liveness testing requests.
        :param pulumi.Input[str] host_header: The Host header for the liveness HTTP request.
        :param pulumi.Input[int] interval: The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
        :param pulumi.Input[bool] peer_certificate_verification: Whether to validate the origin certificate for an HTTPS request.
        :param pulumi.Input[str] request_string: The request used for TCP and TCPS tests.
        :param pulumi.Input[str] response_string: The response used for TCP and TCPS tests.
        :param pulumi.Input[bool] status3xx_failure: If set to `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
        :param pulumi.Input[bool] status4xx_failure: If set to `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
        :param pulumi.Input[bool] status5xx_failure: If set to `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
        :param pulumi.Input[float] timeout: The number of seconds the system waits before failing the liveness test.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if status3xx_failure is not None:
            pulumi.set(__self__, "status3xx_failure", status3xx_failure)
        if status4xx_failure is not None:
            pulumi.set(__self__, "status4xx_failure", status4xx_failure)
        if status5xx_failure is not None:
            pulumi.set(__self__, "status5xx_failure", status5xx_failure)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol or scheme for the database, either `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Maps additional case-insensitive HTTP header names included to the liveness testing requests.
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The Host header for the liveness HTTP request.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to validate the origin certificate for an HTTPS request.
        """
        return pulumi.get(self, "peer_certificate_verification")

    @peer_certificate_verification.setter
    def peer_certificate_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "peer_certificate_verification", value)

    @property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[pulumi.Input[str]]:
        """
        The request used for TCP and TCPS tests.
        """
        return pulumi.get(self, "request_string")

    @request_string.setter
    def request_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_string", value)

    @property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[pulumi.Input[str]]:
        """
        The response used for TCP and TCPS tests.
        """
        return pulumi.get(self, "response_string")

    @response_string.setter
    def response_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_string", value)

    @property
    @pulumi.getter(name="status3xxFailure")
    def status3xx_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
        """
        return pulumi.get(self, "status3xx_failure")

    @status3xx_failure.setter
    def status3xx_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status3xx_failure", value)

    @property
    @pulumi.getter(name="status4xxFailure")
    def status4xx_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
        """
        return pulumi.get(self, "status4xx_failure")

    @status4xx_failure.setter
    def status4xx_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status4xx_failure", value)

    @property
    @pulumi.getter(name="status5xxFailure")
    def status5xx_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
        """
        return pulumi.get(self, "status5xx_failure")

    @status5xx_failure.setter
    def status5xx_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "status5xx_failure", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds the system waits before failing the liveness test.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class CpsDvEnrollmentAdminContactArgs:
    def __init__(__self__, *,
                 address_line_one: pulumi.Input[str],
                 city: pulumi.Input[str],
                 country_code: pulumi.Input[str],
                 email: pulumi.Input[str],
                 first_name: pulumi.Input[str],
                 last_name: pulumi.Input[str],
                 organization: pulumi.Input[str],
                 phone: pulumi.Input[str],
                 postal_code: pulumi.Input[str],
                 region: pulumi.Input[str],
                 address_line_two: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address_line_one: The address of your organization.
        :param pulumi.Input[str] city: The city where your organization resides.
        :param pulumi.Input[str] country_code: The code for the country where your organization resides.
        :param pulumi.Input[str] email: The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.
        :param pulumi.Input[str] first_name: The first name of the technical contact at Akamai.
        :param pulumi.Input[str] last_name: The last name of the technical contact at Akamai.
        :param pulumi.Input[str] organization: Your organization information.
        :param pulumi.Input[str] phone: The phone number of the administrator who you want to use as a contact at your company.
        :param pulumi.Input[str] postal_code: The postal code of your organization.
        :param pulumi.Input[str] region: The region of your organization, typically a state or province.
        :param pulumi.Input[str] address_line_two: The address of your organization.
        :param pulumi.Input[str] title: The title of the technical contact at Akamai.
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> pulumi.Input[str]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_line_one", value)

    @property
    @pulumi.getter
    def city(self) -> pulumi.Input[str]:
        """
        The city where your organization resides.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[str]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The code for the country where your organization resides.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[str]:
        """
        The first name of the technical contact at Akamai.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[str]:
        """
        The last name of the technical contact at Akamai.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[str]:
        """
        Your organization information.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def phone(self) -> pulumi.Input[str]:
        """
        The phone number of the administrator who you want to use as a contact at your company.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[str]):
        pulumi.set(self, "phone", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> pulumi.Input[str]:
        """
        The postal code of your organization.
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of your organization, typically a state or province.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[str]]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_line_two", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the technical contact at Akamai.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class CpsDvEnrollmentCsrArgs:
    def __init__(__self__, *,
                 city: pulumi.Input[str],
                 country_code: pulumi.Input[str],
                 organization: pulumi.Input[str],
                 organizational_unit: pulumi.Input[str],
                 state: pulumi.Input[str]):
        """
        :param pulumi.Input[str] city: The city where your organization resides.
        :param pulumi.Input[str] country_code: The code for the country where your organization resides.
        :param pulumi.Input[str] organization: Your organization information.
        :param pulumi.Input[str] organizational_unit: Your organizational unit.
        :param pulumi.Input[str] state: Your state or province.
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def city(self) -> pulumi.Input[str]:
        """
        The city where your organization resides.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[str]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The code for the country where your organization resides.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[str]:
        """
        Your organization information.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> pulumi.Input[str]:
        """
        Your organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        """
        Your state or province.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class CpsDvEnrollmentDnsChallengeArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 full_path: Optional[pulumi.Input[str]] = None,
                 response_body: Optional[pulumi.Input[str]] = None):
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "full_path")

    @full_path.setter
    def full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_path", value)

    @property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_body")

    @response_body.setter
    def response_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_body", value)


@pulumi.input_type
class CpsDvEnrollmentHttpChallengeArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 full_path: Optional[pulumi.Input[str]] = None,
                 response_body: Optional[pulumi.Input[str]] = None):
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "full_path")

    @full_path.setter
    def full_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_path", value)

    @property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "response_body")

    @response_body.setter
    def response_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_body", value)


@pulumi.input_type
class CpsDvEnrollmentNetworkConfigurationArgs:
    def __init__(__self__, *,
                 geography: pulumi.Input[str],
                 client_mutual_authentication: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']] = None,
                 clone_dns_names: Optional[pulumi.Input[bool]] = None,
                 disallowed_tls_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 must_have_ciphers: Optional[pulumi.Input[str]] = None,
                 ocsp_stapling: Optional[pulumi.Input[str]] = None,
                 preferred_ciphers: Optional[pulumi.Input[str]] = None,
                 quic_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] geography: Lists where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia. You can only use the setting to include China and Russia if your Akamai contract specifies your ability to do so and you have approval from the Chinese and Russian government.
        :param pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs'] client_mutual_authentication: The configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
        :param pulumi.Input[bool] clone_dns_names: Whether CPS should direct traffic using all the SANs you listed in the SANs parameter when you created your enrollment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disallowed_tls_versions: The TLS protocol version to disallow. CPS uses the TLS protocols that Akamai currently supports as a best practice.
        :param pulumi.Input[str] must_have_ciphers: The ciphers to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        :param pulumi.Input[str] ocsp_stapling: Whether to use OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response must be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want visitors to your site to contact the CA directly for an OSCP response. OCSP allows you to obtain the revocation status of a certificate.
        :param pulumi.Input[str] preferred_ciphers: Ciphers that you preferably want to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        :param pulumi.Input[bool] quic_enabled: Whether to use the QUIC transport layer network protocol.
        """
        pulumi.set(__self__, "geography", geography)
        if client_mutual_authentication is not None:
            pulumi.set(__self__, "client_mutual_authentication", client_mutual_authentication)
        if clone_dns_names is not None:
            pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        if disallowed_tls_versions is not None:
            pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        if must_have_ciphers is not None:
            pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        if ocsp_stapling is not None:
            pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        if preferred_ciphers is not None:
            pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        if quic_enabled is not None:
            pulumi.set(__self__, "quic_enabled", quic_enabled)

    @property
    @pulumi.getter
    def geography(self) -> pulumi.Input[str]:
        """
        Lists where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia. You can only use the setting to include China and Russia if your Akamai contract specifies your ability to do so and you have approval from the Chinese and Russian government.
        """
        return pulumi.get(self, "geography")

    @geography.setter
    def geography(self, value: pulumi.Input[str]):
        pulumi.set(self, "geography", value)

    @property
    @pulumi.getter(name="clientMutualAuthentication")
    def client_mutual_authentication(self) -> Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]:
        """
        The configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
        """
        return pulumi.get(self, "client_mutual_authentication")

    @client_mutual_authentication.setter
    def client_mutual_authentication(self, value: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]):
        pulumi.set(self, "client_mutual_authentication", value)

    @property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether CPS should direct traffic using all the SANs you listed in the SANs parameter when you created your enrollment.
        """
        return pulumi.get(self, "clone_dns_names")

    @clone_dns_names.setter
    def clone_dns_names(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone_dns_names", value)

    @property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The TLS protocol version to disallow. CPS uses the TLS protocols that Akamai currently supports as a best practice.
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @disallowed_tls_versions.setter
    def disallowed_tls_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disallowed_tls_versions", value)

    @property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> Optional[pulumi.Input[str]]:
        """
        The ciphers to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        """
        return pulumi.get(self, "must_have_ciphers")

    @must_have_ciphers.setter
    def must_have_ciphers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "must_have_ciphers", value)

    @property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response must be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want visitors to your site to contact the CA directly for an OSCP response. OCSP allows you to obtain the revocation status of a certificate.
        """
        return pulumi.get(self, "ocsp_stapling")

    @ocsp_stapling.setter
    def ocsp_stapling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ocsp_stapling", value)

    @property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> Optional[pulumi.Input[str]]:
        """
        Ciphers that you preferably want to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
        """
        return pulumi.get(self, "preferred_ciphers")

    @preferred_ciphers.setter
    def preferred_ciphers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_ciphers", value)

    @property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the QUIC transport layer network protocol.
        """
        return pulumi.get(self, "quic_enabled")

    @quic_enabled.setter
    def quic_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "quic_enabled", value)


@pulumi.input_type
class CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs:
    def __init__(__self__, *,
                 ocsp_enabled: Optional[pulumi.Input[bool]] = None,
                 send_ca_list_to_client: Optional[pulumi.Input[bool]] = None,
                 set_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] ocsp_enabled: Whether you want to enable the Online Certificate Status Protocol (OCSP) stapling for client certificates.
        :param pulumi.Input[bool] send_ca_list_to_client: Whether you want to enable the server to send the certificate authority (CA) list to the client.
        :param pulumi.Input[str] set_id: The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
        """
        if ocsp_enabled is not None:
            pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        if send_ca_list_to_client is not None:
            pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        if set_id is not None:
            pulumi.set(__self__, "set_id", set_id)

    @property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether you want to enable the Online Certificate Status Protocol (OCSP) stapling for client certificates.
        """
        return pulumi.get(self, "ocsp_enabled")

    @ocsp_enabled.setter
    def ocsp_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ocsp_enabled", value)

    @property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether you want to enable the server to send the certificate authority (CA) list to the client.
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @send_ca_list_to_client.setter
    def send_ca_list_to_client(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_ca_list_to_client", value)

    @property
    @pulumi.getter(name="setId")
    def set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
        """
        return pulumi.get(self, "set_id")

    @set_id.setter
    def set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_id", value)


@pulumi.input_type
class CpsDvEnrollmentOrganizationArgs:
    def __init__(__self__, *,
                 address_line_one: pulumi.Input[str],
                 city: pulumi.Input[str],
                 country_code: pulumi.Input[str],
                 name: pulumi.Input[str],
                 phone: pulumi.Input[str],
                 postal_code: pulumi.Input[str],
                 region: pulumi.Input[str],
                 address_line_two: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address_line_one: The address of your organization.
        :param pulumi.Input[str] city: The city where your organization resides.
        :param pulumi.Input[str] country_code: The code for the country where your organization resides.
        :param pulumi.Input[str] name: The name of your organization.
        :param pulumi.Input[str] phone: The phone number of the administrator who you want to use as a contact at your company.
        :param pulumi.Input[str] postal_code: The postal code of your organization.
        :param pulumi.Input[str] region: The region of your organization, typically a state or province.
        :param pulumi.Input[str] address_line_two: The address of your organization.
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)

    @property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> pulumi.Input[str]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_line_one", value)

    @property
    @pulumi.getter
    def city(self) -> pulumi.Input[str]:
        """
        The city where your organization resides.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[str]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The code for the country where your organization resides.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of your organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def phone(self) -> pulumi.Input[str]:
        """
        The phone number of the administrator who you want to use as a contact at your company.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[str]):
        pulumi.set(self, "phone", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> pulumi.Input[str]:
        """
        The postal code of your organization.
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of your organization, typically a state or province.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[str]]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_line_two", value)


@pulumi.input_type
class CpsDvEnrollmentTechContactArgs:
    def __init__(__self__, *,
                 address_line_one: pulumi.Input[str],
                 city: pulumi.Input[str],
                 country_code: pulumi.Input[str],
                 email: pulumi.Input[str],
                 first_name: pulumi.Input[str],
                 last_name: pulumi.Input[str],
                 organization: pulumi.Input[str],
                 phone: pulumi.Input[str],
                 postal_code: pulumi.Input[str],
                 region: pulumi.Input[str],
                 address_line_two: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address_line_one: The address of your organization.
        :param pulumi.Input[str] city: The city where your organization resides.
        :param pulumi.Input[str] country_code: The code for the country where your organization resides.
        :param pulumi.Input[str] email: The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.
        :param pulumi.Input[str] first_name: The first name of the technical contact at Akamai.
        :param pulumi.Input[str] last_name: The last name of the technical contact at Akamai.
        :param pulumi.Input[str] organization: Your organization information.
        :param pulumi.Input[str] phone: The phone number of the administrator who you want to use as a contact at your company.
        :param pulumi.Input[str] postal_code: The postal code of your organization.
        :param pulumi.Input[str] region: The region of your organization, typically a state or province.
        :param pulumi.Input[str] address_line_two: The address of your organization.
        :param pulumi.Input[str] title: The title of the technical contact at Akamai.
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> pulumi.Input[str]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_line_one", value)

    @property
    @pulumi.getter
    def city(self) -> pulumi.Input[str]:
        """
        The city where your organization resides.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[str]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The code for the country where your organization resides.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[str]:
        """
        The first name of the technical contact at Akamai.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[str]:
        """
        The last name of the technical contact at Akamai.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[str]:
        """
        Your organization information.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def phone(self) -> pulumi.Input[str]:
        """
        The phone number of the administrator who you want to use as a contact at your company.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[str]):
        pulumi.set(self, "phone", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> pulumi.Input[str]:
        """
        The postal code of your organization.
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of your organization, typically a state or province.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[str]]:
        """
        The address of your organization.
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_line_two", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the technical contact at Akamai.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class DatastreamAzureConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 container_name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_key: **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        :param pulumi.Input[str] account_name: - (Required) Specifies the Azure Storage account name.
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] container_name: - (Required) Specifies the Azure Storage container name.
        :param pulumi.Input[str] path: The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "path", path)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        - (Required) Specifies the Azure Storage account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[str]:
        """
        - (Required) Specifies the Azure Storage container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)


@pulumi.input_type
class DatastreamConfigArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 frequency: pulumi.Input['DatastreamConfigFrequencyArgs'],
                 delimiter: Optional[pulumi.Input[str]] = None,
                 upload_file_prefix: Optional[pulumi.Input[str]] = None,
                 upload_file_suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: - (Required) The format in which you want to receive log files, either `STRUCTURED` or `JSON`. When `delimiter` is present in the request, `STRUCTURED` is the mandatory format.
        :param pulumi.Input['DatastreamConfigFrequencyArgs'] frequency: - (Required) How often you want to collect logs from each uploader and send them to a destination.
        :param pulumi.Input[str] delimiter: A delimiter that you want to use to separate data set fields in the log lines. Currently, `SPACE` is the only available delimiter. This field is required for the `STRUCTURED` log file `format`.
        :param pulumi.Input[str] upload_file_prefix: - (Optional) The prefix of the log file that you want to send to a destination. It’s a string of at most 200 characters. If unspecified, defaults to `ak`.
        :param pulumi.Input[str] upload_file_suffix: The suffix of the log file that you want to send to a destination. It’s a static string of at most 10 characters. If unspecified, defaults to `ds`.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "frequency", frequency)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if upload_file_prefix is not None:
            pulumi.set(__self__, "upload_file_prefix", upload_file_prefix)
        if upload_file_suffix is not None:
            pulumi.set(__self__, "upload_file_suffix", upload_file_suffix)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        - (Required) The format in which you want to receive log files, either `STRUCTURED` or `JSON`. When `delimiter` is present in the request, `STRUCTURED` is the mandatory format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input['DatastreamConfigFrequencyArgs']:
        """
        - (Required) How often you want to collect logs from each uploader and send them to a destination.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input['DatastreamConfigFrequencyArgs']):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        A delimiter that you want to use to separate data set fields in the log lines. Currently, `SPACE` is the only available delimiter. This field is required for the `STRUCTURED` log file `format`.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="uploadFilePrefix")
    def upload_file_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The prefix of the log file that you want to send to a destination. It’s a string of at most 200 characters. If unspecified, defaults to `ak`.
        """
        return pulumi.get(self, "upload_file_prefix")

    @upload_file_prefix.setter
    def upload_file_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upload_file_prefix", value)

    @property
    @pulumi.getter(name="uploadFileSuffix")
    def upload_file_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The suffix of the log file that you want to send to a destination. It’s a static string of at most 10 characters. If unspecified, defaults to `ds`.
        """
        return pulumi.get(self, "upload_file_suffix")

    @upload_file_suffix.setter
    def upload_file_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upload_file_suffix", value)


@pulumi.input_type
class DatastreamConfigFrequencyArgs:
    def __init__(__self__, *,
                 time_in_sec: pulumi.Input[int]):
        """
        :param pulumi.Input[int] time_in_sec: - (Required) The time in seconds after which the system bundles log lines into a file and sends it to a destination. `30` or `60` are the possible values.
        """
        pulumi.set(__self__, "time_in_sec", time_in_sec)

    @property
    @pulumi.getter(name="timeInSec")
    def time_in_sec(self) -> pulumi.Input[int]:
        """
        - (Required) The time in seconds after which the system bundles log lines into a file and sends it to a destination. `30` or `60` are the possible values.
        """
        return pulumi.get(self, "time_in_sec")

    @time_in_sec.setter
    def time_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_in_sec", value)


@pulumi.input_type
class DatastreamDatadogConnectorArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_token: - (Required) **Secret**. The API key associated with your Datadog account. See [View API keys in Datadog](https://docs.datadoghq.com/account_management/api-app-keys/#api-keys).
               * `compress logs` - (Optional) Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `false`.
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] url: Enter the secure URL where you want to send and store your logs.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        :param pulumi.Input[str] service: The service of the Datadog connector. A service groups together endpoints, queries, or jobs for the purposes of scaling instances. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes).
        :param pulumi.Input[str] source: The source of the Datadog connector. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_collection/?tab=http#reserved-attributes).
        :param pulumi.Input[str] tags: The tags of the Datadog connector. See [View Datadog tags](https://docs.datadoghq.com/getting_started/tagging/).
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "url", url)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        - (Required) **Secret**. The API key associated with your Datadog account. See [View API keys in Datadog](https://docs.datadoghq.com/account_management/api-app-keys/#api-keys).
        * `compress logs` - (Optional) Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `false`.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Enter the secure URL where you want to send and store your logs.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The service of the Datadog connector. A service groups together endpoints, queries, or jobs for the purposes of scaling instances. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes).
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the Datadog connector. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_collection/?tab=http#reserved-attributes).
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        The tags of the Datadog connector. See [View Datadog tags](https://docs.datadoghq.com/getting_started/tagging/).
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class DatastreamGcsConnectorArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 service_account_name: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] private_key: - (Required) **Secret**. The contents of the JSON private key you generated and downloaded in your Google Cloud Storage account.
        :param pulumi.Input[str] project_id: - (Required) The unique ID of your Google Cloud project.
        :param pulumi.Input[str] service_account_name: - (Required)	The name of the service account with the storage.object.create permission or Storage Object Creator role.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        :param pulumi.Input[str] path: The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_name", service_account_name)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        - (Required) **Secret**. The contents of the JSON private key you generated and downloaded in your Google Cloud Storage account.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        - (Required) The unique ID of your Google Cloud project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> pulumi.Input[str]:
        """
        - (Required)	The name of the service account with the storage.object.create permission or Storage Object Creator role.
        """
        return pulumi.get(self, "service_account_name")

    @service_account_name.setter
    def service_account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_name", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class DatastreamHttpsConnectorArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_type: Either `NONE` for no authentication, or `BASIC`. For basic authentication, provide the `user_name` and `password` you set in your custom HTTPS endpoint.
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] url: Enter the secure URL where you want to send and store your logs.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        :param pulumi.Input[str] password: **Secret**. Enter the password you set in your custom HTTPS endpoint for authentication.
        :param pulumi.Input[str] user_name: **Secret**. Enter the valid username you set in your custom HTTPS endpoint for authentication.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "url", url)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Either `NONE` for no authentication, or `BASIC`. For basic authentication, provide the `user_name` and `password` you set in your custom HTTPS endpoint.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Enter the secure URL where you want to send and store your logs.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        **Secret**. Enter the password you set in your custom HTTPS endpoint for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        **Secret**. Enter the valid username you set in your custom HTTPS endpoint for authentication.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class DatastreamOracleConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 path: pulumi.Input[str],
                 region: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_key: **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        :param pulumi.Input[str] bucket: The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] namespace: The namespace of your Oracle Cloud Storage account. See [Understanding Object Storage namespaces](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/understandingnamespaces.htm).
        :param pulumi.Input[str] path: The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        :param pulumi.Input[str] region: The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).
        :param pulumi.Input[str] secret_access_key: **Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace of your Oracle Cloud Storage account. See [Understanding Object Storage namespaces](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/understandingnamespaces.htm).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        **Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)


@pulumi.input_type
class DatastreamS3ConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 region: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_key: **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        :param pulumi.Input[str] bucket: The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] path: The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        :param pulumi.Input[str] region: The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).
        :param pulumi.Input[str] secret_access_key: **Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        **Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        **Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)


@pulumi.input_type
class DatastreamSplunkConnectorArgs:
    def __init__(__self__, *,
                 connector_name: pulumi.Input[str],
                 event_collector_token: pulumi.Input[str],
                 url: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] event_collector_token: - (Required) **Secret**. The Event Collector token associated with your Splunk account. See [View usage of Event Collector token in Splunk](https://docs.splunk.com/Documentation/Splunk/8.0.3/Data/UsetheHTTPEventCollector).
        :param pulumi.Input[str] url: Enter the secure URL where you want to send and store your logs.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "event_collector_token", event_collector_token)
        pulumi.set(__self__, "url", url)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter(name="eventCollectorToken")
    def event_collector_token(self) -> pulumi.Input[str]:
        """
        - (Required) **Secret**. The Event Collector token associated with your Splunk account. See [View usage of Event Collector token in Splunk](https://docs.splunk.com/Documentation/Splunk/8.0.3/Data/UsetheHTTPEventCollector).
        """
        return pulumi.get(self, "event_collector_token")

    @event_collector_token.setter
    def event_collector_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_collector_token", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Enter the secure URL where you want to send and store your logs.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)


@pulumi.input_type
class DatastreamSumologicConnectorArgs:
    def __init__(__self__, *,
                 collector_code: pulumi.Input[str],
                 connector_name: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 compress_logs: Optional[pulumi.Input[bool]] = None,
                 connector_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] collector_code: **Secret**. The unique HTTP collector code of your Sumo Logic `endpoint`.
        :param pulumi.Input[str] connector_name: The name of the connector.
        :param pulumi.Input[str] endpoint: The Sumo Logic collection endpoint where you want to send your logs. You should follow the `https://<SumoEndpoint>/receiver/v1/http` format and pass the collector code in the `collectorCode` argument.
        :param pulumi.Input[bool] compress_logs: Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        pulumi.set(__self__, "collector_code", collector_code)
        pulumi.set(__self__, "connector_name", connector_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)

    @property
    @pulumi.getter(name="collectorCode")
    def collector_code(self) -> pulumi.Input[str]:
        """
        **Secret**. The unique HTTP collector code of your Sumo Logic `endpoint`.
        """
        return pulumi.get(self, "collector_code")

    @collector_code.setter
    def collector_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "collector_code", value)

    @property
    @pulumi.getter(name="connectorName")
    def connector_name(self) -> pulumi.Input[str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "connector_name")

    @connector_name.setter
    def connector_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The Sumo Logic collection endpoint where you want to send your logs. You should follow the `https://<SumoEndpoint>/receiver/v1/http` format and pass the collector code in the `collectorCode` argument.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress_logs", value)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connector_id", value)


@pulumi.input_type
class DnsZoneTsigKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 name: pulumi.Input[str],
                 secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] algorithm: The hashing algorithm.
        :param pulumi.Input[str] name: The key name.
        :param pulumi.Input[str] secret: String known between transfer endpoints.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        The hashing algorithm.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        String known between transfer endpoints.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class EdgeKvInitialDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)


@pulumi.input_type
class GtmAsmapAssignmentArgs:
    def __init__(__self__, *,
                 as_numbers: pulumi.Input[Sequence[pulumi.Input[int]]],
                 datacenter_id: pulumi.Input[int],
                 nickname: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] as_numbers: Specifies an array of AS numbers.
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Specifies an array of AS numbers.
        """
        return pulumi.get(self, "as_numbers")

    @as_numbers.setter
    def as_numbers(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "as_numbers", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[str]:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[str]):
        pulumi.set(self, "nickname", value)


@pulumi.input_type
class GtmAsmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 nickname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nickname", value)


@pulumi.input_type
class GtmCidrmapAssignmentArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 nickname: pulumi.Input[str],
                 blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the CIDR zone group, up to 256 characters.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocks: Specifies an array of CIDR blocks.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[str]:
        """
        A descriptive label for the CIDR zone group, up to 256 characters.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[str]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of CIDR blocks.
        """
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocks", value)


@pulumi.input_type
class GtmCidrmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 nickname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the CIDR zone group, up to 256 characters.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive label for the CIDR zone group, up to 256 characters.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nickname", value)


@pulumi.input_type
class GtmDatacenterDefaultLoadObjectArgs:
    def __init__(__self__, *,
                 load_object: Optional[pulumi.Input[str]] = None,
                 load_object_port: Optional[pulumi.Input[int]] = None,
                 load_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] load_object: A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.
        :param pulumi.Input[int] load_object_port: Specifies the TCP port to connect to when requesting the load object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_servers: Specifies a list of servers to request the load object from.
        """
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)

    @property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[pulumi.Input[str]]:
        """
        A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_object", value)

    @property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "load_object_port", value)

    @property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of servers to request the load object from.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_servers", value)


@pulumi.input_type
class GtmGeomapAssignmentArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 nickname: pulumi.Input[str],
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] countries: Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[str]:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[str]):
        pulumi.set(self, "nickname", value)

    @property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "countries", value)


@pulumi.input_type
class GtmGeomapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 nickname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nickname", value)


@pulumi.input_type
class GtmPropertyLivenessTestArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 test_interval: pulumi.Input[int],
                 test_object: pulumi.Input[str],
                 test_object_protocol: pulumi.Input[str],
                 test_timeout: pulumi.Input[float],
                 answers_required: Optional[pulumi.Input[bool]] = None,
                 disable_nonstandard_port_warning: Optional[pulumi.Input[bool]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 error_penalty: Optional[pulumi.Input[float]] = None,
                 http_error3xx: Optional[pulumi.Input[bool]] = None,
                 http_error4xx: Optional[pulumi.Input[bool]] = None,
                 http_error5xx: Optional[pulumi.Input[bool]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]] = None,
                 peer_certificate_verification: Optional[pulumi.Input[bool]] = None,
                 recursion_requested: Optional[pulumi.Input[bool]] = None,
                 request_string: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 response_string: Optional[pulumi.Input[str]] = None,
                 ssl_client_certificate: Optional[pulumi.Input[str]] = None,
                 ssl_client_private_key: Optional[pulumi.Input[str]] = None,
                 test_object_password: Optional[pulumi.Input[str]] = None,
                 test_object_port: Optional[pulumi.Input[int]] = None,
                 test_object_username: Optional[pulumi.Input[str]] = None,
                 timeout_penalty: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[int] test_interval: Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.
        :param pulumi.Input[str] test_object: Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        :param pulumi.Input[str] test_object_protocol: Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.
        :param pulumi.Input[float] test_timeout: Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.
        :param pulumi.Input[bool] answers_required: If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.
        :param pulumi.Input[bool] disable_nonstandard_port_warning: A boolean that if set to `true`, disables warnings when non-standard ports are used.
        :param pulumi.Input[bool] disabled: A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.
        :param pulumi.Input[float] error_penalty: Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        :param pulumi.Input[bool] http_error3xx: A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        :param pulumi.Input[bool] http_error4xx: A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        :param pulumi.Input[bool] http_error5xx: A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        :param pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]] http_headers: Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:
        :param pulumi.Input[bool] peer_certificate_verification: A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.
        :param pulumi.Input[bool] recursion_requested: A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.
        :param pulumi.Input[str] request_string: Specifies a request string.
        :param pulumi.Input[str] resource_type: Specifies the query type, if `test_object_protocol` is DNS.
        :param pulumi.Input[str] response_string: Specifies a response string.
        :param pulumi.Input[str] ssl_client_certificate: Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.
        :param pulumi.Input[str] ssl_client_private_key: Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.
        :param pulumi.Input[str] test_object_password: Specifies the test object's password. It is required if testObjectProtocol is ftp.
        :param pulumi.Input[int] test_object_port: Specifies the port number for the testObject.
        :param pulumi.Input[str] test_object_username: A descriptive name for the testObject.
        :param pulumi.Input[float] timeout_penalty: Specifies the score to be reported if the liveness test times out.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "test_interval", test_interval)
        pulumi.set(__self__, "test_object", test_object)
        pulumi.set(__self__, "test_object_protocol", test_object_protocol)
        pulumi.set(__self__, "test_timeout", test_timeout)
        if answers_required is not None:
            pulumi.set(__self__, "answers_required", answers_required)
        if disable_nonstandard_port_warning is not None:
            pulumi.set(__self__, "disable_nonstandard_port_warning", disable_nonstandard_port_warning)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if error_penalty is not None:
            pulumi.set(__self__, "error_penalty", error_penalty)
        if http_error3xx is not None:
            pulumi.set(__self__, "http_error3xx", http_error3xx)
        if http_error4xx is not None:
            pulumi.set(__self__, "http_error4xx", http_error4xx)
        if http_error5xx is not None:
            pulumi.set(__self__, "http_error5xx", http_error5xx)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if recursion_requested is not None:
            pulumi.set(__self__, "recursion_requested", recursion_requested)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if ssl_client_certificate is not None:
            pulumi.set(__self__, "ssl_client_certificate", ssl_client_certificate)
        if ssl_client_private_key is not None:
            pulumi.set(__self__, "ssl_client_private_key", ssl_client_private_key)
        if test_object_password is not None:
            pulumi.set(__self__, "test_object_password", test_object_password)
        if test_object_port is not None:
            pulumi.set(__self__, "test_object_port", test_object_port)
        if test_object_username is not None:
            pulumi.set(__self__, "test_object_username", test_object_username)
        if timeout_penalty is not None:
            pulumi.set(__self__, "timeout_penalty", timeout_penalty)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="testInterval")
    def test_interval(self) -> pulumi.Input[int]:
        """
        Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.
        """
        return pulumi.get(self, "test_interval")

    @test_interval.setter
    def test_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "test_interval", value)

    @property
    @pulumi.getter(name="testObject")
    def test_object(self) -> pulumi.Input[str]:
        """
        Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        """
        return pulumi.get(self, "test_object")

    @test_object.setter
    def test_object(self, value: pulumi.Input[str]):
        pulumi.set(self, "test_object", value)

    @property
    @pulumi.getter(name="testObjectProtocol")
    def test_object_protocol(self) -> pulumi.Input[str]:
        """
        Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.
        """
        return pulumi.get(self, "test_object_protocol")

    @test_object_protocol.setter
    def test_object_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "test_object_protocol", value)

    @property
    @pulumi.getter(name="testTimeout")
    def test_timeout(self) -> pulumi.Input[float]:
        """
        Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.
        """
        return pulumi.get(self, "test_timeout")

    @test_timeout.setter
    def test_timeout(self, value: pulumi.Input[float]):
        pulumi.set(self, "test_timeout", value)

    @property
    @pulumi.getter(name="answersRequired")
    def answers_required(self) -> Optional[pulumi.Input[bool]]:
        """
        If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.
        """
        return pulumi.get(self, "answers_required")

    @answers_required.setter
    def answers_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "answers_required", value)

    @property
    @pulumi.getter(name="disableNonstandardPortWarning")
    def disable_nonstandard_port_warning(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that if set to `true`, disables warnings when non-standard ports are used.
        """
        return pulumi.get(self, "disable_nonstandard_port_warning")

    @disable_nonstandard_port_warning.setter
    def disable_nonstandard_port_warning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_nonstandard_port_warning", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="errorPenalty")
    def error_penalty(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        """
        return pulumi.get(self, "error_penalty")

    @error_penalty.setter
    def error_penalty(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "error_penalty", value)

    @property
    @pulumi.getter(name="httpError3xx")
    def http_error3xx(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        """
        return pulumi.get(self, "http_error3xx")

    @http_error3xx.setter
    def http_error3xx(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_error3xx", value)

    @property
    @pulumi.getter(name="httpError4xx")
    def http_error4xx(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        """
        return pulumi.get(self, "http_error4xx")

    @http_error4xx.setter
    def http_error4xx(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_error4xx", value)

    @property
    @pulumi.getter(name="httpError5xx")
    def http_error5xx(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.
        """
        return pulumi.get(self, "http_error5xx")

    @http_error5xx.setter
    def http_error5xx(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_error5xx", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]]:
        """
        Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.
        """
        return pulumi.get(self, "peer_certificate_verification")

    @peer_certificate_verification.setter
    def peer_certificate_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "peer_certificate_verification", value)

    @property
    @pulumi.getter(name="recursionRequested")
    def recursion_requested(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.
        """
        return pulumi.get(self, "recursion_requested")

    @recursion_requested.setter
    def recursion_requested(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "recursion_requested", value)

    @property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a request string.
        """
        return pulumi.get(self, "request_string")

    @request_string.setter
    def request_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_string", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the query type, if `test_object_protocol` is DNS.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a response string.
        """
        return pulumi.get(self, "response_string")

    @response_string.setter
    def response_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_string", value)

    @property
    @pulumi.getter(name="sslClientCertificate")
    def ssl_client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.
        """
        return pulumi.get(self, "ssl_client_certificate")

    @ssl_client_certificate.setter
    def ssl_client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_client_certificate", value)

    @property
    @pulumi.getter(name="sslClientPrivateKey")
    def ssl_client_private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.
        """
        return pulumi.get(self, "ssl_client_private_key")

    @ssl_client_private_key.setter
    def ssl_client_private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_client_private_key", value)

    @property
    @pulumi.getter(name="testObjectPassword")
    def test_object_password(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the test object's password. It is required if testObjectProtocol is ftp.
        """
        return pulumi.get(self, "test_object_password")

    @test_object_password.setter
    def test_object_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "test_object_password", value)

    @property
    @pulumi.getter(name="testObjectPort")
    def test_object_port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the port number for the testObject.
        """
        return pulumi.get(self, "test_object_port")

    @test_object_port.setter
    def test_object_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "test_object_port", value)

    @property
    @pulumi.getter(name="testObjectUsername")
    def test_object_username(self) -> Optional[pulumi.Input[str]]:
        """
        A descriptive name for the testObject.
        """
        return pulumi.get(self, "test_object_username")

    @test_object_username.setter
    def test_object_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "test_object_username", value)

    @property
    @pulumi.getter(name="timeoutPenalty")
    def timeout_penalty(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the score to be reported if the liveness test times out.
        """
        return pulumi.get(self, "timeout_penalty")

    @timeout_penalty.setter
    def timeout_penalty(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "timeout_penalty", value)


@pulumi.input_type
class GtmPropertyLivenessTestHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[str] value: Value of HTTP header.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GtmPropertyStaticRrSetArgs:
    def __init__(__self__, *,
                 rdatas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ttl: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rdatas: (List) An array of data strings, representing multiple records within a set.
        :param pulumi.Input[int] ttl: The number of seconds that this record should live in a resolver's cache before being refetched.
        :param pulumi.Input[str] type: The record type.
        """
        if rdatas is not None:
            pulumi.set(__self__, "rdatas", rdatas)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def rdatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) An array of data strings, representing multiple records within a set.
        """
        return pulumi.get(self, "rdatas")

    @rdatas.setter
    def rdatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rdatas", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds that this record should live in a resolver's cache before being refetched.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GtmPropertyTrafficTargetArgs:
    def __init__(__self__, *,
                 datacenter_id: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 handout_cname: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[bool] enabled: A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.
        :param pulumi.Input[str] handout_cname: Specifies an optional data center for the property. Used when there are no servers configured for the property.
        :param pulumi.Input[str] name: Name of HTTP header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: (List) Identifies the IP address or the hostnames of the servers.
        :param pulumi.Input[float] weight: Specifies the traffic weight for the target.
        """
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if handout_cname is not None:
            pulumi.set(__self__, "handout_cname", handout_cname)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[int]]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="handoutCname")
    def handout_cname(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an optional data center for the property. Used when there are no servers configured for the property.
        """
        return pulumi.get(self, "handout_cname")

    @handout_cname.setter
    def handout_cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handout_cname", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Identifies the IP address or the hostnames of the servers.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the traffic weight for the target.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class GtmResourceResourceInstanceArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[int],
                 load_object: Optional[pulumi.Input[str]] = None,
                 load_object_port: Optional[pulumi.Input[int]] = None,
                 load_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_default_load_object: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
        :param pulumi.Input[str] load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.
        :param pulumi.Input[int] load_object_port: Specifies the TCP port of the `load_object`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_servers: (List) Specifies a list of servers from which to request the load object.
        :param pulumi.Input[bool] use_default_load_object: A boolean that indicates whether a default `load_object` is used for the resources.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)
        if use_default_load_object is not None:
            pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[int]:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[pulumi.Input[str]]:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_object", value)

    @property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the TCP port of the `load_object`.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "load_object_port", value)

    @property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Specifies a list of servers from which to request the load object.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_servers", value)

    @property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean that indicates whether a default `load_object` is used for the resources.
        """
        return pulumi.get(self, "use_default_load_object")

    @use_default_load_object.setter
    def use_default_load_object(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_default_load_object", value)


@pulumi.input_type
class PropertyActivationRuleErrorArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 error_location: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior_name", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_location", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PropertyActivationRuleWarningArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 error_location: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior_name", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_location", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PropertyHostnameArgs:
    def __init__(__self__, *,
                 cert_provisioning_type: pulumi.Input[str],
                 cname_from: pulumi.Input[str],
                 cname_to: pulumi.Input[str],
                 cert_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]] = None,
                 cname_type: Optional[pulumi.Input[str]] = None,
                 edge_hostname_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cert_provisioning_type: The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://learn.akamai.com/en-us/products/core_features/certificate_provisioning_system.html), or `DEFAULT` for certificates provisioned automatically.
        :param pulumi.Input[str] cname_from: A string containing the original origin's hostname. For example, `"example.org"`.
        :param pulumi.Input[str] cname_to: A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
        """
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_to", cname_to)
        if cert_statuses is not None:
            pulumi.set(__self__, "cert_statuses", cert_statuses)
        if cname_type is not None:
            pulumi.set(__self__, "cname_type", cname_type)
        if edge_hostname_id is not None:
            pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)

    @property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> pulumi.Input[str]:
        """
        The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://learn.akamai.com/en-us/products/core_features/certificate_provisioning_system.html), or `DEFAULT` for certificates provisioned automatically.
        """
        return pulumi.get(self, "cert_provisioning_type")

    @cert_provisioning_type.setter
    def cert_provisioning_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "cert_provisioning_type", value)

    @property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> pulumi.Input[str]:
        """
        A string containing the original origin's hostname. For example, `"example.org"`.
        """
        return pulumi.get(self, "cname_from")

    @cname_from.setter
    def cname_from(self, value: pulumi.Input[str]):
        pulumi.set(self, "cname_from", value)

    @property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> pulumi.Input[str]:
        """
        A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
        """
        return pulumi.get(self, "cname_to")

    @cname_to.setter
    def cname_to(self, value: pulumi.Input[str]):
        pulumi.set(self, "cname_to", value)

    @property
    @pulumi.getter(name="certStatuses")
    def cert_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]]:
        return pulumi.get(self, "cert_statuses")

    @cert_statuses.setter
    def cert_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]]):
        pulumi.set(self, "cert_statuses", value)

    @property
    @pulumi.getter(name="cnameType")
    def cname_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cname_type")

    @cname_type.setter
    def cname_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname_type", value)

    @property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "edge_hostname_id")

    @edge_hostname_id.setter
    def edge_hostname_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "edge_hostname_id", value)


@pulumi.input_type
class PropertyHostnameCertStatusArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 production_status: Optional[pulumi.Input[str]] = None,
                 staging_status: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if production_status is not None:
            pulumi.set(__self__, "production_status", production_status)
        if staging_status is not None:
            pulumi.set(__self__, "staging_status", staging_status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "production_status")

    @production_status.setter
    def production_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "production_status", value)

    @property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "staging_status")

    @staging_status.setter
    def staging_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "staging_status", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class PropertyOriginArgs:
    def __init__(__self__, *,
                 cache_key_hostname: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 enable_true_client_ip: Optional[pulumi.Input[bool]] = None,
                 forward_hostname: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        if cache_key_hostname is not None:
            pulumi.set(__self__, "cache_key_hostname", cache_key_hostname)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if enable_true_client_ip is not None:
            pulumi.set(__self__, "enable_true_client_ip", enable_true_client_ip)
        if forward_hostname is not None:
            pulumi.set(__self__, "forward_hostname", forward_hostname)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="cacheKeyHostname")
    def cache_key_hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cache_key_hostname")

    @cache_key_hostname.setter
    def cache_key_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_key_hostname", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="enableTrueClientIp")
    def enable_true_client_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_true_client_ip")

    @enable_true_client_ip.setter
    def enable_true_client_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_true_client_ip", value)

    @property
    @pulumi.getter(name="forwardHostname")
    def forward_hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "forward_hostname")

    @forward_hostname.setter
    def forward_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_hostname", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class PropertyRuleErrorArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 error_location: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior_name", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_location", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PropertyRuleWarningArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 error_location: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "behavior_name", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_location", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ProviderAppsecArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class ProviderConfigArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class ProviderDnsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class ProviderGtmArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class ProviderNetworkArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class ProviderPropertyArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_token: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 max_body: Optional[pulumi.Input[int]] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_token", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_body", value)


@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 pass_through_percent: float,
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
               * `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin.
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> float:
        return pulumi.get(self, "pass_through_percent")

    @pass_through_percent.setter
    def pass_through_percent(self, value: float):
        pulumi.set(self, "pass_through_percent", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        * `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs'],
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 id: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[bool] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs'] forward_settings: - (Required) Defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, the Edge Server returns an HTTP response from the rewritten URL.
        :param str type: - (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param int id: - (Optional) An identifier for Akamai internal use only.
        :param str match_url: - (Optional) The URL that the Cloudlet uses to match the incoming request.
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param bool matches_always: - (Optional) Whether the match supports default rules that apply to all requests.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs']:
        """
        - (Required) Defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, the Edge Server returns an HTTP response from the rewritten URL.
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs']):
        pulumi.set(self, "forward_settings", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        - (Optional) An identifier for Akamai internal use only.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) The URL that the Cloudlet uses to match the incoming request.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[bool]:
        """
        - (Optional) Whether the match supports default rules that apply to all requests.
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[bool]):
        pulumi.set(self, "matches_always", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs:
    def __init__(__self__, *,
                 origin_id: str):
        """
        :param str origin_id: - (Required) The ID of the Conditional Origin the requests are forwarded to.
        """
        pulumi.set(__self__, "origin_id", origin_id)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> str:
        """
        - (Required) The ID of the Conditional Origin the requests are forwarded to.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: str):
        pulumi.set(self, "origin_id", value)


@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `clientip`, `continent`, `cookie`, `countrycode`, `deviceCharacteristics`, `extension`, `header`, `hostname`, `method`, `path`, `protocol`, `proxy`, `query`, `regioncode`, or `range`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `clientip`, `continent`, `cookie`, `countrycode`, `deviceCharacteristics`, `extension`, `header`, `hostname`, `method`, `path`, `protocol`, `proxy`, `query`, `regioncode`, or `range`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs',
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs' forward_settings: (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs':
        """
        (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: Optional[str] = None,
                 path_and_qs: Optional[str] = None,
                 use_incoming_query_string: Optional[bool] = None):
        """
        :param str origin_id: - (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        :param str path_and_qs: - (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.
        :param bool use_incoming_query_string: - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[str]:
        """
        - (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[str]):
        pulumi.set(self, "origin_id", value)

    @property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[str]:
        """
        - (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.
        """
        return pulumi.get(self, "path_and_qs")

    @path_and_qs.setter
    def path_and_qs(self, value: Optional[str]):
        pulumi.set(self, "path_and_qs", value)

    @property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[bool]:
        """
        - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[bool]):
        pulumi.set(self, "use_incoming_query_string", value)


@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 redirect_url: str,
                 status_code: int,
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None,
                 use_incoming_query_string: Optional[bool] = None,
                 use_relative_url: Optional[str] = None):
        """
        :param str redirect_url: - (Required) The URL Edge Redirector redirects the request to. If you're using `use_relative_url`, you can enter a path for the value.
        :param int status_code: - (Required) The HTTP response status code, which is either `301` (permanent redirect) or `302` (temporary redirect).
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        :param bool use_incoming_query_string: - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        :param str use_relative_url: - (Optional) If set to `relative_url`, takes the path you specify in the `redirect_url` argument and sets it in the response’s Location header. The client or browser receiving the request decides which protocol and hostname to use. If set to `copy_scheme_hostname`, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information you specify in the `redirect_url` argument. This absolute path is set in the response’s Location header. If you do not specify use_relative_url or set to `none`, then specify the `redirect_url` argument as a fully-qualified URL.
        """
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)
        if use_relative_url is not None:
            pulumi.set(__self__, "use_relative_url", use_relative_url)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> str:
        """
        - (Required) The URL Edge Redirector redirects the request to. If you're using `use_relative_url`, you can enter a path for the value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: str):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        - (Required) The HTTP response status code, which is either `301` (permanent redirect) or `302` (temporary redirect).
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: int):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[bool]:
        """
        - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[bool]):
        pulumi.set(self, "use_incoming_query_string", value)

    @property
    @pulumi.getter(name="useRelativeUrl")
    def use_relative_url(self) -> Optional[str]:
        """
        - (Optional) If set to `relative_url`, takes the path you specify in the `redirect_url` argument and sets it in the response’s Location header. The client or browser receiving the request decides which protocol and hostname to use. If set to `copy_scheme_hostname`, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information you specify in the `redirect_url` argument. This absolute path is set in the response’s Location header. If you do not specify use_relative_url or set to `none`, then specify the `redirect_url` argument as a fully-qualified URL.
        """
        return pulumi.get(self, "use_relative_url")

    @use_relative_url.setter
    def use_relative_url(self, value: Optional[str]):
        pulumi.set(self, "use_relative_url", value)


@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs',
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs' forward_settings: (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs':
        """
        (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: Optional[str] = None,
                 path_and_qs: Optional[str] = None,
                 use_incoming_query_string: Optional[bool] = None):
        """
        :param str origin_id: - (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        :param str path_and_qs: - (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.
        :param bool use_incoming_query_string: - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[str]:
        """
        - (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[str]):
        pulumi.set(self, "origin_id", value)

    @property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[str]:
        """
        - (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.
        """
        return pulumi.get(self, "path_and_qs")

    @path_and_qs.setter
    def path_and_qs(self, value: Optional[str]):
        pulumi.set(self, "path_and_qs", value)

    @property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[bool]:
        """
        - (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[bool]):
        pulumi.set(self, "use_incoming_query_string", value)


@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs',
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[bool] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs' forward_settings: (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param bool matches_always: - (Optional) Whether the match supports default rules that apply to all requests.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs':
        """
        (Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[bool]:
        """
        - (Optional) Whether the match supports default rules that apply to all requests.
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[bool]):
        pulumi.set(self, "matches_always", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: str,
                 percent: int):
        """
        :param str origin_id: - (Required) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        :param int percent: - (Required)
        """
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> str:
        """
        - (Required) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: str):
        pulumi.set(self, "origin_id", value)

    @property
    @pulumi.getter
    def percent(self) -> int:
        """
        - (Required)
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: int):
        pulumi.set(self, "percent", value)


@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 allow_deny: str,
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 matches: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[bool] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param str allow_deny: - (Required) If set to `allow`, the request is sent to origin when all conditions are true. If set to `deny`, the request is denied when all conditions are true. If set to `denybranded`, the request is denied and rerouted according to the Request Control behavior settings.
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule. When a rule is disabled it's not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param bool matches_always: - (Optional) Match on all incoming requests.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "allow_deny", allow_deny)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="allowDeny")
    def allow_deny(self) -> str:
        """
        - (Required) If set to `allow`, the request is sent to origin when all conditions are true. If set to `deny`, the request is denied when all conditions are true. If set to `denybranded`, the request is denied and rerouted according to the Request Control behavior settings.
        """
        return pulumi.get(self, "allow_deny")

    @allow_deny.setter
    def allow_deny(self, value: str):
        pulumi.set(self, "allow_deny", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule. When a rule is disabled it's not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[bool]:
        """
        - (Optional) Match on all incoming requests.
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[bool]):
        pulumi.set(self, "matches_always", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 pass_through_percent: float,
                 type: str,
                 disabled: Optional[bool] = None,
                 end: Optional[int] = None,
                 match_url: Optional[str] = None,
                 matches: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[str] = None,
                 start: Optional[int] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param bool disabled: - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        :param int end: - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        :param str match_url: - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
               * `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin. Enter `-1` to send everyone to the waiting room.
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs'] matches: - (Optional) A list of conditions to apply to a Cloudlet, including:
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param int start: - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> float:
        return pulumi.get(self, "pass_through_percent")

    @pass_through_percent.setter
    def pass_through_percent(self, value: float):
        pulumi.set(self, "pass_through_percent", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        - (Optional) Whether to disable a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[bool]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        - (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[str]:
        """
        - (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.
        * `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin. Enter `-1` to send everyone to the waiting room.
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[str]):
        pulumi.set(self, "match_url", value)

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']]:
        """
        - (Optional) A list of conditions to apply to a Cloudlet, including:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        """
        - (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[int]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 check_ips: Optional[str] = None,
                 match_operator: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 negate: Optional[bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param bool case_sensitive: - (Optional) Whether the match is case sensitive.
        :param str check_ips: - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        :param str match_operator: - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        :param str match_type: - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        :param str match_value: - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        :param bool negate: - (Optional) Whether to negate the match.
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the match is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[str]:
        """
        - (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[str]):
        pulumi.set(self, "check_ips", value)

    @property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[str]:
        """
        - (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[str]):
        pulumi.set(self, "match_operator", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        - (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        """
        - (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[str]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        - (Optional) Whether to negate the match.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[bool]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        - (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 name_case_sensitive: Optional[bool] = None,
                 name_has_wildcard: Optional[bool] = None,
                 options: Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        :param str name: - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        :param bool name_case_sensitive: - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        :param bool name_has_wildcard: - (Optional) Whether the `name` argument includes wildcards.
        :param 'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        - (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `name` argument includes wildcards.
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        - (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[bool] = None,
                 value_escaped: Optional[bool] = None,
                 value_has_wildcard: Optional[bool] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param bool value_case_sensitive: - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        :param bool value_escaped: - (Optional) Whether the `value` argument should be compared in an escaped form.
        :param bool value_has_wildcard: - (Optional) Whether the `value` argument includes wildcards.
        :param Sequence[str] values: - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be evaluated based on case sensitivity.
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument should be compared in an escaped form.
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[bool]):
        pulumi.set(self, "value_escaped", value)

    @property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[bool]:
        """
        - (Optional) Whether the `value` argument includes wildcards.
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        - (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetPropertyRulesTemplateTemplateArgs:
    def __init__(__self__, *,
                 template_data: str,
                 template_dir: str):
        pulumi.set(__self__, "template_data", template_data)
        pulumi.set(__self__, "template_dir", template_dir)

    @property
    @pulumi.getter(name="templateData")
    def template_data(self) -> str:
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: str):
        pulumi.set(self, "template_data", value)

    @property
    @pulumi.getter(name="templateDir")
    def template_dir(self) -> str:
        return pulumi.get(self, "template_dir")

    @template_dir.setter
    def template_dir(self, value: str):
        pulumi.set(self, "template_dir", value)


@pulumi.input_type
class GetPropertyRulesTemplateVariableArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str,
                 type: Optional[str] = None):
        """
        :param str name: The name of the variable used in template.
        :param str value: The value of the variable passed as a string.
        :param str type: The type of variable: `string`, `number`, `bool`, or `jsonBlock`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable used in template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the variable passed as a string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of variable: `string`, `number`, `bool`, or `jsonBlock`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


