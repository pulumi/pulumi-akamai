# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AppSecIPGeoAsnControlsArgs',
    'AppSecIPGeoAsnControlsArgsDict',
    'AppSecIPGeoGeoControlsArgs',
    'AppSecIPGeoGeoControlsArgsDict',
    'AppSecIPGeoIpControlsArgs',
    'AppSecIPGeoIpControlsArgsDict',
    'AppSecSiemSettingsExceptionsArgs',
    'AppSecSiemSettingsExceptionsArgsDict',
    'AppsecAdvancedSettingsAsePenaltyBoxQualificationExclusionsArgs',
    'AppsecAdvancedSettingsAsePenaltyBoxQualificationExclusionsArgsDict',
    'ClientlistListItemArgs',
    'ClientlistListItemArgsDict',
    'CloudAccessKeyCredentialsAArgs',
    'CloudAccessKeyCredentialsAArgsDict',
    'CloudAccessKeyCredentialsBArgs',
    'CloudAccessKeyCredentialsBArgsDict',
    'CloudAccessKeyNetworkConfigurationArgs',
    'CloudAccessKeyNetworkConfigurationArgsDict',
    'CloudAccessKeyTimeoutsArgs',
    'CloudAccessKeyTimeoutsArgsDict',
    'CloudcertificatesCertificateSubjectArgs',
    'CloudcertificatesCertificateSubjectArgsDict',
    'CloudletsApplicationLoadBalancerActivationTimeoutsArgs',
    'CloudletsApplicationLoadBalancerActivationTimeoutsArgsDict',
    'CloudletsApplicationLoadBalancerDataCenterArgs',
    'CloudletsApplicationLoadBalancerDataCenterArgsDict',
    'CloudletsApplicationLoadBalancerLivenessSettingsArgs',
    'CloudletsApplicationLoadBalancerLivenessSettingsArgsDict',
    'CloudletsPolicyActivationTimeoutsArgs',
    'CloudletsPolicyActivationTimeoutsArgsDict',
    'CloudletsPolicyTimeoutsArgs',
    'CloudletsPolicyTimeoutsArgsDict',
    'CloudwrapperActivationTimeoutsArgs',
    'CloudwrapperActivationTimeoutsArgsDict',
    'CloudwrapperConfigurationLocationArgs',
    'CloudwrapperConfigurationLocationArgsDict',
    'CloudwrapperConfigurationLocationCapacityArgs',
    'CloudwrapperConfigurationLocationCapacityArgsDict',
    'CloudwrapperConfigurationTimeoutsArgs',
    'CloudwrapperConfigurationTimeoutsArgsDict',
    'CpCodeTimeoutsArgs',
    'CpCodeTimeoutsArgsDict',
    'CpsDvEnrollmentAdminContactArgs',
    'CpsDvEnrollmentAdminContactArgsDict',
    'CpsDvEnrollmentCsrArgs',
    'CpsDvEnrollmentCsrArgsDict',
    'CpsDvEnrollmentDnsChallengeArgs',
    'CpsDvEnrollmentDnsChallengeArgsDict',
    'CpsDvEnrollmentHttpChallengeArgs',
    'CpsDvEnrollmentHttpChallengeArgsDict',
    'CpsDvEnrollmentNetworkConfigurationArgs',
    'CpsDvEnrollmentNetworkConfigurationArgsDict',
    'CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs',
    'CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict',
    'CpsDvEnrollmentOrganizationArgs',
    'CpsDvEnrollmentOrganizationArgsDict',
    'CpsDvEnrollmentTechContactArgs',
    'CpsDvEnrollmentTechContactArgsDict',
    'CpsDvEnrollmentTimeoutsArgs',
    'CpsDvEnrollmentTimeoutsArgsDict',
    'CpsDvValidationTimeoutsArgs',
    'CpsDvValidationTimeoutsArgsDict',
    'CpsThirdPartyEnrollmentAdminContactArgs',
    'CpsThirdPartyEnrollmentAdminContactArgsDict',
    'CpsThirdPartyEnrollmentCsrArgs',
    'CpsThirdPartyEnrollmentCsrArgsDict',
    'CpsThirdPartyEnrollmentNetworkConfigurationArgs',
    'CpsThirdPartyEnrollmentNetworkConfigurationArgsDict',
    'CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs',
    'CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict',
    'CpsThirdPartyEnrollmentOrganizationArgs',
    'CpsThirdPartyEnrollmentOrganizationArgsDict',
    'CpsThirdPartyEnrollmentTechContactArgs',
    'CpsThirdPartyEnrollmentTechContactArgsDict',
    'CpsThirdPartyEnrollmentTimeoutsArgs',
    'CpsThirdPartyEnrollmentTimeoutsArgsDict',
    'CpsUploadCertificateTimeoutsArgs',
    'CpsUploadCertificateTimeoutsArgsDict',
    'DatastreamAzureConnectorArgs',
    'DatastreamAzureConnectorArgsDict',
    'DatastreamDatadogConnectorArgs',
    'DatastreamDatadogConnectorArgsDict',
    'DatastreamDeliveryConfigurationArgs',
    'DatastreamDeliveryConfigurationArgsDict',
    'DatastreamDeliveryConfigurationFrequencyArgs',
    'DatastreamDeliveryConfigurationFrequencyArgsDict',
    'DatastreamDynatraceConnectorArgs',
    'DatastreamDynatraceConnectorArgsDict',
    'DatastreamElasticsearchConnectorArgs',
    'DatastreamElasticsearchConnectorArgsDict',
    'DatastreamGcsConnectorArgs',
    'DatastreamGcsConnectorArgsDict',
    'DatastreamHttpsConnectorArgs',
    'DatastreamHttpsConnectorArgsDict',
    'DatastreamLogglyConnectorArgs',
    'DatastreamLogglyConnectorArgsDict',
    'DatastreamNewRelicConnectorArgs',
    'DatastreamNewRelicConnectorArgsDict',
    'DatastreamOracleConnectorArgs',
    'DatastreamOracleConnectorArgsDict',
    'DatastreamS3CompatibleConnectorArgs',
    'DatastreamS3CompatibleConnectorArgsDict',
    'DatastreamS3ConnectorArgs',
    'DatastreamS3ConnectorArgsDict',
    'DatastreamSplunkConnectorArgs',
    'DatastreamSplunkConnectorArgsDict',
    'DatastreamSumologicConnectorArgs',
    'DatastreamSumologicConnectorArgsDict',
    'DatastreamTrafficpeakConnectorArgs',
    'DatastreamTrafficpeakConnectorArgsDict',
    'DnsZoneOutboundZoneTransferArgs',
    'DnsZoneOutboundZoneTransferArgsDict',
    'DnsZoneOutboundZoneTransferTsigKeyArgs',
    'DnsZoneOutboundZoneTransferTsigKeyArgsDict',
    'DnsZoneTsigKeyArgs',
    'DnsZoneTsigKeyArgsDict',
    'EdgeHostNameTimeoutsArgs',
    'EdgeHostNameTimeoutsArgsDict',
    'EdgeWorkerTimeoutsArgs',
    'EdgeWorkerTimeoutsArgsDict',
    'EdgeWorkersActivationTimeoutsArgs',
    'EdgeWorkersActivationTimeoutsArgsDict',
    'EdgekvGroupItemsTimeoutsArgs',
    'EdgekvGroupItemsTimeoutsArgsDict',
    'GtmAsmapAssignmentArgs',
    'GtmAsmapAssignmentArgsDict',
    'GtmAsmapDefaultDatacenterArgs',
    'GtmAsmapDefaultDatacenterArgsDict',
    'GtmCidrmapAssignmentArgs',
    'GtmCidrmapAssignmentArgsDict',
    'GtmCidrmapDefaultDatacenterArgs',
    'GtmCidrmapDefaultDatacenterArgsDict',
    'GtmDatacenterDefaultLoadObjectArgs',
    'GtmDatacenterDefaultLoadObjectArgsDict',
    'GtmGeomapAssignmentArgs',
    'GtmGeomapAssignmentArgsDict',
    'GtmGeomapDefaultDatacenterArgs',
    'GtmGeomapDefaultDatacenterArgsDict',
    'GtmPropertyLivenessTestArgs',
    'GtmPropertyLivenessTestArgsDict',
    'GtmPropertyLivenessTestHttpHeaderArgs',
    'GtmPropertyLivenessTestHttpHeaderArgsDict',
    'GtmPropertyStaticRrSetArgs',
    'GtmPropertyStaticRrSetArgsDict',
    'GtmPropertyTrafficTargetArgs',
    'GtmPropertyTrafficTargetArgsDict',
    'GtmResourceResourceInstanceArgs',
    'GtmResourceResourceInstanceArgsDict',
    'IamApiClientActionsArgs',
    'IamApiClientActionsArgsDict',
    'IamApiClientApiAccessArgs',
    'IamApiClientApiAccessArgsDict',
    'IamApiClientApiAccessApiArgs',
    'IamApiClientApiAccessApiArgsDict',
    'IamApiClientCredentialArgs',
    'IamApiClientCredentialArgsDict',
    'IamApiClientCredentialActionsArgs',
    'IamApiClientCredentialActionsArgsDict',
    'IamApiClientGroupAccessArgs',
    'IamApiClientGroupAccessArgsDict',
    'IamApiClientGroupAccessGroupArgs',
    'IamApiClientGroupAccessGroupArgsDict',
    'IamApiClientGroupAccessGroupSubGroupArgs',
    'IamApiClientGroupAccessGroupSubGroupArgsDict',
    'IamApiClientIpAclArgs',
    'IamApiClientIpAclArgsDict',
    'IamApiClientPurgeOptionsArgs',
    'IamApiClientPurgeOptionsArgsDict',
    'IamApiClientPurgeOptionsCpCodeAccessArgs',
    'IamApiClientPurgeOptionsCpCodeAccessArgsDict',
    'IamCidrBlockActionsArgs',
    'IamCidrBlockActionsArgsDict',
    'IamUserUserNotificationsArgs',
    'IamUserUserNotificationsArgsDict',
    'MtlskeystoreClientCertificateAkamaiTimeoutsArgs',
    'MtlskeystoreClientCertificateAkamaiTimeoutsArgsDict',
    'MtlskeystoreClientCertificateAkamaiVersionArgs',
    'MtlskeystoreClientCertificateAkamaiVersionArgsDict',
    'MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs',
    'MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgsDict',
    'MtlskeystoreClientCertificateThirdPartyVersionsArgs',
    'MtlskeystoreClientCertificateThirdPartyVersionsArgsDict',
    'MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs',
    'MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgsDict',
    'MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs',
    'MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgsDict',
    'MtlskeystoreClientCertificateUploadTimeoutsArgs',
    'MtlskeystoreClientCertificateUploadTimeoutsArgsDict',
    'MtlstruststoreCaSetActivationTimeoutsArgs',
    'MtlstruststoreCaSetActivationTimeoutsArgsDict',
    'MtlstruststoreCaSetCertificateArgs',
    'MtlstruststoreCaSetCertificateArgsDict',
    'MtlstruststoreCaSetTimeoutsArgs',
    'MtlstruststoreCaSetTimeoutsArgsDict',
    'PropertyActivationComplianceRecordArgs',
    'PropertyActivationComplianceRecordArgsDict',
    'PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs',
    'PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict',
    'PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs',
    'PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict',
    'PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs',
    'PropertyActivationComplianceRecordNoncomplianceReasonNoneArgsDict',
    'PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs',
    'PropertyActivationComplianceRecordNoncomplianceReasonOtherArgsDict',
    'PropertyActivationRuleErrorArgs',
    'PropertyActivationRuleErrorArgsDict',
    'PropertyActivationTimeoutsArgs',
    'PropertyActivationTimeoutsArgsDict',
    'PropertyDomainownershipDomainsDomainArgs',
    'PropertyDomainownershipDomainsDomainArgsDict',
    'PropertyDomainownershipDomainsDomainValidationChallengeArgs',
    'PropertyDomainownershipDomainsDomainValidationChallengeArgsDict',
    'PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs',
    'PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgsDict',
    'PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs',
    'PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgsDict',
    'PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs',
    'PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgsDict',
    'PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs',
    'PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgsDict',
    'PropertyDomainownershipValidationDomainArgs',
    'PropertyDomainownershipValidationDomainArgsDict',
    'PropertyDomainownershipValidationTimeoutsArgs',
    'PropertyDomainownershipValidationTimeoutsArgsDict',
    'PropertyHostnameArgs',
    'PropertyHostnameArgsDict',
    'PropertyHostnameBucketHostnamesArgs',
    'PropertyHostnameBucketHostnamesArgsDict',
    'PropertyHostnameCcmCertStatusArgs',
    'PropertyHostnameCcmCertStatusArgsDict',
    'PropertyHostnameCcmCertificatesArgs',
    'PropertyHostnameCcmCertificatesArgsDict',
    'PropertyHostnameCertStatusArgs',
    'PropertyHostnameCertStatusArgsDict',
    'PropertyIncludeActivationComplianceRecordArgs',
    'PropertyIncludeActivationComplianceRecordArgsDict',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgsDict',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs',
    'PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgsDict',
    'PropertyIncludeActivationTimeoutsArgs',
    'PropertyIncludeActivationTimeoutsArgsDict',
    'PropertyRuleErrorArgs',
    'PropertyRuleErrorArgsDict',
    'PropertyRuleWarningArgs',
    'PropertyRuleWarningArgsDict',
    'ProviderConfigArgs',
    'ProviderConfigArgsDict',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleArgsDict',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgsDict',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgsDict',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgsDict',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgsDict',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgsDict',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleArgsDict',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgsDict',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleArgsDict',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgsDict',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsRequestControlMatchRuleMatchRuleArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleArgsDict',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudletsSharedPolicyActivationsArgs',
    'GetCloudletsSharedPolicyActivationsArgsDict',
    'GetCloudletsSharedPolicyActivationsProductionArgs',
    'GetCloudletsSharedPolicyActivationsProductionArgsDict',
    'GetCloudletsSharedPolicyActivationsProductionEffectiveArgs',
    'GetCloudletsSharedPolicyActivationsProductionEffectiveArgsDict',
    'GetCloudletsSharedPolicyActivationsProductionLatestArgs',
    'GetCloudletsSharedPolicyActivationsProductionLatestArgsDict',
    'GetCloudletsSharedPolicyActivationsStagingArgs',
    'GetCloudletsSharedPolicyActivationsStagingArgsDict',
    'GetCloudletsSharedPolicyActivationsStagingEffectiveArgs',
    'GetCloudletsSharedPolicyActivationsStagingEffectiveArgsDict',
    'GetCloudletsSharedPolicyActivationsStagingLatestArgs',
    'GetCloudletsSharedPolicyActivationsStagingLatestArgsDict',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgsDict',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgsDict',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs',
    'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict',
    'GetCloudwrapperCapacitiesCapacityArgs',
    'GetCloudwrapperCapacitiesCapacityArgsDict',
    'GetCloudwrapperCapacitiesCapacityApprovedArgs',
    'GetCloudwrapperCapacitiesCapacityApprovedArgsDict',
    'GetCloudwrapperCapacitiesCapacityAssignedArgs',
    'GetCloudwrapperCapacitiesCapacityAssignedArgsDict',
    'GetCloudwrapperCapacitiesCapacityUnassignedArgs',
    'GetCloudwrapperCapacitiesCapacityUnassignedArgsDict',
    'GetCloudwrapperConfigurationLocationArgs',
    'GetCloudwrapperConfigurationLocationArgsDict',
    'GetCloudwrapperConfigurationLocationCapacityArgs',
    'GetCloudwrapperConfigurationLocationCapacityArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsBoccArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgsDict',
    'GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs',
    'GetCloudwrapperConfigurationMultiCdnSettingsOriginArgsDict',
    'GetCloudwrapperConfigurationsConfigurationArgs',
    'GetCloudwrapperConfigurationsConfigurationArgsDict',
    'GetCloudwrapperConfigurationsConfigurationLocationArgs',
    'GetCloudwrapperConfigurationsConfigurationLocationArgsDict',
    'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs',
    'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgsDict',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs',
    'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgsDict',
    'GetCloudwrapperLocationsLocationArgs',
    'GetCloudwrapperLocationsLocationArgsDict',
    'GetCloudwrapperLocationsLocationTrafficTypeArgs',
    'GetCloudwrapperLocationsLocationTrafficTypeArgsDict',
    'GetCloudwrapperPropertiesPropertyArgs',
    'GetCloudwrapperPropertiesPropertyArgsDict',
    'GetGtmAsmapAssignmentArgs',
    'GetGtmAsmapAssignmentArgsDict',
    'GetGtmAsmapDefaultDatacenterArgs',
    'GetGtmAsmapDefaultDatacenterArgsDict',
    'GetGtmAsmapLinkArgs',
    'GetGtmAsmapLinkArgsDict',
    'GetGtmCidrmapAssignmentArgs',
    'GetGtmCidrmapAssignmentArgsDict',
    'GetGtmCidrmapDefaultDatacenterArgs',
    'GetGtmCidrmapDefaultDatacenterArgsDict',
    'GetGtmCidrmapLinkArgs',
    'GetGtmCidrmapLinkArgsDict',
    'GetGtmDomainAsMapArgs',
    'GetGtmDomainAsMapArgsDict',
    'GetGtmDomainAsMapAssignmentArgs',
    'GetGtmDomainAsMapAssignmentArgsDict',
    'GetGtmDomainAsMapDefaultDatacenterArgs',
    'GetGtmDomainAsMapDefaultDatacenterArgsDict',
    'GetGtmDomainAsMapLinkArgs',
    'GetGtmDomainAsMapLinkArgsDict',
    'GetGtmDomainCidrMapArgs',
    'GetGtmDomainCidrMapArgsDict',
    'GetGtmDomainCidrMapAssignmentArgs',
    'GetGtmDomainCidrMapAssignmentArgsDict',
    'GetGtmDomainCidrMapDefaultDatacenterArgs',
    'GetGtmDomainCidrMapDefaultDatacenterArgsDict',
    'GetGtmDomainCidrMapLinkArgs',
    'GetGtmDomainCidrMapLinkArgsDict',
    'GetGtmDomainDatacenterArgs',
    'GetGtmDomainDatacenterArgsDict',
    'GetGtmDomainDatacenterDefaultLoadObjectArgs',
    'GetGtmDomainDatacenterDefaultLoadObjectArgsDict',
    'GetGtmDomainDatacenterLinkArgs',
    'GetGtmDomainDatacenterLinkArgsDict',
    'GetGtmDomainGeographicMapArgs',
    'GetGtmDomainGeographicMapArgsDict',
    'GetGtmDomainGeographicMapAssignmentArgs',
    'GetGtmDomainGeographicMapAssignmentArgsDict',
    'GetGtmDomainGeographicMapDefaultDatacenterArgs',
    'GetGtmDomainGeographicMapDefaultDatacenterArgsDict',
    'GetGtmDomainGeographicMapLinkArgs',
    'GetGtmDomainGeographicMapLinkArgsDict',
    'GetGtmDomainLinkArgs',
    'GetGtmDomainLinkArgsDict',
    'GetGtmDomainPropertyArgs',
    'GetGtmDomainPropertyArgsDict',
    'GetGtmDomainPropertyLinkArgs',
    'GetGtmDomainPropertyLinkArgsDict',
    'GetGtmDomainPropertyLivenessTestArgs',
    'GetGtmDomainPropertyLivenessTestArgsDict',
    'GetGtmDomainPropertyLivenessTestHttpHeaderArgs',
    'GetGtmDomainPropertyLivenessTestHttpHeaderArgsDict',
    'GetGtmDomainPropertyStaticRrSetArgs',
    'GetGtmDomainPropertyStaticRrSetArgsDict',
    'GetGtmDomainPropertyTrafficTargetArgs',
    'GetGtmDomainPropertyTrafficTargetArgsDict',
    'GetGtmDomainResourceArgs',
    'GetGtmDomainResourceArgsDict',
    'GetGtmDomainResourceLinkArgs',
    'GetGtmDomainResourceLinkArgsDict',
    'GetGtmDomainResourceResourceInstanceArgs',
    'GetGtmDomainResourceResourceInstanceArgsDict',
    'GetGtmDomainStatusArgs',
    'GetGtmDomainStatusArgsDict',
    'GetGtmDomainStatusLinkArgs',
    'GetGtmDomainStatusLinkArgsDict',
    'GetGtmDomainsDomainArgs',
    'GetGtmDomainsDomainArgsDict',
    'GetGtmDomainsDomainLinkArgs',
    'GetGtmDomainsDomainLinkArgsDict',
    'GetGtmResourceLinkArgs',
    'GetGtmResourceLinkArgsDict',
    'GetGtmResourceResourceInstanceArgs',
    'GetGtmResourceResourceInstanceArgsDict',
    'GetGtmResourcesResourceArgs',
    'GetGtmResourcesResourceArgsDict',
    'GetGtmResourcesResourceLinkArgs',
    'GetGtmResourcesResourceLinkArgsDict',
    'GetGtmResourcesResourceResourceInstanceArgs',
    'GetGtmResourcesResourceResourceInstanceArgsDict',
    'GetImagingPolicyImagePolicyArgs',
    'GetImagingPolicyImagePolicyArgsDict',
    'GetImagingPolicyImagePolicyBreakpointsArgs',
    'GetImagingPolicyImagePolicyBreakpointsArgsDict',
    'GetImagingPolicyImagePolicyOutputArgs',
    'GetImagingPolicyImagePolicyOutputArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgsDict',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs',
    'GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgsDict',
    'GetImagingPolicyImagePolicyTransformationArgs',
    'GetImagingPolicyImagePolicyTransformationArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendArgs',
    'GetImagingPolicyImagePolicyTransformationAppendArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendImageArgs',
    'GetImagingPolicyImagePolicyTransformationAppendImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs',
    'GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs',
    'GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs',
    'GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs',
    'GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationAspectCropArgs',
    'GetImagingPolicyImagePolicyTransformationAspectCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationBackgroundColorArgs',
    'GetImagingPolicyImagePolicyTransformationBackgroundColorArgsDict',
    'GetImagingPolicyImagePolicyTransformationBlurArgs',
    'GetImagingPolicyImagePolicyTransformationBlurArgsDict',
    'GetImagingPolicyImagePolicyTransformationChromaKeyArgs',
    'GetImagingPolicyImagePolicyTransformationChromaKeyArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeImageArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs',
    'GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgsDict',
    'GetImagingPolicyImagePolicyTransformationCompoundArgs',
    'GetImagingPolicyImagePolicyTransformationCompoundArgsDict',
    'GetImagingPolicyImagePolicyTransformationContrastArgs',
    'GetImagingPolicyImagePolicyTransformationContrastArgsDict',
    'GetImagingPolicyImagePolicyTransformationCropArgs',
    'GetImagingPolicyImagePolicyTransformationCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationFaceCropArgs',
    'GetImagingPolicyImagePolicyTransformationFaceCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationFeatureCropArgs',
    'GetImagingPolicyImagePolicyTransformationFeatureCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationFitAndFillArgs',
    'GetImagingPolicyImagePolicyTransformationFitAndFillArgsDict',
    'GetImagingPolicyImagePolicyTransformationGoopArgs',
    'GetImagingPolicyImagePolicyTransformationGoopArgsDict',
    'GetImagingPolicyImagePolicyTransformationGrayscaleArgs',
    'GetImagingPolicyImagePolicyTransformationGrayscaleArgsDict',
    'GetImagingPolicyImagePolicyTransformationHslArgs',
    'GetImagingPolicyImagePolicyTransformationHslArgsDict',
    'GetImagingPolicyImagePolicyTransformationHsvArgs',
    'GetImagingPolicyImagePolicyTransformationHsvArgsDict',
    'GetImagingPolicyImagePolicyTransformationIfDimensionArgs',
    'GetImagingPolicyImagePolicyTransformationIfDimensionArgsDict',
    'GetImagingPolicyImagePolicyTransformationIfOrientationArgs',
    'GetImagingPolicyImagePolicyTransformationIfOrientationArgsDict',
    'GetImagingPolicyImagePolicyTransformationImQueryArgs',
    'GetImagingPolicyImagePolicyTransformationImQueryArgsDict',
    'GetImagingPolicyImagePolicyTransformationMaxColorArgs',
    'GetImagingPolicyImagePolicyTransformationMaxColorArgsDict',
    'GetImagingPolicyImagePolicyTransformationMirrorArgs',
    'GetImagingPolicyImagePolicyTransformationMirrorArgsDict',
    'GetImagingPolicyImagePolicyTransformationMonoHueArgs',
    'GetImagingPolicyImagePolicyTransformationMonoHueArgsDict',
    'GetImagingPolicyImagePolicyTransformationOpacityArgs',
    'GetImagingPolicyImagePolicyTransformationOpacityArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgs',
    'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRelativeCropArgs',
    'GetImagingPolicyImagePolicyTransformationRelativeCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationRemoveColorArgs',
    'GetImagingPolicyImagePolicyTransformationRemoveColorArgsDict',
    'GetImagingPolicyImagePolicyTransformationResizeArgs',
    'GetImagingPolicyImagePolicyTransformationResizeArgsDict',
    'GetImagingPolicyImagePolicyTransformationRotateArgs',
    'GetImagingPolicyImagePolicyTransformationRotateArgsDict',
    'GetImagingPolicyImagePolicyTransformationScaleArgs',
    'GetImagingPolicyImagePolicyTransformationScaleArgsDict',
    'GetImagingPolicyImagePolicyTransformationShearsArgs',
    'GetImagingPolicyImagePolicyTransformationShearsArgsDict',
    'GetImagingPolicyImagePolicyTransformationSmartCropArgs',
    'GetImagingPolicyImagePolicyTransformationSmartCropArgsDict',
    'GetImagingPolicyImagePolicyTransformationTrimArgs',
    'GetImagingPolicyImagePolicyTransformationTrimArgsDict',
    'GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs',
    'GetImagingPolicyImagePolicyTransformationUnsharpMaskArgsDict',
    'GetImagingPolicyImagePolicyVariableArgs',
    'GetImagingPolicyImagePolicyVariableArgsDict',
    'GetImagingPolicyImagePolicyVariableEnumOptionArgs',
    'GetImagingPolicyImagePolicyVariableEnumOptionArgsDict',
    'GetImagingPolicyVideoPolicyArgs',
    'GetImagingPolicyVideoPolicyArgsDict',
    'GetImagingPolicyVideoPolicyBreakpointsArgs',
    'GetImagingPolicyVideoPolicyBreakpointsArgsDict',
    'GetImagingPolicyVideoPolicyOutputArgs',
    'GetImagingPolicyVideoPolicyOutputArgsDict',
    'GetImagingPolicyVideoPolicyVariableArgs',
    'GetImagingPolicyVideoPolicyVariableArgsDict',
    'GetImagingPolicyVideoPolicyVariableEnumOptionArgs',
    'GetImagingPolicyVideoPolicyVariableEnumOptionArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainArgs',
    'GetPropertyDomainownershipSearchDomainsDomainArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgsDict',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs',
    'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgsDict',
    'GetPropertyIncludesParentPropertyArgs',
    'GetPropertyIncludesParentPropertyArgsDict',
    'GetPropertyRulesTemplateTemplateArgs',
    'GetPropertyRulesTemplateTemplateArgsDict',
    'GetPropertyRulesTemplateVariableArgs',
    'GetPropertyRulesTemplateVariableArgsDict',
]

MYPY = False

if not MYPY:
    class AppSecIPGeoAsnControlsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action set for ASN Controls
        """
        asn_network_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IDs of ASN network list to be blocked.
        """
elif False:
    AppSecIPGeoAsnControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSecIPGeoAsnControlsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 asn_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action set for ASN Controls
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] asn_network_lists: List of IDs of ASN network list to be blocked.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if asn_network_lists is not None:
            pulumi.set(__self__, "asn_network_lists", asn_network_lists)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action set for ASN Controls
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="asnNetworkLists")
    def asn_network_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IDs of ASN network list to be blocked.
        """
        return pulumi.get(self, "asn_network_lists")

    @asn_network_lists.setter
    def asn_network_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "asn_network_lists", value)


if not MYPY:
    class AppSecIPGeoGeoControlsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action set for GEO Controls.
        """
        geo_network_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IDs of geographic network list to be blocked.
        """
elif False:
    AppSecIPGeoGeoControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSecIPGeoGeoControlsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 geo_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action set for GEO Controls.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] geo_network_lists: List of IDs of geographic network list to be blocked.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if geo_network_lists is not None:
            pulumi.set(__self__, "geo_network_lists", geo_network_lists)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action set for GEO Controls.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="geoNetworkLists")
    def geo_network_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IDs of geographic network list to be blocked.
        """
        return pulumi.get(self, "geo_network_lists")

    @geo_network_lists.setter
    def geo_network_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "geo_network_lists", value)


if not MYPY:
    class AppSecIPGeoIpControlsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action set for IP Controls.
        """
        ip_network_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IDs of IP network list to be blocked.
        """
elif False:
    AppSecIPGeoIpControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSecIPGeoIpControlsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Action set for IP Controls.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_network_lists: List of IDs of IP network list to be blocked.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if ip_network_lists is not None:
            pulumi.set(__self__, "ip_network_lists", ip_network_lists)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action set for IP Controls.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="ipNetworkLists")
    def ip_network_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IDs of IP network list to be blocked.
        """
        return pulumi.get(self, "ip_network_lists")

    @ip_network_lists.setter
    def ip_network_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_network_lists", value)


if not MYPY:
    class AppSecSiemSettingsExceptionsArgsDict(TypedDict):
        api_request_constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include api request constraints events in SIEM
        """
        apr_protections: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include apr protection events in SIEM
        """
        bot_managements: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include bot management events in SIEM
        """
        client_reps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include client reputation events in SIEM
        """
        custom_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include custom rules events in SIEM
        """
        ip_geos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include ip geo events in SIEM
        """
        malware_protections: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include malware protection events in SIEM
        """
        rates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include rate events in SIEM
        """
        slow_posts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include slow post events in SIEM
        """
        url_protections: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include url protection events in SIEM
        """
        wafs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Whether there should be an exception to include waf events in SIEM
        """
elif False:
    AppSecSiemSettingsExceptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSecSiemSettingsExceptionsArgs:
    def __init__(__self__, *,
                 api_request_constraints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apr_protections: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bot_managements: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 client_reps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ip_geos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 malware_protections: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slow_posts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 url_protections: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wafs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] api_request_constraints: Whether there should be an exception to include api request constraints events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] apr_protections: Whether there should be an exception to include apr protection events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bot_managements: Whether there should be an exception to include bot management events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] client_reps: Whether there should be an exception to include client reputation events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_rules: Whether there should be an exception to include custom rules events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_geos: Whether there should be an exception to include ip geo events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] malware_protections: Whether there should be an exception to include malware protection events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] rates: Whether there should be an exception to include rate events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] slow_posts: Whether there should be an exception to include slow post events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] url_protections: Whether there should be an exception to include url protection events in SIEM
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wafs: Whether there should be an exception to include waf events in SIEM
        """
        if api_request_constraints is not None:
            pulumi.set(__self__, "api_request_constraints", api_request_constraints)
        if apr_protections is not None:
            pulumi.set(__self__, "apr_protections", apr_protections)
        if bot_managements is not None:
            pulumi.set(__self__, "bot_managements", bot_managements)
        if client_reps is not None:
            pulumi.set(__self__, "client_reps", client_reps)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if ip_geos is not None:
            pulumi.set(__self__, "ip_geos", ip_geos)
        if malware_protections is not None:
            pulumi.set(__self__, "malware_protections", malware_protections)
        if rates is not None:
            pulumi.set(__self__, "rates", rates)
        if slow_posts is not None:
            pulumi.set(__self__, "slow_posts", slow_posts)
        if url_protections is not None:
            pulumi.set(__self__, "url_protections", url_protections)
        if wafs is not None:
            pulumi.set(__self__, "wafs", wafs)

    @_builtins.property
    @pulumi.getter(name="apiRequestConstraints")
    def api_request_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include api request constraints events in SIEM
        """
        return pulumi.get(self, "api_request_constraints")

    @api_request_constraints.setter
    def api_request_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "api_request_constraints", value)

    @_builtins.property
    @pulumi.getter(name="aprProtections")
    def apr_protections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include apr protection events in SIEM
        """
        return pulumi.get(self, "apr_protections")

    @apr_protections.setter
    def apr_protections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "apr_protections", value)

    @_builtins.property
    @pulumi.getter(name="botManagements")
    def bot_managements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include bot management events in SIEM
        """
        return pulumi.get(self, "bot_managements")

    @bot_managements.setter
    def bot_managements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bot_managements", value)

    @_builtins.property
    @pulumi.getter(name="clientReps")
    def client_reps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include client reputation events in SIEM
        """
        return pulumi.get(self, "client_reps")

    @client_reps.setter
    def client_reps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "client_reps", value)

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include custom rules events in SIEM
        """
        return pulumi.get(self, "custom_rules")

    @custom_rules.setter
    def custom_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_rules", value)

    @_builtins.property
    @pulumi.getter(name="ipGeos")
    def ip_geos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include ip geo events in SIEM
        """
        return pulumi.get(self, "ip_geos")

    @ip_geos.setter
    def ip_geos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_geos", value)

    @_builtins.property
    @pulumi.getter(name="malwareProtections")
    def malware_protections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include malware protection events in SIEM
        """
        return pulumi.get(self, "malware_protections")

    @malware_protections.setter
    def malware_protections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "malware_protections", value)

    @_builtins.property
    @pulumi.getter
    def rates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include rate events in SIEM
        """
        return pulumi.get(self, "rates")

    @rates.setter
    def rates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "rates", value)

    @_builtins.property
    @pulumi.getter(name="slowPosts")
    def slow_posts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include slow post events in SIEM
        """
        return pulumi.get(self, "slow_posts")

    @slow_posts.setter
    def slow_posts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "slow_posts", value)

    @_builtins.property
    @pulumi.getter(name="urlProtections")
    def url_protections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include url protection events in SIEM
        """
        return pulumi.get(self, "url_protections")

    @url_protections.setter
    def url_protections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "url_protections", value)

    @_builtins.property
    @pulumi.getter
    def wafs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Whether there should be an exception to include waf events in SIEM
        """
        return pulumi.get(self, "wafs")

    @wafs.setter
    def wafs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wafs", value)


if not MYPY:
    class AppsecAdvancedSettingsAsePenaltyBoxQualificationExclusionsArgsDict(TypedDict):
        attack_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of attack group names.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        List of rule IDs.
        """
elif False:
    AppsecAdvancedSettingsAsePenaltyBoxQualificationExclusionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppsecAdvancedSettingsAsePenaltyBoxQualificationExclusionsArgs:
    def __init__(__self__, *,
                 attack_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attack_groups: List of attack group names.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] rules: List of rule IDs.
        """
        if attack_groups is not None:
            pulumi.set(__self__, "attack_groups", attack_groups)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="attackGroups")
    def attack_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of attack group names.
        """
        return pulumi.get(self, "attack_groups")

    @attack_groups.setter
    def attack_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attack_groups", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        List of rule IDs.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ClientlistListItemArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the item.
        """
        expiration_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The item expiration date.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The item tags.
        """
elif False:
    ClientlistListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientlistListItemArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] value: Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
        :param pulumi.Input[_builtins.str] description: A description of the item.
        :param pulumi.Input[_builtins.str] expiration_date: The item expiration date.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: The item tags.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the item. (i.e. IP address, AS Number, GEO, ...etc)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the item.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The item expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The item tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CloudAccessKeyCredentialsAArgsDict(TypedDict):
        cloud_access_key_id: pulumi.Input[_builtins.str]
        """
        Access key id from cloud provider which is used to sign API requests
        """
        cloud_secret_access_key: pulumi.Input[_builtins.str]
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        primary_key: pulumi.Input[_builtins.bool]
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        version_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier assigned to specific access key version
        """
elif False:
    CloudAccessKeyCredentialsAArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessKeyCredentialsAArgs:
    def __init__(__self__, *,
                 cloud_access_key_id: pulumi.Input[_builtins.str],
                 cloud_secret_access_key: pulumi.Input[_builtins.str],
                 primary_key: pulumi.Input[_builtins.bool],
                 version: Optional[pulumi.Input[_builtins.int]] = None,
                 version_guid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_access_key_id: Access key id from cloud provider which is used to sign API requests
        :param pulumi.Input[_builtins.str] cloud_secret_access_key: Cloud Access secret from cloud provider which is used to sign API requests
        :param pulumi.Input[_builtins.bool] primary_key: Boolean value which helps to define if credentials should be assigned to property
        :param pulumi.Input[_builtins.int] version: Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        :param pulumi.Input[_builtins.str] version_guid: The unique identifier assigned to specific access key version
        """
        pulumi.set(__self__, "cloud_access_key_id", cloud_access_key_id)
        pulumi.set(__self__, "cloud_secret_access_key", cloud_secret_access_key)
        pulumi.set(__self__, "primary_key", primary_key)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="cloudAccessKeyId")
    def cloud_access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        Access key id from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_access_key_id")

    @cloud_access_key_id.setter
    def cloud_access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="cloudSecretAccessKey")
    def cloud_secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_secret_access_key")

    @cloud_secret_access_key.setter
    def cloud_secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "primary_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier assigned to specific access key version
        """
        return pulumi.get(self, "version_guid")

    @version_guid.setter
    def version_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_guid", value)


if not MYPY:
    class CloudAccessKeyCredentialsBArgsDict(TypedDict):
        cloud_access_key_id: pulumi.Input[_builtins.str]
        """
        Access key id from cloud provider which is used to sign API requests
        """
        cloud_secret_access_key: pulumi.Input[_builtins.str]
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        primary_key: pulumi.Input[_builtins.bool]
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        version_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier assigned to specific access key version
        """
elif False:
    CloudAccessKeyCredentialsBArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessKeyCredentialsBArgs:
    def __init__(__self__, *,
                 cloud_access_key_id: pulumi.Input[_builtins.str],
                 cloud_secret_access_key: pulumi.Input[_builtins.str],
                 primary_key: pulumi.Input[_builtins.bool],
                 version: Optional[pulumi.Input[_builtins.int]] = None,
                 version_guid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_access_key_id: Access key id from cloud provider which is used to sign API requests
        :param pulumi.Input[_builtins.str] cloud_secret_access_key: Cloud Access secret from cloud provider which is used to sign API requests
        :param pulumi.Input[_builtins.bool] primary_key: Boolean value which helps to define if credentials should be assigned to property
        :param pulumi.Input[_builtins.int] version: Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        :param pulumi.Input[_builtins.str] version_guid: The unique identifier assigned to specific access key version
        """
        pulumi.set(__self__, "cloud_access_key_id", cloud_access_key_id)
        pulumi.set(__self__, "cloud_secret_access_key", cloud_secret_access_key)
        pulumi.set(__self__, "primary_key", primary_key)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="cloudAccessKeyId")
    def cloud_access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        Access key id from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_access_key_id")

    @cloud_access_key_id.setter
    def cloud_access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="cloudSecretAccessKey")
    def cloud_secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Cloud Access secret from cloud provider which is used to sign API requests
        """
        return pulumi.get(self, "cloud_secret_access_key")

    @cloud_secret_access_key.setter
    def cloud_secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean value which helps to define if credentials should be assigned to property
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "primary_key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Numeric access key version associated with specific pair of cloud access credentials used to sign API requests
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier assigned to specific access key version
        """
        return pulumi.get(self, "version_guid")

    @version_guid.setter
    def version_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_guid", value)


if not MYPY:
    class CloudAccessKeyNetworkConfigurationArgsDict(TypedDict):
        security_network: pulumi.Input[_builtins.str]
        """
        The API deploys the access key to this secure network
        """
        additional_cdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional type of the deployment network that the access key will be deployed to.
        """
elif False:
    CloudAccessKeyNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessKeyNetworkConfigurationArgs:
    def __init__(__self__, *,
                 security_network: pulumi.Input[_builtins.str],
                 additional_cdn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] security_network: The API deploys the access key to this secure network
        :param pulumi.Input[_builtins.str] additional_cdn: Additional type of the deployment network that the access key will be deployed to.
        """
        pulumi.set(__self__, "security_network", security_network)
        if additional_cdn is not None:
            pulumi.set(__self__, "additional_cdn", additional_cdn)

    @_builtins.property
    @pulumi.getter(name="securityNetwork")
    def security_network(self) -> pulumi.Input[_builtins.str]:
        """
        The API deploys the access key to this secure network
        """
        return pulumi.get(self, "security_network")

    @security_network.setter
    def security_network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "security_network", value)

    @_builtins.property
    @pulumi.getter(name="additionalCdn")
    def additional_cdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional type of the deployment network that the access key will be deployed to.
        """
        return pulumi.get(self, "additional_cdn")

    @additional_cdn.setter
    def additional_cdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_cdn", value)


if not MYPY:
    class CloudAccessKeyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
        """
elif False:
    CloudAccessKeyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccessKeyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
        :param pulumi.Input[_builtins.str] delete: Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
        :param pulumi.Input[_builtins.str] update: Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource create timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource delete timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource update timeout. By default it's 60 minutes with 1 minute polling interval.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CloudcertificatesCertificateSubjectArgsDict(TypedDict):
        common_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fully qualified domain name (FQDN) or other name associated with the subject. If specified, this value must also be included in the SANs list.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        Two-letter ISO 3166 country code.
        """
        locality: NotRequired[pulumi.Input[_builtins.str]]
        """
        City or locality name.
        """
        organization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Legal name of the organization.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full name of the state or province.
        """
elif False:
    CloudcertificatesCertificateSubjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudcertificatesCertificateSubjectArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 locality: Optional[pulumi.Input[_builtins.str]] = None,
                 organization: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] common_name: Fully qualified domain name (FQDN) or other name associated with the subject. If specified, this value must also be included in the SANs list.
        :param pulumi.Input[_builtins.str] country: Two-letter ISO 3166 country code.
        :param pulumi.Input[_builtins.str] locality: City or locality name.
        :param pulumi.Input[_builtins.str] organization: Legal name of the organization.
        :param pulumi.Input[_builtins.str] state: Full name of the state or province.
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fully qualified domain name (FQDN) or other name associated with the subject. If specified, this value must also be included in the SANs list.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Two-letter ISO 3166 country code.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City or locality name.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locality", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Legal name of the organization.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full name of the state or province.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CloudletsApplicationLoadBalancerActivationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CloudletsApplicationLoadBalancerActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudletsApplicationLoadBalancerActivationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CloudletsApplicationLoadBalancerDataCenterArgsDict(TypedDict):
        continent: pulumi.Input[_builtins.str]
        """
        The continent on which the data center is located
        """
        country: pulumi.Input[_builtins.str]
        """
        The country in which the data center is located
        """
        latitude: pulumi.Input[_builtins.float]
        """
        The latitude value for the data center. This member supports six decimal places of precision.
        """
        longitude: pulumi.Input[_builtins.float]
        """
        The longitude value for the data center. This member supports six decimal places of precision.
        """
        origin_id: pulumi.Input[_builtins.str]
        """
        The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        """
        percent: pulumi.Input[_builtins.float]
        """
        The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        The city in which the data center is located.
        """
        cloud_server_host_header_override: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Describes if cloud server host header is overridden
        """
        cloud_service: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Describes if this datacenter is a cloud service
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        This should match the 'hostname' value defined for this datacenter in Property Manager
        """
        liveness_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        """
        state_or_province: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state, province, or region where the data center is located
        """
elif False:
    CloudletsApplicationLoadBalancerDataCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudletsApplicationLoadBalancerDataCenterArgs:
    def __init__(__self__, *,
                 continent: pulumi.Input[_builtins.str],
                 country: pulumi.Input[_builtins.str],
                 latitude: pulumi.Input[_builtins.float],
                 longitude: pulumi.Input[_builtins.float],
                 origin_id: pulumi.Input[_builtins.str],
                 percent: pulumi.Input[_builtins.float],
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_server_host_header_override: Optional[pulumi.Input[_builtins.bool]] = None,
                 cloud_service: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 liveness_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 state_or_province: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] continent: The continent on which the data center is located
        :param pulumi.Input[_builtins.str] country: The country in which the data center is located
        :param pulumi.Input[_builtins.float] latitude: The latitude value for the data center. This member supports six decimal places of precision.
        :param pulumi.Input[_builtins.float] longitude: The longitude value for the data center. This member supports six decimal places of precision.
        :param pulumi.Input[_builtins.str] origin_id: The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        :param pulumi.Input[_builtins.float] percent: The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        :param pulumi.Input[_builtins.str] city: The city in which the data center is located.
        :param pulumi.Input[_builtins.bool] cloud_server_host_header_override: Describes if cloud server host header is overridden
        :param pulumi.Input[_builtins.bool] cloud_service: Describes if this datacenter is a cloud service
        :param pulumi.Input[_builtins.str] hostname: This should match the 'hostname' value defined for this datacenter in Property Manager
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] liveness_hosts: An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        :param pulumi.Input[_builtins.str] state_or_province: The state, province, or region where the data center is located
        """
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if cloud_server_host_header_override is not None:
            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        if cloud_service is not None:
            pulumi.set(__self__, "cloud_service", cloud_service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if liveness_hosts is not None:
            pulumi.set(__self__, "liveness_hosts", liveness_hosts)
        if state_or_province is not None:
            pulumi.set(__self__, "state_or_province", state_or_province)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> pulumi.Input[_builtins.str]:
        """
        The continent on which the data center is located
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "continent", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> pulumi.Input[_builtins.str]:
        """
        The country in which the data center is located
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[_builtins.float]:
        """
        The latitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[_builtins.float]:
        """
        The longitude value for the data center. This member supports six decimal places of precision.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "longitude", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> pulumi.Input[_builtins.float]:
        """
        The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "percent", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The city in which the data center is located.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Describes if cloud server host header is overridden
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @cloud_server_host_header_override.setter
    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloud_server_host_header_override", value)

    @_builtins.property
    @pulumi.getter(name="cloudService")
    def cloud_service(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Describes if this datacenter is a cloud service
        """
        return pulumi.get(self, "cloud_service")

    @cloud_service.setter
    def cloud_service(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloud_service", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This should match the 'hostname' value defined for this datacenter in Property Manager
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="livenessHosts")
    def liveness_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
        """
        return pulumi.get(self, "liveness_hosts")

    @liveness_hosts.setter
    def liveness_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "liveness_hosts", value)

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state, province, or region where the data center is located
        """
        return pulumi.get(self, "state_or_province")

    @state_or_province.setter
    def state_or_province(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state_or_province", value)


if not MYPY:
    class CloudletsApplicationLoadBalancerLivenessSettingsArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The protocol or scheme for the database, either HTTP or HTTPS.
        """
        additional_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps additional case-insensitive HTTP header names included to the liveness testing requests
        """
        host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Host header for the liveness HTTP request
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        """
        peer_certificate_verification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Describes whether or not to validate the origin certificate for an HTTPS request
        """
        request_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request which will be used for TCP(S) tests
        """
        response_string: NotRequired[pulumi.Input[_builtins.str]]
        status3xx_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        """
        status4xx_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        """
        status5xx_failure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        """
        timeout: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
elif False:
    CloudletsApplicationLoadBalancerLivenessSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudletsApplicationLoadBalancerLivenessSettingsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 additional_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 peer_certificate_verification: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_string: Optional[pulumi.Input[_builtins.str]] = None,
                 response_string: Optional[pulumi.Input[_builtins.str]] = None,
                 status3xx_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 status4xx_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 status5xx_failure: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] path: The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        :param pulumi.Input[_builtins.int] port: The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        :param pulumi.Input[_builtins.str] protocol: The protocol or scheme for the database, either HTTP or HTTPS.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] additional_headers: Maps additional case-insensitive HTTP header names included to the liveness testing requests
        :param pulumi.Input[_builtins.str] host_header: The Host header for the liveness HTTP request
        :param pulumi.Input[_builtins.int] interval: Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        :param pulumi.Input[_builtins.bool] peer_certificate_verification: Describes whether or not to validate the origin certificate for an HTTPS request
        :param pulumi.Input[_builtins.str] request_string: The request which will be used for TCP(S) tests
        :param pulumi.Input[_builtins.bool] status3xx_failure: Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        :param pulumi.Input[_builtins.bool] status4xx_failure: Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        :param pulumi.Input[_builtins.bool] status5xx_failure: Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        :param pulumi.Input[_builtins.float] timeout: The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if status3xx_failure is not None:
            pulumi.set(__self__, "status3xx_failure", status3xx_failure)
        if status4xx_failure is not None:
            pulumi.set(__self__, "status4xx_failure", status4xx_failure)
        if status5xx_failure is not None:
            pulumi.set(__self__, "status5xx_failure", status5xx_failure)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol or scheme for the database, either HTTP or HTTPS.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps additional case-insensitive HTTP header names included to the liveness testing requests
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_headers", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Host header for the liveness HTTP request
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Describes whether or not to validate the origin certificate for an HTTPS request
        """
        return pulumi.get(self, "peer_certificate_verification")

    @peer_certificate_verification.setter
    def peer_certificate_verification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "peer_certificate_verification", value)

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request which will be used for TCP(S) tests
        """
        return pulumi.get(self, "request_string")

    @request_string.setter
    def request_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_string", value)

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_string")

    @response_string.setter
    def response_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_string", value)

    @_builtins.property
    @pulumi.getter(name="status3xxFailure")
    def status3xx_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
        """
        return pulumi.get(self, "status3xx_failure")

    @status3xx_failure.setter
    def status3xx_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "status3xx_failure", value)

    @_builtins.property
    @pulumi.getter(name="status4xxFailure")
    def status4xx_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
        """
        return pulumi.get(self, "status4xx_failure")

    @status4xx_failure.setter
    def status4xx_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "status4xx_failure", value)

    @_builtins.property
    @pulumi.getter(name="status5xxFailure")
    def status5xx_failure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
        """
        return pulumi.get(self, "status5xx_failure")

    @status5xx_failure.setter
    def status5xx_failure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "status5xx_failure", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class CloudletsPolicyActivationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CloudletsPolicyActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudletsPolicyActivationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CloudletsPolicyTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CloudletsPolicyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudletsPolicyTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CloudwrapperActivationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
        """
elif False:
    CloudwrapperActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwrapperActivationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
        :param pulumi.Input[_builtins.str] update: Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable activation timeout to be used on resource create. By default it's 4h with 1m pooling interval.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable activation timeout to be used on resource update. By default it's 4h with 1m pooling interval.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CloudwrapperConfigurationLocationArgsDict(TypedDict):
        comments: pulumi.Input[_builtins.str]
        """
        Additional comments provided by the user.
        """
        traffic_type_id: pulumi.Input[_builtins.int]
        """
        Unique identifier for the location and traffic type combination
        """
        capacity: NotRequired[pulumi.Input['CloudwrapperConfigurationLocationCapacityArgsDict']]
        """
        The capacity assigned to this configuration's location
        """
elif False:
    CloudwrapperConfigurationLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwrapperConfigurationLocationArgs:
    def __init__(__self__, *,
                 comments: pulumi.Input[_builtins.str],
                 traffic_type_id: pulumi.Input[_builtins.int],
                 capacity: Optional[pulumi.Input['CloudwrapperConfigurationLocationCapacityArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] comments: Additional comments provided by the user.
        :param pulumi.Input[_builtins.int] traffic_type_id: Unique identifier for the location and traffic type combination
        :param pulumi.Input['CloudwrapperConfigurationLocationCapacityArgs'] capacity: The capacity assigned to this configuration's location
        """
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> pulumi.Input[_builtins.str]:
        """
        Additional comments provided by the user.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> pulumi.Input[_builtins.int]:
        """
        Unique identifier for the location and traffic type combination
        """
        return pulumi.get(self, "traffic_type_id")

    @traffic_type_id.setter
    def traffic_type_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "traffic_type_id", value)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input['CloudwrapperConfigurationLocationCapacityArgs']]:
        """
        The capacity assigned to this configuration's location
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input['CloudwrapperConfigurationLocationCapacityArgs']]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class CloudwrapperConfigurationLocationCapacityArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        """
        Unit of capacity. Can be either 'GB' or 'TB'.
        """
        value: pulumi.Input[_builtins.int]
        """
        Value of capacity.
        """
elif False:
    CloudwrapperConfigurationLocationCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwrapperConfigurationLocationCapacityArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] unit: Unit of capacity. Can be either 'GB' or 'TB'.
        :param pulumi.Input[_builtins.int] value: Value of capacity.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        Unit of capacity. Can be either 'GB' or 'TB'.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Value of capacity.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CloudwrapperConfigurationTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    CloudwrapperConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwrapperConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class CpCodeTimeoutsArgsDict(TypedDict):
        update: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CpCodeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpCodeTimeoutsArgs:
    def __init__(__self__, *,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CpsDvEnrollmentAdminContactArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        E-mail address of the contact
        """
        first_name: pulumi.Input[_builtins.str]
        """
        First name of the contact
        """
        last_name: pulumi.Input[_builtins.str]
        """
        Last name of the contact
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of the contact
        """
        address_line_one: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City of residence of the contact
        """
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Country code of the contact
        """
        organization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization where contact is hired
        """
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Postal code of the contact
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the contact
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Title of the the contact
        """
elif False:
    CpsDvEnrollmentAdminContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentAdminContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 address_line_one: Optional[pulumi.Input[_builtins.str]] = None,
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 organization: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: E-mail address of the contact
        :param pulumi.Input[_builtins.str] first_name: First name of the contact
        :param pulumi.Input[_builtins.str] last_name: Last name of the contact
        :param pulumi.Input[_builtins.str] phone: Phone number of the contact
        :param pulumi.Input[_builtins.str] address_line_one: The address of the contact
        :param pulumi.Input[_builtins.str] address_line_two: The address of the contact
        :param pulumi.Input[_builtins.str] city: City of residence of the contact
        :param pulumi.Input[_builtins.str] country_code: Country code of the contact
        :param pulumi.Input[_builtins.str] organization: Organization where contact is hired
        :param pulumi.Input[_builtins.str] postal_code: Postal code of the contact
        :param pulumi.Input[_builtins.str] region: The region of the contact
        :param pulumi.Input[_builtins.str] title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class CpsDvEnrollmentCsrArgsDict(TypedDict):
        city: pulumi.Input[_builtins.str]
        """
        City where organization is located
        """
        country_code: pulumi.Input[_builtins.str]
        """
        The code of the country where organization is located
        """
        organization: pulumi.Input[_builtins.str]
        """
        Name of organization used in all legal documents
        """
        organizational_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organizational unit of organization
        """
        preferred_trust_chain: NotRequired[pulumi.Input[_builtins.str]]
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        State or province of organization location
        """
elif False:
    CpsDvEnrollmentCsrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentCsrArgs:
    def __init__(__self__, *,
                 city: pulumi.Input[_builtins.str],
                 country_code: pulumi.Input[_builtins.str],
                 organization: pulumi.Input[_builtins.str],
                 organizational_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred_trust_chain: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] city: City where organization is located
        :param pulumi.Input[_builtins.str] country_code: The code of the country where organization is located
        :param pulumi.Input[_builtins.str] organization: Name of organization used in all legal documents
        :param pulumi.Input[_builtins.str] organizational_unit: Organizational unit of organization
        :param pulumi.Input[_builtins.str] preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param pulumi.Input[_builtins.str] state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if preferred_trust_chain is not None:
            pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> pulumi.Input[_builtins.str]:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> pulumi.Input[_builtins.str]:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organizational_unit", value)

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @preferred_trust_chain.setter
    def preferred_trust_chain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_trust_chain", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CpsDvEnrollmentDnsChallengeArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain for which the challenges were completed
        """
        full_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name where Akamai publishes the response body to validate
        """
        response_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique content of the challenge
        """
elif False:
    CpsDvEnrollmentDnsChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentDnsChallengeArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 full_path: Optional[pulumi.Input[_builtins.str]] = None,
                 response_body: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: Domain for which the challenges were completed
        :param pulumi.Input[_builtins.str] full_path: The domain name where Akamai publishes the response body to validate
        :param pulumi.Input[_builtins.str] response_body: The unique content of the challenge
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @full_path.setter
    def full_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_path", value)

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")

    @response_body.setter
    def response_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_body", value)


if not MYPY:
    class CpsDvEnrollmentHttpChallengeArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain for which the challenges were completed
        """
        full_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where Akamai publishes the response body to validate
        """
        response_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique content of the challenge
        """
elif False:
    CpsDvEnrollmentHttpChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentHttpChallengeArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 full_path: Optional[pulumi.Input[_builtins.str]] = None,
                 response_body: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: Domain for which the challenges were completed
        :param pulumi.Input[_builtins.str] full_path: The URL where Akamai publishes the response body to validate
        :param pulumi.Input[_builtins.str] response_body: The unique content of the challenge
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if full_path is not None:
            pulumi.set(__self__, "full_path", full_path)
        if response_body is not None:
            pulumi.set(__self__, "response_body", response_body)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain for which the challenges were completed
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where Akamai publishes the response body to validate
        """
        return pulumi.get(self, "full_path")

    @full_path.setter
    def full_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_path", value)

    @_builtins.property
    @pulumi.getter(name="responseBody")
    def response_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique content of the challenge
        """
        return pulumi.get(self, "response_body")

    @response_body.setter
    def response_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_body", value)


if not MYPY:
    class CpsDvEnrollmentNetworkConfigurationArgsDict(TypedDict):
        geography: pulumi.Input[_builtins.str]
        """
        Geography type used for enrollment
        """
        client_mutual_authentication: NotRequired[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict']]
        """
        The trust chain configuration used for client mutual authentication
        """
        clone_dns_names: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        disallowed_tls_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TLS versions which are disallowed
        """
        must_have_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        ocsp_stapling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable OCSP stapling. Default is 'on'
        """
        preferred_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        quic_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable QUIC protocol. Default is false
        """
elif False:
    CpsDvEnrollmentNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentNetworkConfigurationArgs:
    def __init__(__self__, *,
                 geography: pulumi.Input[_builtins.str],
                 client_mutual_authentication: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']] = None,
                 clone_dns_names: Optional[pulumi.Input[_builtins.bool]] = None,
                 disallowed_tls_versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 must_have_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_stapling: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 quic_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] geography: Geography type used for enrollment
        :param pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs'] client_mutual_authentication: The trust chain configuration used for client mutual authentication
        :param pulumi.Input[_builtins.bool] clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] disallowed_tls_versions: TLS versions which are disallowed
        :param pulumi.Input[_builtins.str] must_have_ciphers: Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param pulumi.Input[_builtins.str] ocsp_stapling: Enable OCSP stapling. Default is 'on'
        :param pulumi.Input[_builtins.str] preferred_ciphers: Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param pulumi.Input[_builtins.bool] quic_enabled: Enable QUIC protocol. Default is false
        """
        pulumi.set(__self__, "geography", geography)
        if client_mutual_authentication is not None:
            pulumi.set(__self__, "client_mutual_authentication", client_mutual_authentication)
        if clone_dns_names is not None:
            pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        if disallowed_tls_versions is not None:
            pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        if must_have_ciphers is not None:
            pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        if ocsp_stapling is not None:
            pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        if preferred_ciphers is not None:
            pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        if quic_enabled is not None:
            pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter
    def geography(self) -> pulumi.Input[_builtins.str]:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @geography.setter
    def geography(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "geography", value)

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentication")
    def client_mutual_authentication(self) -> Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentication")

    @client_mutual_authentication.setter
    def client_mutual_authentication(self, value: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]):
        pulumi.set(self, "client_mutual_authentication", value)

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        return pulumi.get(self, "clone_dns_names")

    @clone_dns_names.setter
    def clone_dns_names(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clone_dns_names", value)

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @disallowed_tls_versions.setter
    def disallowed_tls_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "disallowed_tls_versions", value)

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "must_have_ciphers")

    @must_have_ciphers.setter
    def must_have_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "must_have_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable OCSP stapling. Default is 'on'
        """
        return pulumi.get(self, "ocsp_stapling")

    @ocsp_stapling.setter
    def ocsp_stapling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_stapling", value)

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "preferred_ciphers")

    @preferred_ciphers.setter
    def preferred_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable QUIC protocol. Default is false
        """
        return pulumi.get(self, "quic_enabled")

    @quic_enabled.setter
    def quic_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "quic_enabled", value)


if not MYPY:
    class CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict(TypedDict):
        ocsp_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable OCSP stapling
        """
        send_ca_list_to_client: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
elif False:
    CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentNetworkConfigurationClientMutualAuthenticationArgs:
    def __init__(__self__, *,
                 ocsp_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_ca_list_to_client: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] ocsp_enabled: Enable OCSP stapling
        :param pulumi.Input[_builtins.bool] send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param pulumi.Input[_builtins.str] set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        if ocsp_enabled is not None:
            pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        if send_ca_list_to_client is not None:
            pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        if set_id is not None:
            pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @ocsp_enabled.setter
    def ocsp_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ocsp_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @send_ca_list_to_client.setter
    def send_ca_list_to_client(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_ca_list_to_client", value)

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")

    @set_id.setter
    def set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "set_id", value)


if not MYPY:
    class CpsDvEnrollmentOrganizationArgsDict(TypedDict):
        address_line_one: pulumi.Input[_builtins.str]
        """
        The address of organization
        """
        city: pulumi.Input[_builtins.str]
        """
        City of organization
        """
        country_code: pulumi.Input[_builtins.str]
        """
        Country code of organization
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of organization
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of organization
        """
        postal_code: pulumi.Input[_builtins.str]
        """
        Postal code of organization
        """
        region: pulumi.Input[_builtins.str]
        """
        The region of organization
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of organization
        """
elif False:
    CpsDvEnrollmentOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentOrganizationArgs:
    def __init__(__self__, *,
                 address_line_one: pulumi.Input[_builtins.str],
                 city: pulumi.Input[_builtins.str],
                 country_code: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 postal_code: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address_line_one: The address of organization
        :param pulumi.Input[_builtins.str] city: City of organization
        :param pulumi.Input[_builtins.str] country_code: Country code of organization
        :param pulumi.Input[_builtins.str] name: Name of organization
        :param pulumi.Input[_builtins.str] phone: Phone number of organization
        :param pulumi.Input[_builtins.str] postal_code: Postal code of organization
        :param pulumi.Input[_builtins.str] region: The region of organization
        :param pulumi.Input[_builtins.str] address_line_two: The address of organization
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> pulumi.Input[_builtins.str]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> pulumi.Input[_builtins.str]:
        """
        City of organization
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        Country code of organization
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of organization
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> pulumi.Input[_builtins.str]:
        """
        Postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The region of organization
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)


if not MYPY:
    class CpsDvEnrollmentTechContactArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        E-mail address of the contact
        """
        first_name: pulumi.Input[_builtins.str]
        """
        First name of the contact
        """
        last_name: pulumi.Input[_builtins.str]
        """
        Last name of the contact
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of the contact
        """
        address_line_one: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City of residence of the contact
        """
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Country code of the contact
        """
        organization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization where contact is hired
        """
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Postal code of the contact
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the contact
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Title of the the contact
        """
elif False:
    CpsDvEnrollmentTechContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentTechContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 address_line_one: Optional[pulumi.Input[_builtins.str]] = None,
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 organization: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: E-mail address of the contact
        :param pulumi.Input[_builtins.str] first_name: First name of the contact
        :param pulumi.Input[_builtins.str] last_name: Last name of the contact
        :param pulumi.Input[_builtins.str] phone: Phone number of the contact
        :param pulumi.Input[_builtins.str] address_line_one: The address of the contact
        :param pulumi.Input[_builtins.str] address_line_two: The address of the contact
        :param pulumi.Input[_builtins.str] city: City of residence of the contact
        :param pulumi.Input[_builtins.str] country_code: Country code of the contact
        :param pulumi.Input[_builtins.str] organization: Organization where contact is hired
        :param pulumi.Input[_builtins.str] postal_code: Postal code of the contact
        :param pulumi.Input[_builtins.str] region: The region of the contact
        :param pulumi.Input[_builtins.str] title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class CpsDvEnrollmentTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CpsDvEnrollmentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvEnrollmentTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CpsDvValidationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CpsDvValidationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsDvValidationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CpsThirdPartyEnrollmentAdminContactArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        E-mail address of the contact
        """
        first_name: pulumi.Input[_builtins.str]
        """
        First name of the contact
        """
        last_name: pulumi.Input[_builtins.str]
        """
        Last name of the contact
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of the contact
        """
        address_line_one: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City of residence of the contact
        """
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Country code of the contact
        """
        organization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization where contact is hired
        """
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Postal code of the contact
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the contact
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Title of the the contact
        """
elif False:
    CpsThirdPartyEnrollmentAdminContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentAdminContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 address_line_one: Optional[pulumi.Input[_builtins.str]] = None,
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 organization: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: E-mail address of the contact
        :param pulumi.Input[_builtins.str] first_name: First name of the contact
        :param pulumi.Input[_builtins.str] last_name: Last name of the contact
        :param pulumi.Input[_builtins.str] phone: Phone number of the contact
        :param pulumi.Input[_builtins.str] address_line_one: The address of the contact
        :param pulumi.Input[_builtins.str] address_line_two: The address of the contact
        :param pulumi.Input[_builtins.str] city: City of residence of the contact
        :param pulumi.Input[_builtins.str] country_code: Country code of the contact
        :param pulumi.Input[_builtins.str] organization: Organization where contact is hired
        :param pulumi.Input[_builtins.str] postal_code: Postal code of the contact
        :param pulumi.Input[_builtins.str] region: The region of the contact
        :param pulumi.Input[_builtins.str] title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class CpsThirdPartyEnrollmentCsrArgsDict(TypedDict):
        city: pulumi.Input[_builtins.str]
        """
        City where organization is located
        """
        country_code: pulumi.Input[_builtins.str]
        """
        The code of the country where organization is located
        """
        organization: pulumi.Input[_builtins.str]
        """
        Name of organization used in all legal documents
        """
        organizational_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organizational unit of organization
        """
        preferred_trust_chain: NotRequired[pulumi.Input[_builtins.str]]
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        State or province of organization location
        """
elif False:
    CpsThirdPartyEnrollmentCsrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentCsrArgs:
    def __init__(__self__, *,
                 city: pulumi.Input[_builtins.str],
                 country_code: pulumi.Input[_builtins.str],
                 organization: pulumi.Input[_builtins.str],
                 organizational_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred_trust_chain: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] city: City where organization is located
        :param pulumi.Input[_builtins.str] country_code: The code of the country where organization is located
        :param pulumi.Input[_builtins.str] organization: Name of organization used in all legal documents
        :param pulumi.Input[_builtins.str] organizational_unit: Organizational unit of organization
        :param pulumi.Input[_builtins.str] preferred_trust_chain: For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        :param pulumi.Input[_builtins.str] state: State or province of organization location
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if preferred_trust_chain is not None:
            pulumi.set(__self__, "preferred_trust_chain", preferred_trust_chain)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> pulumi.Input[_builtins.str]:
        """
        City where organization is located
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The code of the country where organization is located
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> pulumi.Input[_builtins.str]:
        """
        Name of organization used in all legal documents
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organizational unit of organization
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organizational_unit", value)

    @_builtins.property
    @pulumi.getter(name="preferredTrustChain")
    def preferred_trust_chain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For the Let's Encrypt Domain Validated (DV) SAN certificates, the preferred trust chain will be included by CPS with the leaf certificate in the TLS handshake. If the field does not have a value, whichever trust chain Akamai chooses will be used by default
        """
        return pulumi.get(self, "preferred_trust_chain")

    @preferred_trust_chain.setter
    def preferred_trust_chain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_trust_chain", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State or province of organization location
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CpsThirdPartyEnrollmentNetworkConfigurationArgsDict(TypedDict):
        geography: pulumi.Input[_builtins.str]
        """
        Geography type used for enrollment
        """
        client_mutual_authentication: NotRequired[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict']]
        """
        The trust chain configuration used for client mutual authentication
        """
        clone_dns_names: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        disallowed_tls_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TLS versions which are disallowed
        """
        must_have_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        ocsp_stapling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enable OCSP stapling. Default is 'on'
        """
        preferred_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        quic_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable QUIC protocol. Default is false
        """
elif False:
    CpsThirdPartyEnrollmentNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentNetworkConfigurationArgs:
    def __init__(__self__, *,
                 geography: pulumi.Input[_builtins.str],
                 client_mutual_authentication: Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']] = None,
                 clone_dns_names: Optional[pulumi.Input[_builtins.bool]] = None,
                 disallowed_tls_versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 must_have_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_stapling: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 quic_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] geography: Geography type used for enrollment
        :param pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs'] client_mutual_authentication: The trust chain configuration used for client mutual authentication
        :param pulumi.Input[_builtins.bool] clone_dns_names: Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] disallowed_tls_versions: TLS versions which are disallowed
        :param pulumi.Input[_builtins.str] must_have_ciphers: Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param pulumi.Input[_builtins.str] ocsp_stapling: Enable OCSP stapling. Default is 'on'
        :param pulumi.Input[_builtins.str] preferred_ciphers: Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        :param pulumi.Input[_builtins.bool] quic_enabled: Enable QUIC protocol. Default is false
        """
        pulumi.set(__self__, "geography", geography)
        if client_mutual_authentication is not None:
            pulumi.set(__self__, "client_mutual_authentication", client_mutual_authentication)
        if clone_dns_names is not None:
            pulumi.set(__self__, "clone_dns_names", clone_dns_names)
        if disallowed_tls_versions is not None:
            pulumi.set(__self__, "disallowed_tls_versions", disallowed_tls_versions)
        if must_have_ciphers is not None:
            pulumi.set(__self__, "must_have_ciphers", must_have_ciphers)
        if ocsp_stapling is not None:
            pulumi.set(__self__, "ocsp_stapling", ocsp_stapling)
        if preferred_ciphers is not None:
            pulumi.set(__self__, "preferred_ciphers", preferred_ciphers)
        if quic_enabled is not None:
            pulumi.set(__self__, "quic_enabled", quic_enabled)

    @_builtins.property
    @pulumi.getter
    def geography(self) -> pulumi.Input[_builtins.str]:
        """
        Geography type used for enrollment
        """
        return pulumi.get(self, "geography")

    @geography.setter
    def geography(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "geography", value)

    @_builtins.property
    @pulumi.getter(name="clientMutualAuthentication")
    def client_mutual_authentication(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]:
        """
        The trust chain configuration used for client mutual authentication
        """
        return pulumi.get(self, "client_mutual_authentication")

    @client_mutual_authentication.setter
    def client_mutual_authentication(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs']]):
        pulumi.set(self, "client_mutual_authentication", value)

    @_builtins.property
    @pulumi.getter(name="cloneDnsNames")
    def clone_dns_names(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable CPS to direct traffic using all the SANs listed in the SANs parameter when enrollment is created. Default is false
        """
        return pulumi.get(self, "clone_dns_names")

    @clone_dns_names.setter
    def clone_dns_names(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clone_dns_names", value)

    @_builtins.property
    @pulumi.getter(name="disallowedTlsVersions")
    def disallowed_tls_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TLS versions which are disallowed
        """
        return pulumi.get(self, "disallowed_tls_versions")

    @disallowed_tls_versions.setter
    def disallowed_tls_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "disallowed_tls_versions", value)

    @_builtins.property
    @pulumi.getter(name="mustHaveCiphers")
    def must_have_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mandatory Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "must_have_ciphers")

    @must_have_ciphers.setter
    def must_have_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "must_have_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="ocspStapling")
    def ocsp_stapling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enable OCSP stapling. Default is 'on'
        """
        return pulumi.get(self, "ocsp_stapling")

    @ocsp_stapling.setter
    def ocsp_stapling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_stapling", value)

    @_builtins.property
    @pulumi.getter(name="preferredCiphers")
    def preferred_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Preferred Ciphers which are included for enrollment. Default is 'ak-akamai-2020q1'
        """
        return pulumi.get(self, "preferred_ciphers")

    @preferred_ciphers.setter
    def preferred_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preferred_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="quicEnabled")
    def quic_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable QUIC protocol. Default is false
        """
        return pulumi.get(self, "quic_enabled")

    @quic_enabled.setter
    def quic_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "quic_enabled", value)


if not MYPY:
    class CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict(TypedDict):
        ocsp_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable OCSP stapling
        """
        send_ca_list_to_client: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
elif False:
    CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthenticationArgs:
    def __init__(__self__, *,
                 ocsp_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_ca_list_to_client: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] ocsp_enabled: Enable OCSP stapling
        :param pulumi.Input[_builtins.bool] send_ca_list_to_client: Enable the server to send the certificate authority (CA) list to the client
        :param pulumi.Input[_builtins.str] set_id: The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        if ocsp_enabled is not None:
            pulumi.set(__self__, "ocsp_enabled", ocsp_enabled)
        if send_ca_list_to_client is not None:
            pulumi.set(__self__, "send_ca_list_to_client", send_ca_list_to_client)
        if set_id is not None:
            pulumi.set(__self__, "set_id", set_id)

    @_builtins.property
    @pulumi.getter(name="ocspEnabled")
    def ocsp_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable OCSP stapling
        """
        return pulumi.get(self, "ocsp_enabled")

    @ocsp_enabled.setter
    def ocsp_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ocsp_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sendCaListToClient")
    def send_ca_list_to_client(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the server to send the certificate authority (CA) list to the client
        """
        return pulumi.get(self, "send_ca_list_to_client")

    @send_ca_list_to_client.setter
    def send_ca_list_to_client(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_ca_list_to_client", value)

    @_builtins.property
    @pulumi.getter(name="setId")
    def set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the set of trust chains, created in the Trust Chain Manager
        """
        return pulumi.get(self, "set_id")

    @set_id.setter
    def set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "set_id", value)


if not MYPY:
    class CpsThirdPartyEnrollmentOrganizationArgsDict(TypedDict):
        address_line_one: pulumi.Input[_builtins.str]
        """
        The address of organization
        """
        city: pulumi.Input[_builtins.str]
        """
        City of organization
        """
        country_code: pulumi.Input[_builtins.str]
        """
        Country code of organization
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of organization
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of organization
        """
        postal_code: pulumi.Input[_builtins.str]
        """
        Postal code of organization
        """
        region: pulumi.Input[_builtins.str]
        """
        The region of organization
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of organization
        """
elif False:
    CpsThirdPartyEnrollmentOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentOrganizationArgs:
    def __init__(__self__, *,
                 address_line_one: pulumi.Input[_builtins.str],
                 city: pulumi.Input[_builtins.str],
                 country_code: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 postal_code: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address_line_one: The address of organization
        :param pulumi.Input[_builtins.str] city: City of organization
        :param pulumi.Input[_builtins.str] country_code: Country code of organization
        :param pulumi.Input[_builtins.str] name: Name of organization
        :param pulumi.Input[_builtins.str] phone: Phone number of organization
        :param pulumi.Input[_builtins.str] postal_code: Postal code of organization
        :param pulumi.Input[_builtins.str] region: The region of organization
        :param pulumi.Input[_builtins.str] address_line_two: The address of organization
        """
        pulumi.set(__self__, "address_line_one", address_line_one)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "postal_code", postal_code)
        pulumi.set(__self__, "region", region)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> pulumi.Input[_builtins.str]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> pulumi.Input[_builtins.str]:
        """
        City of organization
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        Country code of organization
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of organization
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of organization
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> pulumi.Input[_builtins.str]:
        """
        Postal code of organization
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The region of organization
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of organization
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)


if not MYPY:
    class CpsThirdPartyEnrollmentTechContactArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        E-mail address of the contact
        """
        first_name: pulumi.Input[_builtins.str]
        """
        First name of the contact
        """
        last_name: pulumi.Input[_builtins.str]
        """
        Last name of the contact
        """
        phone: pulumi.Input[_builtins.str]
        """
        Phone number of the contact
        """
        address_line_one: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        address_line_two: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address of the contact
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City of residence of the contact
        """
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Country code of the contact
        """
        organization: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization where contact is hired
        """
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Postal code of the contact
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the contact
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        Title of the the contact
        """
elif False:
    CpsThirdPartyEnrollmentTechContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentTechContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 phone: pulumi.Input[_builtins.str],
                 address_line_one: Optional[pulumi.Input[_builtins.str]] = None,
                 address_line_two: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 organization: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: E-mail address of the contact
        :param pulumi.Input[_builtins.str] first_name: First name of the contact
        :param pulumi.Input[_builtins.str] last_name: Last name of the contact
        :param pulumi.Input[_builtins.str] phone: Phone number of the contact
        :param pulumi.Input[_builtins.str] address_line_one: The address of the contact
        :param pulumi.Input[_builtins.str] address_line_two: The address of the contact
        :param pulumi.Input[_builtins.str] city: City of residence of the contact
        :param pulumi.Input[_builtins.str] country_code: Country code of the contact
        :param pulumi.Input[_builtins.str] organization: Organization where contact is hired
        :param pulumi.Input[_builtins.str] postal_code: Postal code of the contact
        :param pulumi.Input[_builtins.str] region: The region of the contact
        :param pulumi.Input[_builtins.str] title: Title of the the contact
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone", phone)
        if address_line_one is not None:
            pulumi.set(__self__, "address_line_one", address_line_one)
        if address_line_two is not None:
            pulumi.set(__self__, "address_line_two", address_line_two)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        E-mail address of the contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        First name of the contact
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        Last name of the contact
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> pulumi.Input[_builtins.str]:
        """
        Phone number of the contact
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="addressLineOne")
    def address_line_one(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_one")

    @address_line_one.setter
    def address_line_one(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_one", value)

    @_builtins.property
    @pulumi.getter(name="addressLineTwo")
    def address_line_two(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address of the contact
        """
        return pulumi.get(self, "address_line_two")

    @address_line_two.setter
    def address_line_two(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_line_two", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City of residence of the contact
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Country code of the contact
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization where contact is hired
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Postal code of the contact
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the contact
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Title of the the contact
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class CpsThirdPartyEnrollmentTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CpsThirdPartyEnrollmentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsThirdPartyEnrollmentTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class CpsUploadCertificateTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CpsUploadCertificateTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpsUploadCertificateTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class DatastreamAzureConnectorArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Access keys associated with Azure Storage account
        """
        account_name: pulumi.Input[_builtins.str]
        """
        Specifies the Azure Storage account name
        """
        container_name: pulumi.Input[_builtins.str]
        """
        Specifies the Azure Storage container name
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to the folder within Azure Storage container where logs will be stored
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
elif False:
    DatastreamAzureConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamAzureConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 account_name: pulumi.Input[_builtins.str],
                 container_name: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Access keys associated with Azure Storage account
        :param pulumi.Input[_builtins.str] account_name: Specifies the Azure Storage account name
        :param pulumi.Input[_builtins.str] container_name: Specifies the Azure Storage container name
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] path: The path to the folder within Azure Storage container where logs will be stored
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "path", path)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Access keys associated with Azure Storage account
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Azure Storage account name
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Azure Storage container name
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the folder within Azure Storage container where logs will be stored
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)


if not MYPY:
    class DatastreamDatadogConnectorArgsDict(TypedDict):
        auth_token: pulumi.Input[_builtins.str]
        """
        The API key associated with Datadog account
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The Datadog endpoint where logs will be stored
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service of the Datadog connector
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source of the Datadog connector
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tags of the Datadog connector
        """
elif False:
    DatastreamDatadogConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamDatadogConnectorArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_token: The API key associated with Datadog account
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] endpoint: The Datadog endpoint where logs will be stored
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        :param pulumi.Input[_builtins.str] service: The service of the Datadog connector
        :param pulumi.Input[_builtins.str] source: The source of the Datadog connector
        :param pulumi.Input[_builtins.str] tags: The tags of the Datadog connector
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[_builtins.str]:
        """
        The API key associated with Datadog account
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_token", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The Datadog endpoint where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service of the Datadog connector
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source of the Datadog connector
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tags of the Datadog connector
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DatastreamDeliveryConfigurationArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        The format in which logs will be received
        """
        frequency: pulumi.Input['DatastreamDeliveryConfigurationFrequencyArgsDict']
        """
        The frequency of collecting logs from each uploader and sending these logs to a destination
        """
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A delimiter that you use to separate data set fields in log lines
        """
        upload_file_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prefix of the log file that will be send to a destination
        """
        upload_file_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The suffix of the log file that will be send to a destination
        """
elif False:
    DatastreamDeliveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamDeliveryConfigurationArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 frequency: pulumi.Input['DatastreamDeliveryConfigurationFrequencyArgs'],
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_file_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_file_suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: The format in which logs will be received
        :param pulumi.Input['DatastreamDeliveryConfigurationFrequencyArgs'] frequency: The frequency of collecting logs from each uploader and sending these logs to a destination
        :param pulumi.Input[_builtins.str] field_delimiter: A delimiter that you use to separate data set fields in log lines
        :param pulumi.Input[_builtins.str] upload_file_prefix: The prefix of the log file that will be send to a destination
        :param pulumi.Input[_builtins.str] upload_file_suffix: The suffix of the log file that will be send to a destination
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "frequency", frequency)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if upload_file_prefix is not None:
            pulumi.set(__self__, "upload_file_prefix", upload_file_prefix)
        if upload_file_suffix is not None:
            pulumi.set(__self__, "upload_file_suffix", upload_file_suffix)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        The format in which logs will be received
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> pulumi.Input['DatastreamDeliveryConfigurationFrequencyArgs']:
        """
        The frequency of collecting logs from each uploader and sending these logs to a destination
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input['DatastreamDeliveryConfigurationFrequencyArgs']):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A delimiter that you use to separate data set fields in log lines
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="uploadFilePrefix")
    def upload_file_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prefix of the log file that will be send to a destination
        """
        return pulumi.get(self, "upload_file_prefix")

    @upload_file_prefix.setter
    def upload_file_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload_file_prefix", value)

    @_builtins.property
    @pulumi.getter(name="uploadFileSuffix")
    def upload_file_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The suffix of the log file that will be send to a destination
        """
        return pulumi.get(self, "upload_file_suffix")

    @upload_file_suffix.setter
    def upload_file_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload_file_suffix", value)


if not MYPY:
    class DatastreamDeliveryConfigurationFrequencyArgsDict(TypedDict):
        interval_in_secs: pulumi.Input[_builtins.int]
        """
        The time in seconds after which the system bundles log lines into a file and sends it to a destination
        """
elif False:
    DatastreamDeliveryConfigurationFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamDeliveryConfigurationFrequencyArgs:
    def __init__(__self__, *,
                 interval_in_secs: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] interval_in_secs: The time in seconds after which the system bundles log lines into a file and sends it to a destination
        """
        pulumi.set(__self__, "interval_in_secs", interval_in_secs)

    @_builtins.property
    @pulumi.getter(name="intervalInSecs")
    def interval_in_secs(self) -> pulumi.Input[_builtins.int]:
        """
        The time in seconds after which the system bundles log lines into a file and sends it to a destination
        """
        return pulumi.get(self, "interval_in_secs")

    @interval_in_secs.setter
    def interval_in_secs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval_in_secs", value)


if not MYPY:
    class DatastreamDynatraceConnectorArgsDict(TypedDict):
        api_token: pulumi.Input[_builtins.str]
        """
        The Dynatrace Log Ingest access token.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The destination's name.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The Dynatrace Ingestion API endpoint URL in the https://{dynatrace-environment-id}.live.dynatrace.com/api/v2/logs/ingest format.
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
elif False:
    DatastreamDynatraceConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamDynatraceConnectorArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_token: The Dynatrace Log Ingest access token.
        :param pulumi.Input[_builtins.str] display_name: The destination's name.
        :param pulumi.Input[_builtins.str] endpoint: The Dynatrace Ingestion API endpoint URL in the https://{dynatrace-environment-id}.live.dynatrace.com/api/v2/logs/ingest format.
        :param pulumi.Input[_builtins.str] custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[_builtins.str]:
        """
        The Dynatrace Log Ingest access token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_token", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The destination's name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The Dynatrace Ingestion API endpoint URL in the https://{dynatrace-environment-id}.live.dynatrace.com/api/v2/logs/ingest format.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)


if not MYPY:
    class DatastreamElasticsearchConnectorArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
        """
        index_name: pulumi.Input[_builtins.str]
        """
        The index name of the Elastic cloud where you want to store log files.
        """
        password: pulumi.Input[_builtins.str]
        """
        The Elasticsearch basic access authentication password.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        The Elasticsearch basic access authentication username.
        """
        ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        m_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether mTLS is enabled or not.
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
elif False:
    DatastreamElasticsearchConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamElasticsearchConnectorArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 index_name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str],
                 ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 m_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The name of the connector.
        :param pulumi.Input[_builtins.str] endpoint: The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
        :param pulumi.Input[_builtins.str] index_name: The index name of the Elastic cloud where you want to store log files.
        :param pulumi.Input[_builtins.str] password: The Elasticsearch basic access authentication password.
        :param pulumi.Input[_builtins.str] user_name: The Elasticsearch basic access authentication username.
        :param pulumi.Input[_builtins.str] ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param pulumi.Input[_builtins.str] client_cert: The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param pulumi.Input[_builtins.str] client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param pulumi.Input[_builtins.str] content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.bool] m_tls: Indicates whether mTLS is enabled or not.
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The Elasticsearch bulk endpoint URL in the https://hostname.elastic-cloud.com:9243/_bulk/ format. Set indexName in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Elasticsearch.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[_builtins.str]:
        """
        The index name of the Elastic cloud where you want to store log files.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The Elasticsearch basic access authentication password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        The Elasticsearch basic access authentication username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @m_tls.setter
    def m_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "m_tls", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)


if not MYPY:
    class DatastreamGcsConnectorArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the storage bucket created in Google Cloud account
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The contents of the JSON private key generated and downloaded in Google Cloud Storage account
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The unique ID of Google Cloud project
        """
        service_account_name: pulumi.Input[_builtins.str]
        """
        The name of the service account with the storage.object.create permission or Storage Object Creator role
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the folder within Google Cloud bucket where logs will be stored
        """
elif False:
    DatastreamGcsConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamGcsConnectorArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 service_account_name: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The name of the storage bucket created in Google Cloud account
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] private_key: The contents of the JSON private key generated and downloaded in Google Cloud Storage account
        :param pulumi.Input[_builtins.str] project_id: The unique ID of Google Cloud project
        :param pulumi.Input[_builtins.str] service_account_name: The name of the service account with the storage.object.create permission or Storage Object Creator role
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        :param pulumi.Input[_builtins.str] path: The path to the folder within Google Cloud bucket where logs will be stored
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_name", service_account_name)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the storage bucket created in Google Cloud account
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The contents of the JSON private key generated and downloaded in Google Cloud Storage account
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique ID of Google Cloud project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the service account with the storage.object.create permission or Storage Object Creator role
        """
        return pulumi.get(self, "service_account_name")

    @service_account_name.setter
    def service_account_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account_name", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the folder within Google Cloud bucket where logs will be stored
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatastreamHttpsConnectorArgsDict(TypedDict):
        authentication_type: pulumi.Input[_builtins.str]
        """
        Either NONE for no authentication, or BASIC for username and password authentication
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        URL where logs will be stored
        """
        ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content type to pass in the log file header
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of custom header passed with the request to the destination
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request to the destination
        """
        m_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether mTLS is enabled or not.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password set for custom HTTPS endpoint for authentication
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Username used for authentication
        """
elif False:
    DatastreamHttpsConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamHttpsConnectorArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 m_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_type: Either NONE for no authentication, or BASIC for username and password authentication
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] endpoint: URL where logs will be stored
        :param pulumi.Input[_builtins.str] ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param pulumi.Input[_builtins.str] client_cert: The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        :param pulumi.Input[_builtins.str] client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        :param pulumi.Input[_builtins.str] content_type: Content type to pass in the log file header
        :param pulumi.Input[_builtins.str] custom_header_name: The name of custom header passed with the request to the destination
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request to the destination
        :param pulumi.Input[_builtins.bool] m_tls: Indicates whether mTLS is enabled or not.
        :param pulumi.Input[_builtins.str] password: Password set for custom HTTPS endpoint for authentication
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        :param pulumi.Input[_builtins.str] user_name: Username used for authentication
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[_builtins.str]:
        """
        Either NONE for no authentication, or BASIC for username and password authentication
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        URL where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content type to pass in the log file header
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @m_tls.setter
    def m_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "m_tls", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password set for custom HTTPS endpoint for authentication
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Username used for authentication
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class DatastreamLogglyConnectorArgsDict(TypedDict):
        auth_token: pulumi.Input[_builtins.str]
        """
        The unique HTTP code for your Loggly bulk endpoint.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
        """
elif False:
    DatastreamLogglyConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamLogglyConnectorArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_token: The unique HTTP code for your Loggly bulk endpoint.
        :param pulumi.Input[_builtins.str] display_name: The name of the connector.
        :param pulumi.Input[_builtins.str] endpoint: The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
        :param pulumi.Input[_builtins.str] content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] tags: The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[_builtins.str]:
        """
        The unique HTTP code for your Loggly bulk endpoint.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_token", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The Loggly bulk endpoint URL in the https://hostname.loggly.com/bulk/ format. Set the endpoint code in the authToken field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. See Stream logs to Loggly.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tags you can use to segment and filter log events in Loggly. See Tags in the Loggly documentation.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DatastreamNewRelicConnectorArgsDict(TypedDict):
        auth_token: pulumi.Input[_builtins.str]
        """
        Your Log API token for your account in New Relic.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
elif False:
    DatastreamNewRelicConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamNewRelicConnectorArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_token: Your Log API token for your account in New Relic.
        :param pulumi.Input[_builtins.str] display_name: The name of the connector.
        :param pulumi.Input[_builtins.str] endpoint: A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
        :param pulumi.Input[_builtins.str] content_type: The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[_builtins.str]:
        """
        Your Log API token for your account in New Relic.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_token", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        A New Relic endpoint URL you want to send your logs to. The endpoint URL should follow the https://<newrelic.com>/log/v1/ format format. See Introduction to the Log API https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/ if you want to retrieve your New Relic endpoint URL.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the resource passed in the request's custom header. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request that contains information about the client connection. For details, see Additional options in the DataStream user guide.
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)


if not MYPY:
    class DatastreamOracleConnectorArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        The access key identifier used to authenticate requests to the Oracle Cloud account
        """
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the Oracle Cloud Storage bucket
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        namespace: pulumi.Input[_builtins.str]
        """
        The namespace of Oracle Cloud Storage account
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
        """
        region: pulumi.Input[_builtins.str]
        """
        The Oracle Cloud Storage region where bucket resides
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        The secret access key identifier used to authenticate requests to the Oracle Cloud account
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
elif False:
    DatastreamOracleConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamOracleConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The access key identifier used to authenticate requests to the Oracle Cloud account
        :param pulumi.Input[_builtins.str] bucket: The name of the Oracle Cloud Storage bucket
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] namespace: The namespace of Oracle Cloud Storage account
        :param pulumi.Input[_builtins.str] path: The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
        :param pulumi.Input[_builtins.str] region: The Oracle Cloud Storage region where bucket resides
        :param pulumi.Input[_builtins.str] secret_access_key: The secret access key identifier used to authenticate requests to the Oracle Cloud account
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The access key identifier used to authenticate requests to the Oracle Cloud account
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Oracle Cloud Storage bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The namespace of Oracle Cloud Storage account
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the folder within your Oracle Cloud Storage bucket where logs will be stored
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The Oracle Cloud Storage region where bucket resides
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret access key identifier used to authenticate requests to the Oracle Cloud account
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)


if not MYPY:
    class DatastreamS3CompatibleConnectorArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        The access key identifier of the S3-compatible object storage bucket.
        """
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the S3-compatible object storage bucket.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the destination.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The scheme-qualified host of your S3-compatible object storage bucket.
        """
        region: pulumi.Input[_builtins.str]
        """
        The physical storage location of your S3-compatible object storage bucket.
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        The secret access key identifier of the S3-compatible object storage bucket.
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables gzip compression for a log file sent to a destination. This value is always true for this destination type.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the folder within your S3-compatible object storage bucket where you want to store logs. Optional field.
        """
elif False:
    DatastreamS3CompatibleConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamS3CompatibleConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The access key identifier of the S3-compatible object storage bucket.
        :param pulumi.Input[_builtins.str] bucket: The name of the S3-compatible object storage bucket.
        :param pulumi.Input[_builtins.str] display_name: The name of the destination.
        :param pulumi.Input[_builtins.str] endpoint: The scheme-qualified host of your S3-compatible object storage bucket.
        :param pulumi.Input[_builtins.str] region: The physical storage location of your S3-compatible object storage bucket.
        :param pulumi.Input[_builtins.str] secret_access_key: The secret access key identifier of the S3-compatible object storage bucket.
        :param pulumi.Input[_builtins.bool] compress_logs: Enables gzip compression for a log file sent to a destination. This value is always true for this destination type.
        :param pulumi.Input[_builtins.str] path: The path to the folder within your S3-compatible object storage bucket where you want to store logs. Optional field.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The access key identifier of the S3-compatible object storage bucket.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the S3-compatible object storage bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the destination.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The scheme-qualified host of your S3-compatible object storage bucket.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The physical storage location of your S3-compatible object storage bucket.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret access key identifier of the S3-compatible object storage bucket.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables gzip compression for a log file sent to a destination. This value is always true for this destination type.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the folder within your S3-compatible object storage bucket where you want to store logs. Optional field.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatastreamS3ConnectorArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        The access key identifier used to authenticate requests to the Amazon S3 account
        """
        bucket: pulumi.Input[_builtins.str]
        """
        The name of the Amazon S3 bucket
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to the folder within Amazon S3 bucket where logs will be stored
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region where Amazon S3 bucket resides
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        The secret access key identifier used to authenticate requests to the Amazon S3 account
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
elif False:
    DatastreamS3ConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamS3ConnectorArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The access key identifier used to authenticate requests to the Amazon S3 account
        :param pulumi.Input[_builtins.str] bucket: The name of the Amazon S3 bucket
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] path: The path to the folder within Amazon S3 bucket where logs will be stored
        :param pulumi.Input[_builtins.str] region: The AWS region where Amazon S3 bucket resides
        :param pulumi.Input[_builtins.str] secret_access_key: The secret access key identifier used to authenticate requests to the Amazon S3 account
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The access key identifier used to authenticate requests to the Amazon S3 account
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Amazon S3 bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the folder within Amazon S3 bucket where logs will be stored
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region where Amazon S3 bucket resides
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret access key identifier used to authenticate requests to the Amazon S3 account
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)


if not MYPY:
    class DatastreamSplunkConnectorArgsDict(TypedDict):
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The raw event Splunk URL where logs will be stored
        """
        event_collector_token: pulumi.Input[_builtins.str]
        """
        The Event Collector token associated with Splunk account
        """
        ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of custom header passed with the request to the destination
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request to the destination
        """
        m_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether mTLS is enabled or not.
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
elif False:
    DatastreamSplunkConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamSplunkConnectorArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 event_collector_token: pulumi.Input[_builtins.str],
                 ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 m_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] endpoint: The raw event Splunk URL where logs will be stored
        :param pulumi.Input[_builtins.str] event_collector_token: The Event Collector token associated with Splunk account
        :param pulumi.Input[_builtins.str] ca_cert: The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        :param pulumi.Input[_builtins.str] client_cert: The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        :param pulumi.Input[_builtins.str] client_key: The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        :param pulumi.Input[_builtins.str] custom_header_name: The name of custom header passed with the request to the destination
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request to the destination
        :param pulumi.Input[_builtins.bool] m_tls: Indicates whether mTLS is enabled or not.
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "event_collector_token", event_collector_token)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)
        if m_tls is not None:
            pulumi.set(__self__, "m_tls", m_tls)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The raw event Splunk URL where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="eventCollectorToken")
    def event_collector_token(self) -> pulumi.Input[_builtins.str]:
        """
        The Event Collector token associated with Splunk account
        """
        return pulumi.get(self, "event_collector_token")

    @event_collector_token.setter
    def event_collector_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_collector_token", value)

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certification authority (CA) certificate used to verify the origin server's certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)

    @_builtins.property
    @pulumi.getter(name="mTls")
    def m_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether mTLS is enabled or not.
        """
        return pulumi.get(self, "m_tls")

    @m_tls.setter
    def m_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "m_tls", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)


if not MYPY:
    class DatastreamSumologicConnectorArgsDict(TypedDict):
        collector_code: pulumi.Input[_builtins.str]
        """
        The unique HTTP collector code of Sumo Logic endpoint
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the connector
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The Sumo Logic collection endpoint where logs will be stored
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the logs should be compressed
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content type to pass in the log file header
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of custom header passed with the request to the destination
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request to the destination
        """
elif False:
    DatastreamSumologicConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamSumologicConnectorArgs:
    def __init__(__self__, *,
                 collector_code: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collector_code: The unique HTTP collector code of Sumo Logic endpoint
        :param pulumi.Input[_builtins.str] display_name: The name of the connector
        :param pulumi.Input[_builtins.str] endpoint: The Sumo Logic collection endpoint where logs will be stored
        :param pulumi.Input[_builtins.bool] compress_logs: Indicates whether the logs should be compressed
        :param pulumi.Input[_builtins.str] content_type: Content type to pass in the log file header
        :param pulumi.Input[_builtins.str] custom_header_name: The name of custom header passed with the request to the destination
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request to the destination
        """
        pulumi.set(__self__, "collector_code", collector_code)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="collectorCode")
    def collector_code(self) -> pulumi.Input[_builtins.str]:
        """
        The unique HTTP collector code of Sumo Logic endpoint
        """
        return pulumi.get(self, "collector_code")

    @collector_code.setter
    def collector_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collector_code", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the connector
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The Sumo Logic collection endpoint where logs will be stored
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the logs should be compressed
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content type to pass in the log file header
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of custom header passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request to the destination
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)


if not MYPY:
    class DatastreamTrafficpeakConnectorArgsDict(TypedDict):
        authentication_type: pulumi.Input[_builtins.str]
        """
        Only BASIC authentication is supported for TrafficPeak destination.
        """
        content_type: pulumi.Input[_builtins.str]
        """
        The type of the resource passed in the request's custom header. - Supported headers: `application/json` or `application/json; charset=utf-8`.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The destination's name.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Enter the Hydrolix endpoint URL in the https://<host>/ingest/event?table=<tablename>&token=<token> format, where the token is the HTTP streaming ingest token, and the tablename is the Hydrolix data set table name.
        """
        password: pulumi.Input[_builtins.str]
        """
        Enter the password you set in your TrafficPeak endpoint for authentication.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Enter the valid username you set in your TrafficPeak endpoint for authentication.
        """
        compress_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables gzip compression for a log file sent to a destination. The value is true by default.
        """
        custom_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. Optional field.
        """
        custom_header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom header's contents passed with the request that contains information about the client connection. Optional field.
        """
elif False:
    DatastreamTrafficpeakConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatastreamTrafficpeakConnectorArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str],
                 compress_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_header_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_type: Only BASIC authentication is supported for TrafficPeak destination.
        :param pulumi.Input[_builtins.str] content_type: The type of the resource passed in the request's custom header. - Supported headers: `application/json` or `application/json; charset=utf-8`.
        :param pulumi.Input[_builtins.str] display_name: The destination's name.
        :param pulumi.Input[_builtins.str] endpoint: Enter the Hydrolix endpoint URL in the https://<host>/ingest/event?table=<tablename>&token=<token> format, where the token is the HTTP streaming ingest token, and the tablename is the Hydrolix data set table name.
        :param pulumi.Input[_builtins.str] password: Enter the password you set in your TrafficPeak endpoint for authentication.
        :param pulumi.Input[_builtins.str] user_name: Enter the valid username you set in your TrafficPeak endpoint for authentication.
        :param pulumi.Input[_builtins.bool] compress_logs: Enables gzip compression for a log file sent to a destination. The value is true by default.
        :param pulumi.Input[_builtins.str] custom_header_name: A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. Optional field.
        :param pulumi.Input[_builtins.str] custom_header_value: The custom header's contents passed with the request that contains information about the client connection. Optional field.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)
        if compress_logs is not None:
            pulumi.set(__self__, "compress_logs", compress_logs)
        if custom_header_name is not None:
            pulumi.set(__self__, "custom_header_name", custom_header_name)
        if custom_header_value is not None:
            pulumi.set(__self__, "custom_header_value", custom_header_value)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[_builtins.str]:
        """
        Only BASIC authentication is supported for TrafficPeak destination.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_type", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the resource passed in the request's custom header. - Supported headers: `application/json` or `application/json; charset=utf-8`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The destination's name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the Hydrolix endpoint URL in the https://<host>/ingest/event?table=<tablename>&token=<token> format, where the token is the HTTP streaming ingest token, and the tablename is the Hydrolix data set table name.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the password you set in your TrafficPeak endpoint for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the valid username you set in your TrafficPeak endpoint for authentication.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="compressLogs")
    def compress_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables gzip compression for a log file sent to a destination. The value is true by default.
        """
        return pulumi.get(self, "compress_logs")

    @compress_logs.setter
    def compress_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress_logs", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderName")
    def custom_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters. Optional field.
        """
        return pulumi.get(self, "custom_header_name")

    @custom_header_name.setter
    def custom_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_name", value)

    @_builtins.property
    @pulumi.getter(name="customHeaderValue")
    def custom_header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom header's contents passed with the request that contains information about the client connection. Optional field.
        """
        return pulumi.get(self, "custom_header_value")

    @custom_header_value.setter
    def custom_header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_header_value", value)


if not MYPY:
    class DnsZoneOutboundZoneTransferArgsDict(TypedDict):
        acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The access control list, defined as IPv4 and IPv6 CIDR blocks.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables outbound zone transfer.
        """
        notify_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
        """
        tsig_key: NotRequired[pulumi.Input['DnsZoneOutboundZoneTransferTsigKeyArgsDict']]
        """
        The TSIG key used for outbound zone transfers.
        """
elif False:
    DnsZoneOutboundZoneTransferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsZoneOutboundZoneTransferArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_targets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tsig_key: Optional[pulumi.Input['DnsZoneOutboundZoneTransferTsigKeyArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] acls: The access control list, defined as IPv4 and IPv6 CIDR blocks.
        :param pulumi.Input[_builtins.bool] enabled: Enables outbound zone transfer.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notify_targets: Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
        :param pulumi.Input['DnsZoneOutboundZoneTransferTsigKeyArgs'] tsig_key: The TSIG key used for outbound zone transfers.
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if notify_targets is not None:
            pulumi.set(__self__, "notify_targets", notify_targets)
        if tsig_key is not None:
            pulumi.set(__self__, "tsig_key", tsig_key)

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The access control list, defined as IPv4 and IPv6 CIDR blocks.
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "acls", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables outbound zone transfer.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="notifyTargets")
    def notify_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Customer secondary nameservers to notify, if NOTIFY requests are desired. Up to 64 IPv4 or IPv6 addresses. If no targets are specified, you can manually request zone transfer updates as needed.
        """
        return pulumi.get(self, "notify_targets")

    @notify_targets.setter
    def notify_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "notify_targets", value)

    @_builtins.property
    @pulumi.getter(name="tsigKey")
    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneOutboundZoneTransferTsigKeyArgs']]:
        """
        The TSIG key used for outbound zone transfers.
        """
        return pulumi.get(self, "tsig_key")

    @tsig_key.setter
    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneOutboundZoneTransferTsigKeyArgs']]):
        pulumi.set(self, "tsig_key", value)


if not MYPY:
    class DnsZoneOutboundZoneTransferTsigKeyArgsDict(TypedDict):
        algorithm: pulumi.Input[_builtins.str]
        """
        The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
        """
        name: pulumi.Input[_builtins.str]
        """
        The zone name.
        """
        secret: pulumi.Input[_builtins.str]
        """
        A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
        """
elif False:
    DnsZoneOutboundZoneTransferTsigKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsZoneOutboundZoneTransferTsigKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] algorithm: The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
        :param pulumi.Input[_builtins.str] name: The zone name.
        :param pulumi.Input[_builtins.str] secret: A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        The algorithm used to encode the TSIG key's secret data. Possible values are: hmac-md5, hmac-sha1, hmac-sha224, hmac-sha256, hmac-sha384, hmac-sha512, or HMAC-MD5.SIG-ALG.REG.INT.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The zone name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        A Base64-encoded string of data. When decoded, it needs to contain the correct number of bits for the chosen algorithm. If the input isn't correctly padded, the server applies the padding.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class DnsZoneTsigKeyArgsDict(TypedDict):
        algorithm: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        secret: pulumi.Input[_builtins.str]
elif False:
    DnsZoneTsigKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsZoneTsigKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class EdgeHostNameTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EdgeHostNameTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeHostNameTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class EdgeWorkerTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EdgeWorkerTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeWorkerTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class EdgeWorkersActivationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
        delete: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EdgeWorkersActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgeWorkersActivationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class EdgekvGroupItemsTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EdgekvGroupItemsTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgekvGroupItemsTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class GtmAsmapAssignmentArgsDict(TypedDict):
        as_numbers: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: pulumi.Input[_builtins.str]
elif False:
    GtmAsmapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmAsmapAssignmentArgs:
    def __init__(__self__, *,
                 as_numbers: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "as_numbers")

    @as_numbers.setter
    def as_numbers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "as_numbers", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GtmAsmapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GtmAsmapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmAsmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GtmCidrmapAssignmentArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: pulumi.Input[_builtins.str]
        blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    GtmCidrmapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmCidrmapAssignmentArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: pulumi.Input[_builtins.str],
                 blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nickname", value)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blocks", value)


if not MYPY:
    class GtmCidrmapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GtmCidrmapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmCidrmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GtmDatacenterDefaultLoadObjectArgsDict(TypedDict):
        load_object: NotRequired[pulumi.Input[_builtins.str]]
        load_object_port: NotRequired[pulumi.Input[_builtins.int]]
        load_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    GtmDatacenterDefaultLoadObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmDatacenterDefaultLoadObjectArgs:
    def __init__(__self__, *,
                 load_object: Optional[pulumi.Input[_builtins.str]] = None,
                 load_object_port: Optional[pulumi.Input[_builtins.int]] = None,
                 load_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "load_servers", value)


if not MYPY:
    class GtmGeomapAssignmentArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: pulumi.Input[_builtins.str]
        countries: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    GtmGeomapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmGeomapAssignmentArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: pulumi.Input[_builtins.str],
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)
        if countries is not None:
            pulumi.set(__self__, "countries", countries)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nickname", value)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "countries", value)


if not MYPY:
    class GtmGeomapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        nickname: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GtmGeomapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmGeomapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 nickname: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if nickname is not None:
            pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GtmPropertyLivenessTestArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        test_interval: pulumi.Input[_builtins.int]
        test_object_protocol: pulumi.Input[_builtins.str]
        test_timeout: pulumi.Input[_builtins.float]
        alternate_ca_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        answers_required: NotRequired[pulumi.Input[_builtins.bool]]
        disable_nonstandard_port_warning: NotRequired[pulumi.Input[_builtins.bool]]
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        error_penalty: NotRequired[pulumi.Input[_builtins.float]]
        http_error3xx: NotRequired[pulumi.Input[_builtins.bool]]
        http_error4xx: NotRequired[pulumi.Input[_builtins.bool]]
        http_error5xx: NotRequired[pulumi.Input[_builtins.bool]]
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgsDict']]]]
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        http_request_body: NotRequired[pulumi.Input[_builtins.str]]
        peer_certificate_verification: NotRequired[pulumi.Input[_builtins.bool]]
        pre2023_security_posture: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        recursion_requested: NotRequired[pulumi.Input[_builtins.bool]]
        request_string: NotRequired[pulumi.Input[_builtins.str]]
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        response_string: NotRequired[pulumi.Input[_builtins.str]]
        ssl_client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        ssl_client_private_key: NotRequired[pulumi.Input[_builtins.str]]
        test_object: NotRequired[pulumi.Input[_builtins.str]]
        test_object_password: NotRequired[pulumi.Input[_builtins.str]]
        test_object_port: NotRequired[pulumi.Input[_builtins.int]]
        test_object_username: NotRequired[pulumi.Input[_builtins.str]]
        timeout_penalty: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    GtmPropertyLivenessTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmPropertyLivenessTestArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 test_interval: pulumi.Input[_builtins.int],
                 test_object_protocol: pulumi.Input[_builtins.str],
                 test_timeout: pulumi.Input[_builtins.float],
                 alternate_ca_certificates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 answers_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_nonstandard_port_warning: Optional[pulumi.Input[_builtins.bool]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 error_penalty: Optional[pulumi.Input[_builtins.float]] = None,
                 http_error3xx: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_error4xx: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_error5xx: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 http_request_body: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_certificate_verification: Optional[pulumi.Input[_builtins.bool]] = None,
                 pre2023_security_posture: Optional[pulumi.Input[_builtins.bool]] = None,
                 recursion_requested: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_string: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 response_string: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 test_object: Optional[pulumi.Input[_builtins.str]] = None,
                 test_object_password: Optional[pulumi.Input[_builtins.str]] = None,
                 test_object_port: Optional[pulumi.Input[_builtins.int]] = None,
                 test_object_username: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_penalty: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] pre2023_security_posture: Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "test_interval", test_interval)
        pulumi.set(__self__, "test_object_protocol", test_object_protocol)
        pulumi.set(__self__, "test_timeout", test_timeout)
        if alternate_ca_certificates is not None:
            pulumi.set(__self__, "alternate_ca_certificates", alternate_ca_certificates)
        if answers_required is not None:
            pulumi.set(__self__, "answers_required", answers_required)
        if disable_nonstandard_port_warning is not None:
            pulumi.set(__self__, "disable_nonstandard_port_warning", disable_nonstandard_port_warning)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if error_penalty is not None:
            pulumi.set(__self__, "error_penalty", error_penalty)
        if http_error3xx is not None:
            pulumi.set(__self__, "http_error3xx", http_error3xx)
        if http_error4xx is not None:
            pulumi.set(__self__, "http_error4xx", http_error4xx)
        if http_error5xx is not None:
            pulumi.set(__self__, "http_error5xx", http_error5xx)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_request_body is not None:
            pulumi.set(__self__, "http_request_body", http_request_body)
        if peer_certificate_verification is not None:
            pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        if pre2023_security_posture is not None:
            pulumi.set(__self__, "pre2023_security_posture", pre2023_security_posture)
        if recursion_requested is not None:
            pulumi.set(__self__, "recursion_requested", recursion_requested)
        if request_string is not None:
            pulumi.set(__self__, "request_string", request_string)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if response_string is not None:
            pulumi.set(__self__, "response_string", response_string)
        if ssl_client_certificate is not None:
            pulumi.set(__self__, "ssl_client_certificate", ssl_client_certificate)
        if ssl_client_private_key is not None:
            pulumi.set(__self__, "ssl_client_private_key", ssl_client_private_key)
        if test_object is not None:
            pulumi.set(__self__, "test_object", test_object)
        if test_object_password is not None:
            pulumi.set(__self__, "test_object_password", test_object_password)
        if test_object_port is not None:
            pulumi.set(__self__, "test_object_port", test_object_port)
        if test_object_username is not None:
            pulumi.set(__self__, "test_object_username", test_object_username)
        if timeout_penalty is not None:
            pulumi.set(__self__, "timeout_penalty", timeout_penalty)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="testInterval")
    def test_interval(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "test_interval")

    @test_interval.setter
    def test_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "test_interval", value)

    @_builtins.property
    @pulumi.getter(name="testObjectProtocol")
    def test_object_protocol(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "test_object_protocol")

    @test_object_protocol.setter
    def test_object_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "test_object_protocol", value)

    @_builtins.property
    @pulumi.getter(name="testTimeout")
    def test_timeout(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "test_timeout")

    @test_timeout.setter
    def test_timeout(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "test_timeout", value)

    @_builtins.property
    @pulumi.getter(name="alternateCaCertificates")
    def alternate_ca_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "alternate_ca_certificates")

    @alternate_ca_certificates.setter
    def alternate_ca_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alternate_ca_certificates", value)

    @_builtins.property
    @pulumi.getter(name="answersRequired")
    def answers_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "answers_required")

    @answers_required.setter
    def answers_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "answers_required", value)

    @_builtins.property
    @pulumi.getter(name="disableNonstandardPortWarning")
    def disable_nonstandard_port_warning(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_nonstandard_port_warning")

    @disable_nonstandard_port_warning.setter
    def disable_nonstandard_port_warning(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_nonstandard_port_warning", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="errorPenalty")
    def error_penalty(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "error_penalty")

    @error_penalty.setter
    def error_penalty(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "error_penalty", value)

    @_builtins.property
    @pulumi.getter(name="httpError3xx")
    def http_error3xx(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "http_error3xx")

    @http_error3xx.setter
    def http_error3xx(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http_error3xx", value)

    @_builtins.property
    @pulumi.getter(name="httpError4xx")
    def http_error4xx(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "http_error4xx")

    @http_error4xx.setter
    def http_error4xx(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http_error4xx", value)

    @_builtins.property
    @pulumi.getter(name="httpError5xx")
    def http_error5xx(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "http_error5xx")

    @http_error5xx.setter
    def http_error5xx(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http_error5xx", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="httpRequestBody")
    def http_request_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "http_request_body")

    @http_request_body.setter
    def http_request_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_request_body", value)

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "peer_certificate_verification")

    @peer_certificate_verification.setter
    def peer_certificate_verification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "peer_certificate_verification", value)

    @_builtins.property
    @pulumi.getter(name="pre2023SecurityPosture")
    def pre2023_security_posture(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        return pulumi.get(self, "pre2023_security_posture")

    @pre2023_security_posture.setter
    def pre2023_security_posture(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pre2023_security_posture", value)

    @_builtins.property
    @pulumi.getter(name="recursionRequested")
    def recursion_requested(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "recursion_requested")

    @recursion_requested.setter
    def recursion_requested(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "recursion_requested", value)

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "request_string")

    @request_string.setter
    def request_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_string", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_string")

    @response_string.setter
    def response_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_string", value)

    @_builtins.property
    @pulumi.getter(name="sslClientCertificate")
    def ssl_client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ssl_client_certificate")

    @ssl_client_certificate.setter
    def ssl_client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="sslClientPrivateKey")
    def ssl_client_private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ssl_client_private_key")

    @ssl_client_private_key.setter
    def ssl_client_private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_private_key", value)

    @_builtins.property
    @pulumi.getter(name="testObject")
    def test_object(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "test_object")

    @test_object.setter
    def test_object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_object", value)

    @_builtins.property
    @pulumi.getter(name="testObjectPassword")
    def test_object_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "test_object_password")

    @test_object_password.setter
    def test_object_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_object_password", value)

    @_builtins.property
    @pulumi.getter(name="testObjectPort")
    def test_object_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "test_object_port")

    @test_object_port.setter
    def test_object_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "test_object_port", value)

    @_builtins.property
    @pulumi.getter(name="testObjectUsername")
    def test_object_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "test_object_username")

    @test_object_username.setter
    def test_object_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_object_username", value)

    @_builtins.property
    @pulumi.getter(name="timeoutPenalty")
    def timeout_penalty(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "timeout_penalty")

    @timeout_penalty.setter
    def timeout_penalty(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout_penalty", value)


if not MYPY:
    class GtmPropertyLivenessTestHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GtmPropertyLivenessTestHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmPropertyLivenessTestHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GtmPropertyStaticRrSetArgsDict(TypedDict):
        rdatas: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GtmPropertyStaticRrSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmPropertyStaticRrSetArgs:
    def __init__(__self__, *,
                 rdatas: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if rdatas is not None:
            pulumi.set(__self__, "rdatas", rdatas)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def rdatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "rdatas")

    @rdatas.setter
    def rdatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "rdatas", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GtmPropertyTrafficTargetArgsDict(TypedDict):
        datacenter_id: NotRequired[pulumi.Input[_builtins.int]]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        handout_cname: NotRequired[pulumi.Input[_builtins.str]]
        precedence: NotRequired[pulumi.Input[_builtins.int]]
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        weight: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    GtmPropertyTrafficTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmPropertyTrafficTargetArgs:
    def __init__(__self__, *,
                 datacenter_id: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 handout_cname: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if handout_cname is not None:
            pulumi.set(__self__, "handout_cname", handout_cname)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="handoutCname")
    def handout_cname(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "handout_cname")

    @handout_cname.setter
    def handout_cname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "handout_cname", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GtmResourceResourceInstanceArgsDict(TypedDict):
        datacenter_id: pulumi.Input[_builtins.int]
        load_object: NotRequired[pulumi.Input[_builtins.str]]
        load_object_port: NotRequired[pulumi.Input[_builtins.int]]
        load_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        use_default_load_object: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    GtmResourceResourceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GtmResourceResourceInstanceArgs:
    def __init__(__self__, *,
                 datacenter_id: pulumi.Input[_builtins.int],
                 load_object: Optional[pulumi.Input[_builtins.str]] = None,
                 load_object_port: Optional[pulumi.Input[_builtins.int]] = None,
                 load_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 use_default_load_object: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        if load_object is not None:
            pulumi.set(__self__, "load_object", load_object)
        if load_object_port is not None:
            pulumi.set(__self__, "load_object_port", load_object_port)
        if load_servers is not None:
            pulumi.set(__self__, "load_servers", load_servers)
        if use_default_load_object is not None:
            pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "load_servers", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_default_load_object")

    @use_default_load_object.setter
    def use_default_load_object(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_default_load_object", value)


if not MYPY:
    class IamApiClientActionsArgsDict(TypedDict):
        deactivate_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can deactivate the API client's credentials.
        """
        delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can remove the API client.
        """
        edit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the API client.
        """
        edit_apis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the `apis` the API client can access, same as `edit_auth`.
        """
        edit_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the `apis` the API client can access, same as `edit_apis`.
        """
        edit_groups: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the `groups` the API client can access.
        """
        edit_ip_acl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the 'ip acl' the API client can access.
        """
        edit_switch_account: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can update the API client's option to manage many accounts.
        """
        lock: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can lock the API client.
        """
        transfer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can transfer the API client to a new owner.
        """
        unlock: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can unlock the API client.
        """
elif False:
    IamApiClientActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientActionsArgs:
    def __init__(__self__, *,
                 deactivate_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_apis: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_groups: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_ip_acl: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_switch_account: Optional[pulumi.Input[_builtins.bool]] = None,
                 lock: Optional[pulumi.Input[_builtins.bool]] = None,
                 transfer: Optional[pulumi.Input[_builtins.bool]] = None,
                 unlock: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] deactivate_all: Whether you can deactivate the API client's credentials.
        :param pulumi.Input[_builtins.bool] delete: Whether you can remove the API client.
        :param pulumi.Input[_builtins.bool] edit: Whether you can update the API client.
        :param pulumi.Input[_builtins.bool] edit_apis: Whether you can update the `apis` the API client can access, same as `edit_auth`.
        :param pulumi.Input[_builtins.bool] edit_auth: Whether you can update the `apis` the API client can access, same as `edit_apis`.
        :param pulumi.Input[_builtins.bool] edit_groups: Whether you can update the `groups` the API client can access.
        :param pulumi.Input[_builtins.bool] edit_ip_acl: Whether you can update the 'ip acl' the API client can access.
        :param pulumi.Input[_builtins.bool] edit_switch_account: Whether you can update the API client's option to manage many accounts.
        :param pulumi.Input[_builtins.bool] lock: Whether you can lock the API client.
        :param pulumi.Input[_builtins.bool] transfer: Whether you can transfer the API client to a new owner.
        :param pulumi.Input[_builtins.bool] unlock: Whether you can unlock the API client.
        """
        if deactivate_all is not None:
            pulumi.set(__self__, "deactivate_all", deactivate_all)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit is not None:
            pulumi.set(__self__, "edit", edit)
        if edit_apis is not None:
            pulumi.set(__self__, "edit_apis", edit_apis)
        if edit_auth is not None:
            pulumi.set(__self__, "edit_auth", edit_auth)
        if edit_groups is not None:
            pulumi.set(__self__, "edit_groups", edit_groups)
        if edit_ip_acl is not None:
            pulumi.set(__self__, "edit_ip_acl", edit_ip_acl)
        if edit_switch_account is not None:
            pulumi.set(__self__, "edit_switch_account", edit_switch_account)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if transfer is not None:
            pulumi.set(__self__, "transfer", transfer)
        if unlock is not None:
            pulumi.set(__self__, "unlock", unlock)

    @_builtins.property
    @pulumi.getter(name="deactivateAll")
    def deactivate_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can deactivate the API client's credentials.
        """
        return pulumi.get(self, "deactivate_all")

    @deactivate_all.setter
    def deactivate_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deactivate_all", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can remove the API client.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def edit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the API client.
        """
        return pulumi.get(self, "edit")

    @edit.setter
    def edit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit", value)

    @_builtins.property
    @pulumi.getter(name="editApis")
    def edit_apis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the `apis` the API client can access, same as `edit_auth`.
        """
        return pulumi.get(self, "edit_apis")

    @edit_apis.setter
    def edit_apis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_apis", value)

    @_builtins.property
    @pulumi.getter(name="editAuth")
    def edit_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the `apis` the API client can access, same as `edit_apis`.
        """
        return pulumi.get(self, "edit_auth")

    @edit_auth.setter
    def edit_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_auth", value)

    @_builtins.property
    @pulumi.getter(name="editGroups")
    def edit_groups(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the `groups` the API client can access.
        """
        return pulumi.get(self, "edit_groups")

    @edit_groups.setter
    def edit_groups(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_groups", value)

    @_builtins.property
    @pulumi.getter(name="editIpAcl")
    def edit_ip_acl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the 'ip acl' the API client can access.
        """
        return pulumi.get(self, "edit_ip_acl")

    @edit_ip_acl.setter
    def edit_ip_acl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_ip_acl", value)

    @_builtins.property
    @pulumi.getter(name="editSwitchAccount")
    def edit_switch_account(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can update the API client's option to manage many accounts.
        """
        return pulumi.get(self, "edit_switch_account")

    @edit_switch_account.setter
    def edit_switch_account(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_switch_account", value)

    @_builtins.property
    @pulumi.getter
    def lock(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can lock the API client.
        """
        return pulumi.get(self, "lock")

    @lock.setter
    def lock(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock", value)

    @_builtins.property
    @pulumi.getter
    def transfer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can transfer the API client to a new owner.
        """
        return pulumi.get(self, "transfer")

    @transfer.setter
    def transfer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "transfer", value)

    @_builtins.property
    @pulumi.getter
    def unlock(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can unlock the API client.
        """
        return pulumi.get(self, "unlock")

    @unlock.setter
    def unlock(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unlock", value)


if not MYPY:
    class IamApiClientApiAccessArgsDict(TypedDict):
        all_accessible_apis: pulumi.Input[_builtins.bool]
        """
        Enables the API client to access a full set of available APIs.
        """
        apis: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamApiClientApiAccessApiArgsDict']]]]
        """
        The set of APIs the API client can access when `all_accessible_apis` is `false`.
        """
elif False:
    IamApiClientApiAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientApiAccessArgs:
    def __init__(__self__, *,
                 all_accessible_apis: pulumi.Input[_builtins.bool],
                 apis: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientApiAccessApiArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_accessible_apis: Enables the API client to access a full set of available APIs.
        :param pulumi.Input[Sequence[pulumi.Input['IamApiClientApiAccessApiArgs']]] apis: The set of APIs the API client can access when `all_accessible_apis` is `false`.
        """
        pulumi.set(__self__, "all_accessible_apis", all_accessible_apis)
        if apis is not None:
            pulumi.set(__self__, "apis", apis)

    @_builtins.property
    @pulumi.getter(name="allAccessibleApis")
    def all_accessible_apis(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables the API client to access a full set of available APIs.
        """
        return pulumi.get(self, "all_accessible_apis")

    @all_accessible_apis.setter
    def all_accessible_apis(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "all_accessible_apis", value)

    @_builtins.property
    @pulumi.getter
    def apis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientApiAccessApiArgs']]]]:
        """
        The set of APIs the API client can access when `all_accessible_apis` is `false`.
        """
        return pulumi.get(self, "apis")

    @apis.setter
    def apis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientApiAccessApiArgs']]]]):
        pulumi.set(self, "apis", value)


if not MYPY:
    class IamApiClientApiAccessApiArgsDict(TypedDict):
        access_level: pulumi.Input[_builtins.str]
        """
        The API client's access level on an API basis, either 'READ-ONLY', 'READ-WRITE', 'CREDENTIAL-READ-ONLY', or 'CREDENTIAL-READ-WRITE'.
        """
        api_id: pulumi.Input[_builtins.int]
        """
        A unique identifier of the API.
        """
        api_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the API.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable description for the API.
        """
        documentation_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A link to more information about the API.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies where the API can access resources.
        """
elif False:
    IamApiClientApiAccessApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientApiAccessApiArgs:
    def __init__(__self__, *,
                 access_level: pulumi.Input[_builtins.str],
                 api_id: pulumi.Input[_builtins.int],
                 api_name: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 documentation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: The API client's access level on an API basis, either 'READ-ONLY', 'READ-WRITE', 'CREDENTIAL-READ-ONLY', or 'CREDENTIAL-READ-WRITE'.
        :param pulumi.Input[_builtins.int] api_id: A unique identifier of the API.
        :param pulumi.Input[_builtins.str] api_name: A human-readable name for the API.
        :param pulumi.Input[_builtins.str] description: A human-readable description for the API.
        :param pulumi.Input[_builtins.str] documentation_url: A link to more information about the API.
        :param pulumi.Input[_builtins.str] endpoint: Specifies where the API can access resources.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "api_id", api_id)
        if api_name is not None:
            pulumi.set(__self__, "api_name", api_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> pulumi.Input[_builtins.str]:
        """
        The API client's access level on an API basis, either 'READ-ONLY', 'READ-WRITE', 'CREDENTIAL-READ-ONLY', or 'CREDENTIAL-READ-WRITE'.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier of the API.
        """
        return pulumi.get(self, "api_id")

    @api_id.setter
    def api_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "api_id", value)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the API.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable description for the API.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A link to more information about the API.
        """
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "documentation_url", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies where the API can access resources.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class IamApiClientCredentialArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input['IamApiClientCredentialActionsArgsDict']]
        """
        Actions available on the API client's credentials.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret.
        """
        client_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The part of the credential that identifies the API client.
        """
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ISO 8601 timestamp indicating when the credential was created.
        """
        credential_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        A unique identifier of the credential.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable description for the credential.
        """
        expires_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ISO 8601 timestamp indicating when the credential expires. The default expiration date is two years from the creation date.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether a credential is 'ACTIVE', 'INACTIVE', or 'DELETED'. Can be updated to 'ACTIVE' or 'INACTIVE' only.
        """
elif False:
    IamApiClientCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientCredentialArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input['IamApiClientCredentialActionsArgs']] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_token: Optional[pulumi.Input[_builtins.str]] = None,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_id: Optional[pulumi.Input[_builtins.int]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expires_on: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['IamApiClientCredentialActionsArgs'] actions: Actions available on the API client's credentials.
        :param pulumi.Input[_builtins.str] client_secret: The client secret.
        :param pulumi.Input[_builtins.str] client_token: The part of the credential that identifies the API client.
        :param pulumi.Input[_builtins.str] created_on: The ISO 8601 timestamp indicating when the credential was created.
        :param pulumi.Input[_builtins.int] credential_id: A unique identifier of the credential.
        :param pulumi.Input[_builtins.str] description: A human-readable description for the credential.
        :param pulumi.Input[_builtins.str] expires_on: The ISO 8601 timestamp indicating when the credential expires. The default expiration date is two years from the creation date.
        :param pulumi.Input[_builtins.str] status: Whether a credential is 'ACTIVE', 'INACTIVE', or 'DELETED'. Can be updated to 'ACTIVE' or 'INACTIVE' only.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expires_on is not None:
            pulumi.set(__self__, "expires_on", expires_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['IamApiClientCredentialActionsArgs']]:
        """
        Actions available on the API client's credentials.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['IamApiClientCredentialActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The part of the credential that identifies the API client.
        """
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_token", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ISO 8601 timestamp indicating when the credential was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A unique identifier of the credential.
        """
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "credential_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable description for the credential.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="expiresOn")
    def expires_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ISO 8601 timestamp indicating when the credential expires. The default expiration date is two years from the creation date.
        """
        return pulumi.get(self, "expires_on")

    @expires_on.setter
    def expires_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_on", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether a credential is 'ACTIVE', 'INACTIVE', or 'DELETED'. Can be updated to 'ACTIVE' or 'INACTIVE' only.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IamApiClientCredentialActionsArgsDict(TypedDict):
        activate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can activate the credential.
        """
        deactivate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can deactivate the credential.
        """
        delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can remove the credential.
        """
        edit_description: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can modify the credential's description.
        """
        edit_expiration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can modify the credential's expiration date.
        """
elif False:
    IamApiClientCredentialActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientCredentialActionsArgs:
    def __init__(__self__, *,
                 activate: Optional[pulumi.Input[_builtins.bool]] = None,
                 deactivate: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_description: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit_expiration: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] activate: Whether you can activate the credential.
        :param pulumi.Input[_builtins.bool] deactivate: Whether you can deactivate the credential.
        :param pulumi.Input[_builtins.bool] delete: Whether you can remove the credential.
        :param pulumi.Input[_builtins.bool] edit_description: Whether you can modify the credential's description.
        :param pulumi.Input[_builtins.bool] edit_expiration: Whether you can modify the credential's expiration date.
        """
        if activate is not None:
            pulumi.set(__self__, "activate", activate)
        if deactivate is not None:
            pulumi.set(__self__, "deactivate", deactivate)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit_description is not None:
            pulumi.set(__self__, "edit_description", edit_description)
        if edit_expiration is not None:
            pulumi.set(__self__, "edit_expiration", edit_expiration)

    @_builtins.property
    @pulumi.getter
    def activate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can activate the credential.
        """
        return pulumi.get(self, "activate")

    @activate.setter
    def activate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "activate", value)

    @_builtins.property
    @pulumi.getter
    def deactivate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can deactivate the credential.
        """
        return pulumi.get(self, "deactivate")

    @deactivate.setter
    def deactivate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deactivate", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can remove the credential.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter(name="editDescription")
    def edit_description(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can modify the credential's description.
        """
        return pulumi.get(self, "edit_description")

    @edit_description.setter
    def edit_description(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_description", value)

    @_builtins.property
    @pulumi.getter(name="editExpiration")
    def edit_expiration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can modify the credential's expiration date.
        """
        return pulumi.get(self, "edit_expiration")

    @edit_expiration.setter
    def edit_expiration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit_expiration", value)


if not MYPY:
    class IamApiClientGroupAccessArgsDict(TypedDict):
        clone_authorized_user_groups: pulumi.Input[_builtins.bool]
        """
        Sets the API client's group access the same as the authorized user.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupArgsDict']]]]
        """
        Groups the API client can access.
        """
elif False:
    IamApiClientGroupAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientGroupAccessArgs:
    def __init__(__self__, *,
                 clone_authorized_user_groups: pulumi.Input[_builtins.bool],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] clone_authorized_user_groups: Sets the API client's group access the same as the authorized user.
        :param pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupArgs']]] groups: Groups the API client can access.
        """
        pulumi.set(__self__, "clone_authorized_user_groups", clone_authorized_user_groups)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="cloneAuthorizedUserGroups")
    def clone_authorized_user_groups(self) -> pulumi.Input[_builtins.bool]:
        """
        Sets the API client's group access the same as the authorized user.
        """
        return pulumi.get(self, "clone_authorized_user_groups")

    @clone_authorized_user_groups.setter
    def clone_authorized_user_groups(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "clone_authorized_user_groups", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupArgs']]]]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class IamApiClientGroupAccessGroupArgsDict(TypedDict):
        group_id: pulumi.Input[_builtins.int]
        """
        A unique identifier for the group.
        """
        role_id: pulumi.Input[_builtins.int]
        """
        A unique identifier for the role.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the group.
        """
        is_blocked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks the API client access to the group's child groups.
        """
        parent_group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        A unique identifier for the parent group within the group tree.
        """
        role_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable description for the role to convey its use.
        """
        role_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the role.
        """
        sub_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgsDict']]]]
        """
        Groups the API client can access.
        """
elif False:
    IamApiClientGroupAccessGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientGroupAccessGroupArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[_builtins.int],
                 role_id: pulumi.Input[_builtins.int],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_blocked: Optional[pulumi.Input[_builtins.bool]] = None,
                 parent_group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 role_description: Optional[pulumi.Input[_builtins.str]] = None,
                 role_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_groups: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] group_id: A unique identifier for the group.
        :param pulumi.Input[_builtins.int] role_id: A unique identifier for the role.
        :param pulumi.Input[_builtins.str] group_name: A human-readable name for the group.
        :param pulumi.Input[_builtins.bool] is_blocked: Blocks the API client access to the group's child groups.
        :param pulumi.Input[_builtins.int] parent_group_id: A unique identifier for the parent group within the group tree.
        :param pulumi.Input[_builtins.str] role_description: A human-readable description for the role to convey its use.
        :param pulumi.Input[_builtins.str] role_name: A human-readable name for the role.
        :param pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "role_id", role_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_blocked is not None:
            pulumi.set(__self__, "is_blocked", is_blocked)
        if parent_group_id is not None:
            pulumi.set(__self__, "parent_group_id", parent_group_id)
        if role_description is not None:
            pulumi.set(__self__, "role_description", role_description)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if sub_groups is not None:
            pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier for the group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier for the role.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @is_blocked.setter
    def is_blocked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_blocked", value)

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @parent_group_id.setter
    def parent_group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "parent_group_id", value)

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable description for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @role_description.setter
    def role_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_description", value)

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_name", value)

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")

    @sub_groups.setter
    def sub_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]]):
        pulumi.set(self, "sub_groups", value)


if not MYPY:
    class IamApiClientGroupAccessGroupSubGroupArgsDict(TypedDict):
        group_id: pulumi.Input[_builtins.int]
        """
        A unique identifier for the group.
        """
        role_id: pulumi.Input[_builtins.int]
        """
        A unique identifier for the role.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the group.
        """
        is_blocked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks the API client access to the group's child groups.
        """
        parent_group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        A unique identifier for the parent group within the group tree.
        """
        role_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable description for the role to convey its use.
        """
        role_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable name for the role.
        """
        sub_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgsDict']]]]
        """
        Groups the API client can access.
        """
elif False:
    IamApiClientGroupAccessGroupSubGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientGroupAccessGroupSubGroupArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[_builtins.int],
                 role_id: pulumi.Input[_builtins.int],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_blocked: Optional[pulumi.Input[_builtins.bool]] = None,
                 parent_group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 role_description: Optional[pulumi.Input[_builtins.str]] = None,
                 role_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_groups: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] group_id: A unique identifier for the group.
        :param pulumi.Input[_builtins.int] role_id: A unique identifier for the role.
        :param pulumi.Input[_builtins.str] group_name: A human-readable name for the group.
        :param pulumi.Input[_builtins.bool] is_blocked: Blocks the API client access to the group's child groups.
        :param pulumi.Input[_builtins.int] parent_group_id: A unique identifier for the parent group within the group tree.
        :param pulumi.Input[_builtins.str] role_description: A human-readable description for the role to convey its use.
        :param pulumi.Input[_builtins.str] role_name: A human-readable name for the role.
        :param pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]] sub_groups: Groups the API client can access.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "role_id", role_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_blocked is not None:
            pulumi.set(__self__, "is_blocked", is_blocked)
        if parent_group_id is not None:
            pulumi.set(__self__, "parent_group_id", parent_group_id)
        if role_description is not None:
            pulumi.set(__self__, "role_description", role_description)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if sub_groups is not None:
            pulumi.set(__self__, "sub_groups", sub_groups)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier for the group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier for the role.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="isBlocked")
    def is_blocked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks the API client access to the group's child groups.
        """
        return pulumi.get(self, "is_blocked")

    @is_blocked.setter
    def is_blocked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_blocked", value)

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A unique identifier for the parent group within the group tree.
        """
        return pulumi.get(self, "parent_group_id")

    @parent_group_id.setter
    def parent_group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "parent_group_id", value)

    @_builtins.property
    @pulumi.getter(name="roleDescription")
    def role_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable description for the role to convey its use.
        """
        return pulumi.get(self, "role_description")

    @role_description.setter
    def role_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_description", value)

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable name for the role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_name", value)

    @_builtins.property
    @pulumi.getter(name="subGroups")
    def sub_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]]:
        """
        Groups the API client can access.
        """
        return pulumi.get(self, "sub_groups")

    @sub_groups.setter
    def sub_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IamApiClientGroupAccessGroupSubGroupArgs']]]]):
        pulumi.set(self, "sub_groups", value)


if not MYPY:
    class IamApiClientIpAclArgsDict(TypedDict):
        cidrs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        IP addresses or CIDR blocks the API client can access.
        """
        enable: pulumi.Input[_builtins.bool]
        """
        Enables the API client to access the IP access control list (ACL).
        """
elif False:
    IamApiClientIpAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientIpAclArgs:
    def __init__(__self__, *,
                 cidrs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cidrs: IP addresses or CIDR blocks the API client can access.
        :param pulumi.Input[_builtins.bool] enable: Enables the API client to access the IP access control list (ACL).
        """
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        IP addresses or CIDR blocks the API client can access.
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "cidrs", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables the API client to access the IP access control list (ACL).
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class IamApiClientPurgeOptionsArgsDict(TypedDict):
        can_purge_by_cache_tag: pulumi.Input[_builtins.bool]
        """
        Whether the API client can purge content by cache tag.
        """
        can_purge_by_cp_code: pulumi.Input[_builtins.bool]
        """
        Whether the API client can purge content by CP code.
        """
        cp_code_access: pulumi.Input['IamApiClientPurgeOptionsCpCodeAccessArgsDict']
        """
        CP codes the API client can purge.
        """
elif False:
    IamApiClientPurgeOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientPurgeOptionsArgs:
    def __init__(__self__, *,
                 can_purge_by_cache_tag: pulumi.Input[_builtins.bool],
                 can_purge_by_cp_code: pulumi.Input[_builtins.bool],
                 cp_code_access: pulumi.Input['IamApiClientPurgeOptionsCpCodeAccessArgs']):
        """
        :param pulumi.Input[_builtins.bool] can_purge_by_cache_tag: Whether the API client can purge content by cache tag.
        :param pulumi.Input[_builtins.bool] can_purge_by_cp_code: Whether the API client can purge content by CP code.
        :param pulumi.Input['IamApiClientPurgeOptionsCpCodeAccessArgs'] cp_code_access: CP codes the API client can purge.
        """
        pulumi.set(__self__, "can_purge_by_cache_tag", can_purge_by_cache_tag)
        pulumi.set(__self__, "can_purge_by_cp_code", can_purge_by_cp_code)
        pulumi.set(__self__, "cp_code_access", cp_code_access)

    @_builtins.property
    @pulumi.getter(name="canPurgeByCacheTag")
    def can_purge_by_cache_tag(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the API client can purge content by cache tag.
        """
        return pulumi.get(self, "can_purge_by_cache_tag")

    @can_purge_by_cache_tag.setter
    def can_purge_by_cache_tag(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "can_purge_by_cache_tag", value)

    @_builtins.property
    @pulumi.getter(name="canPurgeByCpCode")
    def can_purge_by_cp_code(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the API client can purge content by CP code.
        """
        return pulumi.get(self, "can_purge_by_cp_code")

    @can_purge_by_cp_code.setter
    def can_purge_by_cp_code(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "can_purge_by_cp_code", value)

    @_builtins.property
    @pulumi.getter(name="cpCodeAccess")
    def cp_code_access(self) -> pulumi.Input['IamApiClientPurgeOptionsCpCodeAccessArgs']:
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_code_access")

    @cp_code_access.setter
    def cp_code_access(self, value: pulumi.Input['IamApiClientPurgeOptionsCpCodeAccessArgs']):
        pulumi.set(self, "cp_code_access", value)


if not MYPY:
    class IamApiClientPurgeOptionsCpCodeAccessArgsDict(TypedDict):
        all_current_and_new_cp_codes: pulumi.Input[_builtins.bool]
        """
        Whether the API can purge content by all current and new CP codes.
        """
        cp_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        CP codes the API client can purge.
        """
elif False:
    IamApiClientPurgeOptionsCpCodeAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamApiClientPurgeOptionsCpCodeAccessArgs:
    def __init__(__self__, *,
                 all_current_and_new_cp_codes: pulumi.Input[_builtins.bool],
                 cp_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all_current_and_new_cp_codes: Whether the API can purge content by all current and new CP codes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] cp_codes: CP codes the API client can purge.
        """
        pulumi.set(__self__, "all_current_and_new_cp_codes", all_current_and_new_cp_codes)
        if cp_codes is not None:
            pulumi.set(__self__, "cp_codes", cp_codes)

    @_builtins.property
    @pulumi.getter(name="allCurrentAndNewCpCodes")
    def all_current_and_new_cp_codes(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the API can purge content by all current and new CP codes.
        """
        return pulumi.get(self, "all_current_and_new_cp_codes")

    @all_current_and_new_cp_codes.setter
    def all_current_and_new_cp_codes(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "all_current_and_new_cp_codes", value)

    @_builtins.property
    @pulumi.getter(name="cpCodes")
    def cp_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        CP codes the API client can purge.
        """
        return pulumi.get(self, "cp_codes")

    @cp_codes.setter
    def cp_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "cp_codes", value)


if not MYPY:
    class IamCidrBlockActionsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        edit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
elif False:
    IamCidrBlockActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamCidrBlockActionsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 edit: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete: Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        :param pulumi.Input[_builtins.bool] edit: Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if edit is not None:
            pulumi.set(__self__, "edit", edit)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can delete this CIDR block. You can't delete a CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def edit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether you can edit this CIDR block. You can't edit CIDR block from an IP address not on the allowlist, or if the CIDR block is the only one on the allowlist.
        """
        return pulumi.get(self, "edit")

    @edit.setter
    def edit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "edit", value)


if not MYPY:
    class IamUserUserNotificationsArgsDict(TypedDict):
        enable_email_notifications: pulumi.Input[_builtins.bool]
        """
        Enables email notifications.
        """
        password_expiry: pulumi.Input[_builtins.bool]
        """
        Enables notifications for expiring passwords.
        """
        proactives: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Products for which the user gets notifications for service issues.
        """
        upgrades: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Products for which the user receives notifications for upgrades.
        """
        api_client_credential_expiry_notification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables notifications for expiring API client credentials.
        """
        new_user_notification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables notifications for group administrators when the user creates other new users.
        """
elif False:
    IamUserUserNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamUserUserNotificationsArgs:
    def __init__(__self__, *,
                 enable_email_notifications: pulumi.Input[_builtins.bool],
                 password_expiry: pulumi.Input[_builtins.bool],
                 proactives: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 upgrades: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 api_client_credential_expiry_notification: Optional[pulumi.Input[_builtins.bool]] = None,
                 new_user_notification: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_email_notifications: Enables email notifications.
        :param pulumi.Input[_builtins.bool] password_expiry: Enables notifications for expiring passwords.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] proactives: Products for which the user gets notifications for service issues.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] upgrades: Products for which the user receives notifications for upgrades.
        :param pulumi.Input[_builtins.bool] api_client_credential_expiry_notification: Enables notifications for expiring API client credentials.
        :param pulumi.Input[_builtins.bool] new_user_notification: Enables notifications for group administrators when the user creates other new users.
        """
        pulumi.set(__self__, "enable_email_notifications", enable_email_notifications)
        pulumi.set(__self__, "password_expiry", password_expiry)
        pulumi.set(__self__, "proactives", proactives)
        pulumi.set(__self__, "upgrades", upgrades)
        if api_client_credential_expiry_notification is not None:
            pulumi.set(__self__, "api_client_credential_expiry_notification", api_client_credential_expiry_notification)
        if new_user_notification is not None:
            pulumi.set(__self__, "new_user_notification", new_user_notification)

    @_builtins.property
    @pulumi.getter(name="enableEmailNotifications")
    def enable_email_notifications(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables email notifications.
        """
        return pulumi.get(self, "enable_email_notifications")

    @enable_email_notifications.setter
    def enable_email_notifications(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_email_notifications", value)

    @_builtins.property
    @pulumi.getter(name="passwordExpiry")
    def password_expiry(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables notifications for expiring passwords.
        """
        return pulumi.get(self, "password_expiry")

    @password_expiry.setter
    def password_expiry(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "password_expiry", value)

    @_builtins.property
    @pulumi.getter
    def proactives(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Products for which the user gets notifications for service issues.
        """
        return pulumi.get(self, "proactives")

    @proactives.setter
    def proactives(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "proactives", value)

    @_builtins.property
    @pulumi.getter
    def upgrades(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Products for which the user receives notifications for upgrades.
        """
        return pulumi.get(self, "upgrades")

    @upgrades.setter
    def upgrades(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "upgrades", value)

    @_builtins.property
    @pulumi.getter(name="apiClientCredentialExpiryNotification")
    def api_client_credential_expiry_notification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables notifications for expiring API client credentials.
        """
        return pulumi.get(self, "api_client_credential_expiry_notification")

    @api_client_credential_expiry_notification.setter
    def api_client_credential_expiry_notification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "api_client_credential_expiry_notification", value)

    @_builtins.property
    @pulumi.getter(name="newUserNotification")
    def new_user_notification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables notifications for group administrators when the user creates other new users.
        """
        return pulumi.get(self, "new_user_notification")

    @new_user_notification.setter
    def new_user_notification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "new_user_notification", value)


if not MYPY:
    class MtlskeystoreClientCertificateAkamaiTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource create timeout. By default it's 30m.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource update timeout. By default it's 30m.
        """
elif False:
    MtlskeystoreClientCertificateAkamaiTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateAkamaiTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable resource create timeout. By default it's 30m.
        :param pulumi.Input[_builtins.str] update: Optional configurable resource update timeout. By default it's 30m.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource create timeout. By default it's 30m.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource update timeout. By default it's 30m.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class MtlskeystoreClientCertificateAkamaiVersionArgsDict(TypedDict):
        certificate_block: NotRequired[pulumi.Input['MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgsDict']]
        """
        Details of the certificate block for the client certificate version.
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user who created the client certificate version.
        """
        created_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's creation.
        """
        delete_requested_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        """
        elliptic_curve: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        """
        expiry_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating when the client certificate version expires.
        """
        issued_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's availability.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signing entity of the client certificate version.
        """
        key_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        """
        key_size_in_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key length of the client certificate version when key algorithm `RSA` is used.
        """
        scheduled_delete_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        """
        signature_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the algorithm that secures the data exchange between the edge server and origin.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate version status. Possible values: `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key's entity stored in the client certificate version's subject public key field.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique identifier of the client certificate version.
        """
        version_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
elif False:
    MtlskeystoreClientCertificateAkamaiVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateAkamaiVersionArgs:
    def __init__(__self__, *,
                 certificate_block: Optional[pulumi.Input['MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs']] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_requested_date: Optional[pulumi.Input[_builtins.str]] = None,
                 elliptic_curve: Optional[pulumi.Input[_builtins.str]] = None,
                 expiry_date: Optional[pulumi.Input[_builtins.str]] = None,
                 issued_date: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 key_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 key_size_in_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_delete_date: Optional[pulumi.Input[_builtins.str]] = None,
                 signature_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None,
                 version_guid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs'] certificate_block: Details of the certificate block for the client certificate version.
        :param pulumi.Input[_builtins.str] created_by: The user who created the client certificate version.
        :param pulumi.Input[_builtins.str] created_date: An ISO 8601 timestamp indicating the client certificate version's creation.
        :param pulumi.Input[_builtins.str] delete_requested_date: An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        :param pulumi.Input[_builtins.str] elliptic_curve: Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        :param pulumi.Input[_builtins.str] expiry_date: An ISO 8601 timestamp indicating when the client certificate version expires.
        :param pulumi.Input[_builtins.str] issued_date: An ISO 8601 timestamp indicating the client certificate version's availability.
        :param pulumi.Input[_builtins.str] issuer: The signing entity of the client certificate version.
        :param pulumi.Input[_builtins.str] key_algorithm: Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        :param pulumi.Input[_builtins.str] key_size_in_bytes: The private key length of the client certificate version when key algorithm `RSA` is used.
        :param pulumi.Input[_builtins.str] scheduled_delete_date: An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        :param pulumi.Input[_builtins.str] signature_algorithm: Specifies the algorithm that secures the data exchange between the edge server and origin.
        :param pulumi.Input[_builtins.str] status: The client certificate version status. Possible values: `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        :param pulumi.Input[_builtins.str] subject: The public key's entity stored in the client certificate version's subject public key field.
        :param pulumi.Input[_builtins.int] version: The unique identifier of the client certificate version.
        :param pulumi.Input[_builtins.str] version_guid: Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
        if certificate_block is not None:
            pulumi.set(__self__, "certificate_block", certificate_block)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if delete_requested_date is not None:
            pulumi.set(__self__, "delete_requested_date", delete_requested_date)
        if elliptic_curve is not None:
            pulumi.set(__self__, "elliptic_curve", elliptic_curve)
        if expiry_date is not None:
            pulumi.set(__self__, "expiry_date", expiry_date)
        if issued_date is not None:
            pulumi.set(__self__, "issued_date", issued_date)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if key_algorithm is not None:
            pulumi.set(__self__, "key_algorithm", key_algorithm)
        if key_size_in_bytes is not None:
            pulumi.set(__self__, "key_size_in_bytes", key_size_in_bytes)
        if scheduled_delete_date is not None:
            pulumi.set(__self__, "scheduled_delete_date", scheduled_delete_date)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="certificateBlock")
    def certificate_block(self) -> Optional[pulumi.Input['MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs']]:
        """
        Details of the certificate block for the client certificate version.
        """
        return pulumi.get(self, "certificate_block")

    @certificate_block.setter
    def certificate_block(self, value: Optional[pulumi.Input['MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs']]):
        pulumi.set(self, "certificate_block", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user who created the client certificate version.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's creation.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="deleteRequestedDate")
    def delete_requested_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        """
        return pulumi.get(self, "delete_requested_date")

    @delete_requested_date.setter
    def delete_requested_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_requested_date", value)

    @_builtins.property
    @pulumi.getter(name="ellipticCurve")
    def elliptic_curve(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        """
        return pulumi.get(self, "elliptic_curve")

    @elliptic_curve.setter
    def elliptic_curve(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "elliptic_curve", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating when the client certificate version expires.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's availability.
        """
        return pulumi.get(self, "issued_date")

    @issued_date.setter
    def issued_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issued_date", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signing entity of the client certificate version.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="keyAlgorithm")
    def key_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        """
        return pulumi.get(self, "key_algorithm")

    @key_algorithm.setter
    def key_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="keySizeInBytes")
    def key_size_in_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key length of the client certificate version when key algorithm `RSA` is used.
        """
        return pulumi.get(self, "key_size_in_bytes")

    @key_size_in_bytes.setter
    def key_size_in_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_size_in_bytes", value)

    @_builtins.property
    @pulumi.getter(name="scheduledDeleteDate")
    def scheduled_delete_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        """
        return pulumi.get(self, "scheduled_delete_date")

    @scheduled_delete_date.setter
    def scheduled_delete_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_delete_date", value)

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the algorithm that secures the data exchange between the edge server and origin.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signature_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate version status. Possible values: `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key's entity stored in the client certificate version's subject public key field.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique identifier of the client certificate version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
        return pulumi.get(self, "version_guid")

    @version_guid.setter
    def version_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_guid", value)


if not MYPY:
    class MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgsDict(TypedDict):
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text representation of the client certificate in PEM format.
        """
        trust_chain: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text representation of the trust chain in PEM format.
        """
elif False:
    MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateAkamaiVersionCertificateBlockArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_chain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate: A text representation of the client certificate in PEM format.
        :param pulumi.Input[_builtins.str] trust_chain: A text representation of the trust chain in PEM format.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if trust_chain is not None:
            pulumi.set(__self__, "trust_chain", trust_chain)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text representation of the client certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="trustChain")
    def trust_chain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text representation of the trust chain in PEM format.
        """
        return pulumi.get(self, "trust_chain")

    @trust_chain.setter
    def trust_chain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_chain", value)


if not MYPY:
    class MtlskeystoreClientCertificateThirdPartyVersionsArgsDict(TypedDict):
        certificate_block: NotRequired[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgsDict']]
        """
        Details of the certificate block for the client certificate version.
        """
        certificate_submitted_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user who uploaded the THIRD_PARTY client certificate version. Appears as null if not specified.
        """
        certificate_submitted_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating when the THIRD_PARTY signer client certificate version was uploaded. Appears as null if not specified.
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user who created the client certificate version.
        """
        created_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's creation.
        """
        csr_block: NotRequired[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgsDict']]
        """
        Details of the Certificate Signing Request (CSR) for the client certificate version.
        """
        delete_requested_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        """
        elliptic_curve: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        """
        expiry_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating when the client certificate version expires.
        """
        issued_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's availability.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signing entity of the client certificate version.
        """
        key_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        """
        key_size_in_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key length of the client certificate version when key algorithm `RSA` is used.
        """
        scheduled_delete_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        """
        signature_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the algorithm that secures the data exchange between the edge server and origin.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate version status. Possible values: `AWAITING_SIGNED_CERTIFICATE`, `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key's entity stored in the client certificate version's subject public key field.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique identifier of the client certificate version.
        """
        version_guid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
elif False:
    MtlskeystoreClientCertificateThirdPartyVersionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateThirdPartyVersionsArgs:
    def __init__(__self__, *,
                 certificate_block: Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs']] = None,
                 certificate_submitted_by: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_submitted_date: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date: Optional[pulumi.Input[_builtins.str]] = None,
                 csr_block: Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs']] = None,
                 delete_requested_date: Optional[pulumi.Input[_builtins.str]] = None,
                 elliptic_curve: Optional[pulumi.Input[_builtins.str]] = None,
                 expiry_date: Optional[pulumi.Input[_builtins.str]] = None,
                 issued_date: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 key_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 key_size_in_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduled_delete_date: Optional[pulumi.Input[_builtins.str]] = None,
                 signature_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None,
                 version_guid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs'] certificate_block: Details of the certificate block for the client certificate version.
        :param pulumi.Input[_builtins.str] certificate_submitted_by: The user who uploaded the THIRD_PARTY client certificate version. Appears as null if not specified.
        :param pulumi.Input[_builtins.str] certificate_submitted_date: An ISO 8601 timestamp indicating when the THIRD_PARTY signer client certificate version was uploaded. Appears as null if not specified.
        :param pulumi.Input[_builtins.str] created_by: The user who created the client certificate version.
        :param pulumi.Input[_builtins.str] created_date: An ISO 8601 timestamp indicating the client certificate version's creation.
        :param pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs'] csr_block: Details of the Certificate Signing Request (CSR) for the client certificate version.
        :param pulumi.Input[_builtins.str] delete_requested_date: An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        :param pulumi.Input[_builtins.str] elliptic_curve: Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        :param pulumi.Input[_builtins.str] expiry_date: An ISO 8601 timestamp indicating when the client certificate version expires.
        :param pulumi.Input[_builtins.str] issued_date: An ISO 8601 timestamp indicating the client certificate version's availability.
        :param pulumi.Input[_builtins.str] issuer: The signing entity of the client certificate version.
        :param pulumi.Input[_builtins.str] key_algorithm: Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        :param pulumi.Input[_builtins.str] key_size_in_bytes: The private key length of the client certificate version when key algorithm `RSA` is used.
        :param pulumi.Input[_builtins.str] scheduled_delete_date: An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        :param pulumi.Input[_builtins.str] signature_algorithm: Specifies the algorithm that secures the data exchange between the edge server and origin.
        :param pulumi.Input[_builtins.str] status: The client certificate version status. Possible values: `AWAITING_SIGNED_CERTIFICATE`, `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        :param pulumi.Input[_builtins.str] subject: The public key's entity stored in the client certificate version's subject public key field.
        :param pulumi.Input[_builtins.int] version: The unique identifier of the client certificate version.
        :param pulumi.Input[_builtins.str] version_guid: Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
        if certificate_block is not None:
            pulumi.set(__self__, "certificate_block", certificate_block)
        if certificate_submitted_by is not None:
            pulumi.set(__self__, "certificate_submitted_by", certificate_submitted_by)
        if certificate_submitted_date is not None:
            pulumi.set(__self__, "certificate_submitted_date", certificate_submitted_date)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if csr_block is not None:
            pulumi.set(__self__, "csr_block", csr_block)
        if delete_requested_date is not None:
            pulumi.set(__self__, "delete_requested_date", delete_requested_date)
        if elliptic_curve is not None:
            pulumi.set(__self__, "elliptic_curve", elliptic_curve)
        if expiry_date is not None:
            pulumi.set(__self__, "expiry_date", expiry_date)
        if issued_date is not None:
            pulumi.set(__self__, "issued_date", issued_date)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if key_algorithm is not None:
            pulumi.set(__self__, "key_algorithm", key_algorithm)
        if key_size_in_bytes is not None:
            pulumi.set(__self__, "key_size_in_bytes", key_size_in_bytes)
        if scheduled_delete_date is not None:
            pulumi.set(__self__, "scheduled_delete_date", scheduled_delete_date)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_guid is not None:
            pulumi.set(__self__, "version_guid", version_guid)

    @_builtins.property
    @pulumi.getter(name="certificateBlock")
    def certificate_block(self) -> Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs']]:
        """
        Details of the certificate block for the client certificate version.
        """
        return pulumi.get(self, "certificate_block")

    @certificate_block.setter
    def certificate_block(self, value: Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs']]):
        pulumi.set(self, "certificate_block", value)

    @_builtins.property
    @pulumi.getter(name="certificateSubmittedBy")
    def certificate_submitted_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user who uploaded the THIRD_PARTY client certificate version. Appears as null if not specified.
        """
        return pulumi.get(self, "certificate_submitted_by")

    @certificate_submitted_by.setter
    def certificate_submitted_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_submitted_by", value)

    @_builtins.property
    @pulumi.getter(name="certificateSubmittedDate")
    def certificate_submitted_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating when the THIRD_PARTY signer client certificate version was uploaded. Appears as null if not specified.
        """
        return pulumi.get(self, "certificate_submitted_date")

    @certificate_submitted_date.setter
    def certificate_submitted_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_submitted_date", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user who created the client certificate version.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's creation.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="csrBlock")
    def csr_block(self) -> Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs']]:
        """
        Details of the Certificate Signing Request (CSR) for the client certificate version.
        """
        return pulumi.get(self, "csr_block")

    @csr_block.setter
    def csr_block(self, value: Optional[pulumi.Input['MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs']]):
        pulumi.set(self, "csr_block", value)

    @_builtins.property
    @pulumi.getter(name="deleteRequestedDate")
    def delete_requested_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion request. Appears as null if there's no request.
        """
        return pulumi.get(self, "delete_requested_date")

    @delete_requested_date.setter
    def delete_requested_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_requested_date", value)

    @_builtins.property
    @pulumi.getter(name="ellipticCurve")
    def elliptic_curve(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key elliptic curve when key algorithm `ECDSA` is used.
        """
        return pulumi.get(self, "elliptic_curve")

    @elliptic_curve.setter
    def elliptic_curve(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "elliptic_curve", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating when the client certificate version expires.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's availability.
        """
        return pulumi.get(self, "issued_date")

    @issued_date.setter
    def issued_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issued_date", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signing entity of the client certificate version.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="keyAlgorithm")
    def key_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the client certificate version's encryption algorithm. Supported values are `RSA` and `ECDSA`.
        """
        return pulumi.get(self, "key_algorithm")

    @key_algorithm.setter
    def key_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="keySizeInBytes")
    def key_size_in_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key length of the client certificate version when key algorithm `RSA` is used.
        """
        return pulumi.get(self, "key_size_in_bytes")

    @key_size_in_bytes.setter
    def key_size_in_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_size_in_bytes", value)

    @_builtins.property
    @pulumi.getter(name="scheduledDeleteDate")
    def scheduled_delete_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ISO 8601 timestamp indicating the client certificate version's deletion. Appears as null if there's no request.
        """
        return pulumi.get(self, "scheduled_delete_date")

    @scheduled_delete_date.setter
    def scheduled_delete_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduled_delete_date", value)

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the algorithm that secures the data exchange between the edge server and origin.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signature_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate version status. Possible values: `AWAITING_SIGNED_CERTIFICATE`, `DEPLOYMENT_PENDING`, `DEPLOYED`, or `DELETE_PENDING`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key's entity stored in the client certificate version's subject public key field.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique identifier of the client certificate version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionGuid")
    def version_guid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the client certificate version. Use it to configure mutual authentication (mTLS) sessions between the origin and edge servers in Property Manager's Mutual TLS Origin Keystore behavior.
        """
        return pulumi.get(self, "version_guid")

    @version_guid.setter
    def version_guid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_guid", value)


if not MYPY:
    class MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgsDict(TypedDict):
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text representation of the client certificate in PEM format.
        """
        trust_chain: NotRequired[pulumi.Input[_builtins.str]]
        """
        A text representation of the trust chain in PEM format.
        """
elif False:
    MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateThirdPartyVersionsCertificateBlockArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_chain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate: A text representation of the client certificate in PEM format.
        :param pulumi.Input[_builtins.str] trust_chain: A text representation of the trust chain in PEM format.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if trust_chain is not None:
            pulumi.set(__self__, "trust_chain", trust_chain)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text representation of the client certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="trustChain")
    def trust_chain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A text representation of the trust chain in PEM format.
        """
        return pulumi.get(self, "trust_chain")

    @trust_chain.setter
    def trust_chain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_chain", value)


if not MYPY:
    class MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgsDict(TypedDict):
        csr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text of the certificate signing request.
        """
        key_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the client certificate's encryption algorithm.
        """
elif False:
    MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateThirdPartyVersionsCsrBlockArgs:
    def __init__(__self__, *,
                 csr: Optional[pulumi.Input[_builtins.str]] = None,
                 key_algorithm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] csr: Text of the certificate signing request.
        :param pulumi.Input[_builtins.str] key_algorithm: Identifies the client certificate's encryption algorithm.
        """
        if csr is not None:
            pulumi.set(__self__, "csr", csr)
        if key_algorithm is not None:
            pulumi.set(__self__, "key_algorithm", key_algorithm)

    @_builtins.property
    @pulumi.getter
    def csr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text of the certificate signing request.
        """
        return pulumi.get(self, "csr")

    @csr.setter
    def csr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "csr", value)

    @_builtins.property
    @pulumi.getter(name="keyAlgorithm")
    def key_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the client certificate's encryption algorithm.
        """
        return pulumi.get(self, "key_algorithm")

    @key_algorithm.setter
    def key_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_algorithm", value)


if not MYPY:
    class MtlskeystoreClientCertificateUploadTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource create timeout. By default it's 30m.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource update timeout. By default it's 30m.
        """
elif False:
    MtlskeystoreClientCertificateUploadTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlskeystoreClientCertificateUploadTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable resource create timeout. By default it's 30m.
        :param pulumi.Input[_builtins.str] update: Optional configurable resource update timeout. By default it's 30m.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource create timeout. By default it's 30m.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource update timeout. By default it's 30m.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class MtlstruststoreCaSetActivationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource create timeout. By default it's 1h.
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource delete timeout. By default it's 1h.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource update timeout. By default it's 1h.
        """
elif False:
    MtlstruststoreCaSetActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlstruststoreCaSetActivationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable resource create timeout. By default it's 1h.
        :param pulumi.Input[_builtins.str] delete: Optional configurable resource delete timeout. By default it's 1h.
        :param pulumi.Input[_builtins.str] update: Optional configurable resource update timeout. By default it's 1h.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource create timeout. By default it's 1h.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource delete timeout. By default it's 1h.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource update timeout. By default it's 1h.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class MtlstruststoreCaSetCertificateArgsDict(TypedDict):
        certificate_pem: pulumi.Input[_builtins.str]
        """
        The certificate in PEM format, as found in a Base64 ASCII encoded file.
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user who created this CA certificate.
        """
        created_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the CA certificate was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional description for the certificate.
        """
        end_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate's ISO 8601 formatted expiration date.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fingerprint of the certificate.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate's issuer.
        """
        serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique serial number of the certificate.
        """
        signature_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signature algorithm of the CA certificate.
        """
        start_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The start date of the certificate.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate's subject field.
        """
elif False:
    MtlstruststoreCaSetCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlstruststoreCaSetCertificateArgs:
    def __init__(__self__, *,
                 certificate_pem: pulumi.Input[_builtins.str],
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 created_date: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 end_date: Optional[pulumi.Input[_builtins.str]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 signature_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 start_date: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_pem: The certificate in PEM format, as found in a Base64 ASCII encoded file.
        :param pulumi.Input[_builtins.str] created_by: The user who created this CA certificate.
        :param pulumi.Input[_builtins.str] created_date: When the CA certificate was created.
        :param pulumi.Input[_builtins.str] description: Optional description for the certificate.
        :param pulumi.Input[_builtins.str] end_date: The certificate's ISO 8601 formatted expiration date.
        :param pulumi.Input[_builtins.str] fingerprint: The fingerprint of the certificate.
        :param pulumi.Input[_builtins.str] issuer: The certificate's issuer.
        :param pulumi.Input[_builtins.str] serial_number: The unique serial number of the certificate.
        :param pulumi.Input[_builtins.str] signature_algorithm: The signature algorithm of the CA certificate.
        :param pulumi.Input[_builtins.str] start_date: The start date of the certificate.
        :param pulumi.Input[_builtins.str] subject: The certificate's subject field.
        """
        pulumi.set(__self__, "certificate_pem", certificate_pem)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="certificatePem")
    def certificate_pem(self) -> pulumi.Input[_builtins.str]:
        """
        The certificate in PEM format, as found in a Base64 ASCII encoded file.
        """
        return pulumi.get(self, "certificate_pem")

    @certificate_pem.setter
    def certificate_pem(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_pem", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user who created this CA certificate.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the CA certificate was created.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional description for the certificate.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate's ISO 8601 formatted expiration date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fingerprint of the certificate.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate's issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique serial number of the certificate.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signature algorithm of the CA certificate.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signature_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The start date of the certificate.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_date", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate's subject field.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class MtlstruststoreCaSetTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable resource delete timeout. By default it's 1h.
        """
elif False:
    MtlstruststoreCaSetTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlstruststoreCaSetTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete: Optional configurable resource delete timeout. By default it's 1h.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable resource delete timeout. By default it's 1h.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class PropertyActivationComplianceRecordArgsDict(TypedDict):
        noncompliance_reason_emergency: NotRequired[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        noncompliance_reason_no_production_traffic: NotRequired[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        noncompliance_reason_none: NotRequired[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoneArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        noncompliance_reason_other: NotRequired[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonOtherArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
elif False:
    PropertyActivationComplianceRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationComplianceRecordArgs:
    def __init__(__self__, *,
                 noncompliance_reason_emergency: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs']] = None,
                 noncompliance_reason_no_production_traffic: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']] = None,
                 noncompliance_reason_none: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs']] = None,
                 noncompliance_reason_other: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs']] = None):
        """
        :param pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs'] noncompliance_reason_emergency: Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        :param pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs'] noncompliance_reason_no_production_traffic: Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        :param pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs'] noncompliance_reason_none: Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        :param pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs'] noncompliance_reason_other: Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        if noncompliance_reason_emergency is not None:
            pulumi.set(__self__, "noncompliance_reason_emergency", noncompliance_reason_emergency)
        if noncompliance_reason_no_production_traffic is not None:
            pulumi.set(__self__, "noncompliance_reason_no_production_traffic", noncompliance_reason_no_production_traffic)
        if noncompliance_reason_none is not None:
            pulumi.set(__self__, "noncompliance_reason_none", noncompliance_reason_none)
        if noncompliance_reason_other is not None:
            pulumi.set(__self__, "noncompliance_reason_other", noncompliance_reason_other)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonEmergency")
    def noncompliance_reason_emergency(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        return pulumi.get(self, "noncompliance_reason_emergency")

    @noncompliance_reason_emergency.setter
    def noncompliance_reason_emergency(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs']]):
        pulumi.set(self, "noncompliance_reason_emergency", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNoProductionTraffic")
    def noncompliance_reason_no_production_traffic(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        return pulumi.get(self, "noncompliance_reason_no_production_traffic")

    @noncompliance_reason_no_production_traffic.setter
    def noncompliance_reason_no_production_traffic(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']]):
        pulumi.set(self, "noncompliance_reason_no_production_traffic", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNone")
    def noncompliance_reason_none(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        return pulumi.get(self, "noncompliance_reason_none")

    @noncompliance_reason_none.setter
    def noncompliance_reason_none(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs']]):
        pulumi.set(self, "noncompliance_reason_none", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonOther")
    def noncompliance_reason_other(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        return pulumi.get(self, "noncompliance_reason_other")

    @noncompliance_reason_other.setter
    def noncompliance_reason_other(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs']]):
        pulumi.set(self, "noncompliance_reason_other", value)


if not MYPY:
    class PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict(TypedDict):
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationComplianceRecordNoncomplianceReasonEmergencyArgs:
    def __init__(__self__, *,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict(TypedDict):
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs:
    def __init__(__self__, *,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyActivationComplianceRecordNoncomplianceReasonNoneArgsDict(TypedDict):
        customer_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the customer
        """
        peer_reviewed_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies person who has independently approved the activation request
        """
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
        unit_tested: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the metadata to activate has been fully tested
        """
elif False:
    PropertyActivationComplianceRecordNoncomplianceReasonNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationComplianceRecordNoncomplianceReasonNoneArgs:
    def __init__(__self__, *,
                 customer_email: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_reviewed_by: Optional[pulumi.Input[_builtins.str]] = None,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_tested: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_email: Identifies the customer
        :param pulumi.Input[_builtins.str] peer_reviewed_by: Identifies person who has independently approved the activation request
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        :param pulumi.Input[_builtins.bool] unit_tested: Whether the metadata to activate has been fully tested
        """
        if customer_email is not None:
            pulumi.set(__self__, "customer_email", customer_email)
        if peer_reviewed_by is not None:
            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)
        if unit_tested is not None:
            pulumi.set(__self__, "unit_tested", unit_tested)

    @_builtins.property
    @pulumi.getter(name="customerEmail")
    def customer_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the customer
        """
        return pulumi.get(self, "customer_email")

    @customer_email.setter
    def customer_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_email", value)

    @_builtins.property
    @pulumi.getter(name="peerReviewedBy")
    def peer_reviewed_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies person who has independently approved the activation request
        """
        return pulumi.get(self, "peer_reviewed_by")

    @peer_reviewed_by.setter
    def peer_reviewed_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_reviewed_by", value)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)

    @_builtins.property
    @pulumi.getter(name="unitTested")
    def unit_tested(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the metadata to activate has been fully tested
        """
        return pulumi.get(self, "unit_tested")

    @unit_tested.setter
    def unit_tested(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unit_tested", value)


if not MYPY:
    class PropertyActivationComplianceRecordNoncomplianceReasonOtherArgsDict(TypedDict):
        other_noncompliance_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyActivationComplianceRecordNoncomplianceReasonOtherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationComplianceRecordNoncomplianceReasonOtherArgs:
    def __init__(__self__, *,
                 other_noncompliance_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] other_noncompliance_reason: Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if other_noncompliance_reason is not None:
            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="otherNoncomplianceReason")
    def other_noncompliance_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        return pulumi.get(self, "other_noncompliance_reason")

    @other_noncompliance_reason.setter
    def other_noncompliance_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "other_noncompliance_reason", value)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyActivationRuleErrorArgsDict(TypedDict):
        behavior_name: NotRequired[pulumi.Input[_builtins.str]]
        detail: NotRequired[pulumi.Input[_builtins.str]]
        error_location: NotRequired[pulumi.Input[_builtins.str]]
        instance: NotRequired[pulumi.Input[_builtins.str]]
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        title: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyActivationRuleErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationRuleErrorArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 error_location: Optional[pulumi.Input[_builtins.str]] = None,
                 instance: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "behavior_name", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_location", value)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PropertyActivationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyActivationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        """
        Your domain's name.
        """
        validation_scope: pulumi.Input[_builtins.str]
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your account's ID.
        """
        domain_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain's validation status. Possible values are: 
        * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
        * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
        * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
        * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
        * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        """
        validation_challenge: NotRequired[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeArgsDict']]
        """
        The domain's validation challenge details.
        """
        validation_completed_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timestamp indicating when the domain validation was completed.
        """
        validation_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
        * `MANUAL` - For this method, the DOM team manually performed the validation.
        """
        validation_requested_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the user who requested the domain validation.
        """
        validation_requested_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timestamp indicating when the domain validation was requested.
        """
elif False:
    PropertyDomainownershipDomainsDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 validation_scope: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 domain_status: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_challenge: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeArgs']] = None,
                 validation_completed_date: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_method: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_requested_by: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_requested_date: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain_name: Your domain's name.
        :param pulumi.Input[_builtins.str] validation_scope: Your domain's validation scope. Possible values are: 
               * `HOST` - The scope is only the exactly specified domain.
               * `WILDCARD` - The scope covers any hostname within one subdomain level.
               * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        :param pulumi.Input[_builtins.str] account_id: Your account's ID.
        :param pulumi.Input[_builtins.str] domain_status: The domain's validation status. Possible values are: 
               * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
               * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
               * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
               * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
               * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        :param pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeArgs'] validation_challenge: The domain's validation challenge details.
        :param pulumi.Input[_builtins.str] validation_completed_date: The timestamp indicating when the domain validation was completed.
        :param pulumi.Input[_builtins.str] validation_method: The method used to validate the domain. Possible values are: 
               * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
               * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
               * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
               * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
               * `MANUAL` - For this method, the DOM team manually performed the validation.
        :param pulumi.Input[_builtins.str] validation_requested_by: The name of the user who requested the domain validation.
        :param pulumi.Input[_builtins.str] validation_requested_date: The timestamp indicating when the domain validation was requested.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "validation_scope", validation_scope)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if domain_status is not None:
            pulumi.set(__self__, "domain_status", domain_status)
        if validation_challenge is not None:
            pulumi.set(__self__, "validation_challenge", validation_challenge)
        if validation_completed_date is not None:
            pulumi.set(__self__, "validation_completed_date", validation_completed_date)
        if validation_method is not None:
            pulumi.set(__self__, "validation_method", validation_method)
        if validation_requested_by is not None:
            pulumi.set(__self__, "validation_requested_by", validation_requested_by)
        if validation_requested_date is not None:
            pulumi.set(__self__, "validation_requested_date", validation_requested_date)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        """
        Your domain's name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="validationScope")
    def validation_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        return pulumi.get(self, "validation_scope")

    @validation_scope.setter
    def validation_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "validation_scope", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your account's ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="domainStatus")
    def domain_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain's validation status. Possible values are: 
        * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
        * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
        * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
        * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
        * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        """
        return pulumi.get(self, "domain_status")

    @domain_status.setter
    def domain_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_status", value)

    @_builtins.property
    @pulumi.getter(name="validationChallenge")
    def validation_challenge(self) -> Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeArgs']]:
        """
        The domain's validation challenge details.
        """
        return pulumi.get(self, "validation_challenge")

    @validation_challenge.setter
    def validation_challenge(self, value: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeArgs']]):
        pulumi.set(self, "validation_challenge", value)

    @_builtins.property
    @pulumi.getter(name="validationCompletedDate")
    def validation_completed_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timestamp indicating when the domain validation was completed.
        """
        return pulumi.get(self, "validation_completed_date")

    @validation_completed_date.setter
    def validation_completed_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_completed_date", value)

    @_builtins.property
    @pulumi.getter(name="validationMethod")
    def validation_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
        * `MANUAL` - For this method, the DOM team manually performed the validation.
        """
        return pulumi.get(self, "validation_method")

    @validation_method.setter
    def validation_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_method", value)

    @_builtins.property
    @pulumi.getter(name="validationRequestedBy")
    def validation_requested_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the user who requested the domain validation.
        """
        return pulumi.get(self, "validation_requested_by")

    @validation_requested_by.setter
    def validation_requested_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_requested_by", value)

    @_builtins.property
    @pulumi.getter(name="validationRequestedDate")
    def validation_requested_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timestamp indicating when the domain validation was requested.
        """
        return pulumi.get(self, "validation_requested_date")

    @validation_requested_date.setter
    def validation_requested_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_requested_date", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainValidationChallengeArgsDict(TypedDict):
        cname_record: NotRequired[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgsDict']]
        """
        The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        """
        expiration_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timestamp indicating when the challenge data expires.
        """
        http_file: NotRequired[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgsDict']]
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        """
        http_redirect: NotRequired[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgsDict']]
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        """
        txt_record: NotRequired[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgsDict']]
        """
        The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
elif False:
    PropertyDomainownershipDomainsDomainValidationChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainValidationChallengeArgs:
    def __init__(__self__, *,
                 cname_record: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs']] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 http_file: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs']] = None,
                 http_redirect: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs']] = None,
                 txt_record: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs']] = None):
        """
        :param pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs'] cname_record: The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        :param pulumi.Input[_builtins.str] expiration_date: The timestamp indicating when the challenge data expires.
        :param pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs'] http_file: Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        :param pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs'] http_redirect: Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        :param pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs'] txt_record: The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
        if cname_record is not None:
            pulumi.set(__self__, "cname_record", cname_record)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if http_file is not None:
            pulumi.set(__self__, "http_file", http_file)
        if http_redirect is not None:
            pulumi.set(__self__, "http_redirect", http_redirect)
        if txt_record is not None:
            pulumi.set(__self__, "txt_record", txt_record)

    @_builtins.property
    @pulumi.getter(name="cnameRecord")
    def cname_record(self) -> Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs']]:
        """
        The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        """
        return pulumi.get(self, "cname_record")

    @cname_record.setter
    def cname_record(self, value: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs']]):
        pulumi.set(self, "cname_record", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timestamp indicating when the challenge data expires.
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="httpFile")
    def http_file(self) -> Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs']]:
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        """
        return pulumi.get(self, "http_file")

    @http_file.setter
    def http_file(self, value: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs']]):
        pulumi.set(self, "http_file", value)

    @_builtins.property
    @pulumi.getter(name="httpRedirect")
    def http_redirect(self) -> Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs']]:
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        """
        return pulumi.get(self, "http_redirect")

    @http_redirect.setter
    def http_redirect(self, value: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs']]):
        pulumi.set(self, "http_redirect", value)

    @_builtins.property
    @pulumi.getter(name="txtRecord")
    def txt_record(self) -> Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs']]:
        """
        The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
        return pulumi.get(self, "txt_record")

    @txt_record.setter
    def txt_record(self, value: Optional[pulumi.Input['PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs']]):
        pulumi.set(self, "txt_record", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'CNAME' record for your domain that you add to the DNS configuration.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
elif False:
    PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainValidationChallengeCnameRecordArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The 'CNAME' record for your domain that you add to the DNS configuration.
        :param pulumi.Input[_builtins.str] target: The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'CNAME' record for your domain that you add to the DNS configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content of the file that you should place at the specified URL.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content type of the file containing the token.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where you should place the file containing the challenge token.
        """
elif False:
    PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainValidationChallengeHttpFileArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: The content of the file that you should place at the specified URL.
        :param pulumi.Input[_builtins.str] content_type: The content type of the file containing the token.
        :param pulumi.Input[_builtins.str] path: The URL where you should place the file containing the challenge token.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content of the file that you should place at the specified URL.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content type of the file containing the token.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where you should place the file containing the challenge token.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        The location on your HTTP server where you set up the redirect.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redirect URL with the token that you place on your HTTP server.
        """
elif False:
    PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainValidationChallengeHttpRedirectArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] from_: The location on your HTTP server where you set up the redirect.
        :param pulumi.Input[_builtins.str] to: The redirect URL with the token that you place on your HTTP server.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The location on your HTTP server where you set up the redirect.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redirect URL with the token that you place on your HTTP server.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname where you should add the 'TXT' record to validate the domain ownership.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
elif False:
    PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipDomainsDomainValidationChallengeTxtRecordArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The hostname where you should add the 'TXT' record to validate the domain ownership.
        :param pulumi.Input[_builtins.str] value: The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname where you should add the 'TXT' record to validate the domain ownership.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PropertyDomainownershipValidationDomainArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        """
        Your domain's name.
        """
        validation_scope: pulumi.Input[_builtins.str]
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        validation_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        """
elif False:
    PropertyDomainownershipValidationDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipValidationDomainArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 validation_scope: pulumi.Input[_builtins.str],
                 validation_method: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain_name: Your domain's name.
        :param pulumi.Input[_builtins.str] validation_scope: Your domain's validation scope. Possible values are: 
               * `HOST` - The scope is only the exactly specified domain.
               * `WILDCARD` - The scope covers any hostname within one subdomain level.
               * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        :param pulumi.Input[_builtins.str] validation_method: The method used to validate the domain. Possible values are: 
               * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
               * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
               * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "validation_scope", validation_scope)
        if validation_method is not None:
            pulumi.set(__self__, "validation_method", validation_method)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        """
        Your domain's name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="validationScope")
    def validation_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        return pulumi.get(self, "validation_scope")

    @validation_scope.setter
    def validation_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "validation_scope", value)

    @_builtins.property
    @pulumi.getter(name="validationMethod")
    def validation_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        """
        return pulumi.get(self, "validation_method")

    @validation_method.setter
    def validation_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_method", value)


if not MYPY:
    class PropertyDomainownershipValidationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable domains validation timeout to be used on resource create. By default it's 30m.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional configurable domains validation timeout to be used on resource update. By default it's 30m.
        """
elif False:
    PropertyDomainownershipValidationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyDomainownershipValidationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Optional configurable domains validation timeout to be used on resource create. By default it's 30m.
        :param pulumi.Input[_builtins.str] update: Optional configurable domains validation timeout to be used on resource update. By default it's 30m.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable domains validation timeout to be used on resource create. By default it's 30m.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional configurable domains validation timeout to be used on resource update. By default it's 30m.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class PropertyHostnameArgsDict(TypedDict):
        cert_provisioning_type: pulumi.Input[_builtins.str]
        cname_from: pulumi.Input[_builtins.str]
        cname_to: pulumi.Input[_builtins.str]
        ccm_cert_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCcmCertStatusArgsDict']]]]
        """
        Deployment status for the RSA and ECDSA certificates created with Cloud Certificate Manager (CCM).
        """
        ccm_certificates: NotRequired[pulumi.Input['PropertyHostnameCcmCertificatesArgsDict']]
        """
        Certificate identifiers and links for the CCM-managed certificates.
        """
        cert_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgsDict']]]]
        cname_type: NotRequired[pulumi.Input[_builtins.str]]
        edge_hostname_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyHostnameArgs:
    def __init__(__self__, *,
                 cert_provisioning_type: pulumi.Input[_builtins.str],
                 cname_from: pulumi.Input[_builtins.str],
                 cname_to: pulumi.Input[_builtins.str],
                 ccm_cert_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCcmCertStatusArgs']]]] = None,
                 ccm_certificates: Optional[pulumi.Input['PropertyHostnameCcmCertificatesArgs']] = None,
                 cert_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]] = None,
                 cname_type: Optional[pulumi.Input[_builtins.str]] = None,
                 edge_hostname_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCcmCertStatusArgs']]] ccm_cert_statuses: Deployment status for the RSA and ECDSA certificates created with Cloud Certificate Manager (CCM).
        :param pulumi.Input['PropertyHostnameCcmCertificatesArgs'] ccm_certificates: Certificate identifiers and links for the CCM-managed certificates.
        """
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "cname_from", cname_from)
        pulumi.set(__self__, "cname_to", cname_to)
        if ccm_cert_statuses is not None:
            pulumi.set(__self__, "ccm_cert_statuses", ccm_cert_statuses)
        if ccm_certificates is not None:
            pulumi.set(__self__, "ccm_certificates", ccm_certificates)
        if cert_statuses is not None:
            pulumi.set(__self__, "cert_statuses", cert_statuses)
        if cname_type is not None:
            pulumi.set(__self__, "cname_type", cname_type)
        if edge_hostname_id is not None:
            pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cert_provisioning_type")

    @cert_provisioning_type.setter
    def cert_provisioning_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert_provisioning_type", value)

    @_builtins.property
    @pulumi.getter(name="cnameFrom")
    def cname_from(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cname_from")

    @cname_from.setter
    def cname_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cname_from", value)

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cname_to")

    @cname_to.setter
    def cname_to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cname_to", value)

    @_builtins.property
    @pulumi.getter(name="ccmCertStatuses")
    def ccm_cert_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCcmCertStatusArgs']]]]:
        """
        Deployment status for the RSA and ECDSA certificates created with Cloud Certificate Manager (CCM).
        """
        return pulumi.get(self, "ccm_cert_statuses")

    @ccm_cert_statuses.setter
    def ccm_cert_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCcmCertStatusArgs']]]]):
        pulumi.set(self, "ccm_cert_statuses", value)

    @_builtins.property
    @pulumi.getter(name="ccmCertificates")
    def ccm_certificates(self) -> Optional[pulumi.Input['PropertyHostnameCcmCertificatesArgs']]:
        """
        Certificate identifiers and links for the CCM-managed certificates.
        """
        return pulumi.get(self, "ccm_certificates")

    @ccm_certificates.setter
    def ccm_certificates(self, value: Optional[pulumi.Input['PropertyHostnameCcmCertificatesArgs']]):
        pulumi.set(self, "ccm_certificates", value)

    @_builtins.property
    @pulumi.getter(name="certStatuses")
    def cert_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]]:
        return pulumi.get(self, "cert_statuses")

    @cert_statuses.setter
    def cert_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]]):
        pulumi.set(self, "cert_statuses", value)

    @_builtins.property
    @pulumi.getter(name="cnameType")
    def cname_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cname_type")

    @cname_type.setter
    def cname_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cname_type", value)

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "edge_hostname_id")

    @edge_hostname_id.setter
    def edge_hostname_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "edge_hostname_id", value)


if not MYPY:
    class PropertyHostnameBucketHostnamesArgsDict(TypedDict):
        cert_provisioning_type: pulumi.Input[_builtins.str]
        """
        Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
        """
        edge_hostname_id: pulumi.Input[_builtins.str]
        """
        Identifies the edge hostname you mapped your traffic to on the production network.
        """
        cname_to: NotRequired[pulumi.Input[_builtins.str]]
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
elif False:
    PropertyHostnameBucketHostnamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyHostnameBucketHostnamesArgs:
    def __init__(__self__, *,
                 cert_provisioning_type: pulumi.Input[_builtins.str],
                 edge_hostname_id: pulumi.Input[_builtins.str],
                 cname_to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert_provisioning_type: Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
        :param pulumi.Input[_builtins.str] edge_hostname_id: Identifies the edge hostname you mapped your traffic to on the production network.
        :param pulumi.Input[_builtins.str] cname_to: The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
        pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)
        if cname_to is not None:
            pulumi.set(__self__, "cname_to", cname_to)

    @_builtins.property
    @pulumi.getter(name="certProvisioningType")
    def cert_provisioning_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates the type of the certificate used in the property hostname. Either `CPS_MANAGED` for certificates you create with the Certificate Provisioning System (CPS) API, or `DEFAULT` for Domain Validation (DV) certificates deployed automatically.
        """
        return pulumi.get(self, "cert_provisioning_type")

    @cert_provisioning_type.setter
    def cert_provisioning_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert_provisioning_type", value)

    @_builtins.property
    @pulumi.getter(name="edgeHostnameId")
    def edge_hostname_id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifies the edge hostname you mapped your traffic to on the production network.
        """
        return pulumi.get(self, "edge_hostname_id")

    @edge_hostname_id.setter
    def edge_hostname_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "edge_hostname_id", value)

    @_builtins.property
    @pulumi.getter(name="cnameTo")
    def cname_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The edge hostname you point the property hostname to so that you can start serving traffic through Akamai servers. This member corresponds to the edge hostname object's `edgeHostnameDomain` member.
        """
        return pulumi.get(self, "cname_to")

    @cname_to.setter
    def cname_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cname_to", value)


if not MYPY:
    class PropertyHostnameCcmCertStatusArgsDict(TypedDict):
        ecdsa_production_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the ECDSA certificate on production network.
        """
        ecdsa_staging_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the ECDSA certificate on staging network.
        """
        rsa_production_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the RSA certificate on production network.
        """
        rsa_staging_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the RSA certificate on staging network.
        """
elif False:
    PropertyHostnameCcmCertStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyHostnameCcmCertStatusArgs:
    def __init__(__self__, *,
                 ecdsa_production_status: Optional[pulumi.Input[_builtins.str]] = None,
                 ecdsa_staging_status: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_production_status: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_staging_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ecdsa_production_status: Status of the ECDSA certificate on production network.
        :param pulumi.Input[_builtins.str] ecdsa_staging_status: Status of the ECDSA certificate on staging network.
        :param pulumi.Input[_builtins.str] rsa_production_status: Status of the RSA certificate on production network.
        :param pulumi.Input[_builtins.str] rsa_staging_status: Status of the RSA certificate on staging network.
        """
        if ecdsa_production_status is not None:
            pulumi.set(__self__, "ecdsa_production_status", ecdsa_production_status)
        if ecdsa_staging_status is not None:
            pulumi.set(__self__, "ecdsa_staging_status", ecdsa_staging_status)
        if rsa_production_status is not None:
            pulumi.set(__self__, "rsa_production_status", rsa_production_status)
        if rsa_staging_status is not None:
            pulumi.set(__self__, "rsa_staging_status", rsa_staging_status)

    @_builtins.property
    @pulumi.getter(name="ecdsaProductionStatus")
    def ecdsa_production_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the ECDSA certificate on production network.
        """
        return pulumi.get(self, "ecdsa_production_status")

    @ecdsa_production_status.setter
    def ecdsa_production_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecdsa_production_status", value)

    @_builtins.property
    @pulumi.getter(name="ecdsaStagingStatus")
    def ecdsa_staging_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the ECDSA certificate on staging network.
        """
        return pulumi.get(self, "ecdsa_staging_status")

    @ecdsa_staging_status.setter
    def ecdsa_staging_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecdsa_staging_status", value)

    @_builtins.property
    @pulumi.getter(name="rsaProductionStatus")
    def rsa_production_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the RSA certificate on production network.
        """
        return pulumi.get(self, "rsa_production_status")

    @rsa_production_status.setter
    def rsa_production_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_production_status", value)

    @_builtins.property
    @pulumi.getter(name="rsaStagingStatus")
    def rsa_staging_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the RSA certificate on staging network.
        """
        return pulumi.get(self, "rsa_staging_status")

    @rsa_staging_status.setter
    def rsa_staging_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_staging_status", value)


if not MYPY:
    class PropertyHostnameCcmCertificatesArgsDict(TypedDict):
        ecdsa_cert_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate ID for ECDSA.
        """
        rsa_cert_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate ID for RSA.
        """
elif False:
    PropertyHostnameCcmCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyHostnameCcmCertificatesArgs:
    def __init__(__self__, *,
                 ecdsa_cert_id: Optional[pulumi.Input[_builtins.str]] = None,
                 rsa_cert_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ecdsa_cert_id: Certificate ID for ECDSA.
        :param pulumi.Input[_builtins.str] rsa_cert_id: Certificate ID for RSA.
        """
        if ecdsa_cert_id is not None:
            pulumi.set(__self__, "ecdsa_cert_id", ecdsa_cert_id)
        if rsa_cert_id is not None:
            pulumi.set(__self__, "rsa_cert_id", rsa_cert_id)

    @_builtins.property
    @pulumi.getter(name="ecdsaCertId")
    def ecdsa_cert_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate ID for ECDSA.
        """
        return pulumi.get(self, "ecdsa_cert_id")

    @ecdsa_cert_id.setter
    def ecdsa_cert_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecdsa_cert_id", value)

    @_builtins.property
    @pulumi.getter(name="rsaCertId")
    def rsa_cert_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate ID for RSA.
        """
        return pulumi.get(self, "rsa_cert_id")

    @rsa_cert_id.setter
    def rsa_cert_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rsa_cert_id", value)


if not MYPY:
    class PropertyHostnameCertStatusArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname part of the CNAME record used to validate the certificate's domain.
        """
        production_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate's deployment status on the production network.
        """
        staging_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate's deployment status on the staging network.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination part of the CNAME record used to validate the certificate's domain.
        """
elif False:
    PropertyHostnameCertStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyHostnameCertStatusArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 production_status: Optional[pulumi.Input[_builtins.str]] = None,
                 staging_status: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The hostname part of the CNAME record used to validate the certificate's domain.
        :param pulumi.Input[_builtins.str] production_status: The certificate's deployment status on the production network.
        :param pulumi.Input[_builtins.str] staging_status: The certificate's deployment status on the staging network.
        :param pulumi.Input[_builtins.str] target: The destination part of the CNAME record used to validate the certificate's domain.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if production_status is not None:
            pulumi.set(__self__, "production_status", production_status)
        if staging_status is not None:
            pulumi.set(__self__, "staging_status", staging_status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="productionStatus")
    def production_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate's deployment status on the production network.
        """
        return pulumi.get(self, "production_status")

    @production_status.setter
    def production_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "production_status", value)

    @_builtins.property
    @pulumi.getter(name="stagingStatus")
    def staging_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate's deployment status on the staging network.
        """
        return pulumi.get(self, "staging_status")

    @staging_status.setter
    def staging_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "staging_status", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination part of the CNAME record used to validate the certificate's domain.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class PropertyIncludeActivationComplianceRecordArgsDict(TypedDict):
        noncompliance_reason_emergency: NotRequired[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        noncompliance_reason_no_production_traffic: NotRequired[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        noncompliance_reason_none: NotRequired[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        noncompliance_reason_other: NotRequired[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgsDict']]
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
elif False:
    PropertyIncludeActivationComplianceRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationComplianceRecordArgs:
    def __init__(__self__, *,
                 noncompliance_reason_emergency: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs']] = None,
                 noncompliance_reason_no_production_traffic: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']] = None,
                 noncompliance_reason_none: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs']] = None,
                 noncompliance_reason_other: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs']] = None):
        """
        :param pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs'] noncompliance_reason_emergency: Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        :param pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs'] noncompliance_reason_no_production_traffic: Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        :param pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs'] noncompliance_reason_none: Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        :param pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs'] noncompliance_reason_other: Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        if noncompliance_reason_emergency is not None:
            pulumi.set(__self__, "noncompliance_reason_emergency", noncompliance_reason_emergency)
        if noncompliance_reason_no_production_traffic is not None:
            pulumi.set(__self__, "noncompliance_reason_no_production_traffic", noncompliance_reason_no_production_traffic)
        if noncompliance_reason_none is not None:
            pulumi.set(__self__, "noncompliance_reason_none", noncompliance_reason_none)
        if noncompliance_reason_other is not None:
            pulumi.set(__self__, "noncompliance_reason_other", noncompliance_reason_other)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonEmergency")
    def noncompliance_reason_emergency(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `EMERGENCY`
        """
        return pulumi.get(self, "noncompliance_reason_emergency")

    @noncompliance_reason_emergency.setter
    def noncompliance_reason_emergency(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs']]):
        pulumi.set(self, "noncompliance_reason_emergency", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNoProductionTraffic")
    def noncompliance_reason_no_production_traffic(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NO_PRODUCTION_TRAFFIC`
        """
        return pulumi.get(self, "noncompliance_reason_no_production_traffic")

    @noncompliance_reason_no_production_traffic.setter
    def noncompliance_reason_no_production_traffic(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs']]):
        pulumi.set(self, "noncompliance_reason_no_production_traffic", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonNone")
    def noncompliance_reason_none(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `NONE`
        """
        return pulumi.get(self, "noncompliance_reason_none")

    @noncompliance_reason_none.setter
    def noncompliance_reason_none(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs']]):
        pulumi.set(self, "noncompliance_reason_none", value)

    @_builtins.property
    @pulumi.getter(name="noncomplianceReasonOther")
    def noncompliance_reason_other(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs']]:
        """
        Provides an audit record when activating on a production network with noncompliance reason as `OTHER`
        """
        return pulumi.get(self, "noncompliance_reason_other")

    @noncompliance_reason_other.setter
    def noncompliance_reason_other(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs']]):
        pulumi.set(self, "noncompliance_reason_other", value)


if not MYPY:
    class PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict(TypedDict):
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonEmergencyArgs:
    def __init__(__self__, *,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict(TypedDict):
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoProductionTrafficArgs:
    def __init__(__self__, *,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgsDict(TypedDict):
        customer_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the customer
        """
        peer_reviewed_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies person who has independently approved the activation request
        """
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
        unit_tested: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the metadata to activate has been fully tested
        """
elif False:
    PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonNoneArgs:
    def __init__(__self__, *,
                 customer_email: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_reviewed_by: Optional[pulumi.Input[_builtins.str]] = None,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_tested: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] customer_email: Identifies the customer
        :param pulumi.Input[_builtins.str] peer_reviewed_by: Identifies person who has independently approved the activation request
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        :param pulumi.Input[_builtins.bool] unit_tested: Whether the metadata to activate has been fully tested
        """
        if customer_email is not None:
            pulumi.set(__self__, "customer_email", customer_email)
        if peer_reviewed_by is not None:
            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)
        if unit_tested is not None:
            pulumi.set(__self__, "unit_tested", unit_tested)

    @_builtins.property
    @pulumi.getter(name="customerEmail")
    def customer_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the customer
        """
        return pulumi.get(self, "customer_email")

    @customer_email.setter
    def customer_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_email", value)

    @_builtins.property
    @pulumi.getter(name="peerReviewedBy")
    def peer_reviewed_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies person who has independently approved the activation request
        """
        return pulumi.get(self, "peer_reviewed_by")

    @peer_reviewed_by.setter
    def peer_reviewed_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_reviewed_by", value)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)

    @_builtins.property
    @pulumi.getter(name="unitTested")
    def unit_tested(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the metadata to activate has been fully tested
        """
        return pulumi.get(self, "unit_tested")

    @unit_tested.setter
    def unit_tested(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unit_tested", value)


if not MYPY:
    class PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgsDict(TypedDict):
        other_noncompliance_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        ticket_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifies the ticket that describes the need for the activation
        """
elif False:
    PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationComplianceRecordNoncomplianceReasonOtherArgs:
    def __init__(__self__, *,
                 other_noncompliance_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 ticket_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] other_noncompliance_reason: Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        :param pulumi.Input[_builtins.str] ticket_id: Identifies the ticket that describes the need for the activation
        """
        if other_noncompliance_reason is not None:
            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @_builtins.property
    @pulumi.getter(name="otherNoncomplianceReason")
    def other_noncompliance_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Describes the reason why the activation must occur immediately, out of compliance with the standard procedure
        """
        return pulumi.get(self, "other_noncompliance_reason")

    @other_noncompliance_reason.setter
    def other_noncompliance_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "other_noncompliance_reason", value)

    @_builtins.property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifies the ticket that describes the need for the activation
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class PropertyIncludeActivationTimeoutsArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyIncludeActivationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyIncludeActivationTimeoutsArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class PropertyRuleErrorArgsDict(TypedDict):
        behavior_name: NotRequired[pulumi.Input[_builtins.str]]
        detail: NotRequired[pulumi.Input[_builtins.str]]
        error_location: NotRequired[pulumi.Input[_builtins.str]]
        instance: NotRequired[pulumi.Input[_builtins.str]]
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        title: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyRuleErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyRuleErrorArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 error_location: Optional[pulumi.Input[_builtins.str]] = None,
                 instance: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "behavior_name", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_location", value)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PropertyRuleWarningArgsDict(TypedDict):
        behavior_name: NotRequired[pulumi.Input[_builtins.str]]
        detail: NotRequired[pulumi.Input[_builtins.str]]
        error_location: NotRequired[pulumi.Input[_builtins.str]]
        instance: NotRequired[pulumi.Input[_builtins.str]]
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        title: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PropertyRuleWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyRuleWarningArgs:
    def __init__(__self__, *,
                 behavior_name: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 error_location: Optional[pulumi.Input[_builtins.str]] = None,
                 instance: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if behavior_name is not None:
            pulumi.set(__self__, "behavior_name", behavior_name)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if error_location is not None:
            pulumi.set(__self__, "error_location", error_location)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="behaviorName")
    def behavior_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "behavior_name")

    @behavior_name.setter
    def behavior_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "behavior_name", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="errorLocation")
    def error_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error_location")

    @error_location.setter
    def error_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_location", value)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProviderConfigArgsDict(TypedDict):
        access_token: pulumi.Input[_builtins.str]
        client_secret: pulumi.Input[_builtins.str]
        client_token: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        account_key: NotRequired[pulumi.Input[_builtins.str]]
        max_body: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderConfigArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 client_token: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 account_key: Optional[pulumi.Input[_builtins.str]] = None,
                 max_body: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "client_token", client_token)
        pulumi.set(__self__, "host", host)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if max_body is not None:
            pulumi.set(__self__, "max_body", max_body)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_token")

    @client_token.setter
    def client_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_token", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_key", value)

    @_builtins.property
    @pulumi.getter(name="maxBody")
    def max_body(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_body")

    @max_body.setter
    def max_body(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_body", value)


if not MYPY:
    class GetCloudletsApiPrioritizationMatchRuleMatchRuleArgsDict(TypedDict):
        pass_through_percent: _builtins.float
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsApiPrioritizationMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 pass_through_percent: _builtins.float,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.float pass_through_percent: The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> _builtins.float:
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        return pulumi.get(self, "pass_through_percent")

    @pass_through_percent.setter
    def pass_through_percent(self, value: _builtins.float):
        pulumi.set(self, "pass_through_percent", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
elif False:
    GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgsDict(TypedDict):
        forward_settings: Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgsDict']
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        id: NotRequired[_builtins.int]
        """
        Akamai internal use only
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        matches_always: NotRequired[_builtins.bool]
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs'],
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs'] forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.int id: Akamai internal use only
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs']:
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs']):
        pulumi.set(self, "forward_settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Akamai internal use only
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "matches_always", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgsDict(TypedDict):
        origin_id: _builtins.str
        """
        The ID of the Conditional Origin requests are forwarded to
        """
elif False:
    GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs:
    def __init__(__self__, *,
                 origin_id: _builtins.str):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        """
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: _builtins.str):
        pulumi.set(self, "origin_id", value)


if not MYPY:
    class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
        """
elif False:
    GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
elif False:
    GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object, range, or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgsDict(TypedDict):
        forward_settings: 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgsDict'
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgsDict(TypedDict):
        origin_id: NotRequired[_builtins.str]
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        path_and_qs: NotRequired[_builtins.str]
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        use_incoming_query_string: NotRequired[_builtins.bool]
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
elif False:
    GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: Optional[_builtins.str] = None,
                 path_and_qs: Optional[_builtins.str] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.str path_and_qs: If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[_builtins.str]:
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        return pulumi.get(self, "path_and_qs")

    @path_and_qs.setter
    def path_and_qs(self, value: Optional[_builtins.str]):
        pulumi.set(self, "path_and_qs", value)

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "use_incoming_query_string", value)


if not MYPY:
    class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
elif False:
    GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple or range. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgsDict(TypedDict):
        redirect_url: _builtins.str
        """
        The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
        """
        status_code: _builtins.int
        """
        The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        matches_always: NotRequired[_builtins.bool]
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
        use_incoming_query_string: NotRequired[_builtins.bool]
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
        """
        use_relative_url: NotRequired[_builtins.str]
        """
        If set to relative_url, takes the path entered for the redirectUrl and sets it in the responses Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirect_url should be fully-qualified URL
        """
elif False:
    GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 redirect_url: _builtins.str,
                 status_code: _builtins.int,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None,
                 use_relative_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str redirect_url: The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
        :param _builtins.int status_code: The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
        :param _builtins.str use_relative_url: If set to relative_url, takes the path entered for the redirectUrl and sets it in the responses Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirect_url should be fully-qualified URL
        """
        pulumi.set(__self__, "redirect_url", redirect_url)
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)
        if use_relative_url is not None:
            pulumi.set(__self__, "use_relative_url", use_relative_url)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        The URL Edge Redirector redirects the request to. If using use_relative_url, you can enter a path for the value
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: _builtins.str):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> _builtins.int:
        """
        The HTTP response status code (allowed values: 301, 302, 303, 307, 308)
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: _builtins.int):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "matches_always", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "use_incoming_query_string", value)

    @_builtins.property
    @pulumi.getter(name="useRelativeUrl")
    def use_relative_url(self) -> Optional[_builtins.str]:
        """
        If set to relative_url, takes the path entered for the redirectUrl and sets it in the responses Location header. If set to copy_scheme_hostname, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information entered for the redirectUrl. If this property is not included, or is set to none, then the redirect_url should be fully-qualified URL
        """
        return pulumi.get(self, "use_relative_url")

    @use_relative_url.setter
    def use_relative_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "use_relative_url", value)


if not MYPY:
    class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
elif False:
    GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsForwardRewriteMatchRuleMatchRuleArgsDict(TypedDict):
        forward_settings: 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgsDict'
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsForwardRewriteMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgsDict(TypedDict):
        origin_id: NotRequired[_builtins.str]
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        path_and_qs: NotRequired[_builtins.str]
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        use_incoming_query_string: NotRequired[_builtins.bool]
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
elif False:
    GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: Optional[_builtins.str] = None,
                 path_and_qs: Optional[_builtins.str] = None,
                 use_incoming_query_string: Optional[_builtins.bool] = None):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.str path_and_qs: If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        :param _builtins.bool use_incoming_query_string: If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)
        if path_and_qs is not None:
            pulumi.set(__self__, "path_and_qs", path_and_qs)
        if use_incoming_query_string is not None:
            pulumi.set(__self__, "use_incoming_query_string", use_incoming_query_string)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="pathAndQs")
    def path_and_qs(self) -> Optional[_builtins.str]:
        """
        If a value is provided and match conditions are met, this property defines the path/resource/query string to rewrite URL for the incoming request.
        """
        return pulumi.get(self, "path_and_qs")

    @path_and_qs.setter
    def path_and_qs(self, value: Optional[_builtins.str]):
        pulumi.set(self, "path_and_qs", value)

    @_builtins.property
    @pulumi.getter(name="useIncomingQueryString")
    def use_incoming_query_string(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Cloudlet includes the query string from the request in the rewritten or forwarded URL.
        """
        return pulumi.get(self, "use_incoming_query_string")

    @use_incoming_query_string.setter
    def use_incoming_query_string(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "use_incoming_query_string", value)


if not MYPY:
    class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
elif False:
    GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsPhasedReleaseMatchRuleMatchRuleArgsDict(TypedDict):
        forward_settings: 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgsDict'
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        matches_always: NotRequired[_builtins.bool]
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsPhasedReleaseMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 forward_settings: 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs',
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs' forward_settings: This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        :param _builtins.str type: The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "forward_settings", forward_settings)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="forwardSettings")
    def forward_settings(self) -> 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs':
        """
        This property defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, then the Edge Server returns an HTTP response from the rewritten URL
        """
        return pulumi.get(self, "forward_settings")

    @forward_settings.setter
    def forward_settings(self, value: 'GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs'):
        pulumi.set(self, "forward_settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for. It is known as Continuous Deployment (CD) too.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "matches_always", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgsDict(TypedDict):
        origin_id: _builtins.str
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        percent: _builtins.int
        """
        The percent of traffic that is sent to the data center.
        """
elif False:
    GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs:
    def __init__(__self__, *,
                 origin_id: _builtins.str,
                 percent: _builtins.int):
        """
        :param _builtins.str origin_id: The ID of the Conditional Origin requests are forwarded to
        :param _builtins.int percent: The percent of traffic that is sent to the data center.
        """
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        The ID of the Conditional Origin requests are forwarded to
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: _builtins.str):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The percent of traffic that is sent to the data center.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: _builtins.int):
        pulumi.set(self, "percent", value)


if not MYPY:
    class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
elif False:
    GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple or range type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple or range type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsRequestControlMatchRuleMatchRuleArgsDict(TypedDict):
        allow_deny: _builtins.str
        """
        If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        matches: NotRequired[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        matches_always: NotRequired[_builtins.bool]
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsRequestControlMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 allow_deny: _builtins.str,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 matches: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']] = None,
                 matches_always: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.str allow_deny: If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.bool matches_always: Is used in some cloudlets to support default rules (rule that is always matched)
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "allow_deny", allow_deny)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if matches_always is not None:
            pulumi.set(__self__, "matches_always", matches_always)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="allowDeny")
    def allow_deny(self) -> _builtins.str:
        """
        If set to allow, the request is sent to origin when all conditions are true. If deny, the request is denied when all conditions are true. If denybranded, the request is denied and rerouted according to the configuration of the Request Control behavior
        """
        return pulumi.get(self, "allow_deny")

    @allow_deny.setter
    def allow_deny(self, value: _builtins.str):
        pulumi.set(self, "allow_deny", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter(name="matchesAlways")
    def matches_always(self) -> Optional[_builtins.bool]:
        """
        Is used in some cloudlets to support default rules (rule that is always matched)
        """
        return pulumi.get(self, "matches_always")

    @matches_always.setter
    def matches_always(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "matches_always", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsRequestControlMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsRequestControlMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
elif False:
    GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsArgsDict(TypedDict):
        production: NotRequired['GetCloudletsSharedPolicyActivationsProductionArgsDict']
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        staging: NotRequired['GetCloudletsSharedPolicyActivationsStagingArgsDict']
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
elif False:
    GetCloudletsSharedPolicyActivationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsArgs:
    def __init__(__self__, *,
                 production: Optional['GetCloudletsSharedPolicyActivationsProductionArgs'] = None,
                 staging: Optional['GetCloudletsSharedPolicyActivationsStagingArgs'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsProductionArgs' production: The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        :param 'GetCloudletsSharedPolicyActivationsStagingArgs' staging: The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        if production is not None:
            pulumi.set(__self__, "production", production)
        if staging is not None:
            pulumi.set(__self__, "staging", staging)

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional['GetCloudletsSharedPolicyActivationsProductionArgs']:
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional['GetCloudletsSharedPolicyActivationsProductionArgs']):
        pulumi.set(self, "production", value)

    @_builtins.property
    @pulumi.getter
    def staging(self) -> Optional['GetCloudletsSharedPolicyActivationsStagingArgs']:
        """
        The policy version number that's currently in use on this network and the status of the most recent activation or deactivation operation for this policy's versions.
        """
        return pulumi.get(self, "staging")

    @staging.setter
    def staging(self, value: Optional['GetCloudletsSharedPolicyActivationsStagingArgs']):
        pulumi.set(self, "staging", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsProductionArgsDict(TypedDict):
        effective: NotRequired['GetCloudletsSharedPolicyActivationsProductionEffectiveArgsDict']
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        latest: NotRequired['GetCloudletsSharedPolicyActivationsProductionLatestArgsDict']
        """
        The status of the latest activation or null if the policy has no activations.
        """
elif False:
    GetCloudletsSharedPolicyActivationsProductionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsProductionArgs:
    def __init__(__self__, *,
                 effective: Optional['GetCloudletsSharedPolicyActivationsProductionEffectiveArgs'] = None,
                 latest: Optional['GetCloudletsSharedPolicyActivationsProductionLatestArgs'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsProductionEffectiveArgs' effective: The status of the activation that's currently in use on this network, or null if the policy has no activations.
        :param 'GetCloudletsSharedPolicyActivationsProductionLatestArgs' latest: The status of the latest activation or null if the policy has no activations.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional['GetCloudletsSharedPolicyActivationsProductionEffectiveArgs']:
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional['GetCloudletsSharedPolicyActivationsProductionEffectiveArgs']):
        pulumi.set(self, "effective", value)

    @_builtins.property
    @pulumi.getter
    def latest(self) -> Optional['GetCloudletsSharedPolicyActivationsProductionLatestArgs']:
        """
        The status of the latest activation or null if the policy has no activations.
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional['GetCloudletsSharedPolicyActivationsProductionLatestArgs']):
        pulumi.set(self, "latest", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsProductionEffectiveArgsDict(TypedDict):
        activation_id: _builtins.int
        """
        Identifies the activation.
        """
        created_by: _builtins.str
        """
        The username who created the activation.
        """
        created_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        finish_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        network: _builtins.str
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        operation: _builtins.str
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        policy_id: _builtins.int
        """
        Identifies the shared policy.
        """
        policy_version: _builtins.int
        """
        The number of the policy version.
        """
        policy_version_deleted: _builtins.bool
        """
        Indicates if the policy version is deleted.
        """
        status: _builtins.str
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
elif False:
    GetCloudletsSharedPolicyActivationsProductionEffectiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsProductionEffectiveArgs:
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @activation_id.setter
    def activation_id(self, value: _builtins.int):
        pulumi.set(self, "activation_id", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: _builtins.str):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: _builtins.str):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @finish_date.setter
    def finish_date(self, value: _builtins.str):
        pulumi.set(self, "finish_date", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: _builtins.str):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: _builtins.str):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: _builtins.int):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @policy_version.setter
    def policy_version(self, value: _builtins.int):
        pulumi.set(self, "policy_version", value)

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @policy_version_deleted.setter
    def policy_version_deleted(self, value: _builtins.bool):
        pulumi.set(self, "policy_version_deleted", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsProductionLatestArgsDict(TypedDict):
        activation_id: _builtins.int
        """
        Identifies the activation.
        """
        created_by: _builtins.str
        """
        The username who created the activation.
        """
        created_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        finish_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        network: _builtins.str
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        operation: _builtins.str
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        policy_id: _builtins.int
        """
        Identifies the shared policy.
        """
        policy_version: _builtins.int
        """
        The number of the policy version.
        """
        policy_version_deleted: _builtins.bool
        """
        Indicates if the policy version is deleted.
        """
        status: _builtins.str
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
elif False:
    GetCloudletsSharedPolicyActivationsProductionLatestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsProductionLatestArgs:
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @activation_id.setter
    def activation_id(self, value: _builtins.int):
        pulumi.set(self, "activation_id", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: _builtins.str):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: _builtins.str):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @finish_date.setter
    def finish_date(self, value: _builtins.str):
        pulumi.set(self, "finish_date", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: _builtins.str):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: _builtins.str):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: _builtins.int):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @policy_version.setter
    def policy_version(self, value: _builtins.int):
        pulumi.set(self, "policy_version", value)

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @policy_version_deleted.setter
    def policy_version_deleted(self, value: _builtins.bool):
        pulumi.set(self, "policy_version_deleted", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsStagingArgsDict(TypedDict):
        effective: NotRequired['GetCloudletsSharedPolicyActivationsStagingEffectiveArgsDict']
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        latest: NotRequired['GetCloudletsSharedPolicyActivationsStagingLatestArgsDict']
        """
        The status of the latest activation or null if the policy has no activations.
        """
elif False:
    GetCloudletsSharedPolicyActivationsStagingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsStagingArgs:
    def __init__(__self__, *,
                 effective: Optional['GetCloudletsSharedPolicyActivationsStagingEffectiveArgs'] = None,
                 latest: Optional['GetCloudletsSharedPolicyActivationsStagingLatestArgs'] = None):
        """
        :param 'GetCloudletsSharedPolicyActivationsStagingEffectiveArgs' effective: The status of the activation that's currently in use on this network, or null if the policy has no activations.
        :param 'GetCloudletsSharedPolicyActivationsStagingLatestArgs' latest: The status of the latest activation or null if the policy has no activations.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional['GetCloudletsSharedPolicyActivationsStagingEffectiveArgs']:
        """
        The status of the activation that's currently in use on this network, or null if the policy has no activations.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional['GetCloudletsSharedPolicyActivationsStagingEffectiveArgs']):
        pulumi.set(self, "effective", value)

    @_builtins.property
    @pulumi.getter
    def latest(self) -> Optional['GetCloudletsSharedPolicyActivationsStagingLatestArgs']:
        """
        The status of the latest activation or null if the policy has no activations.
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional['GetCloudletsSharedPolicyActivationsStagingLatestArgs']):
        pulumi.set(self, "latest", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsStagingEffectiveArgsDict(TypedDict):
        activation_id: _builtins.int
        """
        Identifies the activation.
        """
        created_by: _builtins.str
        """
        The username who created the activation.
        """
        created_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        finish_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        network: _builtins.str
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        operation: _builtins.str
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        policy_id: _builtins.int
        """
        Identifies the shared policy.
        """
        policy_version: _builtins.int
        """
        The number of the policy version.
        """
        policy_version_deleted: _builtins.bool
        """
        Indicates if the policy version is deleted.
        """
        status: _builtins.str
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
elif False:
    GetCloudletsSharedPolicyActivationsStagingEffectiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsStagingEffectiveArgs:
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @activation_id.setter
    def activation_id(self, value: _builtins.int):
        pulumi.set(self, "activation_id", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: _builtins.str):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: _builtins.str):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @finish_date.setter
    def finish_date(self, value: _builtins.str):
        pulumi.set(self, "finish_date", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: _builtins.str):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: _builtins.str):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: _builtins.int):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @policy_version.setter
    def policy_version(self, value: _builtins.int):
        pulumi.set(self, "policy_version", value)

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @policy_version_deleted.setter
    def policy_version_deleted(self, value: _builtins.bool):
        pulumi.set(self, "policy_version_deleted", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetCloudletsSharedPolicyActivationsStagingLatestArgsDict(TypedDict):
        activation_id: _builtins.int
        """
        Identifies the activation.
        """
        created_by: _builtins.str
        """
        The username who created the activation.
        """
        created_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        finish_date: _builtins.str
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        network: _builtins.str
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        operation: _builtins.str
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        policy_id: _builtins.int
        """
        Identifies the shared policy.
        """
        policy_version: _builtins.int
        """
        The number of the policy version.
        """
        policy_version_deleted: _builtins.bool
        """
        Indicates if the policy version is deleted.
        """
        status: _builtins.str
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
elif False:
    GetCloudletsSharedPolicyActivationsStagingLatestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsSharedPolicyActivationsStagingLatestArgs:
    def __init__(__self__, *,
                 activation_id: _builtins.int,
                 created_by: _builtins.str,
                 created_date: _builtins.str,
                 finish_date: _builtins.str,
                 network: _builtins.str,
                 operation: _builtins.str,
                 policy_id: _builtins.int,
                 policy_version: _builtins.int,
                 policy_version_deleted: _builtins.bool,
                 status: _builtins.str):
        """
        :param _builtins.int activation_id: Identifies the activation.
        :param _builtins.str created_by: The username who created the activation.
        :param _builtins.str created_date: ISO 8601 timestamp indicating when the activation was created.
        :param _builtins.str finish_date: ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        :param _builtins.str network: The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        :param _builtins.str operation: The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        :param _builtins.int policy_id: Identifies the shared policy.
        :param _builtins.int policy_version: The number of the policy version.
        :param _builtins.bool policy_version_deleted: Indicates if the policy version is deleted.
        :param _builtins.str status: The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        pulumi.set(__self__, "activation_id", activation_id)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "finish_date", finish_date)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        pulumi.set(__self__, "policy_version_deleted", policy_version_deleted)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> _builtins.int:
        """
        Identifies the activation.
        """
        return pulumi.get(self, "activation_id")

    @activation_id.setter
    def activation_id(self, value: _builtins.int):
        pulumi.set(self, "activation_id", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The username who created the activation.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: _builtins.str):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation was created.
        """
        return pulumi.get(self, "created_date")

    @created_date.setter
    def created_date(self, value: _builtins.str):
        pulumi.set(self, "created_date", value)

    @_builtins.property
    @pulumi.getter(name="finishDate")
    def finish_date(self) -> _builtins.str:
        """
        ISO 8601 timestamp indicating when the activation ended, either successfully or unsuccessfully. You can check details of unsuccessful attempts in 'failureDetails'.
        """
        return pulumi.get(self, "finish_date")

    @finish_date.setter
    def finish_date(self, value: _builtins.str):
        pulumi.set(self, "finish_date", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The networks where you can activate or deactivate the policy version, either 'PRODUCTION' or 'STAGING'.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: _builtins.str):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operations that you can perform on a policy version, either 'ACTIVATION' or 'DEACTIVATION'.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: _builtins.str):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.int:
        """
        Identifies the shared policy.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: _builtins.int):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.int:
        """
        The number of the policy version.
        """
        return pulumi.get(self, "policy_version")

    @policy_version.setter
    def policy_version(self, value: _builtins.int):
        pulumi.set(self, "policy_version", value)

    @_builtins.property
    @pulumi.getter(name="policyVersionDeleted")
    def policy_version_deleted(self) -> _builtins.bool:
        """
        Indicates if the policy version is deleted.
        """
        return pulumi.get(self, "policy_version_deleted")

    @policy_version_deleted.setter
    def policy_version_deleted(self, value: _builtins.bool):
        pulumi.set(self, "policy_version_deleted", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the operation, either 'IN_PROGRESS', 'SUCCESS', or 'FAILED'.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgsDict(TypedDict):
        pass_through_percent: _builtins.float
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        type: _builtins.str
        """
        The type of Cloudlet the rule is for
        """
        disabled: NotRequired[_builtins.bool]
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        end: NotRequired[_builtins.int]
        """
        The end time for this match (in seconds since the epoch)
        """
        match_url: NotRequired[_builtins.str]
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        matches: NotRequired[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgsDict']]
        """
        Defines a set of match objects
        """
        name: NotRequired[_builtins.str]
        """
        The name of the rule
        """
        start: NotRequired[_builtins.int]
        """
        The start time for this match (in seconds since the epoch)
        """
elif False:
    GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs:
    def __init__(__self__, *,
                 pass_through_percent: _builtins.float,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end: Optional[_builtins.int] = None,
                 match_url: Optional[_builtins.str] = None,
                 matches: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 start: Optional[_builtins.int] = None):
        """
        :param _builtins.float pass_through_percent: The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        :param _builtins.str type: The type of Cloudlet the rule is for
        :param _builtins.bool disabled: If set to true, disables a rule so it is not evaluated against incoming requests.
        :param _builtins.int end: The end time for this match (in seconds since the epoch)
        :param _builtins.str match_url: If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs'] matches: Defines a set of match objects
        :param _builtins.str name: The name of the rule
        :param _builtins.int start: The start time for this match (in seconds since the epoch)
        """
        pulumi.set(__self__, "pass_through_percent", pass_through_percent)
        pulumi.set(__self__, "type", type)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if match_url is not None:
            pulumi.set(__self__, "match_url", match_url)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter(name="passThroughPercent")
    def pass_through_percent(self) -> _builtins.float:
        """
        The range 0.0: 99.0 specifies the percentage of requests that pass through to the origin. The value of 100 means the request always passes through to the origin. A value of -1 means send everyone to the waiting room.
        """
        return pulumi.get(self, "pass_through_percent")

    @pass_through_percent.setter
    def pass_through_percent(self, value: _builtins.float):
        pulumi.set(self, "pass_through_percent", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Cloudlet the rule is for
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, disables a rule so it is not evaluated against incoming requests.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.int]:
        """
        The end time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[_builtins.int]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter(name="matchUrl")
    def match_url(self) -> Optional[_builtins.str]:
        """
        If using a URL match, this property is the URL that the Cloudlet uses to match the incoming request
        """
        return pulumi.get(self, "match_url")

    @match_url.setter
    def match_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_url", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']]:
        """
        Defines a set of match objects
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs']]):
        pulumi.set(self, "matches", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.int]:
        """
        The start time for this match (in seconds since the epoch)
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[_builtins.int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgsDict(TypedDict):
        case_sensitive: NotRequired[_builtins.bool]
        """
        If true, the match is case sensitive
        """
        check_ips: NotRequired[_builtins.str]
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        match_operator: NotRequired[_builtins.str]
        """
        Valid entries for this property: contains, exists, and equals
        """
        match_type: NotRequired[_builtins.str]
        """
        The type of match used
        """
        match_value: NotRequired[_builtins.str]
        """
        Depends on the matchType
        """
        negate: NotRequired[_builtins.bool]
        """
        If true, negates the match
        """
        object_match_values: NotRequired[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict']]
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
elif False:
    GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 check_ips: Optional[_builtins.str] = None,
                 match_operator: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 match_value: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 object_match_values: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']] = None):
        """
        :param _builtins.bool case_sensitive: If true, the match is case sensitive
        :param _builtins.str check_ips: For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        :param _builtins.str match_operator: Valid entries for this property: contains, exists, and equals
        :param _builtins.str match_type: The type of match used
        :param _builtins.str match_value: Depends on the matchType
        :param _builtins.bool negate: If true, negates the match
        :param Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs'] object_match_values: An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if check_ips is not None:
            pulumi.set(__self__, "check_ips", check_ips)
        if match_operator is not None:
            pulumi.set(__self__, "match_operator", match_operator)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if object_match_values is not None:
            pulumi.set(__self__, "object_match_values", object_match_values)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        If true, the match is case sensitive
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="checkIps")
    def check_ips(self) -> Optional[_builtins.str]:
        """
        For clientip, continent, countrycode, proxy, and regioncode match types, the part of the request that determines the IP address to use
        """
        return pulumi.get(self, "check_ips")

    @check_ips.setter
    def check_ips(self, value: Optional[_builtins.str]):
        pulumi.set(self, "check_ips", value)

    @_builtins.property
    @pulumi.getter(name="matchOperator")
    def match_operator(self) -> Optional[_builtins.str]:
        """
        Valid entries for this property: contains, exists, and equals
        """
        return pulumi.get(self, "match_operator")

    @match_operator.setter
    def match_operator(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_operator", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        The type of match used
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Depends on the matchType
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_value", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        If true, negates the match
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="objectMatchValues")
    def object_match_values(self) -> Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]:
        """
        An object used when a rule either includes more complex match criteria, like multiple value attributes
        """
        return pulumi.get(self, "object_match_values")

    @object_match_values.setter
    def object_match_values(self, value: Optional[Sequence['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs']]):
        pulumi.set(self, "object_match_values", value)


if not MYPY:
    class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict(TypedDict):
        type: _builtins.str
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        name: NotRequired[_builtins.str]
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        name_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        name_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entry for the name property includes wildcards
        """
        options: NotRequired['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict']
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
elif False:
    GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 name_case_sensitive: Optional[_builtins.bool] = None,
                 name_has_wildcard: Optional[_builtins.bool] = None,
                 options: Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        :param _builtins.str name: If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        :param _builtins.bool name_case_sensitive: Set to true if the entry for the name property should be evaluated based on case sensitivity
        :param _builtins.bool name_has_wildcard: Set to true if the entry for the name property includes wildcards
        :param 'GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs' options: If using the object type, use this set to list the values to match on (use only with the object type)
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on (use only with simple type)
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_case_sensitive is not None:
            pulumi.set(__self__, "name_case_sensitive", name_case_sensitive)
        if name_has_wildcard is not None:
            pulumi.set(__self__, "name_has_wildcard", name_has_wildcard)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The array type, which can be one of the following: object or simple. Use the simple option when adding only an array of string-based values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        If using a match type that supports name attributes, enter the value in the incoming request to match on. The following match types support this property: cookie, header, parameter, and query
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameCaseSensitive")
    def name_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "name_case_sensitive")

    @name_case_sensitive.setter
    def name_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="nameHasWildcard")
    def name_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entry for the name property includes wildcards
        """
        return pulumi.get(self, "name_has_wildcard")

    @name_has_wildcard.setter
    def name_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "name_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']:
        """
        If using the object type, use this set to list the values to match on (use only with the object type)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional['GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs']):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on (use only with simple type)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict(TypedDict):
        value_case_sensitive: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        value_escaped: NotRequired[_builtins.bool]
        """
        Set to true if provided value should be compared in escaped form
        """
        value_has_wildcard: NotRequired[_builtins.bool]
        """
        Set to true if the entries for the value property include wildcards
        """
        values: NotRequired[Sequence[_builtins.str]]
        """
        The value attributes in the incoming request to match on
        """
elif False:
    GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptionsArgs:
    def __init__(__self__, *,
                 value_case_sensitive: Optional[_builtins.bool] = None,
                 value_escaped: Optional[_builtins.bool] = None,
                 value_has_wildcard: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool value_case_sensitive: Set to true if the entries for the value property should be evaluated based on case sensitivity
        :param _builtins.bool value_escaped: Set to true if provided value should be compared in escaped form
        :param _builtins.bool value_has_wildcard: Set to true if the entries for the value property include wildcards
        :param Sequence[_builtins.str] values: The value attributes in the incoming request to match on
        """
        if value_case_sensitive is not None:
            pulumi.set(__self__, "value_case_sensitive", value_case_sensitive)
        if value_escaped is not None:
            pulumi.set(__self__, "value_escaped", value_escaped)
        if value_has_wildcard is not None:
            pulumi.set(__self__, "value_has_wildcard", value_has_wildcard)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="valueCaseSensitive")
    def value_case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property should be evaluated based on case sensitivity
        """
        return pulumi.get(self, "value_case_sensitive")

    @value_case_sensitive.setter
    def value_case_sensitive(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="valueEscaped")
    def value_escaped(self) -> Optional[_builtins.bool]:
        """
        Set to true if provided value should be compared in escaped form
        """
        return pulumi.get(self, "value_escaped")

    @value_escaped.setter
    def value_escaped(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_escaped", value)

    @_builtins.property
    @pulumi.getter(name="valueHasWildcard")
    def value_has_wildcard(self) -> Optional[_builtins.bool]:
        """
        Set to true if the entries for the value property include wildcards
        """
        return pulumi.get(self, "value_has_wildcard")

    @value_has_wildcard.setter
    def value_has_wildcard(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "value_has_wildcard", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value attributes in the incoming request to match on
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetCloudwrapperCapacitiesCapacityArgsDict(TypedDict):
        approved: 'GetCloudwrapperCapacitiesCapacityApprovedArgsDict'
        """
        Capacity allocated for the location.
        """
        assigned: 'GetCloudwrapperCapacitiesCapacityAssignedArgsDict'
        """
        Capacity already assigned to Cloud Wrapper configurations.
        """
        contract_id: _builtins.str
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        location_id: _builtins.int
        """
        Unique identifier of the configured location.
        """
        location_name: _builtins.str
        """
        Name of the location.
        """
        type: _builtins.str
        """
        The type of property this capacity is related to.
        """
        unassigned: 'GetCloudwrapperCapacitiesCapacityUnassignedArgsDict'
        """
        Capacity value that can be assigned to Cloud Wrapper configurations.
        """
elif False:
    GetCloudwrapperCapacitiesCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperCapacitiesCapacityArgs:
    def __init__(__self__, *,
                 approved: 'GetCloudwrapperCapacitiesCapacityApprovedArgs',
                 assigned: 'GetCloudwrapperCapacitiesCapacityAssignedArgs',
                 contract_id: _builtins.str,
                 location_id: _builtins.int,
                 location_name: _builtins.str,
                 type: _builtins.str,
                 unassigned: 'GetCloudwrapperCapacitiesCapacityUnassignedArgs'):
        """
        :param 'GetCloudwrapperCapacitiesCapacityApprovedArgs' approved: Capacity allocated for the location.
        :param 'GetCloudwrapperCapacitiesCapacityAssignedArgs' assigned: Capacity already assigned to Cloud Wrapper configurations.
        :param _builtins.str contract_id: Contract ID having Cloud Wrapper entitlement.
        :param _builtins.int location_id: Unique identifier of the configured location.
        :param _builtins.str location_name: Name of the location.
        :param _builtins.str type: The type of property this capacity is related to.
        :param 'GetCloudwrapperCapacitiesCapacityUnassignedArgs' unassigned: Capacity value that can be assigned to Cloud Wrapper configurations.
        """
        pulumi.set(__self__, "approved", approved)
        pulumi.set(__self__, "assigned", assigned)
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "location_name", location_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unassigned", unassigned)

    @_builtins.property
    @pulumi.getter
    def approved(self) -> 'GetCloudwrapperCapacitiesCapacityApprovedArgs':
        """
        Capacity allocated for the location.
        """
        return pulumi.get(self, "approved")

    @approved.setter
    def approved(self, value: 'GetCloudwrapperCapacitiesCapacityApprovedArgs'):
        pulumi.set(self, "approved", value)

    @_builtins.property
    @pulumi.getter
    def assigned(self) -> 'GetCloudwrapperCapacitiesCapacityAssignedArgs':
        """
        Capacity already assigned to Cloud Wrapper configurations.
        """
        return pulumi.get(self, "assigned")

    @assigned.setter
    def assigned(self, value: 'GetCloudwrapperCapacitiesCapacityAssignedArgs'):
        pulumi.set(self, "assigned", value)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @contract_id.setter
    def contract_id(self, value: _builtins.str):
        pulumi.set(self, "contract_id", value)

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.int:
        """
        Unique identifier of the configured location.
        """
        return pulumi.get(self, "location_id")

    @location_id.setter
    def location_id(self, value: _builtins.int):
        pulumi.set(self, "location_id", value)

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        Name of the location.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: _builtins.str):
        pulumi.set(self, "location_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of property this capacity is related to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def unassigned(self) -> 'GetCloudwrapperCapacitiesCapacityUnassignedArgs':
        """
        Capacity value that can be assigned to Cloud Wrapper configurations.
        """
        return pulumi.get(self, "unassigned")

    @unassigned.setter
    def unassigned(self, value: 'GetCloudwrapperCapacitiesCapacityUnassignedArgs'):
        pulumi.set(self, "unassigned", value)


if not MYPY:
    class GetCloudwrapperCapacitiesCapacityApprovedArgsDict(TypedDict):
        unit: _builtins.str
        value: _builtins.int
elif False:
    GetCloudwrapperCapacitiesCapacityApprovedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperCapacitiesCapacityApprovedArgs:
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: _builtins.str):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCloudwrapperCapacitiesCapacityAssignedArgsDict(TypedDict):
        unit: _builtins.str
        value: _builtins.int
elif False:
    GetCloudwrapperCapacitiesCapacityAssignedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperCapacitiesCapacityAssignedArgs:
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: _builtins.str):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCloudwrapperCapacitiesCapacityUnassignedArgsDict(TypedDict):
        unit: _builtins.str
        value: _builtins.int
elif False:
    GetCloudwrapperCapacitiesCapacityUnassignedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperCapacitiesCapacityUnassignedArgs:
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: _builtins.str):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCloudwrapperConfigurationLocationArgsDict(TypedDict):
        capacity: 'GetCloudwrapperConfigurationLocationCapacityArgsDict'
        """
        The capacity assigned to this configuration's location.
        """
        comments: _builtins.str
        """
        Additional comments provided by user.
        """
        map_name: _builtins.str
        """
        The name of the map.
        """
        traffic_type_id: _builtins.int
        """
        Unique identifier for the location and traffic type combination.
        """
elif False:
    GetCloudwrapperConfigurationLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationLocationArgs:
    def __init__(__self__, *,
                 capacity: 'GetCloudwrapperConfigurationLocationCapacityArgs',
                 comments: _builtins.str,
                 map_name: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param 'GetCloudwrapperConfigurationLocationCapacityArgs' capacity: The capacity assigned to this configuration's location.
        :param _builtins.str comments: Additional comments provided by user.
        :param _builtins.str map_name: The name of the map.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> 'GetCloudwrapperConfigurationLocationCapacityArgs':
        """
        The capacity assigned to this configuration's location.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: 'GetCloudwrapperConfigurationLocationCapacityArgs'):
        pulumi.set(self, "capacity", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional comments provided by user.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: _builtins.str):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        The name of the map.
        """
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: _builtins.str):
        pulumi.set(self, "map_name", value)

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")

    @traffic_type_id.setter
    def traffic_type_id(self, value: _builtins.int):
        pulumi.set(self, "traffic_type_id", value)


if not MYPY:
    class GetCloudwrapperConfigurationLocationCapacityArgsDict(TypedDict):
        unit: _builtins.str
        value: _builtins.int
elif False:
    GetCloudwrapperConfigurationLocationCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationLocationCapacityArgs:
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: _builtins.str):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsArgsDict(TypedDict):
        enable_soft_alerts: _builtins.bool
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        bocc: NotRequired['GetCloudwrapperConfigurationMultiCdnSettingsBoccArgsDict']
        """
        Specify diagnostic data beacons details.
        """
        cdns: NotRequired[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgsDict']]
        """
        List of CDN added for the configuration.
        """
        data_streams: NotRequired['GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgsDict']
        """
        Specifies data streams details.
        """
        origins: NotRequired[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgsDict']]
        """
        List of origins corresponding to the properties selected in the configuration.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsArgs:
    def __init__(__self__, *,
                 enable_soft_alerts: _builtins.bool,
                 bocc: Optional['GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs'] = None,
                 cdns: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs']] = None,
                 data_streams: Optional['GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs'] = None,
                 origins: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs']] = None):
        """
        :param _builtins.bool enable_soft_alerts: Option to opt out of alerts based on soft limits of bandwidth usage.
        :param 'GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs' bocc: Specify diagnostic data beacons details.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs'] cdns: List of CDN added for the configuration.
        :param 'GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs' data_streams: Specifies data streams details.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs'] origins: List of origins corresponding to the properties selected in the configuration.
        """
        pulumi.set(__self__, "enable_soft_alerts", enable_soft_alerts)
        if bocc is not None:
            pulumi.set(__self__, "bocc", bocc)
        if cdns is not None:
            pulumi.set(__self__, "cdns", cdns)
        if data_streams is not None:
            pulumi.set(__self__, "data_streams", data_streams)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)

    @_builtins.property
    @pulumi.getter(name="enableSoftAlerts")
    def enable_soft_alerts(self) -> _builtins.bool:
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        return pulumi.get(self, "enable_soft_alerts")

    @enable_soft_alerts.setter
    def enable_soft_alerts(self, value: _builtins.bool):
        pulumi.set(self, "enable_soft_alerts", value)

    @_builtins.property
    @pulumi.getter
    def bocc(self) -> Optional['GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs']:
        """
        Specify diagnostic data beacons details.
        """
        return pulumi.get(self, "bocc")

    @bocc.setter
    def bocc(self, value: Optional['GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs']):
        pulumi.set(self, "bocc", value)

    @_builtins.property
    @pulumi.getter
    def cdns(self) -> Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs']]:
        """
        List of CDN added for the configuration.
        """
        return pulumi.get(self, "cdns")

    @cdns.setter
    def cdns(self, value: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs']]):
        pulumi.set(self, "cdns", value)

    @_builtins.property
    @pulumi.getter(name="dataStreams")
    def data_streams(self) -> Optional['GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs']:
        """
        Specifies data streams details.
        """
        return pulumi.get(self, "data_streams")

    @data_streams.setter
    def data_streams(self, value: Optional['GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs']):
        pulumi.set(self, "data_streams", value)

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs']]:
        """
        List of origins corresponding to the properties selected in the configuration.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs']]):
        pulumi.set(self, "origins", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsBoccArgsDict(TypedDict):
        conditional_sampling_frequency: _builtins.str
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        enabled: _builtins.bool
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        forward_type: _builtins.str
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        request_type: _builtins.str
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        sampling_frequency: _builtins.str
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsBoccArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsBoccArgs:
    def __init__(__self__, *,
                 conditional_sampling_frequency: _builtins.str,
                 enabled: _builtins.bool,
                 forward_type: _builtins.str,
                 request_type: _builtins.str,
                 sampling_frequency: _builtins.str):
        """
        :param _builtins.str conditional_sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        :param _builtins.bool enabled: Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        :param _builtins.str forward_type: Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        :param _builtins.str request_type: Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        :param _builtins.str sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        pulumi.set(__self__, "conditional_sampling_frequency", conditional_sampling_frequency)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "forward_type", forward_type)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "sampling_frequency", sampling_frequency)

    @_builtins.property
    @pulumi.getter(name="conditionalSamplingFrequency")
    def conditional_sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "conditional_sampling_frequency")

    @conditional_sampling_frequency.setter
    def conditional_sampling_frequency(self, value: _builtins.str):
        pulumi.set(self, "conditional_sampling_frequency", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="forwardType")
    def forward_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        return pulumi.get(self, "forward_type")

    @forward_type.setter
    def forward_type(self, value: _builtins.str):
        pulumi.set(self, "forward_type", value)

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: _builtins.str):
        pulumi.set(self, "request_type", value)

    @_builtins.property
    @pulumi.getter(name="samplingFrequency")
    def sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "sampling_frequency")

    @sampling_frequency.setter
    def sampling_frequency(self, value: _builtins.str):
        pulumi.set(self, "sampling_frequency", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsCdnArgsDict(TypedDict):
        cdn_code: _builtins.str
        """
        Unique identifier for the CDN.
        """
        enabled: _builtins.bool
        """
        Enable CDN.
        """
        https_only: _builtins.bool
        """
        Specify whether CDN communication is HTTPS only.
        """
        ip_acl_cidrs: Sequence[_builtins.str]
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        cdn_auth_keys: NotRequired[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict']]
        """
        List of auth keys configured for the CDN.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsCdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsCdnArgs:
    def __init__(__self__, *,
                 cdn_code: _builtins.str,
                 enabled: _builtins.bool,
                 https_only: _builtins.bool,
                 ip_acl_cidrs: Sequence[_builtins.str],
                 cdn_auth_keys: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']] = None):
        """
        :param _builtins.str cdn_code: Unique identifier for the CDN.
        :param _builtins.bool enabled: Enable CDN.
        :param _builtins.bool https_only: Specify whether CDN communication is HTTPS only.
        :param Sequence[_builtins.str] ip_acl_cidrs: Configure an access control list using IP addresses in CIDR notation.
        :param Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs'] cdn_auth_keys: List of auth keys configured for the CDN.
        """
        pulumi.set(__self__, "cdn_code", cdn_code)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "https_only", https_only)
        pulumi.set(__self__, "ip_acl_cidrs", ip_acl_cidrs)
        if cdn_auth_keys is not None:
            pulumi.set(__self__, "cdn_auth_keys", cdn_auth_keys)

    @_builtins.property
    @pulumi.getter(name="cdnCode")
    def cdn_code(self) -> _builtins.str:
        """
        Unique identifier for the CDN.
        """
        return pulumi.get(self, "cdn_code")

    @cdn_code.setter
    def cdn_code(self, value: _builtins.str):
        pulumi.set(self, "cdn_code", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable CDN.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> _builtins.bool:
        """
        Specify whether CDN communication is HTTPS only.
        """
        return pulumi.get(self, "https_only")

    @https_only.setter
    def https_only(self, value: _builtins.bool):
        pulumi.set(self, "https_only", value)

    @_builtins.property
    @pulumi.getter(name="ipAclCidrs")
    def ip_acl_cidrs(self) -> Sequence[_builtins.str]:
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        return pulumi.get(self, "ip_acl_cidrs")

    @ip_acl_cidrs.setter
    def ip_acl_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "ip_acl_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="cdnAuthKeys")
    def cdn_auth_keys(self) -> Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']]:
        """
        List of auth keys configured for the CDN.
        """
        return pulumi.get(self, "cdn_auth_keys")

    @cdn_auth_keys.setter
    def cdn_auth_keys(self, value: Optional[Sequence['GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']]):
        pulumi.set(self, "cdn_auth_keys", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict(TypedDict):
        auth_key_name: _builtins.str
        """
        The name of the auth key.
        """
        expiry_date: _builtins.str
        """
        The expirty date of an auth key.
        """
        header_name: _builtins.str
        """
        The header name of an auth key.
        """
        secret: _builtins.str
        """
        The secret of an auth key.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs:
    def __init__(__self__, *,
                 auth_key_name: _builtins.str,
                 expiry_date: _builtins.str,
                 header_name: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str auth_key_name: The name of the auth key.
        :param _builtins.str expiry_date: The expirty date of an auth key.
        :param _builtins.str header_name: The header name of an auth key.
        :param _builtins.str secret: The secret of an auth key.
        """
        pulumi.set(__self__, "auth_key_name", auth_key_name)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="authKeyName")
    def auth_key_name(self) -> _builtins.str:
        """
        The name of the auth key.
        """
        return pulumi.get(self, "auth_key_name")

    @auth_key_name.setter
    def auth_key_name(self, value: _builtins.str):
        pulumi.set(self, "auth_key_name", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> _builtins.str:
        """
        The expirty date of an auth key.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: _builtins.str):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header name of an auth key.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: _builtins.str):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret of an auth key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgsDict(TypedDict):
        data_stream_ids: Sequence[_builtins.int]
        """
        Unique identifiers of the Data Streams.
        """
        enabled: _builtins.bool
        """
        Enables DataStream reporting.
        """
        sampling_rate: _builtins.int
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsDataStreamsArgs:
    def __init__(__self__, *,
                 data_stream_ids: Sequence[_builtins.int],
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.int):
        """
        :param Sequence[_builtins.int] data_stream_ids: Unique identifiers of the Data Streams.
        :param _builtins.bool enabled: Enables DataStream reporting.
        :param _builtins.int sampling_rate: Specifies the percentage of log data you want to collect for this configuration.
        """
        pulumi.set(__self__, "data_stream_ids", data_stream_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter(name="dataStreamIds")
    def data_stream_ids(self) -> Sequence[_builtins.int]:
        """
        Unique identifiers of the Data Streams.
        """
        return pulumi.get(self, "data_stream_ids")

    @data_stream_ids.setter
    def data_stream_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "data_stream_ids", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables DataStream reporting.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.int:
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
        return pulumi.get(self, "sampling_rate")

    @sampling_rate.setter
    def sampling_rate(self, value: _builtins.int):
        pulumi.set(self, "sampling_rate", value)


if not MYPY:
    class GetCloudwrapperConfigurationMultiCdnSettingsOriginArgsDict(TypedDict):
        hostname: _builtins.str
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        origin_id: _builtins.str
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        property_id: _builtins.int
        """
        Property ID of the property that origin belongs to.
        """
elif False:
    GetCloudwrapperConfigurationMultiCdnSettingsOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationMultiCdnSettingsOriginArgs:
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 origin_id: _builtins.str,
                 property_id: _builtins.int):
        """
        :param _builtins.str hostname: Origins hostname corresponding to the Akamai Delivery Property.
        :param _builtins.str origin_id: Origin identifier and will be used to generated Multi CDN host names.
        :param _builtins.int property_id: Property ID of the property that origin belongs to.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "property_id", property_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: _builtins.str):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: _builtins.str):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property that origin belongs to.
        """
        return pulumi.get(self, "property_id")

    @property_id.setter
    def property_id(self, value: _builtins.int):
        pulumi.set(self, "property_id", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationArgsDict(TypedDict):
        capacity_alerts_threshold: _builtins.int
        """
        Represents the threshold for sending alerts.
        """
        comments: _builtins.str
        """
        Additional information provided by user which can help to differentiate or track changes of the configuration.
        """
        config_name: _builtins.str
        """
        Name of the configuration.
        """
        contract_id: _builtins.str
        """
        Contract ID with Cloud Wrapper entitlement.
        """
        id: _builtins.int
        """
        Unique identifier of a Cloud Wrapper configuration.
        """
        last_activated_by: _builtins.str
        """
        User to last activate the configuration.
        """
        last_activated_date: _builtins.str
        """
        ISO format date that represents when the configuration was last activated successfully.
        """
        last_updated_by: _builtins.str
        """
        User to last modify the configuration.
        """
        last_updated_date: _builtins.str
        """
        ISO format date that represents when the configuration was last edited.
        """
        notification_emails: Sequence[_builtins.str]
        """
        Email addresses to receive notifications.
        """
        property_ids: Sequence[_builtins.str]
        """
        List of properties belonging to media delivery products. Properties need to be unique across configurations.
        """
        retain_idle_objects: _builtins.bool
        """
        Retain idle objects beyond their max idle lifetime.
        """
        status: _builtins.str
        """
        Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
        """
        locations: NotRequired[Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgsDict']]
        """
        List of all unused properties.
        """
        multi_cdn_settings: NotRequired['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgsDict']
        """
        Specify details about the Multi CDN settings.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationArgs:
    def __init__(__self__, *,
                 capacity_alerts_threshold: _builtins.int,
                 comments: _builtins.str,
                 config_name: _builtins.str,
                 contract_id: _builtins.str,
                 id: _builtins.int,
                 last_activated_by: _builtins.str,
                 last_activated_date: _builtins.str,
                 last_updated_by: _builtins.str,
                 last_updated_date: _builtins.str,
                 notification_emails: Sequence[_builtins.str],
                 property_ids: Sequence[_builtins.str],
                 retain_idle_objects: _builtins.bool,
                 status: _builtins.str,
                 locations: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgs']] = None,
                 multi_cdn_settings: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs'] = None):
        """
        :param _builtins.int capacity_alerts_threshold: Represents the threshold for sending alerts.
        :param _builtins.str comments: Additional information provided by user which can help to differentiate or track changes of the configuration.
        :param _builtins.str config_name: Name of the configuration.
        :param _builtins.str contract_id: Contract ID with Cloud Wrapper entitlement.
        :param _builtins.int id: Unique identifier of a Cloud Wrapper configuration.
        :param _builtins.str last_activated_by: User to last activate the configuration.
        :param _builtins.str last_activated_date: ISO format date that represents when the configuration was last activated successfully.
        :param _builtins.str last_updated_by: User to last modify the configuration.
        :param _builtins.str last_updated_date: ISO format date that represents when the configuration was last edited.
        :param Sequence[_builtins.str] notification_emails: Email addresses to receive notifications.
        :param Sequence[_builtins.str] property_ids: List of properties belonging to media delivery products. Properties need to be unique across configurations.
        :param _builtins.bool retain_idle_objects: Retain idle objects beyond their max idle lifetime.
        :param _builtins.str status: Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgs'] locations: List of all unused properties.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs' multi_cdn_settings: Specify details about the Multi CDN settings.
        """
        pulumi.set(__self__, "capacity_alerts_threshold", capacity_alerts_threshold)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "config_name", config_name)
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_activated_by", last_activated_by)
        pulumi.set(__self__, "last_activated_date", last_activated_date)
        pulumi.set(__self__, "last_updated_by", last_updated_by)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "notification_emails", notification_emails)
        pulumi.set(__self__, "property_ids", property_ids)
        pulumi.set(__self__, "retain_idle_objects", retain_idle_objects)
        pulumi.set(__self__, "status", status)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if multi_cdn_settings is not None:
            pulumi.set(__self__, "multi_cdn_settings", multi_cdn_settings)

    @_builtins.property
    @pulumi.getter(name="capacityAlertsThreshold")
    def capacity_alerts_threshold(self) -> _builtins.int:
        """
        Represents the threshold for sending alerts.
        """
        return pulumi.get(self, "capacity_alerts_threshold")

    @capacity_alerts_threshold.setter
    def capacity_alerts_threshold(self, value: _builtins.int):
        pulumi.set(self, "capacity_alerts_threshold", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional information provided by user which can help to differentiate or track changes of the configuration.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: _builtins.str):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter(name="configName")
    def config_name(self) -> _builtins.str:
        """
        Name of the configuration.
        """
        return pulumi.get(self, "config_name")

    @config_name.setter
    def config_name(self, value: _builtins.str):
        pulumi.set(self, "config_name", value)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID with Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @contract_id.setter
    def contract_id(self, value: _builtins.str):
        pulumi.set(self, "contract_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        Unique identifier of a Cloud Wrapper configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.int):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="lastActivatedBy")
    def last_activated_by(self) -> _builtins.str:
        """
        User to last activate the configuration.
        """
        return pulumi.get(self, "last_activated_by")

    @last_activated_by.setter
    def last_activated_by(self, value: _builtins.str):
        pulumi.set(self, "last_activated_by", value)

    @_builtins.property
    @pulumi.getter(name="lastActivatedDate")
    def last_activated_date(self) -> _builtins.str:
        """
        ISO format date that represents when the configuration was last activated successfully.
        """
        return pulumi.get(self, "last_activated_date")

    @last_activated_date.setter
    def last_activated_date(self, value: _builtins.str):
        pulumi.set(self, "last_activated_date", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedBy")
    def last_updated_by(self) -> _builtins.str:
        """
        User to last modify the configuration.
        """
        return pulumi.get(self, "last_updated_by")

    @last_updated_by.setter
    def last_updated_by(self, value: _builtins.str):
        pulumi.set(self, "last_updated_by", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> _builtins.str:
        """
        ISO format date that represents when the configuration was last edited.
        """
        return pulumi.get(self, "last_updated_date")

    @last_updated_date.setter
    def last_updated_date(self, value: _builtins.str):
        pulumi.set(self, "last_updated_date", value)

    @_builtins.property
    @pulumi.getter(name="notificationEmails")
    def notification_emails(self) -> Sequence[_builtins.str]:
        """
        Email addresses to receive notifications.
        """
        return pulumi.get(self, "notification_emails")

    @notification_emails.setter
    def notification_emails(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "notification_emails", value)

    @_builtins.property
    @pulumi.getter(name="propertyIds")
    def property_ids(self) -> Sequence[_builtins.str]:
        """
        List of properties belonging to media delivery products. Properties need to be unique across configurations.
        """
        return pulumi.get(self, "property_ids")

    @property_ids.setter
    def property_ids(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "property_ids", value)

    @_builtins.property
    @pulumi.getter(name="retainIdleObjects")
    def retain_idle_objects(self) -> _builtins.bool:
        """
        Retain idle objects beyond their max idle lifetime.
        """
        return pulumi.get(self, "retain_idle_objects")

    @retain_idle_objects.setter
    def retain_idle_objects(self, value: _builtins.bool):
        pulumi.set(self, "retain_idle_objects", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current state of the provisioning of the configuration, either SAVED, IN_PROGRESS, ACTIVE, DELETE_IN_PROGRESS, or FAILED.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgs']]:
        """
        List of all unused properties.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationLocationArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="multiCdnSettings")
    def multi_cdn_settings(self) -> Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs']:
        """
        Specify details about the Multi CDN settings.
        """
        return pulumi.get(self, "multi_cdn_settings")

    @multi_cdn_settings.setter
    def multi_cdn_settings(self, value: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs']):
        pulumi.set(self, "multi_cdn_settings", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationLocationArgsDict(TypedDict):
        capacity: 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgsDict'
        """
        The capacity assigned to this configuration's location.
        """
        comments: _builtins.str
        """
        Additional comments provided by user.
        """
        map_name: _builtins.str
        """
        The name of the map.
        """
        traffic_type_id: _builtins.int
        """
        Unique identifier for the location and traffic type combination.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationLocationArgs:
    def __init__(__self__, *,
                 capacity: 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs',
                 comments: _builtins.str,
                 map_name: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs' capacity: The capacity assigned to this configuration's location.
        :param _builtins.str comments: Additional comments provided by user.
        :param _builtins.str map_name: The name of the map.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs':
        """
        The capacity assigned to this configuration's location.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: 'GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs'):
        pulumi.set(self, "capacity", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Additional comments provided by user.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: _builtins.str):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        The name of the map.
        """
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: _builtins.str):
        pulumi.set(self, "map_name", value)

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")

    @traffic_type_id.setter
    def traffic_type_id(self, value: _builtins.int):
        pulumi.set(self, "traffic_type_id", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationLocationCapacityArgsDict(TypedDict):
        unit: _builtins.str
        value: _builtins.int
elif False:
    GetCloudwrapperConfigurationsConfigurationLocationCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationLocationCapacityArgs:
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: _builtins.str):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgsDict(TypedDict):
        enable_soft_alerts: _builtins.bool
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        bocc: NotRequired['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgsDict']
        """
        Specify diagnostic data beacons details.
        """
        cdns: NotRequired[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgsDict']]
        """
        List of CDN added for the configuration.
        """
        data_streams: NotRequired['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgsDict']
        """
        Specifies data streams details.
        """
        origins: NotRequired[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgsDict']]
        """
        List of origins corresponding to the properties selected in the configuration.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsArgs:
    def __init__(__self__, *,
                 enable_soft_alerts: _builtins.bool,
                 bocc: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs'] = None,
                 cdns: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs']] = None,
                 data_streams: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs'] = None,
                 origins: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs']] = None):
        """
        :param _builtins.bool enable_soft_alerts: Option to opt out of alerts based on soft limits of bandwidth usage.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs' bocc: Specify diagnostic data beacons details.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs'] cdns: List of CDN added for the configuration.
        :param 'GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs' data_streams: Specifies data streams details.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs'] origins: List of origins corresponding to the properties selected in the configuration.
        """
        pulumi.set(__self__, "enable_soft_alerts", enable_soft_alerts)
        if bocc is not None:
            pulumi.set(__self__, "bocc", bocc)
        if cdns is not None:
            pulumi.set(__self__, "cdns", cdns)
        if data_streams is not None:
            pulumi.set(__self__, "data_streams", data_streams)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)

    @_builtins.property
    @pulumi.getter(name="enableSoftAlerts")
    def enable_soft_alerts(self) -> _builtins.bool:
        """
        Option to opt out of alerts based on soft limits of bandwidth usage.
        """
        return pulumi.get(self, "enable_soft_alerts")

    @enable_soft_alerts.setter
    def enable_soft_alerts(self, value: _builtins.bool):
        pulumi.set(self, "enable_soft_alerts", value)

    @_builtins.property
    @pulumi.getter
    def bocc(self) -> Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs']:
        """
        Specify diagnostic data beacons details.
        """
        return pulumi.get(self, "bocc")

    @bocc.setter
    def bocc(self, value: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs']):
        pulumi.set(self, "bocc", value)

    @_builtins.property
    @pulumi.getter
    def cdns(self) -> Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs']]:
        """
        List of CDN added for the configuration.
        """
        return pulumi.get(self, "cdns")

    @cdns.setter
    def cdns(self, value: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs']]):
        pulumi.set(self, "cdns", value)

    @_builtins.property
    @pulumi.getter(name="dataStreams")
    def data_streams(self) -> Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs']:
        """
        Specifies data streams details.
        """
        return pulumi.get(self, "data_streams")

    @data_streams.setter
    def data_streams(self, value: Optional['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs']):
        pulumi.set(self, "data_streams", value)

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs']]:
        """
        List of origins corresponding to the properties selected in the configuration.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs']]):
        pulumi.set(self, "origins", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgsDict(TypedDict):
        conditional_sampling_frequency: _builtins.str
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        enabled: _builtins.bool
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        forward_type: _builtins.str
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        request_type: _builtins.str
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        sampling_frequency: _builtins.str
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsBoccArgs:
    def __init__(__self__, *,
                 conditional_sampling_frequency: _builtins.str,
                 enabled: _builtins.bool,
                 forward_type: _builtins.str,
                 request_type: _builtins.str,
                 sampling_frequency: _builtins.str):
        """
        :param _builtins.str conditional_sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        :param _builtins.bool enabled: Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        :param _builtins.str forward_type: Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        :param _builtins.str request_type: Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        :param _builtins.str sampling_frequency: The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        pulumi.set(__self__, "conditional_sampling_frequency", conditional_sampling_frequency)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "forward_type", forward_type)
        pulumi.set(__self__, "request_type", request_type)
        pulumi.set(__self__, "sampling_frequency", sampling_frequency)

    @_builtins.property
    @pulumi.getter(name="conditionalSamplingFrequency")
    def conditional_sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "conditional_sampling_frequency")

    @conditional_sampling_frequency.setter
    def conditional_sampling_frequency(self, value: _builtins.str):
        pulumi.set(self, "conditional_sampling_frequency", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable diagnostic data beacons for consumption by the Broadcast Operations Control Center.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="forwardType")
    def forward_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for internal ORIGIN_ONLY, MIDGRESS_ONLY, or both ORIGIN_AND_MIDGRESS forwards.
        """
        return pulumi.get(self, "forward_type")

    @forward_type.setter
    def forward_type(self, value: _builtins.str):
        pulumi.set(self, "forward_type", value)

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> _builtins.str:
        """
        Select whether to beacon diagnostics data for EDGE_ONLY or EDGE_AND_MIDGRESS requests.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: _builtins.str):
        pulumi.set(self, "request_type", value)

    @_builtins.property
    @pulumi.getter(name="samplingFrequency")
    def sampling_frequency(self) -> _builtins.str:
        """
        The sampling frequency of requests and forwards for EDGE, MIDGRESS, and ORIGIN beacons.
        """
        return pulumi.get(self, "sampling_frequency")

    @sampling_frequency.setter
    def sampling_frequency(self, value: _builtins.str):
        pulumi.set(self, "sampling_frequency", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgsDict(TypedDict):
        cdn_code: _builtins.str
        """
        Unique identifier for the CDN.
        """
        enabled: _builtins.bool
        """
        Enable CDN.
        """
        https_only: _builtins.bool
        """
        Specify whether CDN communication is HTTPS only.
        """
        ip_acl_cidrs: Sequence[_builtins.str]
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        cdn_auth_keys: NotRequired[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict']]
        """
        List of auth keys configured for the CDN.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnArgs:
    def __init__(__self__, *,
                 cdn_code: _builtins.str,
                 enabled: _builtins.bool,
                 https_only: _builtins.bool,
                 ip_acl_cidrs: Sequence[_builtins.str],
                 cdn_auth_keys: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']] = None):
        """
        :param _builtins.str cdn_code: Unique identifier for the CDN.
        :param _builtins.bool enabled: Enable CDN.
        :param _builtins.bool https_only: Specify whether CDN communication is HTTPS only.
        :param Sequence[_builtins.str] ip_acl_cidrs: Configure an access control list using IP addresses in CIDR notation.
        :param Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs'] cdn_auth_keys: List of auth keys configured for the CDN.
        """
        pulumi.set(__self__, "cdn_code", cdn_code)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "https_only", https_only)
        pulumi.set(__self__, "ip_acl_cidrs", ip_acl_cidrs)
        if cdn_auth_keys is not None:
            pulumi.set(__self__, "cdn_auth_keys", cdn_auth_keys)

    @_builtins.property
    @pulumi.getter(name="cdnCode")
    def cdn_code(self) -> _builtins.str:
        """
        Unique identifier for the CDN.
        """
        return pulumi.get(self, "cdn_code")

    @cdn_code.setter
    def cdn_code(self, value: _builtins.str):
        pulumi.set(self, "cdn_code", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable CDN.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> _builtins.bool:
        """
        Specify whether CDN communication is HTTPS only.
        """
        return pulumi.get(self, "https_only")

    @https_only.setter
    def https_only(self, value: _builtins.bool):
        pulumi.set(self, "https_only", value)

    @_builtins.property
    @pulumi.getter(name="ipAclCidrs")
    def ip_acl_cidrs(self) -> Sequence[_builtins.str]:
        """
        Configure an access control list using IP addresses in CIDR notation.
        """
        return pulumi.get(self, "ip_acl_cidrs")

    @ip_acl_cidrs.setter
    def ip_acl_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "ip_acl_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="cdnAuthKeys")
    def cdn_auth_keys(self) -> Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']]:
        """
        List of auth keys configured for the CDN.
        """
        return pulumi.get(self, "cdn_auth_keys")

    @cdn_auth_keys.setter
    def cdn_auth_keys(self, value: Optional[Sequence['GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs']]):
        pulumi.set(self, "cdn_auth_keys", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict(TypedDict):
        auth_key_name: _builtins.str
        """
        The name of the auth key.
        """
        expiry_date: _builtins.str
        """
        The expirty date of an auth key.
        """
        header_name: _builtins.str
        """
        The header name of an auth key.
        """
        secret: _builtins.str
        """
        The secret of an auth key.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsCdnCdnAuthKeyArgs:
    def __init__(__self__, *,
                 auth_key_name: _builtins.str,
                 expiry_date: _builtins.str,
                 header_name: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str auth_key_name: The name of the auth key.
        :param _builtins.str expiry_date: The expirty date of an auth key.
        :param _builtins.str header_name: The header name of an auth key.
        :param _builtins.str secret: The secret of an auth key.
        """
        pulumi.set(__self__, "auth_key_name", auth_key_name)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="authKeyName")
    def auth_key_name(self) -> _builtins.str:
        """
        The name of the auth key.
        """
        return pulumi.get(self, "auth_key_name")

    @auth_key_name.setter
    def auth_key_name(self, value: _builtins.str):
        pulumi.set(self, "auth_key_name", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> _builtins.str:
        """
        The expirty date of an auth key.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: _builtins.str):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The header name of an auth key.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: _builtins.str):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret of an auth key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgsDict(TypedDict):
        data_stream_ids: Sequence[_builtins.int]
        """
        Unique identifiers of the Data Streams.
        """
        enabled: _builtins.bool
        """
        Enables DataStream reporting.
        """
        sampling_rate: _builtins.int
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsDataStreamsArgs:
    def __init__(__self__, *,
                 data_stream_ids: Sequence[_builtins.int],
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.int):
        """
        :param Sequence[_builtins.int] data_stream_ids: Unique identifiers of the Data Streams.
        :param _builtins.bool enabled: Enables DataStream reporting.
        :param _builtins.int sampling_rate: Specifies the percentage of log data you want to collect for this configuration.
        """
        pulumi.set(__self__, "data_stream_ids", data_stream_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter(name="dataStreamIds")
    def data_stream_ids(self) -> Sequence[_builtins.int]:
        """
        Unique identifiers of the Data Streams.
        """
        return pulumi.get(self, "data_stream_ids")

    @data_stream_ids.setter
    def data_stream_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "data_stream_ids", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables DataStream reporting.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.int:
        """
        Specifies the percentage of log data you want to collect for this configuration.
        """
        return pulumi.get(self, "sampling_rate")

    @sampling_rate.setter
    def sampling_rate(self, value: _builtins.int):
        pulumi.set(self, "sampling_rate", value)


if not MYPY:
    class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgsDict(TypedDict):
        hostname: _builtins.str
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        origin_id: _builtins.str
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        property_id: _builtins.int
        """
        Property ID of the property that origin belongs to.
        """
elif False:
    GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperConfigurationsConfigurationMultiCdnSettingsOriginArgs:
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 origin_id: _builtins.str,
                 property_id: _builtins.int):
        """
        :param _builtins.str hostname: Origins hostname corresponding to the Akamai Delivery Property.
        :param _builtins.str origin_id: Origin identifier and will be used to generated Multi CDN host names.
        :param _builtins.int property_id: Property ID of the property that origin belongs to.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "origin_id", origin_id)
        pulumi.set(__self__, "property_id", property_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Origins hostname corresponding to the Akamai Delivery Property.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: _builtins.str):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        """
        Origin identifier and will be used to generated Multi CDN host names.
        """
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: _builtins.str):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property that origin belongs to.
        """
        return pulumi.get(self, "property_id")

    @property_id.setter
    def property_id(self, value: _builtins.int):
        pulumi.set(self, "property_id", value)


if not MYPY:
    class GetCloudwrapperLocationsLocationArgsDict(TypedDict):
        location_id: _builtins.int
        """
        Unique identifier of the location.
        """
        location_name: _builtins.str
        """
        Name of the location.
        """
        multi_cdn_location_id: _builtins.str
        """
        Unique identifier of the multi CDN location.
        """
        traffic_types: NotRequired[Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgsDict']]
        """
        List of traffic types for the location.
        """
elif False:
    GetCloudwrapperLocationsLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperLocationsLocationArgs:
    def __init__(__self__, *,
                 location_id: _builtins.int,
                 location_name: _builtins.str,
                 multi_cdn_location_id: _builtins.str,
                 traffic_types: Optional[Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgs']] = None):
        """
        :param _builtins.int location_id: Unique identifier of the location.
        :param _builtins.str location_name: Name of the location.
        :param _builtins.str multi_cdn_location_id: Unique identifier of the multi CDN location.
        :param Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgs'] traffic_types: List of traffic types for the location.
        """
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "location_name", location_name)
        pulumi.set(__self__, "multi_cdn_location_id", multi_cdn_location_id)
        if traffic_types is not None:
            pulumi.set(__self__, "traffic_types", traffic_types)

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.int:
        """
        Unique identifier of the location.
        """
        return pulumi.get(self, "location_id")

    @location_id.setter
    def location_id(self, value: _builtins.int):
        pulumi.set(self, "location_id", value)

    @_builtins.property
    @pulumi.getter(name="locationName")
    def location_name(self) -> _builtins.str:
        """
        Name of the location.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: _builtins.str):
        pulumi.set(self, "location_name", value)

    @_builtins.property
    @pulumi.getter(name="multiCdnLocationId")
    def multi_cdn_location_id(self) -> _builtins.str:
        """
        Unique identifier of the multi CDN location.
        """
        return pulumi.get(self, "multi_cdn_location_id")

    @multi_cdn_location_id.setter
    def multi_cdn_location_id(self, value: _builtins.str):
        pulumi.set(self, "multi_cdn_location_id", value)

    @_builtins.property
    @pulumi.getter(name="trafficTypes")
    def traffic_types(self) -> Optional[Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgs']]:
        """
        List of traffic types for the location.
        """
        return pulumi.get(self, "traffic_types")

    @traffic_types.setter
    def traffic_types(self, value: Optional[Sequence['GetCloudwrapperLocationsLocationTrafficTypeArgs']]):
        pulumi.set(self, "traffic_types", value)


if not MYPY:
    class GetCloudwrapperLocationsLocationTrafficTypeArgsDict(TypedDict):
        location_id: _builtins.str
        """
        Represents the failover map.
        """
        traffic_type: _builtins.str
        """
        Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
        """
        traffic_type_id: _builtins.int
        """
        Unique identifier for the location and traffic type combination.
        """
elif False:
    GetCloudwrapperLocationsLocationTrafficTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperLocationsLocationTrafficTypeArgs:
    def __init__(__self__, *,
                 location_id: _builtins.str,
                 traffic_type: _builtins.str,
                 traffic_type_id: _builtins.int):
        """
        :param _builtins.str location_id: Represents the failover map.
        :param _builtins.str traffic_type: Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
        :param _builtins.int traffic_type_id: Unique identifier for the location and traffic type combination.
        """
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "traffic_type", traffic_type)
        pulumi.set(__self__, "traffic_type_id", traffic_type_id)

    @_builtins.property
    @pulumi.getter(name="locationId")
    def location_id(self) -> _builtins.str:
        """
        Represents the failover map.
        """
        return pulumi.get(self, "location_id")

    @location_id.setter
    def location_id(self, value: _builtins.str):
        pulumi.set(self, "location_id", value)

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> _builtins.str:
        """
        Represents the traffic type. LIVE applies to low-latency media traffic, such as live streaming. LIVE_VOD applies to redundant media traffic, like video on demand content. WEB_STANDARD_TLS or WEB_ENHANCED_TLS applies to web content using Standard TLS security or Enhanced TLS security, respectively.
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: _builtins.str):
        pulumi.set(self, "traffic_type", value)

    @_builtins.property
    @pulumi.getter(name="trafficTypeId")
    def traffic_type_id(self) -> _builtins.int:
        """
        Unique identifier for the location and traffic type combination.
        """
        return pulumi.get(self, "traffic_type_id")

    @traffic_type_id.setter
    def traffic_type_id(self, value: _builtins.int):
        pulumi.set(self, "traffic_type_id", value)


if not MYPY:
    class GetCloudwrapperPropertiesPropertyArgsDict(TypedDict):
        contract_id: _builtins.str
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        group_id: _builtins.int
        """
        ID of the group which the property belongs to.
        """
        property_id: _builtins.int
        """
        Property ID of the property.
        """
        property_name: _builtins.str
        """
        Name of the property belonging to the origin.
        """
        type: _builtins.str
        """
        The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
        """
elif False:
    GetCloudwrapperPropertiesPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudwrapperPropertiesPropertyArgs:
    def __init__(__self__, *,
                 contract_id: _builtins.str,
                 group_id: _builtins.int,
                 property_id: _builtins.int,
                 property_name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str contract_id: Contract ID having Cloud Wrapper entitlement.
        :param _builtins.int group_id: ID of the group which the property belongs to.
        :param _builtins.int property_id: Property ID of the property.
        :param _builtins.str property_name: Name of the property belonging to the origin.
        :param _builtins.str type: The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
        """
        pulumi.set(__self__, "contract_id", contract_id)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "property_id", property_id)
        pulumi.set(__self__, "property_name", property_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="contractId")
    def contract_id(self) -> _builtins.str:
        """
        Contract ID having Cloud Wrapper entitlement.
        """
        return pulumi.get(self, "contract_id")

    @contract_id.setter
    def contract_id(self, value: _builtins.str):
        pulumi.set(self, "contract_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        ID of the group which the property belongs to.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: _builtins.int):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> _builtins.int:
        """
        Property ID of the property.
        """
        return pulumi.get(self, "property_id")

    @property_id.setter
    def property_id(self, value: _builtins.int):
        pulumi.set(self, "property_id", value)

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> _builtins.str:
        """
        Name of the property belonging to the origin.
        """
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: _builtins.str):
        pulumi.set(self, "property_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of property. MEDIA applies to live or video on demand content. WEB applies to website or app content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetGtmAsmapAssignmentArgsDict(TypedDict):
        as_numbers: Sequence[_builtins.int]
        """
        Specifies an array of AS numbers.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        nickname: _builtins.str
        """
        A descriptive label for the group.
        """
elif False:
    GetGtmAsmapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmAsmapAssignmentArgs:
    def __init__(__self__, *,
                 as_numbers: Sequence[_builtins.int],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.int] as_numbers: Specifies an array of AS numbers.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the group.
        """
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> Sequence[_builtins.int]:
        """
        Specifies an array of AS numbers.
        """
        return pulumi.get(self, "as_numbers")

    @as_numbers.setter
    def as_numbers(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "as_numbers", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmAsmapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        For each property, an identifier for all other AS zones
        """
        nickname: _builtins.str
        """
        A descriptive label for all other AS zones
        """
elif False:
    GetGtmAsmapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmAsmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other AS zones
        :param _builtins.str nickname: A descriptive label for all other AS zones
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other AS zones
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmAsmapLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmAsmapLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmAsmapLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmCidrmapAssignmentArgsDict(TypedDict):
        blocks: Sequence[_builtins.str]
        """
        Specifies an array of CIDR blocks.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        nickname: _builtins.str
        """
        A descriptive label for the CIDR zone group.
        """
elif False:
    GetGtmCidrmapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmCidrmapAssignmentArgs:
    def __init__(__self__, *,
                 blocks: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] blocks: Specifies an array of CIDR blocks.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for the CIDR zone group.
        """
        pulumi.set(__self__, "blocks", blocks)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of CIDR blocks.
        """
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "blocks", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the CIDR zone group.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmCidrmapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other CIDR blocks.
        """
elif False:
    GetGtmCidrmapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmCidrmapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other CIDR zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other CIDR blocks.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other CIDR blocks.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmCidrmapLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmCidrmapLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmCidrmapLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainAsMapArgsDict(TypedDict):
        name: _builtins.str
        """
        A descriptive label for the AS map.
        """
        assignments: NotRequired[Sequence['GetGtmDomainAsMapAssignmentArgsDict']]
        """
        Contains information about the AS zone groupings of AS IDs.
        """
        default_datacenter: NotRequired['GetGtmDomainAsMapDefaultDatacenterArgsDict']
        """
        A placeholder for all other AS zones, AS IDs not found in these AS zones.
        """
        links: NotRequired[Sequence['GetGtmDomainAsMapLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the As map.
        """
elif False:
    GetGtmDomainAsMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainAsMapArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['GetGtmDomainAsMapAssignmentArgs']] = None,
                 default_datacenter: Optional['GetGtmDomainAsMapDefaultDatacenterArgs'] = None,
                 links: Optional[Sequence['GetGtmDomainAsMapLinkArgs']] = None):
        """
        :param _builtins.str name: A descriptive label for the AS map.
        :param Sequence['GetGtmDomainAsMapAssignmentArgs'] assignments: Contains information about the AS zone groupings of AS IDs.
        :param 'GetGtmDomainAsMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other AS zones, AS IDs not found in these AS zones.
        :param Sequence['GetGtmDomainAsMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the As map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the AS map.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['GetGtmDomainAsMapAssignmentArgs']]:
        """
        Contains information about the AS zone groupings of AS IDs.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[Sequence['GetGtmDomainAsMapAssignmentArgs']]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['GetGtmDomainAsMapDefaultDatacenterArgs']:
        """
        A placeholder for all other AS zones, AS IDs not found in these AS zones.
        """
        return pulumi.get(self, "default_datacenter")

    @default_datacenter.setter
    def default_datacenter(self, value: Optional['GetGtmDomainAsMapDefaultDatacenterArgs']):
        pulumi.set(self, "default_datacenter", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainAsMapLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the As map.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainAsMapLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainAsMapAssignmentArgsDict(TypedDict):
        as_numbers: Sequence[_builtins.int]
        """
        Specifies an array of AS numbers.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other AS zones.
        """
elif False:
    GetGtmDomainAsMapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainAsMapAssignmentArgs:
    def __init__(__self__, *,
                 as_numbers: Sequence[_builtins.int],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.int] as_numbers: Specifies an array of AS numbers.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "as_numbers", as_numbers)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="asNumbers")
    def as_numbers(self) -> Sequence[_builtins.int]:
        """
        Specifies an array of AS numbers.
        """
        return pulumi.get(self, "as_numbers")

    @as_numbers.setter
    def as_numbers(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "as_numbers", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainAsMapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        For each property, an identifier for all other AS zones' CNAME.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other AS zones.
        """
elif False:
    GetGtmDomainAsMapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainAsMapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other AS zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other AS zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainAsMapLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainAsMapLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainAsMapLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainCidrMapArgsDict(TypedDict):
        name: _builtins.str
        """
        Unique name for the CIDR map.
        """
        assignments: NotRequired[Sequence['GetGtmDomainCidrMapAssignmentArgsDict']]
        """
        Contains information about the CIDR zone groupings of CIDR blocks.
        """
        default_datacenter: NotRequired['GetGtmDomainCidrMapDefaultDatacenterArgsDict']
        """
        A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
        """
        links: NotRequired[Sequence['GetGtmDomainCidrMapLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the CIDR map.
        """
elif False:
    GetGtmDomainCidrMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainCidrMapArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['GetGtmDomainCidrMapAssignmentArgs']] = None,
                 default_datacenter: Optional['GetGtmDomainCidrMapDefaultDatacenterArgs'] = None,
                 links: Optional[Sequence['GetGtmDomainCidrMapLinkArgs']] = None):
        """
        :param _builtins.str name: Unique name for the CIDR map.
        :param Sequence['GetGtmDomainCidrMapAssignmentArgs'] assignments: Contains information about the CIDR zone groupings of CIDR blocks.
        :param 'GetGtmDomainCidrMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
        :param Sequence['GetGtmDomainCidrMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the CIDR map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for the CIDR map.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['GetGtmDomainCidrMapAssignmentArgs']]:
        """
        Contains information about the CIDR zone groupings of CIDR blocks.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[Sequence['GetGtmDomainCidrMapAssignmentArgs']]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['GetGtmDomainCidrMapDefaultDatacenterArgs']:
        """
        A placeholder for all other CIDR zones, CIDR blocks not found in these CIDR zones.
        """
        return pulumi.get(self, "default_datacenter")

    @default_datacenter.setter
    def default_datacenter(self, value: Optional['GetGtmDomainCidrMapDefaultDatacenterArgs']):
        pulumi.set(self, "default_datacenter", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainCidrMapLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the CIDR map.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainCidrMapLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainCidrMapAssignmentArgsDict(TypedDict):
        blocks: Sequence[_builtins.str]
        """
        Specifies an array of CIDR blocks.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other AS zones.
        """
elif False:
    GetGtmDomainCidrMapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainCidrMapAssignmentArgs:
    def __init__(__self__, *,
                 blocks: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] blocks: Specifies an array of CIDR blocks.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "blocks", blocks)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def blocks(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of CIDR blocks.
        """
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "blocks", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainCidrMapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other CIDR blocks.
        """
elif False:
    GetGtmDomainCidrMapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainCidrMapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: For each property, an identifier for all other CIDR zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other CIDR blocks.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        For each property, an identifier for all other CIDR zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other CIDR blocks.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainCidrMapLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainCidrMapLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainCidrMapLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainDatacenterArgsDict(TypedDict):
        city: _builtins.str
        """
        The name of the city where the data center is located.
        """
        clone_of: _builtins.int
        """
        Identifies the data center's ID of which this data center is a clone.
        """
        cloud_server_host_header_override: _builtins.bool
        """
        Balances load between two or more servers in a cloud environment.
        """
        cloud_server_targeting: _builtins.bool
        """
        Balances load between two or more servers in a cloud environment.
        """
        continent: _builtins.str
        """
        A two-letter code that specifies the continent where the data center maps to.
        """
        country: _builtins.str
        """
        A two-letter ISO 3166 country code that specifies the country where the data center is located.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        latitude: _builtins.float
        """
        Specifies the geographic latitude of the data center's position.
        """
        longitude: _builtins.float
        """
        Specifies the geographic longitude of the data center's position.
        """
        nickname: _builtins.str
        """
        A descriptive label for the datacenter.
        """
        score_penalty: _builtins.int
        """
        Influences the score for a datacenter.
        """
        server_monitor_pool: _builtins.str
        """
        The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
        """
        state_or_province: _builtins.str
        """
        Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        """
        virtual: _builtins.bool
        """
        Indicates whether or not the data center is virtual or physical.
        """
        default_load_objects: NotRequired[Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgsDict']]
        """
        Specifies the load reporting interface between you and the GTM system.
        """
        links: NotRequired[Sequence['GetGtmDomainDatacenterLinkArgsDict']]
        """
        Provides a URL path that allows direct navigation to a data center.
        """
elif False:
    GetGtmDomainDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainDatacenterArgs:
    def __init__(__self__, *,
                 city: _builtins.str,
                 clone_of: _builtins.int,
                 cloud_server_host_header_override: _builtins.bool,
                 cloud_server_targeting: _builtins.bool,
                 continent: _builtins.str,
                 country: _builtins.str,
                 datacenter_id: _builtins.int,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 nickname: _builtins.str,
                 score_penalty: _builtins.int,
                 server_monitor_pool: _builtins.str,
                 state_or_province: _builtins.str,
                 virtual: _builtins.bool,
                 default_load_objects: Optional[Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgs']] = None,
                 links: Optional[Sequence['GetGtmDomainDatacenterLinkArgs']] = None):
        """
        :param _builtins.str city: The name of the city where the data center is located.
        :param _builtins.int clone_of: Identifies the data center's ID of which this data center is a clone.
        :param _builtins.bool cloud_server_host_header_override: Balances load between two or more servers in a cloud environment.
        :param _builtins.bool cloud_server_targeting: Balances load between two or more servers in a cloud environment.
        :param _builtins.str continent: A two-letter code that specifies the continent where the data center maps to.
        :param _builtins.str country: A two-letter ISO 3166 country code that specifies the country where the data center is located.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.float latitude: Specifies the geographic latitude of the data center's position.
        :param _builtins.float longitude: Specifies the geographic longitude of the data center's position.
        :param _builtins.str nickname: A descriptive label for the datacenter.
        :param _builtins.int score_penalty: Influences the score for a datacenter.
        :param _builtins.str server_monitor_pool: The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
        :param _builtins.str state_or_province: Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        :param _builtins.bool virtual: Indicates whether or not the data center is virtual or physical.
        :param Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgs'] default_load_objects: Specifies the load reporting interface between you and the GTM system.
        :param Sequence['GetGtmDomainDatacenterLinkArgs'] links: Provides a URL path that allows direct navigation to a data center.
        """
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "clone_of", clone_of)
        pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
        pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
        pulumi.set(__self__, "continent", continent)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "nickname", nickname)
        pulumi.set(__self__, "score_penalty", score_penalty)
        pulumi.set(__self__, "server_monitor_pool", server_monitor_pool)
        pulumi.set(__self__, "state_or_province", state_or_province)
        pulumi.set(__self__, "virtual", virtual)
        if default_load_objects is not None:
            pulumi.set(__self__, "default_load_objects", default_load_objects)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The name of the city where the data center is located.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: _builtins.str):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter(name="cloneOf")
    def clone_of(self) -> _builtins.int:
        """
        Identifies the data center's ID of which this data center is a clone.
        """
        return pulumi.get(self, "clone_of")

    @clone_of.setter
    def clone_of(self, value: _builtins.int):
        pulumi.set(self, "clone_of", value)

    @_builtins.property
    @pulumi.getter(name="cloudServerHostHeaderOverride")
    def cloud_server_host_header_override(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_host_header_override")

    @cloud_server_host_header_override.setter
    def cloud_server_host_header_override(self, value: _builtins.bool):
        pulumi.set(self, "cloud_server_host_header_override", value)

    @_builtins.property
    @pulumi.getter(name="cloudServerTargeting")
    def cloud_server_targeting(self) -> _builtins.bool:
        """
        Balances load between two or more servers in a cloud environment.
        """
        return pulumi.get(self, "cloud_server_targeting")

    @cloud_server_targeting.setter
    def cloud_server_targeting(self, value: _builtins.bool):
        pulumi.set(self, "cloud_server_targeting", value)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> _builtins.str:
        """
        A two-letter code that specifies the continent where the data center maps to.
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: _builtins.str):
        pulumi.set(self, "continent", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        A two-letter ISO 3166 country code that specifies the country where the data center is located.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: _builtins.str):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        Specifies the geographic latitude of the data center's position.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: _builtins.float):
        pulumi.set(self, "latitude", value)

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        Specifies the geographic longitude of the data center's position.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: _builtins.float):
        pulumi.set(self, "longitude", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for the datacenter.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)

    @_builtins.property
    @pulumi.getter(name="scorePenalty")
    def score_penalty(self) -> _builtins.int:
        """
        Influences the score for a datacenter.
        """
        return pulumi.get(self, "score_penalty")

    @score_penalty.setter
    def score_penalty(self, value: _builtins.int):
        pulumi.set(self, "score_penalty", value)

    @_builtins.property
    @pulumi.getter(name="serverMonitorPool")
    def server_monitor_pool(self) -> _builtins.str:
        """
        The name of the pool from which servermonitors are drawn for liveness tests in this datacenter. If omitted (null), the domain-wide default is used. (If no domain-wide default is specified, the pool used is all servermonitors in the same continent as the datacenter.).
        """
        return pulumi.get(self, "server_monitor_pool")

    @server_monitor_pool.setter
    def server_monitor_pool(self, value: _builtins.str):
        pulumi.set(self, "server_monitor_pool", value)

    @_builtins.property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> _builtins.str:
        """
        Specifies a two-letter ISO 3166 country code for the state of province, where the data center is located.
        """
        return pulumi.get(self, "state_or_province")

    @state_or_province.setter
    def state_or_province(self, value: _builtins.str):
        pulumi.set(self, "state_or_province", value)

    @_builtins.property
    @pulumi.getter
    def virtual(self) -> _builtins.bool:
        """
        Indicates whether or not the data center is virtual or physical.
        """
        return pulumi.get(self, "virtual")

    @virtual.setter
    def virtual(self, value: _builtins.bool):
        pulumi.set(self, "virtual", value)

    @_builtins.property
    @pulumi.getter(name="defaultLoadObjects")
    def default_load_objects(self) -> Optional[Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgs']]:
        """
        Specifies the load reporting interface between you and the GTM system.
        """
        return pulumi.get(self, "default_load_objects")

    @default_load_objects.setter
    def default_load_objects(self, value: Optional[Sequence['GetGtmDomainDatacenterDefaultLoadObjectArgs']]):
        pulumi.set(self, "default_load_objects", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainDatacenterLinkArgs']]:
        """
        Provides a URL path that allows direct navigation to a data center.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainDatacenterLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainDatacenterDefaultLoadObjectArgsDict(TypedDict):
        load_object: _builtins.str
        """
        Specifies the load object that GTM requests.
        """
        load_object_port: _builtins.int
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        load_servers: Sequence[_builtins.str]
        """
        Specifies the list of servers to requests the load object from.
        """
elif False:
    GetGtmDomainDatacenterDefaultLoadObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainDatacenterDefaultLoadObjectArgs:
    def __init__(__self__, *,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str load_object: Specifies the load object that GTM requests.
        :param _builtins.int load_object_port: Specifies the TCP port to connect to when requesting the load object.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        """
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Specifies the load object that GTM requests.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: _builtins.str):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port to connect to when requesting the load object.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: _builtins.int):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "load_servers", value)


if not MYPY:
    class GetGtmDomainDatacenterLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainDatacenterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainDatacenterLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainGeographicMapArgsDict(TypedDict):
        name: _builtins.str
        """
        A descriptive label for the geographic map.
        """
        assignments: NotRequired[Sequence['GetGtmDomainGeographicMapAssignmentArgsDict']]
        """
        Contains information about the geographic zone groupings of countries.
        """
        default_datacenter: NotRequired['GetGtmDomainGeographicMapDefaultDatacenterArgsDict']
        """
        A placeholder for all other geographic zones, countries not found in these geographic zones.
        """
        links: NotRequired[Sequence['GetGtmDomainGeographicMapLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the geographic map.
        """
elif False:
    GetGtmDomainGeographicMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainGeographicMapArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 assignments: Optional[Sequence['GetGtmDomainGeographicMapAssignmentArgs']] = None,
                 default_datacenter: Optional['GetGtmDomainGeographicMapDefaultDatacenterArgs'] = None,
                 links: Optional[Sequence['GetGtmDomainGeographicMapLinkArgs']] = None):
        """
        :param _builtins.str name: A descriptive label for the geographic map.
        :param Sequence['GetGtmDomainGeographicMapAssignmentArgs'] assignments: Contains information about the geographic zone groupings of countries.
        :param 'GetGtmDomainGeographicMapDefaultDatacenterArgs' default_datacenter: A placeholder for all other geographic zones, countries not found in these geographic zones.
        :param Sequence['GetGtmDomainGeographicMapLinkArgs'] links: Specifies the URL path that allows direct navigation to the geographic map.
        """
        pulumi.set(__self__, "name", name)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if default_datacenter is not None:
            pulumi.set(__self__, "default_datacenter", default_datacenter)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the geographic map.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['GetGtmDomainGeographicMapAssignmentArgs']]:
        """
        Contains information about the geographic zone groupings of countries.
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[Sequence['GetGtmDomainGeographicMapAssignmentArgs']]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatacenter")
    def default_datacenter(self) -> Optional['GetGtmDomainGeographicMapDefaultDatacenterArgs']:
        """
        A placeholder for all other geographic zones, countries not found in these geographic zones.
        """
        return pulumi.get(self, "default_datacenter")

    @default_datacenter.setter
    def default_datacenter(self, value: Optional['GetGtmDomainGeographicMapDefaultDatacenterArgs']):
        pulumi.set(self, "default_datacenter", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainGeographicMapLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the geographic map.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainGeographicMapLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainGeographicMapAssignmentArgsDict(TypedDict):
        countries: Sequence[_builtins.str]
        """
        Specifies an array of two-letter ISO 3166 `country` codes.
        """
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other AS zones.
        """
elif False:
    GetGtmDomainGeographicMapAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainGeographicMapAssignmentArgs:
    def __init__(__self__, *,
                 countries: Sequence[_builtins.str],
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param Sequence[_builtins.str] countries: Specifies an array of two-letter ISO 3166 `country` codes.
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str nickname: A descriptive label for all other AS zones.
        """
        pulumi.set(__self__, "countries", countries)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter
    def countries(self) -> Sequence[_builtins.str]:
        """
        Specifies an array of two-letter ISO 3166 `country` codes.
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "countries", value)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other AS zones.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainGeographicMapDefaultDatacenterArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        An identifier for all other geographic zones' CNAME.
        """
        nickname: _builtins.str
        """
        A descriptive label for all other geographic zones.
        """
elif False:
    GetGtmDomainGeographicMapDefaultDatacenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainGeographicMapDefaultDatacenterArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 nickname: _builtins.str):
        """
        :param _builtins.int datacenter_id: An identifier for all other geographic zones' CNAME.
        :param _builtins.str nickname: A descriptive label for all other geographic zones.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "nickname", nickname)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        An identifier for all other geographic zones' CNAME.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def nickname(self) -> _builtins.str:
        """
        A descriptive label for all other geographic zones.
        """
        return pulumi.get(self, "nickname")

    @nickname.setter
    def nickname(self, value: _builtins.str):
        pulumi.set(self, "nickname", value)


if not MYPY:
    class GetGtmDomainGeographicMapLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainGeographicMapLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainGeographicMapLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainPropertyArgsDict(TypedDict):
        backup_cname: _builtins.str
        """
        Specifies a backup CNAME.
        """
        backup_ip: _builtins.str
        """
        Specifies a backup IP.
        """
        balance_by_download_score: _builtins.bool
        """
        Indicates whether download score based load balancing is enabled.
        """
        cname: _builtins.str
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        comments: _builtins.str
        """
        Descriptive comments for the property.
        """
        dynamic_ttl: _builtins.int
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        """
        failback_delay: _builtins.int
        """
        Specifies the failback delay in seconds.
        """
        failover_delay: _builtins.int
        """
        Specifies the failover delay in seconds.
        """
        ghost_demand_reporting: _builtins.bool
        """
        Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        """
        handout_limit: _builtins.int
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        handout_mode: _builtins.str
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        health_max: _builtins.float
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        health_multiplier: _builtins.float
        """
        Configures a cutoff value that is computed from the median scores.
        """
        health_threshold: _builtins.float
        """
        Configures a cutoff value that is computed from the median scores.
        """
        ipv6: _builtins.bool
        """
        Indicates the type of IP address handed out by a property.
        """
        last_modified: _builtins.str
        """
        An ISO 8601 timestamp that indicates when the property was last changed.
        """
        load_imbalance_percentage: _builtins.float
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        map_name: _builtins.str
        """
        A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        """
        max_unreachable_penalty: _builtins.int
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        min_live_fraction: _builtins.float
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        name: _builtins.str
        """
        A descriptive label for the property.
        """
        score_aggregation_type: _builtins.str
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        static_ttl: _builtins.int
        """
        Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        """
        stickness_bonus_constant: _builtins.int
        """
        Specifies a percentage used to configure data center affinity.
        """
        stickness_bonus_percentage: _builtins.int
        """
        Specifies a percentage used to configure data center affinity.
        """
        type: _builtins.str
        """
        Specifies the load balancing behvior for the property.
        """
        unreachable_threshold: _builtins.float
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        use_computed_targets: _builtins.bool
        """
        For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        """
        weighted_hash_bits_for_ipv4: _builtins.int
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        """
        weighted_hash_bits_for_ipv6: _builtins.int
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        """
        links: NotRequired[Sequence['GetGtmDomainPropertyLinkArgsDict']]
        """
        Provides a URL path that allows direct navigation to the property.
        """
        liveness_tests: NotRequired[Sequence['GetGtmDomainPropertyLivenessTestArgsDict']]
        """
        Contains information about liveness tests.
        """
        static_rr_sets: NotRequired[Sequence['GetGtmDomainPropertyStaticRrSetArgsDict']]
        """
        Contains static recordsets.
        """
        traffic_targets: NotRequired[Sequence['GetGtmDomainPropertyTrafficTargetArgsDict']]
        """
        Traffic targets for the property.
        """
elif False:
    GetGtmDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyArgs:
    def __init__(__self__, *,
                 backup_cname: _builtins.str,
                 backup_ip: _builtins.str,
                 balance_by_download_score: _builtins.bool,
                 cname: _builtins.str,
                 comments: _builtins.str,
                 dynamic_ttl: _builtins.int,
                 failback_delay: _builtins.int,
                 failover_delay: _builtins.int,
                 ghost_demand_reporting: _builtins.bool,
                 handout_limit: _builtins.int,
                 handout_mode: _builtins.str,
                 health_max: _builtins.float,
                 health_multiplier: _builtins.float,
                 health_threshold: _builtins.float,
                 ipv6: _builtins.bool,
                 last_modified: _builtins.str,
                 load_imbalance_percentage: _builtins.float,
                 map_name: _builtins.str,
                 max_unreachable_penalty: _builtins.int,
                 min_live_fraction: _builtins.float,
                 name: _builtins.str,
                 score_aggregation_type: _builtins.str,
                 static_ttl: _builtins.int,
                 stickness_bonus_constant: _builtins.int,
                 stickness_bonus_percentage: _builtins.int,
                 type: _builtins.str,
                 unreachable_threshold: _builtins.float,
                 use_computed_targets: _builtins.bool,
                 weighted_hash_bits_for_ipv4: _builtins.int,
                 weighted_hash_bits_for_ipv6: _builtins.int,
                 links: Optional[Sequence['GetGtmDomainPropertyLinkArgs']] = None,
                 liveness_tests: Optional[Sequence['GetGtmDomainPropertyLivenessTestArgs']] = None,
                 static_rr_sets: Optional[Sequence['GetGtmDomainPropertyStaticRrSetArgs']] = None,
                 traffic_targets: Optional[Sequence['GetGtmDomainPropertyTrafficTargetArgs']] = None):
        """
        :param _builtins.str backup_cname: Specifies a backup CNAME.
        :param _builtins.str backup_ip: Specifies a backup IP.
        :param _builtins.bool balance_by_download_score: Indicates whether download score based load balancing is enabled.
        :param _builtins.str cname: Indicates the fully qualified name aliased to a particular property.
        :param _builtins.str comments: Descriptive comments for the property.
        :param _builtins.int dynamic_ttl: Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        :param _builtins.int failback_delay: Specifies the failback delay in seconds.
        :param _builtins.int failover_delay: Specifies the failover delay in seconds.
        :param _builtins.bool ghost_demand_reporting: Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        :param _builtins.int handout_limit: Indicates the limit for the number of live IPs handed out to a DNS request.
        :param _builtins.str handout_mode: Specifies how IPs are returned when more than one IP is alive and available.
        :param _builtins.float health_max: Defines the absolute limit beyond which IPs are declared unhealthy.
        :param _builtins.float health_multiplier: Configures a cutoff value that is computed from the median scores.
        :param _builtins.float health_threshold: Configures a cutoff value that is computed from the median scores.
        :param _builtins.bool ipv6: Indicates the type of IP address handed out by a property.
        :param _builtins.str last_modified: An ISO 8601 timestamp that indicates when the property was last changed.
        :param _builtins.float load_imbalance_percentage: Indicates the percent of load imbalance factor for the domain.
        :param _builtins.str map_name: A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        :param _builtins.int max_unreachable_penalty: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        :param _builtins.float min_live_fraction: Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        :param _builtins.str name: A descriptive label for the property.
        :param _builtins.str score_aggregation_type: Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        :param _builtins.int static_ttl: Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        :param _builtins.int stickness_bonus_constant: Specifies a percentage used to configure data center affinity.
        :param _builtins.int stickness_bonus_percentage: Specifies a percentage used to configure data center affinity.
        :param _builtins.str type: Specifies the load balancing behvior for the property.
        :param _builtins.float unreachable_threshold: For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        :param _builtins.bool use_computed_targets: For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        :param _builtins.int weighted_hash_bits_for_ipv4: For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        :param _builtins.int weighted_hash_bits_for_ipv6: For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        :param Sequence['GetGtmDomainPropertyLinkArgs'] links: Provides a URL path that allows direct navigation to the property.
        :param Sequence['GetGtmDomainPropertyLivenessTestArgs'] liveness_tests: Contains information about liveness tests.
        :param Sequence['GetGtmDomainPropertyStaticRrSetArgs'] static_rr_sets: Contains static recordsets.
        :param Sequence['GetGtmDomainPropertyTrafficTargetArgs'] traffic_targets: Traffic targets for the property.
        """
        pulumi.set(__self__, "backup_cname", backup_cname)
        pulumi.set(__self__, "backup_ip", backup_ip)
        pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "comments", comments)
        pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
        pulumi.set(__self__, "failback_delay", failback_delay)
        pulumi.set(__self__, "failover_delay", failover_delay)
        pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
        pulumi.set(__self__, "handout_limit", handout_limit)
        pulumi.set(__self__, "handout_mode", handout_mode)
        pulumi.set(__self__, "health_max", health_max)
        pulumi.set(__self__, "health_multiplier", health_multiplier)
        pulumi.set(__self__, "health_threshold", health_threshold)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "map_name", map_name)
        pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
        pulumi.set(__self__, "min_live_fraction", min_live_fraction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
        pulumi.set(__self__, "static_ttl", static_ttl)
        pulumi.set(__self__, "stickness_bonus_constant", stickness_bonus_constant)
        pulumi.set(__self__, "stickness_bonus_percentage", stickness_bonus_percentage)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
        pulumi.set(__self__, "use_computed_targets", use_computed_targets)
        pulumi.set(__self__, "weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
        pulumi.set(__self__, "weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if liveness_tests is not None:
            pulumi.set(__self__, "liveness_tests", liveness_tests)
        if static_rr_sets is not None:
            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
        if traffic_targets is not None:
            pulumi.set(__self__, "traffic_targets", traffic_targets)

    @_builtins.property
    @pulumi.getter(name="backupCname")
    def backup_cname(self) -> _builtins.str:
        """
        Specifies a backup CNAME.
        """
        return pulumi.get(self, "backup_cname")

    @backup_cname.setter
    def backup_cname(self, value: _builtins.str):
        pulumi.set(self, "backup_cname", value)

    @_builtins.property
    @pulumi.getter(name="backupIp")
    def backup_ip(self) -> _builtins.str:
        """
        Specifies a backup IP.
        """
        return pulumi.get(self, "backup_ip")

    @backup_ip.setter
    def backup_ip(self, value: _builtins.str):
        pulumi.set(self, "backup_ip", value)

    @_builtins.property
    @pulumi.getter(name="balanceByDownloadScore")
    def balance_by_download_score(self) -> _builtins.bool:
        """
        Indicates whether download score based load balancing is enabled.
        """
        return pulumi.get(self, "balance_by_download_score")

    @balance_by_download_score.setter
    def balance_by_download_score(self, value: _builtins.bool):
        pulumi.set(self, "balance_by_download_score", value)

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        Indicates the fully qualified name aliased to a particular property.
        """
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: _builtins.str):
        pulumi.set(self, "cname", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> _builtins.str:
        """
        Descriptive comments for the property.
        """
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: _builtins.str):
        pulumi.set(self, "comments", value)

    @_builtins.property
    @pulumi.getter(name="dynamicTtl")
    def dynamic_ttl(self) -> _builtins.int:
        """
        Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
        """
        return pulumi.get(self, "dynamic_ttl")

    @dynamic_ttl.setter
    def dynamic_ttl(self, value: _builtins.int):
        pulumi.set(self, "dynamic_ttl", value)

    @_builtins.property
    @pulumi.getter(name="failbackDelay")
    def failback_delay(self) -> _builtins.int:
        """
        Specifies the failback delay in seconds.
        """
        return pulumi.get(self, "failback_delay")

    @failback_delay.setter
    def failback_delay(self, value: _builtins.int):
        pulumi.set(self, "failback_delay", value)

    @_builtins.property
    @pulumi.getter(name="failoverDelay")
    def failover_delay(self) -> _builtins.int:
        """
        Specifies the failover delay in seconds.
        """
        return pulumi.get(self, "failover_delay")

    @failover_delay.setter
    def failover_delay(self, value: _builtins.int):
        pulumi.set(self, "failover_delay", value)

    @_builtins.property
    @pulumi.getter(name="ghostDemandReporting")
    def ghost_demand_reporting(self) -> _builtins.bool:
        """
        Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
        """
        return pulumi.get(self, "ghost_demand_reporting")

    @ghost_demand_reporting.setter
    def ghost_demand_reporting(self, value: _builtins.bool):
        pulumi.set(self, "ghost_demand_reporting", value)

    @_builtins.property
    @pulumi.getter(name="handoutLimit")
    def handout_limit(self) -> _builtins.int:
        """
        Indicates the limit for the number of live IPs handed out to a DNS request.
        """
        return pulumi.get(self, "handout_limit")

    @handout_limit.setter
    def handout_limit(self, value: _builtins.int):
        pulumi.set(self, "handout_limit", value)

    @_builtins.property
    @pulumi.getter(name="handoutMode")
    def handout_mode(self) -> _builtins.str:
        """
        Specifies how IPs are returned when more than one IP is alive and available.
        """
        return pulumi.get(self, "handout_mode")

    @handout_mode.setter
    def handout_mode(self, value: _builtins.str):
        pulumi.set(self, "handout_mode", value)

    @_builtins.property
    @pulumi.getter(name="healthMax")
    def health_max(self) -> _builtins.float:
        """
        Defines the absolute limit beyond which IPs are declared unhealthy.
        """
        return pulumi.get(self, "health_max")

    @health_max.setter
    def health_max(self, value: _builtins.float):
        pulumi.set(self, "health_max", value)

    @_builtins.property
    @pulumi.getter(name="healthMultiplier")
    def health_multiplier(self) -> _builtins.float:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_multiplier")

    @health_multiplier.setter
    def health_multiplier(self, value: _builtins.float):
        pulumi.set(self, "health_multiplier", value)

    @_builtins.property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> _builtins.float:
        """
        Configures a cutoff value that is computed from the median scores.
        """
        return pulumi.get(self, "health_threshold")

    @health_threshold.setter
    def health_threshold(self, value: _builtins.float):
        pulumi.set(self, "health_threshold", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        Indicates the type of IP address handed out by a property.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: _builtins.bool):
        pulumi.set(self, "ipv6", value)

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> _builtins.str:
        """
        An ISO 8601 timestamp that indicates when the property was last changed.
        """
        return pulumi.get(self, "last_modified")

    @last_modified.setter
    def last_modified(self, value: _builtins.str):
        pulumi.set(self, "last_modified", value)

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: _builtins.float):
        pulumi.set(self, "load_imbalance_percentage", value)

    @_builtins.property
    @pulumi.getter(name="mapName")
    def map_name(self) -> _builtins.str:
        """
        A descriptive label for a geographic or a CIDR map that's required if the property is either geographic or cidrmapping.
        """
        return pulumi.get(self, "map_name")

    @map_name.setter
    def map_name(self, value: _builtins.str):
        pulumi.set(self, "map_name", value)

    @_builtins.property
    @pulumi.getter(name="maxUnreachablePenalty")
    def max_unreachable_penalty(self) -> _builtins.int:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
        """
        return pulumi.get(self, "max_unreachable_penalty")

    @max_unreachable_penalty.setter
    def max_unreachable_penalty(self, value: _builtins.int):
        pulumi.set(self, "max_unreachable_penalty", value)

    @_builtins.property
    @pulumi.getter(name="minLiveFraction")
    def min_live_fraction(self) -> _builtins.float:
        """
        Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
        """
        return pulumi.get(self, "min_live_fraction")

    @min_live_fraction.setter
    def min_live_fraction(self, value: _builtins.float):
        pulumi.set(self, "min_live_fraction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="scoreAggregationType")
    def score_aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
        """
        return pulumi.get(self, "score_aggregation_type")

    @score_aggregation_type.setter
    def score_aggregation_type(self, value: _builtins.str):
        pulumi.set(self, "score_aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="staticTtl")
    def static_ttl(self) -> _builtins.int:
        """
        Specifies the TTL in seconds for static resource records that don't change based on the requesting name server IP.
        """
        return pulumi.get(self, "static_ttl")

    @static_ttl.setter
    def static_ttl(self, value: _builtins.int):
        pulumi.set(self, "static_ttl", value)

    @_builtins.property
    @pulumi.getter(name="sticknessBonusConstant")
    def stickness_bonus_constant(self) -> _builtins.int:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickness_bonus_constant")

    @stickness_bonus_constant.setter
    def stickness_bonus_constant(self, value: _builtins.int):
        pulumi.set(self, "stickness_bonus_constant", value)

    @_builtins.property
    @pulumi.getter(name="sticknessBonusPercentage")
    def stickness_bonus_percentage(self) -> _builtins.int:
        """
        Specifies a percentage used to configure data center affinity.
        """
        return pulumi.get(self, "stickness_bonus_percentage")

    @stickness_bonus_percentage.setter
    def stickness_bonus_percentage(self, value: _builtins.int):
        pulumi.set(self, "stickness_bonus_percentage", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the load balancing behvior for the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="unreachableThreshold")
    def unreachable_threshold(self) -> _builtins.float:
        """
        For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
        """
        return pulumi.get(self, "unreachable_threshold")

    @unreachable_threshold.setter
    def unreachable_threshold(self, value: _builtins.float):
        pulumi.set(self, "unreachable_threshold", value)

    @_builtins.property
    @pulumi.getter(name="useComputedTargets")
    def use_computed_targets(self) -> _builtins.bool:
        """
        For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
        """
        return pulumi.get(self, "use_computed_targets")

    @use_computed_targets.setter
    def use_computed_targets(self, value: _builtins.bool):
        pulumi.set(self, "use_computed_targets", value)

    @_builtins.property
    @pulumi.getter(name="weightedHashBitsForIpv4")
    def weighted_hash_bits_for_ipv4(self) -> _builtins.int:
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
        """
        return pulumi.get(self, "weighted_hash_bits_for_ipv4")

    @weighted_hash_bits_for_ipv4.setter
    def weighted_hash_bits_for_ipv4(self, value: _builtins.int):
        pulumi.set(self, "weighted_hash_bits_for_ipv4", value)

    @_builtins.property
    @pulumi.getter(name="weightedHashBitsForIpv6")
    def weighted_hash_bits_for_ipv6(self) -> _builtins.int:
        """
        For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
        """
        return pulumi.get(self, "weighted_hash_bits_for_ipv6")

    @weighted_hash_bits_for_ipv6.setter
    def weighted_hash_bits_for_ipv6(self, value: _builtins.int):
        pulumi.set(self, "weighted_hash_bits_for_ipv6", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainPropertyLinkArgs']]:
        """
        Provides a URL path that allows direct navigation to the property.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainPropertyLinkArgs']]):
        pulumi.set(self, "links", value)

    @_builtins.property
    @pulumi.getter(name="livenessTests")
    def liveness_tests(self) -> Optional[Sequence['GetGtmDomainPropertyLivenessTestArgs']]:
        """
        Contains information about liveness tests.
        """
        return pulumi.get(self, "liveness_tests")

    @liveness_tests.setter
    def liveness_tests(self, value: Optional[Sequence['GetGtmDomainPropertyLivenessTestArgs']]):
        pulumi.set(self, "liveness_tests", value)

    @_builtins.property
    @pulumi.getter(name="staticRrSets")
    def static_rr_sets(self) -> Optional[Sequence['GetGtmDomainPropertyStaticRrSetArgs']]:
        """
        Contains static recordsets.
        """
        return pulumi.get(self, "static_rr_sets")

    @static_rr_sets.setter
    def static_rr_sets(self, value: Optional[Sequence['GetGtmDomainPropertyStaticRrSetArgs']]):
        pulumi.set(self, "static_rr_sets", value)

    @_builtins.property
    @pulumi.getter(name="trafficTargets")
    def traffic_targets(self) -> Optional[Sequence['GetGtmDomainPropertyTrafficTargetArgs']]:
        """
        Traffic targets for the property.
        """
        return pulumi.get(self, "traffic_targets")

    @traffic_targets.setter
    def traffic_targets(self, value: Optional[Sequence['GetGtmDomainPropertyTrafficTargetArgs']]):
        pulumi.set(self, "traffic_targets", value)


if not MYPY:
    class GetGtmDomainPropertyLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainPropertyLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainPropertyLivenessTestArgsDict(TypedDict):
        alternate_ca_certificates: Sequence[_builtins.str]
        """
        List of alternate trust anchors (CA certificates)
        """
        answers_required: _builtins.bool
        """
        If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
        """
        disable_nonstandard_port_warning: _builtins.bool
        """
        Disables warnings when non-standard ports are used.
        """
        disabled: _builtins.bool
        """
        Disables the liveness test.
        """
        error_penalty: _builtins.float
        """
        Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        """
        http_error3xx: _builtins.bool
        """
        Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        http_error4xx: _builtins.bool
        """
        Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        http_error5xx: _builtins.bool
        """
        Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        http_method: _builtins.str
        """
        Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
        """
        http_request_body: _builtins.str
        """
        Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
        """
        name: _builtins.str
        """
        A descriptive name for the liveness test.
        """
        peer_certificate_verification: _builtins.bool
        """
        Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
        """
        pre2023_security_posture: _builtins.bool
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        recursion_requested: _builtins.bool
        """
        Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
        """
        request_string: _builtins.str
        """
        Specifies a request string.
        """
        resource_type: _builtins.str
        """
        Specifies the query type, if testObjectProtocol is DNS.
        """
        response_string: _builtins.str
        """
        Specifies a response string.
        """
        ssl_client_certificate: _builtins.str
        """
        Indicates a base64-encoded certificate.
        """
        ssl_client_private_key: _builtins.str
        """
        Indicates a base64-encoded private key.
        """
        test_interval: _builtins.int
        """
        Indicates the interval at which the liveness test is run, in seconds.
        """
        test_object: _builtins.str
        """
        Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        """
        test_object_password: _builtins.str
        """
        Specifies the test object's password.
        """
        test_object_port: _builtins.int
        """
        Specifies the port number for the testObject.
        """
        test_object_protocol: _builtins.str
        """
        Specifies the test protocol.
        """
        test_object_username: _builtins.str
        """
        A descriptive name for the testObject.
        """
        test_timeout: _builtins.float
        """
        Specifies the duration of the liveness test before it fails.
        """
        timeout_penalty: _builtins.float
        """
        Specifies the timeout penalty score.
        """
        http_headers: NotRequired[Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgsDict']]
        """
        List of HTTP headers for the liveness test.
        """
elif False:
    GetGtmDomainPropertyLivenessTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyLivenessTestArgs:
    def __init__(__self__, *,
                 alternate_ca_certificates: Sequence[_builtins.str],
                 answers_required: _builtins.bool,
                 disable_nonstandard_port_warning: _builtins.bool,
                 disabled: _builtins.bool,
                 error_penalty: _builtins.float,
                 http_error3xx: _builtins.bool,
                 http_error4xx: _builtins.bool,
                 http_error5xx: _builtins.bool,
                 http_method: _builtins.str,
                 http_request_body: _builtins.str,
                 name: _builtins.str,
                 peer_certificate_verification: _builtins.bool,
                 pre2023_security_posture: _builtins.bool,
                 recursion_requested: _builtins.bool,
                 request_string: _builtins.str,
                 resource_type: _builtins.str,
                 response_string: _builtins.str,
                 ssl_client_certificate: _builtins.str,
                 ssl_client_private_key: _builtins.str,
                 test_interval: _builtins.int,
                 test_object: _builtins.str,
                 test_object_password: _builtins.str,
                 test_object_port: _builtins.int,
                 test_object_protocol: _builtins.str,
                 test_object_username: _builtins.str,
                 test_timeout: _builtins.float,
                 timeout_penalty: _builtins.float,
                 http_headers: Optional[Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgs']] = None):
        """
        :param Sequence[_builtins.str] alternate_ca_certificates: List of alternate trust anchors (CA certificates)
        :param _builtins.bool answers_required: If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
        :param _builtins.bool disable_nonstandard_port_warning: Disables warnings when non-standard ports are used.
        :param _builtins.bool disabled: Disables the liveness test.
        :param _builtins.float error_penalty: Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        :param _builtins.bool http_error3xx: Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.bool http_error4xx: Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.bool http_error5xx: Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        :param _builtins.str http_method: Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
        :param _builtins.str http_request_body: Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
        :param _builtins.str name: A descriptive name for the liveness test.
        :param _builtins.bool peer_certificate_verification: Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
        :param _builtins.bool pre2023_security_posture: Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        :param _builtins.bool recursion_requested: Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
        :param _builtins.str request_string: Specifies a request string.
        :param _builtins.str resource_type: Specifies the query type, if testObjectProtocol is DNS.
        :param _builtins.str response_string: Specifies a response string.
        :param _builtins.str ssl_client_certificate: Indicates a base64-encoded certificate.
        :param _builtins.str ssl_client_private_key: Indicates a base64-encoded private key.
        :param _builtins.int test_interval: Indicates the interval at which the liveness test is run, in seconds.
        :param _builtins.str test_object: Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        :param _builtins.str test_object_password: Specifies the test object's password.
        :param _builtins.int test_object_port: Specifies the port number for the testObject.
        :param _builtins.str test_object_protocol: Specifies the test protocol.
        :param _builtins.str test_object_username: A descriptive name for the testObject.
        :param _builtins.float test_timeout: Specifies the duration of the liveness test before it fails.
        :param _builtins.float timeout_penalty: Specifies the timeout penalty score.
        :param Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgs'] http_headers: List of HTTP headers for the liveness test.
        """
        pulumi.set(__self__, "alternate_ca_certificates", alternate_ca_certificates)
        pulumi.set(__self__, "answers_required", answers_required)
        pulumi.set(__self__, "disable_nonstandard_port_warning", disable_nonstandard_port_warning)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "error_penalty", error_penalty)
        pulumi.set(__self__, "http_error3xx", http_error3xx)
        pulumi.set(__self__, "http_error4xx", http_error4xx)
        pulumi.set(__self__, "http_error5xx", http_error5xx)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "http_request_body", http_request_body)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "peer_certificate_verification", peer_certificate_verification)
        pulumi.set(__self__, "pre2023_security_posture", pre2023_security_posture)
        pulumi.set(__self__, "recursion_requested", recursion_requested)
        pulumi.set(__self__, "request_string", request_string)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "response_string", response_string)
        pulumi.set(__self__, "ssl_client_certificate", ssl_client_certificate)
        pulumi.set(__self__, "ssl_client_private_key", ssl_client_private_key)
        pulumi.set(__self__, "test_interval", test_interval)
        pulumi.set(__self__, "test_object", test_object)
        pulumi.set(__self__, "test_object_password", test_object_password)
        pulumi.set(__self__, "test_object_port", test_object_port)
        pulumi.set(__self__, "test_object_protocol", test_object_protocol)
        pulumi.set(__self__, "test_object_username", test_object_username)
        pulumi.set(__self__, "test_timeout", test_timeout)
        pulumi.set(__self__, "timeout_penalty", timeout_penalty)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter(name="alternateCaCertificates")
    def alternate_ca_certificates(self) -> Sequence[_builtins.str]:
        """
        List of alternate trust anchors (CA certificates)
        """
        return pulumi.get(self, "alternate_ca_certificates")

    @alternate_ca_certificates.setter
    def alternate_ca_certificates(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "alternate_ca_certificates", value)

    @_builtins.property
    @pulumi.getter(name="answersRequired")
    def answers_required(self) -> _builtins.bool:
        """
        If testObjectProtocol is DNS, DOH or DOT, requires an answer to the DNS query to be considered a success.
        """
        return pulumi.get(self, "answers_required")

    @answers_required.setter
    def answers_required(self, value: _builtins.bool):
        pulumi.set(self, "answers_required", value)

    @_builtins.property
    @pulumi.getter(name="disableNonstandardPortWarning")
    def disable_nonstandard_port_warning(self) -> _builtins.bool:
        """
        Disables warnings when non-standard ports are used.
        """
        return pulumi.get(self, "disable_nonstandard_port_warning")

    @disable_nonstandard_port_warning.setter
    def disable_nonstandard_port_warning(self, value: _builtins.bool):
        pulumi.set(self, "disable_nonstandard_port_warning", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Disables the liveness test.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: _builtins.bool):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="errorPenalty")
    def error_penalty(self) -> _builtins.float:
        """
        Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.
        """
        return pulumi.get(self, "error_penalty")

    @error_penalty.setter
    def error_penalty(self, value: _builtins.float):
        pulumi.set(self, "error_penalty", value)

    @_builtins.property
    @pulumi.getter(name="httpError3xx")
    def http_error3xx(self) -> _builtins.bool:
        """
        Treats a 3xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error3xx")

    @http_error3xx.setter
    def http_error3xx(self, value: _builtins.bool):
        pulumi.set(self, "http_error3xx", value)

    @_builtins.property
    @pulumi.getter(name="httpError4xx")
    def http_error4xx(self) -> _builtins.bool:
        """
        Treats a 4xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error4xx")

    @http_error4xx.setter
    def http_error4xx(self, value: _builtins.bool):
        pulumi.set(self, "http_error4xx", value)

    @_builtins.property
    @pulumi.getter(name="httpError5xx")
    def http_error5xx(self) -> _builtins.bool:
        """
        Treats a 5xx HTTP response as a failure if the testObjectProtocol is http, https or ftp.
        """
        return pulumi.get(self, "http_error5xx")

    @http_error5xx.setter
    def http_error5xx(self, value: _builtins.bool):
        pulumi.set(self, "http_error5xx", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> _builtins.str:
        """
        Contains HTTP method to send if the `testObjectProtocol` is `http` or `https`. Supported values are `TRACE`, `HEAD`, `OPTIONS`, `GET`, `PUT`, `POST`, `PATCH`, `DELETE`. When omitted or `null`, this value defaults to `GET`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: _builtins.str):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="httpRequestBody")
    def http_request_body(self) -> _builtins.str:
        """
        Contains Base64-encoded HTTP request body to send if the `testObjectProtocol` is `http` or `https`. When omitted or `null`, omits the request body from the request.
        """
        return pulumi.get(self, "http_request_body")

    @http_request_body.setter
    def http_request_body(self, value: _builtins.str):
        pulumi.set(self, "http_request_body", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive name for the liveness test.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="peerCertificateVerification")
    def peer_certificate_verification(self) -> _builtins.bool:
        """
        Validates the origin certificate. Applies only to tests with testObjectProtocol of https.
        """
        return pulumi.get(self, "peer_certificate_verification")

    @peer_certificate_verification.setter
    def peer_certificate_verification(self, value: _builtins.bool):
        pulumi.set(self, "peer_certificate_verification", value)

    @_builtins.property
    @pulumi.getter(name="pre2023SecurityPosture")
    def pre2023_security_posture(self) -> _builtins.bool:
        """
        Whether to enable backwards compatibility for liveness endpoints that use older TLS protocols
        """
        return pulumi.get(self, "pre2023_security_posture")

    @pre2023_security_posture.setter
    def pre2023_security_posture(self, value: _builtins.bool):
        pulumi.set(self, "pre2023_security_posture", value)

    @_builtins.property
    @pulumi.getter(name="recursionRequested")
    def recursion_requested(self) -> _builtins.bool:
        """
        Indicates that if testObjectProtocol is DNS, DOH or DOT, the DNS query is recursive.
        """
        return pulumi.get(self, "recursion_requested")

    @recursion_requested.setter
    def recursion_requested(self, value: _builtins.bool):
        pulumi.set(self, "recursion_requested", value)

    @_builtins.property
    @pulumi.getter(name="requestString")
    def request_string(self) -> _builtins.str:
        """
        Specifies a request string.
        """
        return pulumi.get(self, "request_string")

    @request_string.setter
    def request_string(self, value: _builtins.str):
        pulumi.set(self, "request_string", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Specifies the query type, if testObjectProtocol is DNS.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: _builtins.str):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="responseString")
    def response_string(self) -> _builtins.str:
        """
        Specifies a response string.
        """
        return pulumi.get(self, "response_string")

    @response_string.setter
    def response_string(self, value: _builtins.str):
        pulumi.set(self, "response_string", value)

    @_builtins.property
    @pulumi.getter(name="sslClientCertificate")
    def ssl_client_certificate(self) -> _builtins.str:
        """
        Indicates a base64-encoded certificate.
        """
        return pulumi.get(self, "ssl_client_certificate")

    @ssl_client_certificate.setter
    def ssl_client_certificate(self, value: _builtins.str):
        pulumi.set(self, "ssl_client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="sslClientPrivateKey")
    def ssl_client_private_key(self) -> _builtins.str:
        """
        Indicates a base64-encoded private key.
        """
        return pulumi.get(self, "ssl_client_private_key")

    @ssl_client_private_key.setter
    def ssl_client_private_key(self, value: _builtins.str):
        pulumi.set(self, "ssl_client_private_key", value)

    @_builtins.property
    @pulumi.getter(name="testInterval")
    def test_interval(self) -> _builtins.int:
        """
        Indicates the interval at which the liveness test is run, in seconds.
        """
        return pulumi.get(self, "test_interval")

    @test_interval.setter
    def test_interval(self, value: _builtins.int):
        pulumi.set(self, "test_interval", value)

    @_builtins.property
    @pulumi.getter(name="testObject")
    def test_object(self) -> _builtins.str:
        """
        Specifies the static text that acts as a stand-in for the data that you're sending on the network.
        """
        return pulumi.get(self, "test_object")

    @test_object.setter
    def test_object(self, value: _builtins.str):
        pulumi.set(self, "test_object", value)

    @_builtins.property
    @pulumi.getter(name="testObjectPassword")
    def test_object_password(self) -> _builtins.str:
        """
        Specifies the test object's password.
        """
        return pulumi.get(self, "test_object_password")

    @test_object_password.setter
    def test_object_password(self, value: _builtins.str):
        pulumi.set(self, "test_object_password", value)

    @_builtins.property
    @pulumi.getter(name="testObjectPort")
    def test_object_port(self) -> _builtins.int:
        """
        Specifies the port number for the testObject.
        """
        return pulumi.get(self, "test_object_port")

    @test_object_port.setter
    def test_object_port(self, value: _builtins.int):
        pulumi.set(self, "test_object_port", value)

    @_builtins.property
    @pulumi.getter(name="testObjectProtocol")
    def test_object_protocol(self) -> _builtins.str:
        """
        Specifies the test protocol.
        """
        return pulumi.get(self, "test_object_protocol")

    @test_object_protocol.setter
    def test_object_protocol(self, value: _builtins.str):
        pulumi.set(self, "test_object_protocol", value)

    @_builtins.property
    @pulumi.getter(name="testObjectUsername")
    def test_object_username(self) -> _builtins.str:
        """
        A descriptive name for the testObject.
        """
        return pulumi.get(self, "test_object_username")

    @test_object_username.setter
    def test_object_username(self, value: _builtins.str):
        pulumi.set(self, "test_object_username", value)

    @_builtins.property
    @pulumi.getter(name="testTimeout")
    def test_timeout(self) -> _builtins.float:
        """
        Specifies the duration of the liveness test before it fails.
        """
        return pulumi.get(self, "test_timeout")

    @test_timeout.setter
    def test_timeout(self, value: _builtins.float):
        pulumi.set(self, "test_timeout", value)

    @_builtins.property
    @pulumi.getter(name="timeoutPenalty")
    def timeout_penalty(self) -> _builtins.float:
        """
        Specifies the timeout penalty score.
        """
        return pulumi.get(self, "timeout_penalty")

    @timeout_penalty.setter
    def timeout_penalty(self, value: _builtins.float):
        pulumi.set(self, "timeout_penalty", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgs']]:
        """
        List of HTTP headers for the liveness test.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[Sequence['GetGtmDomainPropertyLivenessTestHttpHeaderArgs']]):
        pulumi.set(self, "http_headers", value)


if not MYPY:
    class GetGtmDomainPropertyLivenessTestHttpHeaderArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the HTTP header.
        """
        value: _builtins.str
        """
        Value of the HTTP header.
        """
elif False:
    GetGtmDomainPropertyLivenessTestHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyLivenessTestHttpHeaderArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of the HTTP header.
        :param _builtins.str value: Value of the HTTP header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the HTTP header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetGtmDomainPropertyStaticRrSetArgsDict(TypedDict):
        rdatas: Sequence[_builtins.str]
        """
        An array of data strings, representing multiple records within a set.
        """
        ttl: _builtins.int
        """
        The number of seconds that this record should live in a resolver's cache before being refetched.
        """
        type: _builtins.str
        """
        The record type.
        """
elif False:
    GetGtmDomainPropertyStaticRrSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyStaticRrSetArgs:
    def __init__(__self__, *,
                 rdatas: Sequence[_builtins.str],
                 ttl: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] rdatas: An array of data strings, representing multiple records within a set.
        :param _builtins.int ttl: The number of seconds that this record should live in a resolver's cache before being refetched.
        :param _builtins.str type: The record type.
        """
        pulumi.set(__self__, "rdatas", rdatas)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def rdatas(self) -> Sequence[_builtins.str]:
        """
        An array of data strings, representing multiple records within a set.
        """
        return pulumi.get(self, "rdatas")

    @rdatas.setter
    def rdatas(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "rdatas", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The number of seconds that this record should live in a resolver's cache before being refetched.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: _builtins.int):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetGtmDomainPropertyTrafficTargetArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        enabled: _builtins.bool
        """
        Indicates whether the traffic target is used.
        """
        handout_cname: _builtins.str
        """
        Specifies an optional data center for the property.
        """
        name: _builtins.str
        """
        An alternative label for the traffic target.
        """
        precedence: _builtins.int
        """
        Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
        """
        servers: Sequence[_builtins.str]
        """
        Identifies the IP address or the hostnames of the servers.
        """
        weight: _builtins.float
        """
        Specifies the traffic target weight for the target.
        """
elif False:
    GetGtmDomainPropertyTrafficTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainPropertyTrafficTargetArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 enabled: _builtins.bool,
                 handout_cname: _builtins.str,
                 name: _builtins.str,
                 precedence: _builtins.int,
                 servers: Sequence[_builtins.str],
                 weight: _builtins.float):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.bool enabled: Indicates whether the traffic target is used.
        :param _builtins.str handout_cname: Specifies an optional data center for the property.
        :param _builtins.str name: An alternative label for the traffic target.
        :param _builtins.int precedence: Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
        :param Sequence[_builtins.str] servers: Identifies the IP address or the hostnames of the servers.
        :param _builtins.float weight: Specifies the traffic target weight for the target.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "handout_cname", handout_cname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether the traffic target is used.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="handoutCname")
    def handout_cname(self) -> _builtins.str:
        """
        Specifies an optional data center for the property.
        """
        return pulumi.get(self, "handout_cname")

    @handout_cname.setter
    def handout_cname(self, value: _builtins.str):
        pulumi.set(self, "handout_cname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An alternative label for the traffic target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> _builtins.int:
        """
        Non-negative integer that ranks the order of the backups that GTM will hand out in the event that the primary Traffic Target has been declared down
        """
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: _builtins.int):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence[_builtins.str]:
        """
        Identifies the IP address or the hostnames of the servers.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        """
        Specifies the traffic target weight for the target.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: _builtins.float):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetGtmDomainResourceArgsDict(TypedDict):
        aggregation_type: _builtins.str
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        constrained_property: _builtins.str
        """
        Specifies the name of the property that this resource constraints.
        """
        decay_rate: _builtins.float
        """
        For internal use only.
        """
        description: _builtins.str
        """
        A descriptive note to help you track what the resource constraints.
        """
        host_header: _builtins.str
        """
        Specifies the host header used when fetching the load object.
        """
        leader_string: _builtins.str
        """
        Specifies the text that comes before the loadObject.
        """
        least_squares_decay: _builtins.float
        """
        For internal use only.
        """
        load_imbalance_percentage: _builtins.float
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        max_u_multiplicative_increment: _builtins.float
        """
        For internal use only.
        """
        name: _builtins.str
        """
        A descriptive label for the resource.
        """
        type: _builtins.str
        """
        Indicates the kind of loadObject format used to determine the load on the resource.
        """
        upper_bound: _builtins.int
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        links: NotRequired[Sequence['GetGtmDomainResourceLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        resource_instances: NotRequired[Sequence['GetGtmDomainResourceResourceInstanceArgsDict']]
        """
        List of resource instances.
        """
elif False:
    GetGtmDomainResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainResourceArgs:
    def __init__(__self__, *,
                 aggregation_type: _builtins.str,
                 constrained_property: _builtins.str,
                 decay_rate: _builtins.float,
                 description: _builtins.str,
                 host_header: _builtins.str,
                 leader_string: _builtins.str,
                 least_squares_decay: _builtins.float,
                 load_imbalance_percentage: _builtins.float,
                 max_u_multiplicative_increment: _builtins.float,
                 name: _builtins.str,
                 type: _builtins.str,
                 upper_bound: _builtins.int,
                 links: Optional[Sequence['GetGtmDomainResourceLinkArgs']] = None,
                 resource_instances: Optional[Sequence['GetGtmDomainResourceResourceInstanceArgs']] = None):
        """
        :param _builtins.str aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        :param _builtins.str constrained_property: Specifies the name of the property that this resource constraints.
        :param _builtins.float decay_rate: For internal use only.
        :param _builtins.str description: A descriptive note to help you track what the resource constraints.
        :param _builtins.str host_header: Specifies the host header used when fetching the load object.
        :param _builtins.str leader_string: Specifies the text that comes before the loadObject.
        :param _builtins.float least_squares_decay: For internal use only.
        :param _builtins.float load_imbalance_percentage: Indicates the percent of load imbalance factor for the domain.
        :param _builtins.float max_u_multiplicative_increment: For internal use only.
        :param _builtins.str name: A descriptive label for the resource.
        :param _builtins.str type: Indicates the kind of loadObject format used to determine the load on the resource.
        :param _builtins.int upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
        :param Sequence['GetGtmDomainResourceLinkArgs'] links: Specifies the URL path that allows direct navigation to the resource.
        :param Sequence['GetGtmDomainResourceResourceInstanceArgs'] resource_instances: List of resource instances.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "constrained_property", constrained_property)
        pulumi.set(__self__, "decay_rate", decay_rate)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "leader_string", leader_string)
        pulumi.set(__self__, "least_squares_decay", least_squares_decay)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upper_bound", upper_bound)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if resource_instances is not None:
            pulumi.set(__self__, "resource_instances", resource_instances)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: _builtins.str):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="constrainedProperty")
    def constrained_property(self) -> _builtins.str:
        """
        Specifies the name of the property that this resource constraints.
        """
        return pulumi.get(self, "constrained_property")

    @constrained_property.setter
    def constrained_property(self, value: _builtins.str):
        pulumi.set(self, "constrained_property", value)

    @_builtins.property
    @pulumi.getter(name="decayRate")
    def decay_rate(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "decay_rate")

    @decay_rate.setter
    def decay_rate(self, value: _builtins.float):
        pulumi.set(self, "decay_rate", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A descriptive note to help you track what the resource constraints.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: _builtins.str):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> _builtins.str:
        """
        Specifies the host header used when fetching the load object.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: _builtins.str):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter(name="leaderString")
    def leader_string(self) -> _builtins.str:
        """
        Specifies the text that comes before the loadObject.
        """
        return pulumi.get(self, "leader_string")

    @leader_string.setter
    def leader_string(self, value: _builtins.str):
        pulumi.set(self, "leader_string", value)

    @_builtins.property
    @pulumi.getter(name="leastSquaresDecay")
    def least_squares_decay(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "least_squares_decay")

    @least_squares_decay.setter
    def least_squares_decay(self, value: _builtins.float):
        pulumi.set(self, "least_squares_decay", value)

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percent of load imbalance factor for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: _builtins.float):
        pulumi.set(self, "load_imbalance_percentage", value)

    @_builtins.property
    @pulumi.getter(name="maxUMultiplicativeIncrement")
    def max_u_multiplicative_increment(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "max_u_multiplicative_increment")

    @max_u_multiplicative_increment.setter
    def max_u_multiplicative_increment(self, value: _builtins.float):
        pulumi.set(self, "max_u_multiplicative_increment", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the kind of loadObject format used to determine the load on the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> _builtins.int:
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: _builtins.int):
        pulumi.set(self, "upper_bound", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainResourceLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainResourceLinkArgs']]):
        pulumi.set(self, "links", value)

    @_builtins.property
    @pulumi.getter(name="resourceInstances")
    def resource_instances(self) -> Optional[Sequence['GetGtmDomainResourceResourceInstanceArgs']]:
        """
        List of resource instances.
        """
        return pulumi.get(self, "resource_instances")

    @resource_instances.setter
    def resource_instances(self, value: Optional[Sequence['GetGtmDomainResourceResourceInstanceArgs']]):
        pulumi.set(self, "resource_instances", value)


if not MYPY:
    class GetGtmDomainResourceLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainResourceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainResourceLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainResourceResourceInstanceArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        load_object: _builtins.str
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        load_object_port: _builtins.int
        """
        Specifies the TCP port of the loadObject.
        """
        load_servers: Sequence[_builtins.str]
        """
        Specifies the list of servers to requests the load object from.
        """
        use_default_load_object: _builtins.bool
        """
        Whether to use default loadObject.
        """
elif False:
    GetGtmDomainResourceResourceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainResourceResourceInstanceArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: _builtins.str):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: _builtins.int):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "load_servers", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")

    @use_default_load_object.setter
    def use_default_load_object(self, value: _builtins.bool):
        pulumi.set(self, "use_default_load_object", value)


if not MYPY:
    class GetGtmDomainStatusArgsDict(TypedDict):
        change_id: _builtins.str
        """
        A unique identifier generated when a change occurs to the domain.
        """
        message: _builtins.str
        """
        A notification generated when a change occurs to the domain.
        """
        passing_validation: _builtins.bool
        """
        Indicates if the domain validates.
        """
        propagation_status: _builtins.str
        """
        Tracks the status of the domain's propagation state.
        """
        propagation_status_date: _builtins.str
        """
        An ISO 8601 timestamp indicating when a change occurs to the domain.
        """
        links: NotRequired[Sequence['GetGtmDomainStatusLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the domain.
        """
elif False:
    GetGtmDomainStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainStatusArgs:
    def __init__(__self__, *,
                 change_id: _builtins.str,
                 message: _builtins.str,
                 passing_validation: _builtins.bool,
                 propagation_status: _builtins.str,
                 propagation_status_date: _builtins.str,
                 links: Optional[Sequence['GetGtmDomainStatusLinkArgs']] = None):
        """
        :param _builtins.str change_id: A unique identifier generated when a change occurs to the domain.
        :param _builtins.str message: A notification generated when a change occurs to the domain.
        :param _builtins.bool passing_validation: Indicates if the domain validates.
        :param _builtins.str propagation_status: Tracks the status of the domain's propagation state.
        :param _builtins.str propagation_status_date: An ISO 8601 timestamp indicating when a change occurs to the domain.
        :param Sequence['GetGtmDomainStatusLinkArgs'] links: Specifies the URL path that allows direct navigation to the domain.
        """
        pulumi.set(__self__, "change_id", change_id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "passing_validation", passing_validation)
        pulumi.set(__self__, "propagation_status", propagation_status)
        pulumi.set(__self__, "propagation_status_date", propagation_status_date)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter(name="changeId")
    def change_id(self) -> _builtins.str:
        """
        A unique identifier generated when a change occurs to the domain.
        """
        return pulumi.get(self, "change_id")

    @change_id.setter
    def change_id(self, value: _builtins.str):
        pulumi.set(self, "change_id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        A notification generated when a change occurs to the domain.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: _builtins.str):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="passingValidation")
    def passing_validation(self) -> _builtins.bool:
        """
        Indicates if the domain validates.
        """
        return pulumi.get(self, "passing_validation")

    @passing_validation.setter
    def passing_validation(self, value: _builtins.bool):
        pulumi.set(self, "passing_validation", value)

    @_builtins.property
    @pulumi.getter(name="propagationStatus")
    def propagation_status(self) -> _builtins.str:
        """
        Tracks the status of the domain's propagation state.
        """
        return pulumi.get(self, "propagation_status")

    @propagation_status.setter
    def propagation_status(self, value: _builtins.str):
        pulumi.set(self, "propagation_status", value)

    @_builtins.property
    @pulumi.getter(name="propagationStatusDate")
    def propagation_status_date(self) -> _builtins.str:
        """
        An ISO 8601 timestamp indicating when a change occurs to the domain.
        """
        return pulumi.get(self, "propagation_status_date")

    @propagation_status_date.setter
    def propagation_status_date(self, value: _builtins.str):
        pulumi.set(self, "propagation_status_date", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainStatusLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the domain.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainStatusLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainStatusLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainStatusLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainStatusLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmDomainsDomainArgsDict(TypedDict):
        acg_id: _builtins.str
        """
        The contract's identifier, with which the domain is associated.
        """
        activation_state: _builtins.str
        """
        'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
        """
        change_id: _builtins.str
        """
        UUID that identifies a version of the domain configuration.
        """
        delete_request_id: _builtins.str
        """
        UUID for delete request during domain deletion. Null if the domain is not being deleted.
        """
        last_modified: _builtins.str
        """
        An ISO 8601 timestamp that indicates the time of the last domain change.
        """
        last_modified_by: _builtins.str
        """
        The email address of the administrator who made the last change to the domain.
        """
        modification_comments: _builtins.str
        """
        A descriptive note about changes to the domain.
        """
        name: _builtins.str
        """
        A unique domain name.
        """
        sign_and_serve: _builtins.bool
        """
        If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
        """
        sign_and_serve_algorithm: _builtins.str
        """
        The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
        """
        status: _builtins.str
        """
        The current status of the domain.
        """
        links: NotRequired[Sequence['GetGtmDomainsDomainLinkArgsDict']]
        """
        Provides a URL path that allows direct navigation to the domain.
        """
elif False:
    GetGtmDomainsDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainsDomainArgs:
    def __init__(__self__, *,
                 acg_id: _builtins.str,
                 activation_state: _builtins.str,
                 change_id: _builtins.str,
                 delete_request_id: _builtins.str,
                 last_modified: _builtins.str,
                 last_modified_by: _builtins.str,
                 modification_comments: _builtins.str,
                 name: _builtins.str,
                 sign_and_serve: _builtins.bool,
                 sign_and_serve_algorithm: _builtins.str,
                 status: _builtins.str,
                 links: Optional[Sequence['GetGtmDomainsDomainLinkArgs']] = None):
        """
        :param _builtins.str acg_id: The contract's identifier, with which the domain is associated.
        :param _builtins.str activation_state: 'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
        :param _builtins.str change_id: UUID that identifies a version of the domain configuration.
        :param _builtins.str delete_request_id: UUID for delete request during domain deletion. Null if the domain is not being deleted.
        :param _builtins.str last_modified: An ISO 8601 timestamp that indicates the time of the last domain change.
        :param _builtins.str last_modified_by: The email address of the administrator who made the last change to the domain.
        :param _builtins.str modification_comments: A descriptive note about changes to the domain.
        :param _builtins.str name: A unique domain name.
        :param _builtins.bool sign_and_serve: If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
        :param _builtins.str sign_and_serve_algorithm: The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
        :param _builtins.str status: The current status of the domain.
        :param Sequence['GetGtmDomainsDomainLinkArgs'] links: Provides a URL path that allows direct navigation to the domain.
        """
        pulumi.set(__self__, "acg_id", acg_id)
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "change_id", change_id)
        pulumi.set(__self__, "delete_request_id", delete_request_id)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "last_modified_by", last_modified_by)
        pulumi.set(__self__, "modification_comments", modification_comments)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sign_and_serve", sign_and_serve)
        pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
        pulumi.set(__self__, "status", status)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter(name="acgId")
    def acg_id(self) -> _builtins.str:
        """
        The contract's identifier, with which the domain is associated.
        """
        return pulumi.get(self, "acg_id")

    @acg_id.setter
    def acg_id(self, value: _builtins.str):
        pulumi.set(self, "acg_id", value)

    @_builtins.property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> _builtins.str:
        """
        'PENDING' when a change has been made but not yet propagated; 'COMPLETE' when the last configuration change has propagated successfully; 'DENIED' if the domain configuration failed validation; 'DELETED' if the domain has been deleted.
        """
        return pulumi.get(self, "activation_state")

    @activation_state.setter
    def activation_state(self, value: _builtins.str):
        pulumi.set(self, "activation_state", value)

    @_builtins.property
    @pulumi.getter(name="changeId")
    def change_id(self) -> _builtins.str:
        """
        UUID that identifies a version of the domain configuration.
        """
        return pulumi.get(self, "change_id")

    @change_id.setter
    def change_id(self, value: _builtins.str):
        pulumi.set(self, "change_id", value)

    @_builtins.property
    @pulumi.getter(name="deleteRequestId")
    def delete_request_id(self) -> _builtins.str:
        """
        UUID for delete request during domain deletion. Null if the domain is not being deleted.
        """
        return pulumi.get(self, "delete_request_id")

    @delete_request_id.setter
    def delete_request_id(self, value: _builtins.str):
        pulumi.set(self, "delete_request_id", value)

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> _builtins.str:
        """
        An ISO 8601 timestamp that indicates the time of the last domain change.
        """
        return pulumi.get(self, "last_modified")

    @last_modified.setter
    def last_modified(self, value: _builtins.str):
        pulumi.set(self, "last_modified", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> _builtins.str:
        """
        The email address of the administrator who made the last change to the domain.
        """
        return pulumi.get(self, "last_modified_by")

    @last_modified_by.setter
    def last_modified_by(self, value: _builtins.str):
        pulumi.set(self, "last_modified_by", value)

    @_builtins.property
    @pulumi.getter(name="modificationComments")
    def modification_comments(self) -> _builtins.str:
        """
        A descriptive note about changes to the domain.
        """
        return pulumi.get(self, "modification_comments")

    @modification_comments.setter
    def modification_comments(self, value: _builtins.str):
        pulumi.set(self, "modification_comments", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A unique domain name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="signAndServe")
    def sign_and_serve(self) -> _builtins.bool:
        """
        If set (true) we will sign the domain's resource records so that they can be validated by a validating resolver.
        """
        return pulumi.get(self, "sign_and_serve")

    @sign_and_serve.setter
    def sign_and_serve(self, value: _builtins.bool):
        pulumi.set(self, "sign_and_serve", value)

    @_builtins.property
    @pulumi.getter(name="signAndServeAlgorithm")
    def sign_and_serve_algorithm(self) -> _builtins.str:
        """
        The signing algorithm to use for signAndServe. One of the following values: RSA_SHA1, RSA_SHA256, RSA_SHA512, ECDSA_P256_SHA256, ECDSA_P384_SHA384, ED25519, ED448.
        """
        return pulumi.get(self, "sign_and_serve_algorithm")

    @sign_and_serve_algorithm.setter
    def sign_and_serve_algorithm(self, value: _builtins.str):
        pulumi.set(self, "sign_and_serve_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the domain.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmDomainsDomainLinkArgs']]:
        """
        Provides a URL path that allows direct navigation to the domain.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmDomainsDomainLinkArgs']]):
        pulumi.set(self, "links", value)


if not MYPY:
    class GetGtmDomainsDomainLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmDomainsDomainLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmDomainsDomainLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmResourceLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmResourceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmResourceLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmResourceResourceInstanceArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        load_object: _builtins.str
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        load_object_port: _builtins.int
        """
        Specifies the TCP port of the loadObject.
        """
        load_servers: Sequence[_builtins.str]
        """
        Specifies the list of servers to requests the load object from.
        """
        use_default_load_object: _builtins.bool
        """
        Whether to use default loadObject.
        """
elif False:
    GetGtmResourceResourceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmResourceResourceInstanceArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: _builtins.str):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: _builtins.int):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "load_servers", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")

    @use_default_load_object.setter
    def use_default_load_object(self, value: _builtins.bool):
        pulumi.set(self, "use_default_load_object", value)


if not MYPY:
    class GetGtmResourcesResourceArgsDict(TypedDict):
        aggregation_type: _builtins.str
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        constrained_property: _builtins.str
        """
        Specifies the name of the property that this resource constraints.
        """
        decay_rate: _builtins.float
        """
        For internal use only.
        """
        description: _builtins.str
        """
        A descriptive note which allows to track what is constrained by this resource.
        """
        host_header: _builtins.str
        """
        Specifies the host header used when fetching the load object.
        """
        leader_string: _builtins.str
        """
        Specifies the text that comes before the load object.
        """
        least_squares_decay: _builtins.float
        """
        For internal use only.
        """
        load_imbalance_percentage: _builtins.float
        """
        Indicates the percentage of load imbalance for the domain.
        """
        max_u_multiplicative_increment: _builtins.float
        """
        For internal use only.
        """
        name: _builtins.str
        """
        A descriptive label for the resource.
        """
        type: _builtins.str
        """
        Indicates the type of load object used to determine the load on the resource.
        """
        upper_bound: _builtins.int
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        links: NotRequired[Sequence['GetGtmResourcesResourceLinkArgsDict']]
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        resource_instances: NotRequired[Sequence['GetGtmResourcesResourceResourceInstanceArgsDict']]
        """
        Instances of the resource.
        """
elif False:
    GetGtmResourcesResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmResourcesResourceArgs:
    def __init__(__self__, *,
                 aggregation_type: _builtins.str,
                 constrained_property: _builtins.str,
                 decay_rate: _builtins.float,
                 description: _builtins.str,
                 host_header: _builtins.str,
                 leader_string: _builtins.str,
                 least_squares_decay: _builtins.float,
                 load_imbalance_percentage: _builtins.float,
                 max_u_multiplicative_increment: _builtins.float,
                 name: _builtins.str,
                 type: _builtins.str,
                 upper_bound: _builtins.int,
                 links: Optional[Sequence['GetGtmResourcesResourceLinkArgs']] = None,
                 resource_instances: Optional[Sequence['GetGtmResourcesResourceResourceInstanceArgs']] = None):
        """
        :param _builtins.str aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        :param _builtins.str constrained_property: Specifies the name of the property that this resource constraints.
        :param _builtins.float decay_rate: For internal use only.
        :param _builtins.str description: A descriptive note which allows to track what is constrained by this resource.
        :param _builtins.str host_header: Specifies the host header used when fetching the load object.
        :param _builtins.str leader_string: Specifies the text that comes before the load object.
        :param _builtins.float least_squares_decay: For internal use only.
        :param _builtins.float load_imbalance_percentage: Indicates the percentage of load imbalance for the domain.
        :param _builtins.float max_u_multiplicative_increment: For internal use only.
        :param _builtins.str name: A descriptive label for the resource.
        :param _builtins.str type: Indicates the type of load object used to determine the load on the resource.
        :param _builtins.int upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
        :param Sequence['GetGtmResourcesResourceLinkArgs'] links: Specifies the URL path that allows direct navigation to the resource.
        :param Sequence['GetGtmResourcesResourceResourceInstanceArgs'] resource_instances: Instances of the resource.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "constrained_property", constrained_property)
        pulumi.set(__self__, "decay_rate", decay_rate)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "leader_string", leader_string)
        pulumi.set(__self__, "least_squares_decay", least_squares_decay)
        pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
        pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upper_bound", upper_bound)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if resource_instances is not None:
            pulumi.set(__self__, "resource_instances", resource_instances)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: _builtins.str):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="constrainedProperty")
    def constrained_property(self) -> _builtins.str:
        """
        Specifies the name of the property that this resource constraints.
        """
        return pulumi.get(self, "constrained_property")

    @constrained_property.setter
    def constrained_property(self, value: _builtins.str):
        pulumi.set(self, "constrained_property", value)

    @_builtins.property
    @pulumi.getter(name="decayRate")
    def decay_rate(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "decay_rate")

    @decay_rate.setter
    def decay_rate(self, value: _builtins.float):
        pulumi.set(self, "decay_rate", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A descriptive note which allows to track what is constrained by this resource.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: _builtins.str):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> _builtins.str:
        """
        Specifies the host header used when fetching the load object.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: _builtins.str):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter(name="leaderString")
    def leader_string(self) -> _builtins.str:
        """
        Specifies the text that comes before the load object.
        """
        return pulumi.get(self, "leader_string")

    @leader_string.setter
    def leader_string(self, value: _builtins.str):
        pulumi.set(self, "leader_string", value)

    @_builtins.property
    @pulumi.getter(name="leastSquaresDecay")
    def least_squares_decay(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "least_squares_decay")

    @least_squares_decay.setter
    def least_squares_decay(self, value: _builtins.float):
        pulumi.set(self, "least_squares_decay", value)

    @_builtins.property
    @pulumi.getter(name="loadImbalancePercentage")
    def load_imbalance_percentage(self) -> _builtins.float:
        """
        Indicates the percentage of load imbalance for the domain.
        """
        return pulumi.get(self, "load_imbalance_percentage")

    @load_imbalance_percentage.setter
    def load_imbalance_percentage(self, value: _builtins.float):
        pulumi.set(self, "load_imbalance_percentage", value)

    @_builtins.property
    @pulumi.getter(name="maxUMultiplicativeIncrement")
    def max_u_multiplicative_increment(self) -> _builtins.float:
        """
        For internal use only.
        """
        return pulumi.get(self, "max_u_multiplicative_increment")

    @max_u_multiplicative_increment.setter
    def max_u_multiplicative_increment(self, value: _builtins.float):
        pulumi.set(self, "max_u_multiplicative_increment", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A descriptive label for the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the type of load object used to determine the load on the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> _builtins.int:
        """
        An optional sanity check that specifies the maximum allowed value for any component of the load object.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: _builtins.int):
        pulumi.set(self, "upper_bound", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetGtmResourcesResourceLinkArgs']]:
        """
        Specifies the URL path that allows direct navigation to the resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetGtmResourcesResourceLinkArgs']]):
        pulumi.set(self, "links", value)

    @_builtins.property
    @pulumi.getter(name="resourceInstances")
    def resource_instances(self) -> Optional[Sequence['GetGtmResourcesResourceResourceInstanceArgs']]:
        """
        Instances of the resource.
        """
        return pulumi.get(self, "resource_instances")

    @resource_instances.setter
    def resource_instances(self, value: Optional[Sequence['GetGtmResourcesResourceResourceInstanceArgs']]):
        pulumi.set(self, "resource_instances", value)


if not MYPY:
    class GetGtmResourcesResourceLinkArgsDict(TypedDict):
        href: _builtins.str
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        rel: _builtins.str
        """
        Indicates the link relationship of the object.
        """
elif False:
    GetGtmResourcesResourceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmResourcesResourceLinkArgs:
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        """
        :param _builtins.str href: A hypermedia link to the complete URL that uniquely defines a resource.
        :param _builtins.str rel: Indicates the link relationship of the object.
        """
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        """
        A hypermedia link to the complete URL that uniquely defines a resource.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: _builtins.str):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        """
        Indicates the link relationship of the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: _builtins.str):
        pulumi.set(self, "rel", value)


if not MYPY:
    class GetGtmResourcesResourceResourceInstanceArgsDict(TypedDict):
        datacenter_id: _builtins.int
        """
        A unique identifier for an existing data center in the domain.
        """
        load_object: _builtins.str
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        load_object_port: _builtins.int
        """
        Specifies the TCP port of the loadObject.
        """
        load_servers: Sequence[_builtins.str]
        """
        Specifies the list of servers to requests the load object from.
        """
        use_default_load_object: _builtins.bool
        """
        Whether to use default loadObject.
        """
elif False:
    GetGtmResourcesResourceResourceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGtmResourcesResourceResourceInstanceArgs:
    def __init__(__self__, *,
                 datacenter_id: _builtins.int,
                 load_object: _builtins.str,
                 load_object_port: _builtins.int,
                 load_servers: Sequence[_builtins.str],
                 use_default_load_object: _builtins.bool):
        """
        :param _builtins.int datacenter_id: A unique identifier for an existing data center in the domain.
        :param _builtins.str load_object: Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        :param _builtins.int load_object_port: Specifies the TCP port of the loadObject.
        :param Sequence[_builtins.str] load_servers: Specifies the list of servers to requests the load object from.
        :param _builtins.bool use_default_load_object: Whether to use default loadObject.
        """
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "load_object", load_object)
        pulumi.set(__self__, "load_object_port", load_object_port)
        pulumi.set(__self__, "load_servers", load_servers)
        pulumi.set(__self__, "use_default_load_object", use_default_load_object)

    @_builtins.property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> _builtins.int:
        """
        A unique identifier for an existing data center in the domain.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: _builtins.int):
        pulumi.set(self, "datacenter_id", value)

    @_builtins.property
    @pulumi.getter(name="loadObject")
    def load_object(self) -> _builtins.str:
        """
        Identifies the load object file used to report real-time information about the current load, maximum allowable load and target load on each resource.
        """
        return pulumi.get(self, "load_object")

    @load_object.setter
    def load_object(self, value: _builtins.str):
        pulumi.set(self, "load_object", value)

    @_builtins.property
    @pulumi.getter(name="loadObjectPort")
    def load_object_port(self) -> _builtins.int:
        """
        Specifies the TCP port of the loadObject.
        """
        return pulumi.get(self, "load_object_port")

    @load_object_port.setter
    def load_object_port(self, value: _builtins.int):
        pulumi.set(self, "load_object_port", value)

    @_builtins.property
    @pulumi.getter(name="loadServers")
    def load_servers(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of servers to requests the load object from.
        """
        return pulumi.get(self, "load_servers")

    @load_servers.setter
    def load_servers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "load_servers", value)

    @_builtins.property
    @pulumi.getter(name="useDefaultLoadObject")
    def use_default_load_object(self) -> _builtins.bool:
        """
        Whether to use default loadObject.
        """
        return pulumi.get(self, "use_default_load_object")

    @use_default_load_object.setter
    def use_default_load_object(self, value: _builtins.bool):
        pulumi.set(self, "use_default_load_object", value)


if not MYPY:
    class GetImagingPolicyImagePolicyArgsDict(TypedDict):
        breakpoints: NotRequired['GetImagingPolicyImagePolicyBreakpointsArgsDict']
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        hosts: NotRequired[Sequence[_builtins.str]]
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        output: NotRequired['GetImagingPolicyImagePolicyOutputArgsDict']
        """
        Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
        """
        post_breakpoint_transformations: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']]
        """
        Post-processing Transformations are applied to the image after image and quality settings have been applied.
        """
        rollout_duration: NotRequired[_builtins.str]
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        serve_stale_duration: NotRequired[_builtins.str]
        """
        The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
        """
        transformations: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationArgsDict']]
        """
        Set of image transformations to apply to the source image. If unspecified, no operations are performed.
        """
        variables: NotRequired[Sequence['GetImagingPolicyImagePolicyVariableArgsDict']]
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
elif False:
    GetImagingPolicyImagePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyArgs:
    def __init__(__self__, *,
                 breakpoints: Optional['GetImagingPolicyImagePolicyBreakpointsArgs'] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 output: Optional['GetImagingPolicyImagePolicyOutputArgs'] = None,
                 post_breakpoint_transformations: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']] = None,
                 rollout_duration: Optional[_builtins.str] = None,
                 serve_stale_duration: Optional[_builtins.str] = None,
                 transformations: Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']] = None,
                 variables: Optional[Sequence['GetImagingPolicyImagePolicyVariableArgs']] = None):
        """
        :param 'GetImagingPolicyImagePolicyBreakpointsArgs' breakpoints: The breakpoint widths (in pixels) to use to create derivative images/videos.
        :param Sequence[_builtins.str] hosts: Hosts that are allowed for image/video URLs within transformations or variables.
        :param 'GetImagingPolicyImagePolicyOutputArgs' output: Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] post_breakpoint_transformations: Post-processing Transformations are applied to the image after image and quality settings have been applied.
        :param _builtins.str rollout_duration: The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        :param _builtins.str serve_stale_duration: The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
        :param Sequence['GetImagingPolicyImagePolicyTransformationArgs'] transformations: Set of image transformations to apply to the source image. If unspecified, no operations are performed.
        :param Sequence['GetImagingPolicyImagePolicyVariableArgs'] variables: Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        if breakpoints is not None:
            pulumi.set(__self__, "breakpoints", breakpoints)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if post_breakpoint_transformations is not None:
            pulumi.set(__self__, "post_breakpoint_transformations", post_breakpoint_transformations)
        if rollout_duration is not None:
            pulumi.set(__self__, "rollout_duration", rollout_duration)
        if serve_stale_duration is not None:
            pulumi.set(__self__, "serve_stale_duration", serve_stale_duration)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def breakpoints(self) -> Optional['GetImagingPolicyImagePolicyBreakpointsArgs']:
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        return pulumi.get(self, "breakpoints")

    @breakpoints.setter
    def breakpoints(self, value: Optional['GetImagingPolicyImagePolicyBreakpointsArgs']):
        pulumi.set(self, "breakpoints", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['GetImagingPolicyImagePolicyOutputArgs']:
        """
        Dictates the output quality (either `quality` or `perceptualQuality`) and formats that are created for each resized image. If unspecified, image formats are created to support all browsers at the default quality level (`85`), which includes formats such as WEBP, JPEG2000 and JPEG-XR for specific browsers.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional['GetImagingPolicyImagePolicyOutputArgs']):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter(name="postBreakpointTransformations")
    def post_breakpoint_transformations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']]:
        """
        Post-processing Transformations are applied to the image after image and quality settings have been applied.
        """
        return pulumi.get(self, "post_breakpoint_transformations")

    @post_breakpoint_transformations.setter
    def post_breakpoint_transformations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']]):
        pulumi.set(self, "post_breakpoint_transformations", value)

    @_builtins.property
    @pulumi.getter(name="rolloutDuration")
    def rollout_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        return pulumi.get(self, "rollout_duration")

    @rollout_duration.setter
    def rollout_duration(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rollout_duration", value)

    @_builtins.property
    @pulumi.getter(name="serveStaleDuration")
    def serve_stale_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy will serve stale images. During the serve stale period realtime images will attempt to use the offline image from the previous policy version first if possible.
        """
        return pulumi.get(self, "serve_stale_duration")

    @serve_stale_duration.setter
    def serve_stale_duration(self, value: Optional[_builtins.str]):
        pulumi.set(self, "serve_stale_duration", value)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']]:
        """
        Set of image transformations to apply to the source image. If unspecified, no operations are performed.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']]):
        pulumi.set(self, "transformations", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['GetImagingPolicyImagePolicyVariableArgs']]:
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[Sequence['GetImagingPolicyImagePolicyVariableArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class GetImagingPolicyImagePolicyBreakpointsArgsDict(TypedDict):
        widths: NotRequired[Sequence[_builtins.int]]
elif False:
    GetImagingPolicyImagePolicyBreakpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyBreakpointsArgs:
    def __init__(__self__, *,
                 widths: Optional[Sequence[_builtins.int]] = None):
        if widths is not None:
            pulumi.set(__self__, "widths", widths)

    @_builtins.property
    @pulumi.getter
    def widths(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "widths")

    @widths.setter
    def widths(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "widths", value)


if not MYPY:
    class GetImagingPolicyImagePolicyOutputArgsDict(TypedDict):
        adaptive_quality: NotRequired[_builtins.str]
        """
        Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
        """
        allow_pristine_on_downsize: NotRequired[_builtins.str]
        """
        Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
        """
        allowed_formats: NotRequired[Sequence[_builtins.str]]
        """
        The graphics file formats allowed for browser specific results.
        """
        forced_formats: NotRequired[Sequence[_builtins.str]]
        """
        The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
        """
        perceptual_quality: NotRequired[_builtins.str]
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        perceptual_quality_floor: NotRequired[_builtins.str]
        """
        Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
        """
        perceptual_quality_var: NotRequired[_builtins.str]
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        prefer_modern_formats: NotRequired[_builtins.str]
        """
        Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
        """
        quality: NotRequired[_builtins.str]
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        quality_var: NotRequired[_builtins.str]
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
elif False:
    GetImagingPolicyImagePolicyOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyOutputArgs:
    def __init__(__self__, *,
                 adaptive_quality: Optional[_builtins.str] = None,
                 allow_pristine_on_downsize: Optional[_builtins.str] = None,
                 allowed_formats: Optional[Sequence[_builtins.str]] = None,
                 forced_formats: Optional[Sequence[_builtins.str]] = None,
                 perceptual_quality: Optional[_builtins.str] = None,
                 perceptual_quality_floor: Optional[_builtins.str] = None,
                 perceptual_quality_var: Optional[_builtins.str] = None,
                 prefer_modern_formats: Optional[_builtins.str] = None,
                 quality: Optional[_builtins.str] = None,
                 quality_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str adaptive_quality: Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
        :param _builtins.str allow_pristine_on_downsize: Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
        :param Sequence[_builtins.str] allowed_formats: The graphics file formats allowed for browser specific results.
        :param Sequence[_builtins.str] forced_formats: The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
        :param _builtins.str perceptual_quality: Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        :param _builtins.str perceptual_quality_floor: Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
        :param _builtins.str perceptual_quality_var: Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        :param _builtins.str prefer_modern_formats: Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
        :param _builtins.str quality: Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        :param _builtins.str quality_var: Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        if adaptive_quality is not None:
            pulumi.set(__self__, "adaptive_quality", adaptive_quality)
        if allow_pristine_on_downsize is not None:
            pulumi.set(__self__, "allow_pristine_on_downsize", allow_pristine_on_downsize)
        if allowed_formats is not None:
            pulumi.set(__self__, "allowed_formats", allowed_formats)
        if forced_formats is not None:
            pulumi.set(__self__, "forced_formats", forced_formats)
        if perceptual_quality is not None:
            pulumi.set(__self__, "perceptual_quality", perceptual_quality)
        if perceptual_quality_floor is not None:
            pulumi.set(__self__, "perceptual_quality_floor", perceptual_quality_floor)
        if perceptual_quality_var is not None:
            pulumi.set(__self__, "perceptual_quality_var", perceptual_quality_var)
        if prefer_modern_formats is not None:
            pulumi.set(__self__, "prefer_modern_formats", prefer_modern_formats)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)
        if quality_var is not None:
            pulumi.set(__self__, "quality_var", quality_var)

    @_builtins.property
    @pulumi.getter(name="adaptiveQuality")
    def adaptive_quality(self) -> Optional[_builtins.str]:
        """
        Override the quality of image to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of images for users with faster connections.
        """
        return pulumi.get(self, "adaptive_quality")

    @adaptive_quality.setter
    def adaptive_quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "adaptive_quality", value)

    @_builtins.property
    @pulumi.getter(name="allowPristineOnDownsize")
    def allow_pristine_on_downsize(self) -> Optional[_builtins.str]:
        """
        Whether a pristine image wider than the requested breakpoint is allowed as a derivative image if it has the fewest bytes. This will not have an affect if transformations are present.
        """
        return pulumi.get(self, "allow_pristine_on_downsize")

    @allow_pristine_on_downsize.setter
    def allow_pristine_on_downsize(self, value: Optional[_builtins.str]):
        pulumi.set(self, "allow_pristine_on_downsize", value)

    @_builtins.property
    @pulumi.getter(name="allowedFormats")
    def allowed_formats(self) -> Optional[Sequence[_builtins.str]]:
        """
        The graphics file formats allowed for browser specific results.
        """
        return pulumi.get(self, "allowed_formats")

    @allowed_formats.setter
    def allowed_formats(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "allowed_formats", value)

    @_builtins.property
    @pulumi.getter(name="forcedFormats")
    def forced_formats(self) -> Optional[Sequence[_builtins.str]]:
        """
        The forced extra formats for the `imFormat` query parameter, which requests a specific browser type. By default, Image and Video Manager detects the browser and returns the appropriate image.
        """
        return pulumi.get(self, "forced_formats")

    @forced_formats.setter
    def forced_formats(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "forced_formats", value)

    @_builtins.property
    @pulumi.getter(name="perceptualQuality")
    def perceptual_quality(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        return pulumi.get(self, "perceptual_quality")

    @perceptual_quality.setter
    def perceptual_quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "perceptual_quality", value)

    @_builtins.property
    @pulumi.getter(name="perceptualQualityFloor")
    def perceptual_quality_floor(self) -> Optional[_builtins.str]:
        """
        Only applies with perceptualQuality set. Sets a minimum image quality to respect when using perceptual quality. Perceptual quality will not reduce the quality below this value even if it determines the compressed image to be acceptably visually similar.
        """
        return pulumi.get(self, "perceptual_quality_floor")

    @perceptual_quality_floor.setter
    def perceptual_quality_floor(self, value: Optional[_builtins.str]):
        pulumi.set(self, "perceptual_quality_floor", value)

    @_builtins.property
    @pulumi.getter(name="perceptualQualityVar")
    def perceptual_quality_var(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with quality. The perceptual quality to use when comparing resulting images, which overrides the `quality` setting. Perceptual quality tunes each image format's quality parameter dynamically based on the human-perceived quality of the output image. This can result in better byte savings (as compared to using regular quality) as many images can be encoded at a much lower quality without compromising perception of the image. In addition, certain images may need to be encoded at a slightly higher quality in order to maintain human-perceived quality. Values are tiered `high`, `mediumHigh`, `medium`, `mediumLow`, or `low`.
        """
        return pulumi.get(self, "perceptual_quality_var")

    @perceptual_quality_var.setter
    def perceptual_quality_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "perceptual_quality_var", value)

    @_builtins.property
    @pulumi.getter(name="preferModernFormats")
    def prefer_modern_formats(self) -> Optional[_builtins.str]:
        """
        Whether derivative image formats should be selected with a preference for modern formats (such as WebP and Avif) instead the format that results in the fewest bytes.
        """
        return pulumi.get(self, "prefer_modern_formats")

    @prefer_modern_formats.setter
    def prefer_modern_formats(self, value: Optional[_builtins.str]):
        pulumi.set(self, "prefer_modern_formats", value)

    @_builtins.property
    @pulumi.getter
    def quality(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "quality", value)

    @_builtins.property
    @pulumi.getter(name="qualityVar")
    def quality_var(self) -> Optional[_builtins.str]:
        """
        Mutually exclusive with perceptualQuality, used by default if neither is specified. The chosen quality of the output images. Using a quality value from 1-100 resembles JPEG quality across output formats.
        """
        return pulumi.get(self, "quality_var")

    @quality_var.setter
    def quality_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "quality_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict(TypedDict):
        background_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgsDict']]
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        blurs: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgsDict']]
        """
        Applies a Gaussian blur to the image.
        """
        chroma_keys: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgsDict']]
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        composites: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgsDict']]
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        compounds: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgsDict']]
        contrasts: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgsDict']]
        """
        Adjusts both the contrast and brightness of an image.
        """
        goops: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgsDict']]
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        grayscales: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgsDict']]
        """
        Restricts image color to shades of gray only.
        """
        hsls: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgsDict']]
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        hsvs: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgsDict']]
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        if_dimensions: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgsDict']]
        if_orientations: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgsDict']]
        max_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgsDict']]
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        mirrors: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgsDict']]
        """
        Flips an image horizontally, vertically, or both.
        """
        mono_hues: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgsDict']]
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        opacities: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgsDict']]
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        remove_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgsDict']]
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        unsharp_masks: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgsDict']]
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationArgs:
    def __init__(__self__, *,
                 background_colors: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs']] = None,
                 blurs: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs']] = None,
                 chroma_keys: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs']] = None,
                 composites: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs']] = None,
                 compounds: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgs']] = None,
                 contrasts: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs']] = None,
                 goops: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs']] = None,
                 grayscales: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs']] = None,
                 hsls: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs']] = None,
                 hsvs: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs']] = None,
                 if_dimensions: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgs']] = None,
                 if_orientations: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgs']] = None,
                 max_colors: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs']] = None,
                 mirrors: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs']] = None,
                 mono_hues: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs']] = None,
                 opacities: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs']] = None,
                 remove_colors: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs']] = None,
                 unsharp_masks: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs'] background_colors: Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs'] blurs: Applies a Gaussian blur to the image.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs'] chroma_keys: Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs'] composites: Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs'] contrasts: Adjusts both the contrast and brightness of an image.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs'] goops: Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs'] grayscales: Restricts image color to shades of gray only.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs'] hsls: Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs'] hsvs: Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs'] max_colors: Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs'] mirrors: Flips an image horizontally, vertically, or both.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs'] mono_hues: Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs'] opacities: Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs'] remove_colors: Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs'] unsharp_masks: Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        if background_colors is not None:
            pulumi.set(__self__, "background_colors", background_colors)
        if blurs is not None:
            pulumi.set(__self__, "blurs", blurs)
        if chroma_keys is not None:
            pulumi.set(__self__, "chroma_keys", chroma_keys)
        if composites is not None:
            pulumi.set(__self__, "composites", composites)
        if compounds is not None:
            pulumi.set(__self__, "compounds", compounds)
        if contrasts is not None:
            pulumi.set(__self__, "contrasts", contrasts)
        if goops is not None:
            pulumi.set(__self__, "goops", goops)
        if grayscales is not None:
            pulumi.set(__self__, "grayscales", grayscales)
        if hsls is not None:
            pulumi.set(__self__, "hsls", hsls)
        if hsvs is not None:
            pulumi.set(__self__, "hsvs", hsvs)
        if if_dimensions is not None:
            pulumi.set(__self__, "if_dimensions", if_dimensions)
        if if_orientations is not None:
            pulumi.set(__self__, "if_orientations", if_orientations)
        if max_colors is not None:
            pulumi.set(__self__, "max_colors", max_colors)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)
        if mono_hues is not None:
            pulumi.set(__self__, "mono_hues", mono_hues)
        if opacities is not None:
            pulumi.set(__self__, "opacities", opacities)
        if remove_colors is not None:
            pulumi.set(__self__, "remove_colors", remove_colors)
        if unsharp_masks is not None:
            pulumi.set(__self__, "unsharp_masks", unsharp_masks)

    @_builtins.property
    @pulumi.getter(name="backgroundColors")
    def background_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs']]:
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        return pulumi.get(self, "background_colors")

    @background_colors.setter
    def background_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs']]):
        pulumi.set(self, "background_colors", value)

    @_builtins.property
    @pulumi.getter
    def blurs(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs']]:
        """
        Applies a Gaussian blur to the image.
        """
        return pulumi.get(self, "blurs")

    @blurs.setter
    def blurs(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs']]):
        pulumi.set(self, "blurs", value)

    @_builtins.property
    @pulumi.getter(name="chromaKeys")
    def chroma_keys(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs']]:
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        return pulumi.get(self, "chroma_keys")

    @chroma_keys.setter
    def chroma_keys(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs']]):
        pulumi.set(self, "chroma_keys", value)

    @_builtins.property
    @pulumi.getter
    def composites(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs']]:
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        return pulumi.get(self, "composites")

    @composites.setter
    def composites(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs']]):
        pulumi.set(self, "composites", value)

    @_builtins.property
    @pulumi.getter
    def compounds(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgs']]:
        return pulumi.get(self, "compounds")

    @compounds.setter
    def compounds(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgs']]):
        pulumi.set(self, "compounds", value)

    @_builtins.property
    @pulumi.getter
    def contrasts(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs']]:
        """
        Adjusts both the contrast and brightness of an image.
        """
        return pulumi.get(self, "contrasts")

    @contrasts.setter
    def contrasts(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs']]):
        pulumi.set(self, "contrasts", value)

    @_builtins.property
    @pulumi.getter
    def goops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs']]:
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        return pulumi.get(self, "goops")

    @goops.setter
    def goops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs']]):
        pulumi.set(self, "goops", value)

    @_builtins.property
    @pulumi.getter
    def grayscales(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs']]:
        """
        Restricts image color to shades of gray only.
        """
        return pulumi.get(self, "grayscales")

    @grayscales.setter
    def grayscales(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs']]):
        pulumi.set(self, "grayscales", value)

    @_builtins.property
    @pulumi.getter
    def hsls(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs']]:
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        return pulumi.get(self, "hsls")

    @hsls.setter
    def hsls(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs']]):
        pulumi.set(self, "hsls", value)

    @_builtins.property
    @pulumi.getter
    def hsvs(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs']]:
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        return pulumi.get(self, "hsvs")

    @hsvs.setter
    def hsvs(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs']]):
        pulumi.set(self, "hsvs", value)

    @_builtins.property
    @pulumi.getter(name="ifDimensions")
    def if_dimensions(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgs']]:
        return pulumi.get(self, "if_dimensions")

    @if_dimensions.setter
    def if_dimensions(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgs']]):
        pulumi.set(self, "if_dimensions", value)

    @_builtins.property
    @pulumi.getter(name="ifOrientations")
    def if_orientations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgs']]:
        return pulumi.get(self, "if_orientations")

    @if_orientations.setter
    def if_orientations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgs']]):
        pulumi.set(self, "if_orientations", value)

    @_builtins.property
    @pulumi.getter(name="maxColors")
    def max_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs']]:
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        return pulumi.get(self, "max_colors")

    @max_colors.setter
    def max_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs']]):
        pulumi.set(self, "max_colors", value)

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs']]:
        """
        Flips an image horizontally, vertically, or both.
        """
        return pulumi.get(self, "mirrors")

    @mirrors.setter
    def mirrors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs']]):
        pulumi.set(self, "mirrors", value)

    @_builtins.property
    @pulumi.getter(name="monoHues")
    def mono_hues(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs']]:
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        return pulumi.get(self, "mono_hues")

    @mono_hues.setter
    def mono_hues(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs']]):
        pulumi.set(self, "mono_hues", value)

    @_builtins.property
    @pulumi.getter
    def opacities(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs']]:
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        return pulumi.get(self, "opacities")

    @opacities.setter
    def opacities(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs']]):
        pulumi.set(self, "opacities", value)

    @_builtins.property
    @pulumi.getter(name="removeColors")
    def remove_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs']]:
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        return pulumi.get(self, "remove_colors")

    @remove_colors.setter
    def remove_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs']]):
        pulumi.set(self, "remove_colors", value)

    @_builtins.property
    @pulumi.getter(name="unsharpMasks")
    def unsharp_masks(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs']]:
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        return pulumi.get(self, "unsharp_masks")

    @unsharp_masks.setter
    def unsharp_masks(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs']]):
        pulumi.set(self, "unsharp_masks", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value for the background.
        """
        color_var: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value for the background.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationBackgroundColorArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value for the background.
        :param _builtins.str color_var: The hexadecimal CSS color value for the background.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgsDict(TypedDict):
        sigma: NotRequired[_builtins.str]
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        sigma_var: NotRequired[_builtins.str]
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationBlurArgs:
    def __init__(__self__, *,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str sigma: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        :param _builtins.str sigma_var: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma")

    @sigma.setter
    def sigma(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma", value)

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma_var")

    @sigma_var.setter
    def sigma_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        hue_feather: NotRequired[_builtins.str]
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        hue_feather_var: NotRequired[_builtins.str]
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        hue_tolerance: NotRequired[_builtins.str]
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        hue_tolerance_var: NotRequired[_builtins.str]
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        lightness_feather: NotRequired[_builtins.str]
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        lightness_feather_var: NotRequired[_builtins.str]
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        lightness_tolerance: NotRequired[_builtins.str]
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        lightness_tolerance_var: NotRequired[_builtins.str]
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        saturation_feather: NotRequired[_builtins.str]
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        saturation_feather_var: NotRequired[_builtins.str]
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        saturation_tolerance: NotRequired[_builtins.str]
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        saturation_tolerance_var: NotRequired[_builtins.str]
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationChromaKeyArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_feather: Optional[_builtins.str] = None,
                 hue_feather_var: Optional[_builtins.str] = None,
                 hue_tolerance: Optional[_builtins.str] = None,
                 hue_tolerance_var: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness_feather: Optional[_builtins.str] = None,
                 lightness_feather_var: Optional[_builtins.str] = None,
                 lightness_tolerance: Optional[_builtins.str] = None,
                 lightness_tolerance_var: Optional[_builtins.str] = None,
                 saturation_feather: Optional[_builtins.str] = None,
                 saturation_feather_var: Optional[_builtins.str] = None,
                 saturation_tolerance: Optional[_builtins.str] = None,
                 saturation_tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        :param _builtins.str hue_feather: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        :param _builtins.str hue_feather_var: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        :param _builtins.str hue_tolerance: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        :param _builtins.str hue_tolerance_var: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        :param _builtins.str hue_var: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        :param _builtins.str lightness_feather: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_feather_var: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_tolerance: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str lightness_tolerance_var: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str saturation_feather: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_feather_var: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_tolerance: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        :param _builtins.str saturation_tolerance_var: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_feather is not None:
            pulumi.set(__self__, "hue_feather", hue_feather)
        if hue_feather_var is not None:
            pulumi.set(__self__, "hue_feather_var", hue_feather_var)
        if hue_tolerance is not None:
            pulumi.set(__self__, "hue_tolerance", hue_tolerance)
        if hue_tolerance_var is not None:
            pulumi.set(__self__, "hue_tolerance_var", hue_tolerance_var)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness_feather is not None:
            pulumi.set(__self__, "lightness_feather", lightness_feather)
        if lightness_feather_var is not None:
            pulumi.set(__self__, "lightness_feather_var", lightness_feather_var)
        if lightness_tolerance is not None:
            pulumi.set(__self__, "lightness_tolerance", lightness_tolerance)
        if lightness_tolerance_var is not None:
            pulumi.set(__self__, "lightness_tolerance_var", lightness_tolerance_var)
        if saturation_feather is not None:
            pulumi.set(__self__, "saturation_feather", saturation_feather)
        if saturation_feather_var is not None:
            pulumi.set(__self__, "saturation_feather_var", saturation_feather_var)
        if saturation_tolerance is not None:
            pulumi.set(__self__, "saturation_tolerance", saturation_tolerance)
        if saturation_tolerance_var is not None:
            pulumi.set(__self__, "saturation_tolerance_var", saturation_tolerance_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueFeather")
    def hue_feather(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather")

    @hue_feather.setter
    def hue_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_feather", value)

    @_builtins.property
    @pulumi.getter(name="hueFeatherVar")
    def hue_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather_var")

    @hue_feather_var.setter
    def hue_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="hueTolerance")
    def hue_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance")

    @hue_tolerance.setter
    def hue_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="hueToleranceVar")
    def hue_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance_var")

    @hue_tolerance_var.setter
    def hue_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_tolerance_var", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter(name="lightnessFeather")
    def lightness_feather(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather")

    @lightness_feather.setter
    def lightness_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_feather", value)

    @_builtins.property
    @pulumi.getter(name="lightnessFeatherVar")
    def lightness_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather_var")

    @lightness_feather_var.setter
    def lightness_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="lightnessTolerance")
    def lightness_tolerance(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance")

    @lightness_tolerance.setter
    def lightness_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="lightnessToleranceVar")
    def lightness_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance_var")

    @lightness_tolerance_var.setter
    def lightness_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_tolerance_var", value)

    @_builtins.property
    @pulumi.getter(name="saturationFeather")
    def saturation_feather(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather")

    @saturation_feather.setter
    def saturation_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_feather", value)

    @_builtins.property
    @pulumi.getter(name="saturationFeatherVar")
    def saturation_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather_var")

    @saturation_feather_var.setter
    def saturation_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="saturationTolerance")
    def saturation_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance")

    @saturation_tolerance.setter
    def saturation_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="saturationToleranceVar")
    def saturation_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance_var")

    @saturation_tolerance_var.setter
    def saturation_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_tolerance_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgsDict(TypedDict):
        image: 'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgsDict'
        gravity: NotRequired[_builtins.str]
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        placement: NotRequired[_builtins.str]
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        placement_var: NotRequired[_builtins.str]
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        scale: NotRequired[_builtins.str]
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        scale_dimension: NotRequired[_builtins.str]
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        scale_dimension_var: NotRequired[_builtins.str]
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        scale_var: NotRequired[_builtins.str]
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        x_position: NotRequired[_builtins.str]
        """
        The x-axis position of the image to apply.
        """
        x_position_var: NotRequired[_builtins.str]
        """
        The x-axis position of the image to apply.
        """
        y_position: NotRequired[_builtins.str]
        """
        The y-axis position of the image to apply.
        """
        y_position_var: NotRequired[_builtins.str]
        """
        The y-axis position of the image to apply.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeArgs:
    def __init__(__self__, *,
                 image: 'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgs',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 placement: Optional[_builtins.str] = None,
                 placement_var: Optional[_builtins.str] = None,
                 scale: Optional[_builtins.str] = None,
                 scale_dimension: Optional[_builtins.str] = None,
                 scale_dimension_var: Optional[_builtins.str] = None,
                 scale_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str gravity_var: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str placement: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str placement_var: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str scale: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str scale_dimension: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_dimension_var: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_var: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str x_position: The x-axis position of the image to apply.
        :param _builtins.str x_position_var: The x-axis position of the image to apply.
        :param _builtins.str y_position: The y-axis position of the image to apply.
        :param _builtins.str y_position_var: The y-axis position of the image to apply.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if placement_var is not None:
            pulumi.set(__self__, "placement_var", placement_var)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if scale_dimension is not None:
            pulumi.set(__self__, "scale_dimension", scale_dimension)
        if scale_dimension_var is not None:
            pulumi.set(__self__, "scale_dimension_var", scale_dimension_var)
        if scale_var is not None:
            pulumi.set(__self__, "scale_var", scale_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgs':
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: 'GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgs'):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="placementVar")
    def placement_var(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement_var")

    @placement_var.setter
    def placement_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placement_var", value)

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale", value)

    @_builtins.property
    @pulumi.getter(name="scaleDimension")
    def scale_dimension(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension")

    @scale_dimension.setter
    def scale_dimension(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_dimension", value)

    @_builtins.property
    @pulumi.getter(name="scaleDimensionVar")
    def scale_dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension_var")

    @scale_dimension_var.setter
    def scale_dimension_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_dimension_var", value)

    @_builtins.property
    @pulumi.getter(name="scaleVar")
    def scale_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale_var")

    @scale_var.setter
    def scale_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_var", value)

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position", value)

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position_var")

    @x_position_var.setter
    def x_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position_var", value)

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position", value)

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position_var")

    @y_position_var.setter
    def y_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgsDict(TypedDict):
        box_images: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        circle_images: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        text_images: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgsDict']]
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        url_images: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgsDict']]
        """
        An image loaded from a URL.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageArgs:
    def __init__(__self__, *,
                 box_images: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs']] = None,
                 circle_images: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs']] = None,
                 text_images: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs']] = None,
                 url_images: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @box_images.setter
    def box_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs']]):
        pulumi.set(self, "box_images", value)

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @circle_images.setter
    def circle_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs']]):
        pulumi.set(self, "circle_images", value)

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @text_images.setter
    def text_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs']]):
        pulumi.set(self, "text_images", value)

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")

    @url_images.setter
    def url_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs']]):
        pulumi.set(self, "url_images", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        height: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageBoxImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        diameter: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        diameter_var: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageCircleImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @diameter.setter
    def diameter(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter", value)

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @diameter_var.setter
    def diameter_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgsDict(TypedDict):
        fill: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        fill_var: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        size: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        size_var: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        stroke: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        stroke_size: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_size_var: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_var: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        text: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        text_var: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        typeface: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        typeface_var: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageTextImageArgs:
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @fill.setter
    def fill(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill", value)

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @fill_var.setter
    def fill_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill_var", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @size_var.setter
    def size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size_var", value)

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @stroke.setter
    def stroke(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke", value)

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @stroke_size.setter
    def stroke_size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size", value)

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @stroke_size_var.setter
    def stroke_size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size_var", value)

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @stroke_var.setter
    def stroke_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_var", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @text_var.setter
    def text_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @typeface.setter
    def typeface(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface", value)

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")

    @typeface_var.setter
    def typeface_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgsDict(TypedDict):
        transformation: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        url: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
        url_var: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompositeImageUrlImageArgs:
    def __init__(__self__, *,
                 transformation: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")

    @url_var.setter
    def url_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgsDict(TypedDict):
        transformations: NotRequired[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']]
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationCompoundArgs:
    def __init__(__self__, *,
                 transformations: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']] = None):
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']]:
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']]):
        pulumi.set(self, "transformations", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgsDict(TypedDict):
        brightness: NotRequired[_builtins.str]
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        brightness_var: NotRequired[_builtins.str]
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        contrast: NotRequired[_builtins.str]
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        contrast_var: NotRequired[_builtins.str]
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationContrastArgs:
    def __init__(__self__, *,
                 brightness: Optional[_builtins.str] = None,
                 brightness_var: Optional[_builtins.str] = None,
                 contrast: Optional[_builtins.str] = None,
                 contrast_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str brightness: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str brightness_var: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str contrast: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        :param _builtins.str contrast_var: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if brightness_var is not None:
            pulumi.set(__self__, "brightness_var", brightness_var)
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if contrast_var is not None:
            pulumi.set(__self__, "contrast_var", contrast_var)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness")

    @brightness.setter
    def brightness(self, value: Optional[_builtins.str]):
        pulumi.set(self, "brightness", value)

    @_builtins.property
    @pulumi.getter(name="brightnessVar")
    def brightness_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness_var")

    @brightness_var.setter
    def brightness_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "brightness_var", value)

    @_builtins.property
    @pulumi.getter
    def contrast(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast")

    @contrast.setter
    def contrast(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contrast", value)

    @_builtins.property
    @pulumi.getter(name="contrastVar")
    def contrast_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast_var")

    @contrast_var.setter
    def contrast_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contrast_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgsDict(TypedDict):
        chaos: NotRequired[_builtins.str]
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        chaos_var: NotRequired[_builtins.str]
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        density: NotRequired[_builtins.str]
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        density_var: NotRequired[_builtins.str]
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        power: NotRequired[_builtins.str]
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        power_var: NotRequired[_builtins.str]
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        seed: NotRequired[_builtins.str]
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        seed_var: NotRequired[_builtins.str]
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationGoopArgs:
    def __init__(__self__, *,
                 chaos: Optional[_builtins.str] = None,
                 chaos_var: Optional[_builtins.str] = None,
                 density: Optional[_builtins.str] = None,
                 density_var: Optional[_builtins.str] = None,
                 power: Optional[_builtins.str] = None,
                 power_var: Optional[_builtins.str] = None,
                 seed: Optional[_builtins.str] = None,
                 seed_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str chaos: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str chaos_var: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str density: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str density_var: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str power: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str power_var: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str seed: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        :param _builtins.str seed_var: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        if chaos is not None:
            pulumi.set(__self__, "chaos", chaos)
        if chaos_var is not None:
            pulumi.set(__self__, "chaos_var", chaos_var)
        if density is not None:
            pulumi.set(__self__, "density", density)
        if density_var is not None:
            pulumi.set(__self__, "density_var", density_var)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_var is not None:
            pulumi.set(__self__, "power_var", power_var)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)
        if seed_var is not None:
            pulumi.set(__self__, "seed_var", seed_var)

    @_builtins.property
    @pulumi.getter
    def chaos(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos")

    @chaos.setter
    def chaos(self, value: Optional[_builtins.str]):
        pulumi.set(self, "chaos", value)

    @_builtins.property
    @pulumi.getter(name="chaosVar")
    def chaos_var(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos_var")

    @chaos_var.setter
    def chaos_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "chaos_var", value)

    @_builtins.property
    @pulumi.getter
    def density(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density")

    @density.setter
    def density(self, value: Optional[_builtins.str]):
        pulumi.set(self, "density", value)

    @_builtins.property
    @pulumi.getter(name="densityVar")
    def density_var(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density_var")

    @density_var.setter
    def density_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "density_var", value)

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[_builtins.str]):
        pulumi.set(self, "power", value)

    @_builtins.property
    @pulumi.getter(name="powerVar")
    def power_var(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power_var")

    @power_var.setter
    def power_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "power_var", value)

    @_builtins.property
    @pulumi.getter
    def seed(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed")

    @seed.setter
    def seed(self, value: Optional[_builtins.str]):
        pulumi.set(self, "seed", value)

    @_builtins.property
    @pulumi.getter(name="seedVar")
    def seed_var(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed_var")

    @seed_var.setter
    def seed_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "seed_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgsDict(TypedDict):
        type: NotRequired[_builtins.str]
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        type_var: NotRequired[_builtins.str]
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationGrayscaleArgs:
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        :param _builtins.str type_var: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type_var")

    @type_var.setter
    def type_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        lightness: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        lightness_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        saturation: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        saturation_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationHslArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness: Optional[_builtins.str] = None,
                 lightness_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str lightness: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str lightness_var: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness is not None:
            pulumi.set(__self__, "lightness", lightness)
        if lightness_var is not None:
            pulumi.set(__self__, "lightness_var", lightness_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter
    def lightness(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness")

    @lightness.setter
    def lightness(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness", value)

    @_builtins.property
    @pulumi.getter(name="lightnessVar")
    def lightness_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness_var")

    @lightness_var.setter
    def lightness_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_var", value)

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @saturation.setter
    def saturation(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation", value)

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @saturation_var.setter
    def saturation_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        saturation: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        saturation_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        value: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        value_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationHsvArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str value: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        :param _builtins.str value_var: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @saturation.setter
    def saturation(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation", value)

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @saturation_var.setter
    def saturation_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_var", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value_var")

    @value_var.setter
    def value_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgsDict(TypedDict):
        default: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        dimension: NotRequired[_builtins.str]
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        dimension_var: NotRequired[_builtins.str]
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        equal: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        greater_than: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        less_than: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        value: NotRequired[_builtins.str]
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        value_var: NotRequired[_builtins.str]
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationIfDimensionArgs:
    def __init__(__self__, *,
                 default: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 dimension: Optional[_builtins.str] = None,
                 dimension_var: Optional[_builtins.str] = None,
                 equal: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 greater_than: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 less_than: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str dimension: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str dimension_var: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str value: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        :param _builtins.str value_var: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_var is not None:
            pulumi.set(__self__, "dimension_var", dimension_var)
        if equal is not None:
            pulumi.set(__self__, "equal", equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[_builtins.str]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="dimensionVar")
    def dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension_var")

    @dimension_var.setter
    def dimension_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "dimension_var", value)

    @_builtins.property
    @pulumi.getter
    def equal(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "equal")

    @equal.setter
    def equal(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "equal", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value_var")

    @value_var.setter
    def value_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgsDict(TypedDict):
        default: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        landscape: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        portrait: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
        square: NotRequired['GetImagingPolicyImagePolicyPostBreakpointTransformationArgsDict']
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationIfOrientationArgs:
    def __init__(__self__, *,
                 default: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 landscape: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 portrait: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None,
                 square: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs'] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if landscape is not None:
            pulumi.set(__self__, "landscape", landscape)
        if portrait is not None:
            pulumi.set(__self__, "portrait", portrait)
        if square is not None:
            pulumi.set(__self__, "square", square)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def landscape(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "landscape")

    @landscape.setter
    def landscape(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "landscape", value)

    @_builtins.property
    @pulumi.getter
    def portrait(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "portrait")

    @portrait.setter
    def portrait(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "portrait", value)

    @_builtins.property
    @pulumi.getter
    def square(self) -> Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']:
        return pulumi.get(self, "square")

    @square.setter
    def square(self, value: Optional['GetImagingPolicyImagePolicyPostBreakpointTransformationArgs']):
        pulumi.set(self, "square", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgsDict(TypedDict):
        colors: NotRequired[_builtins.str]
        """
        The value representing the maximum number of colors to use with the source image.
        """
        colors_var: NotRequired[_builtins.str]
        """
        The value representing the maximum number of colors to use with the source image.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMaxColorArgs:
    def __init__(__self__, *,
                 colors: Optional[_builtins.str] = None,
                 colors_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str colors: The value representing the maximum number of colors to use with the source image.
        :param _builtins.str colors_var: The value representing the maximum number of colors to use with the source image.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if colors_var is not None:
            pulumi.set(__self__, "colors_var", colors_var)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[_builtins.str]):
        pulumi.set(self, "colors", value)

    @_builtins.property
    @pulumi.getter(name="colorsVar")
    def colors_var(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors_var")

    @colors_var.setter
    def colors_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "colors_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgsDict(TypedDict):
        horizontal: NotRequired[_builtins.str]
        """
        Flips the image horizontally.
        """
        horizontal_var: NotRequired[_builtins.str]
        """
        Flips the image horizontally.
        """
        vertical: NotRequired[_builtins.str]
        """
        Flips the image vertically.
        """
        vertical_var: NotRequired[_builtins.str]
        """
        Flips the image vertically.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMirrorArgs:
    def __init__(__self__, *,
                 horizontal: Optional[_builtins.str] = None,
                 horizontal_var: Optional[_builtins.str] = None,
                 vertical: Optional[_builtins.str] = None,
                 vertical_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str horizontal: Flips the image horizontally.
        :param _builtins.str horizontal_var: Flips the image horizontally.
        :param _builtins.str vertical: Flips the image vertically.
        :param _builtins.str vertical_var: Flips the image vertically.
        """
        if horizontal is not None:
            pulumi.set(__self__, "horizontal", horizontal)
        if horizontal_var is not None:
            pulumi.set(__self__, "horizontal_var", horizontal_var)
        if vertical is not None:
            pulumi.set(__self__, "vertical", vertical)
        if vertical_var is not None:
            pulumi.set(__self__, "vertical_var", vertical_var)

    @_builtins.property
    @pulumi.getter
    def horizontal(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal")

    @horizontal.setter
    def horizontal(self, value: Optional[_builtins.str]):
        pulumi.set(self, "horizontal", value)

    @_builtins.property
    @pulumi.getter(name="horizontalVar")
    def horizontal_var(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal_var")

    @horizontal_var.setter
    def horizontal_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "horizontal_var", value)

    @_builtins.property
    @pulumi.getter
    def vertical(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical")

    @vertical.setter
    def vertical(self, value: Optional[_builtins.str]):
        pulumi.set(self, "vertical", value)

    @_builtins.property
    @pulumi.getter(name="verticalVar")
    def vertical_var(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical_var")

    @vertical_var.setter
    def vertical_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "vertical_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        hue_var: NotRequired[_builtins.str]
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationMonoHueArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        :param _builtins.str hue_var: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgsDict(TypedDict):
        opacity: NotRequired[_builtins.str]
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        opacity_var: NotRequired[_builtins.str]
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationOpacityArgs:
    def __init__(__self__, *,
                 opacity: Optional[_builtins.str] = None,
                 opacity_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str opacity: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        :param _builtins.str opacity_var: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if opacity_var is not None:
            pulumi.set(__self__, "opacity_var", opacity_var)

    @_builtins.property
    @pulumi.getter
    def opacity(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity")

    @opacity.setter
    def opacity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "opacity", value)

    @_builtins.property
    @pulumi.getter(name="opacityVar")
    def opacity_var(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity_var")

    @opacity_var.setter
    def opacity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "opacity_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value to remove.
        """
        color_var: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value to remove.
        """
        feather: NotRequired[_builtins.str]
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        feather_var: NotRequired[_builtins.str]
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        tolerance: NotRequired[_builtins.str]
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        tolerance_var: NotRequired[_builtins.str]
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationRemoveColorArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 feather: Optional[_builtins.str] = None,
                 feather_var: Optional[_builtins.str] = None,
                 tolerance: Optional[_builtins.str] = None,
                 tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value to remove.
        :param _builtins.str color_var: The hexadecimal CSS color value to remove.
        :param _builtins.str feather: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str feather_var: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str tolerance: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        :param _builtins.str tolerance_var: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if feather is not None:
            pulumi.set(__self__, "feather", feather)
        if feather_var is not None:
            pulumi.set(__self__, "feather_var", feather_var)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)
        if tolerance_var is not None:
            pulumi.set(__self__, "tolerance_var", tolerance_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def feather(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather")

    @feather.setter
    def feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feather", value)

    @_builtins.property
    @pulumi.getter(name="featherVar")
    def feather_var(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather_var")

    @feather_var.setter
    def feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feather_var", value)

    @_builtins.property
    @pulumi.getter
    def tolerance(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance")

    @tolerance.setter
    def tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tolerance", value)

    @_builtins.property
    @pulumi.getter(name="toleranceVar")
    def tolerance_var(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance_var")

    @tolerance_var.setter
    def tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tolerance_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgsDict(TypedDict):
        gain: NotRequired[_builtins.str]
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        gain_var: NotRequired[_builtins.str]
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        sigma: NotRequired[_builtins.str]
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        sigma_var: NotRequired[_builtins.str]
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        threshold: NotRequired[_builtins.str]
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        threshold_var: NotRequired[_builtins.str]
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
elif False:
    GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyPostBreakpointTransformationUnsharpMaskArgs:
    def __init__(__self__, *,
                 gain: Optional[_builtins.str] = None,
                 gain_var: Optional[_builtins.str] = None,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 threshold_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gain: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str gain_var: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str sigma: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str sigma_var: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str threshold: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        :param _builtins.str threshold_var: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        if gain is not None:
            pulumi.set(__self__, "gain", gain)
        if gain_var is not None:
            pulumi.set(__self__, "gain_var", gain_var)
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_var is not None:
            pulumi.set(__self__, "threshold_var", threshold_var)

    @_builtins.property
    @pulumi.getter
    def gain(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain")

    @gain.setter
    def gain(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gain", value)

    @_builtins.property
    @pulumi.getter(name="gainVar")
    def gain_var(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain_var")

    @gain_var.setter
    def gain_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gain_var", value)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma")

    @sigma.setter
    def sigma(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma", value)

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma_var")

    @sigma_var.setter
    def sigma_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma_var", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[_builtins.str]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="thresholdVar")
    def threshold_var(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold_var")

    @threshold_var.setter
    def threshold_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "threshold_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationArgsDict(TypedDict):
        appends: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAppendArgsDict']]
        """
        Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
        """
        aspect_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgsDict']]
        """
        Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
        """
        background_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgsDict']]
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        blurs: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationBlurArgsDict']]
        """
        Applies a Gaussian blur to the image.
        """
        chroma_keys: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgsDict']]
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        composites: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgsDict']]
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        compounds: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompoundArgsDict']]
        contrasts: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationContrastArgsDict']]
        """
        Adjusts both the contrast and brightness of an image.
        """
        crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCropArgsDict']]
        """
        Crops an image.
        """
        face_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgsDict']]
        """
        Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
        """
        feature_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgsDict']]
        """
        Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
        """
        fit_and_fills: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgsDict']]
        """
        Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
        """
        goops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationGoopArgsDict']]
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        grayscales: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgsDict']]
        """
        Restricts image color to shades of gray only.
        """
        hsls: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationHslArgsDict']]
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        hsvs: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationHsvArgsDict']]
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        if_dimensions: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationIfDimensionArgsDict']]
        if_orientations: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationIfOrientationArgsDict']]
        im_queries: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgsDict']]
        """
        Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
        """
        max_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgsDict']]
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        mirrors: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgsDict']]
        """
        Flips an image horizontally, vertically, or both.
        """
        mono_hues: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgsDict']]
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        opacities: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgsDict']]
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        region_of_interest_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgsDict']]
        """
        Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
        """
        relative_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgsDict']]
        """
        Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
        """
        remove_colors: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgsDict']]
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        resizes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationResizeArgsDict']]
        """
        Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
        """
        rotates: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRotateArgsDict']]
        """
        Rotate the image around its center by indicating the degrees of rotation.
        """
        scales: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationScaleArgsDict']]
        """
        Changes the image's size to different dimensions relative to its starting size.
        """
        shears: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationShearsArgsDict']]
        """
        Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
        """
        smart_crops: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgsDict']]
        """
        Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
        """
        trims: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationTrimArgsDict']]
        """
        Automatically crops uniform backgrounds from the edges of an image.
        """
        unsharp_masks: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgsDict']]
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationArgs:
    def __init__(__self__, *,
                 appends: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendArgs']] = None,
                 aspect_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgs']] = None,
                 background_colors: Optional[Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgs']] = None,
                 blurs: Optional[Sequence['GetImagingPolicyImagePolicyTransformationBlurArgs']] = None,
                 chroma_keys: Optional[Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgs']] = None,
                 composites: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgs']] = None,
                 compounds: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompoundArgs']] = None,
                 contrasts: Optional[Sequence['GetImagingPolicyImagePolicyTransformationContrastArgs']] = None,
                 crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCropArgs']] = None,
                 face_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgs']] = None,
                 feature_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgs']] = None,
                 fit_and_fills: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgs']] = None,
                 goops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationGoopArgs']] = None,
                 grayscales: Optional[Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgs']] = None,
                 hsls: Optional[Sequence['GetImagingPolicyImagePolicyTransformationHslArgs']] = None,
                 hsvs: Optional[Sequence['GetImagingPolicyImagePolicyTransformationHsvArgs']] = None,
                 if_dimensions: Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfDimensionArgs']] = None,
                 if_orientations: Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfOrientationArgs']] = None,
                 im_queries: Optional[Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgs']] = None,
                 max_colors: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgs']] = None,
                 mirrors: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgs']] = None,
                 mono_hues: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgs']] = None,
                 opacities: Optional[Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgs']] = None,
                 region_of_interest_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs']] = None,
                 relative_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgs']] = None,
                 remove_colors: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgs']] = None,
                 resizes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationResizeArgs']] = None,
                 rotates: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRotateArgs']] = None,
                 scales: Optional[Sequence['GetImagingPolicyImagePolicyTransformationScaleArgs']] = None,
                 shears: Optional[Sequence['GetImagingPolicyImagePolicyTransformationShearsArgs']] = None,
                 smart_crops: Optional[Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgs']] = None,
                 trims: Optional[Sequence['GetImagingPolicyImagePolicyTransformationTrimArgs']] = None,
                 unsharp_masks: Optional[Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendArgs'] appends: Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgs'] aspect_crops: Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
        :param Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgs'] background_colors: Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        :param Sequence['GetImagingPolicyImagePolicyTransformationBlurArgs'] blurs: Applies a Gaussian blur to the image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgs'] chroma_keys: Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgs'] composites: Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        :param Sequence['GetImagingPolicyImagePolicyTransformationContrastArgs'] contrasts: Adjusts both the contrast and brightness of an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCropArgs'] crops: Crops an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgs'] face_crops: Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgs'] feature_crops: Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
        :param Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgs'] fit_and_fills: Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
        :param Sequence['GetImagingPolicyImagePolicyTransformationGoopArgs'] goops: Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        :param Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgs'] grayscales: Restricts image color to shades of gray only.
        :param Sequence['GetImagingPolicyImagePolicyTransformationHslArgs'] hsls: Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        :param Sequence['GetImagingPolicyImagePolicyTransformationHsvArgs'] hsvs: Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        :param Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgs'] im_queries: Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgs'] max_colors: Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgs'] mirrors: Flips an image horizontally, vertically, or both.
        :param Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgs'] mono_hues: Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        :param Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgs'] opacities: Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs'] region_of_interest_crops: Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgs'] relative_crops: Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgs'] remove_colors: Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        :param Sequence['GetImagingPolicyImagePolicyTransformationResizeArgs'] resizes: Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRotateArgs'] rotates: Rotate the image around its center by indicating the degrees of rotation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationScaleArgs'] scales: Changes the image's size to different dimensions relative to its starting size.
        :param Sequence['GetImagingPolicyImagePolicyTransformationShearsArgs'] shears: Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
        :param Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgs'] smart_crops: Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
        :param Sequence['GetImagingPolicyImagePolicyTransformationTrimArgs'] trims: Automatically crops uniform backgrounds from the edges of an image.
        :param Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs'] unsharp_masks: Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        if appends is not None:
            pulumi.set(__self__, "appends", appends)
        if aspect_crops is not None:
            pulumi.set(__self__, "aspect_crops", aspect_crops)
        if background_colors is not None:
            pulumi.set(__self__, "background_colors", background_colors)
        if blurs is not None:
            pulumi.set(__self__, "blurs", blurs)
        if chroma_keys is not None:
            pulumi.set(__self__, "chroma_keys", chroma_keys)
        if composites is not None:
            pulumi.set(__self__, "composites", composites)
        if compounds is not None:
            pulumi.set(__self__, "compounds", compounds)
        if contrasts is not None:
            pulumi.set(__self__, "contrasts", contrasts)
        if crops is not None:
            pulumi.set(__self__, "crops", crops)
        if face_crops is not None:
            pulumi.set(__self__, "face_crops", face_crops)
        if feature_crops is not None:
            pulumi.set(__self__, "feature_crops", feature_crops)
        if fit_and_fills is not None:
            pulumi.set(__self__, "fit_and_fills", fit_and_fills)
        if goops is not None:
            pulumi.set(__self__, "goops", goops)
        if grayscales is not None:
            pulumi.set(__self__, "grayscales", grayscales)
        if hsls is not None:
            pulumi.set(__self__, "hsls", hsls)
        if hsvs is not None:
            pulumi.set(__self__, "hsvs", hsvs)
        if if_dimensions is not None:
            pulumi.set(__self__, "if_dimensions", if_dimensions)
        if if_orientations is not None:
            pulumi.set(__self__, "if_orientations", if_orientations)
        if im_queries is not None:
            pulumi.set(__self__, "im_queries", im_queries)
        if max_colors is not None:
            pulumi.set(__self__, "max_colors", max_colors)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)
        if mono_hues is not None:
            pulumi.set(__self__, "mono_hues", mono_hues)
        if opacities is not None:
            pulumi.set(__self__, "opacities", opacities)
        if region_of_interest_crops is not None:
            pulumi.set(__self__, "region_of_interest_crops", region_of_interest_crops)
        if relative_crops is not None:
            pulumi.set(__self__, "relative_crops", relative_crops)
        if remove_colors is not None:
            pulumi.set(__self__, "remove_colors", remove_colors)
        if resizes is not None:
            pulumi.set(__self__, "resizes", resizes)
        if rotates is not None:
            pulumi.set(__self__, "rotates", rotates)
        if scales is not None:
            pulumi.set(__self__, "scales", scales)
        if shears is not None:
            pulumi.set(__self__, "shears", shears)
        if smart_crops is not None:
            pulumi.set(__self__, "smart_crops", smart_crops)
        if trims is not None:
            pulumi.set(__self__, "trims", trims)
        if unsharp_masks is not None:
            pulumi.set(__self__, "unsharp_masks", unsharp_masks)

    @_builtins.property
    @pulumi.getter
    def appends(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendArgs']]:
        """
        Places a specified `image` beside the source image. The API places the `image` on a major dimension, then aligns it on the minor dimension. Transparent pixels fill any area not covered by either image.
        """
        return pulumi.get(self, "appends")

    @appends.setter
    def appends(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendArgs']]):
        pulumi.set(self, "appends", value)

    @_builtins.property
    @pulumi.getter(name="aspectCrops")
    def aspect_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgs']]:
        """
        Lets you change the height or width of an image (either by cropping or expanding the area) to an aspect ratio of your choosing.
        """
        return pulumi.get(self, "aspect_crops")

    @aspect_crops.setter
    def aspect_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAspectCropArgs']]):
        pulumi.set(self, "aspect_crops", value)

    @_builtins.property
    @pulumi.getter(name="backgroundColors")
    def background_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgs']]:
        """
        Places a transparent image on a set background color. Color is specified in the typical CSS hexadecimal format.
        """
        return pulumi.get(self, "background_colors")

    @background_colors.setter
    def background_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationBackgroundColorArgs']]):
        pulumi.set(self, "background_colors", value)

    @_builtins.property
    @pulumi.getter
    def blurs(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationBlurArgs']]:
        """
        Applies a Gaussian blur to the image.
        """
        return pulumi.get(self, "blurs")

    @blurs.setter
    def blurs(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationBlurArgs']]):
        pulumi.set(self, "blurs", value)

    @_builtins.property
    @pulumi.getter(name="chromaKeys")
    def chroma_keys(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgs']]:
        """
        Changes any color in an image within the specified volume of the HSL colorspace to transparent or semitransparent. This transformation applies a 'green screen' technique commonly used to isolate and remove background colors.
        """
        return pulumi.get(self, "chroma_keys")

    @chroma_keys.setter
    def chroma_keys(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationChromaKeyArgs']]):
        pulumi.set(self, "chroma_keys", value)

    @_builtins.property
    @pulumi.getter
    def composites(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgs']]:
        """
        Applies another image to the source image, either as an overlay or an underlay. The image that's underneath is visible in areas that are beyond the edges of the top image or that are less than 100% opaque. A common use of an overlay composite is to add a watermark.
        """
        return pulumi.get(self, "composites")

    @composites.setter
    def composites(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeArgs']]):
        pulumi.set(self, "composites", value)

    @_builtins.property
    @pulumi.getter
    def compounds(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompoundArgs']]:
        return pulumi.get(self, "compounds")

    @compounds.setter
    def compounds(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompoundArgs']]):
        pulumi.set(self, "compounds", value)

    @_builtins.property
    @pulumi.getter
    def contrasts(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationContrastArgs']]:
        """
        Adjusts both the contrast and brightness of an image.
        """
        return pulumi.get(self, "contrasts")

    @contrasts.setter
    def contrasts(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationContrastArgs']]):
        pulumi.set(self, "contrasts", value)

    @_builtins.property
    @pulumi.getter
    def crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCropArgs']]:
        """
        Crops an image.
        """
        return pulumi.get(self, "crops")

    @crops.setter
    def crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCropArgs']]):
        pulumi.set(self, "crops", value)

    @_builtins.property
    @pulumi.getter(name="faceCrops")
    def face_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgs']]:
        """
        Applies a method to detect faces in the source image and applies the rectangular crop on either the `biggest` face or `all` of the faces detected. Image and Video Manager tries to preserve faces in the image instead of using specified crop coordinates.
        """
        return pulumi.get(self, "face_crops")

    @face_crops.setter
    def face_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFaceCropArgs']]):
        pulumi.set(self, "face_crops", value)

    @_builtins.property
    @pulumi.getter(name="featureCrops")
    def feature_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgs']]:
        """
        Identifies prominent features of the source image, then crops around as many of these features as possible relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "feature_crops")

    @feature_crops.setter
    def feature_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFeatureCropArgs']]):
        pulumi.set(self, "feature_crops", value)

    @_builtins.property
    @pulumi.getter(name="fitAndFills")
    def fit_and_fills(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgs']]:
        """
        Resizes an image to fit within a specific size box and then uses a fill of that same image to cover any transparent space at the edges. By default the fill image has a Blur transformation with a sigma value of 8 applied, but the transformation can be customized using the fillTransformation parameter.
        """
        return pulumi.get(self, "fit_and_fills")

    @fit_and_fills.setter
    def fit_and_fills(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationFitAndFillArgs']]):
        pulumi.set(self, "fit_and_fills", value)

    @_builtins.property
    @pulumi.getter
    def goops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationGoopArgs']]:
        """
        Distorts an image by randomly repositioning a set of control points along a specified grid. The transformed image appears _goopy_. Adjust the density of the grid and the degree of randomity. You can use this transformation to create watermarks for use in security.
        """
        return pulumi.get(self, "goops")

    @goops.setter
    def goops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationGoopArgs']]):
        pulumi.set(self, "goops", value)

    @_builtins.property
    @pulumi.getter
    def grayscales(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgs']]:
        """
        Restricts image color to shades of gray only.
        """
        return pulumi.get(self, "grayscales")

    @grayscales.setter
    def grayscales(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationGrayscaleArgs']]):
        pulumi.set(self, "grayscales", value)

    @_builtins.property
    @pulumi.getter
    def hsls(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationHslArgs']]:
        """
        Adjusts the hue, saturation, and lightness (HSL) of an image. Hue is the number of degrees that colors rotate around the color wheel. Saturation is a multiplier to increase or decrease color saturation. Lightness is a multiplier to increase or decrease the lightness of an image. Other transformations can also affect color, such as `Grayscale` and `MaxColors`. If youre using more than one, consider the order to apply them for the desired results.
        """
        return pulumi.get(self, "hsls")

    @hsls.setter
    def hsls(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationHslArgs']]):
        pulumi.set(self, "hsls", value)

    @_builtins.property
    @pulumi.getter
    def hsvs(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationHsvArgs']]:
        """
        Identical to HSL except it replaces `lightness` with `value`. For example, if you reduce the `lightness` of a light green, almost white, image, the color turns a vibrant green. Reducing the `value` turns the image a darker color, close to grey. This happens because the original image color is very close to white.
        """
        return pulumi.get(self, "hsvs")

    @hsvs.setter
    def hsvs(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationHsvArgs']]):
        pulumi.set(self, "hsvs", value)

    @_builtins.property
    @pulumi.getter(name="ifDimensions")
    def if_dimensions(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfDimensionArgs']]:
        return pulumi.get(self, "if_dimensions")

    @if_dimensions.setter
    def if_dimensions(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfDimensionArgs']]):
        pulumi.set(self, "if_dimensions", value)

    @_builtins.property
    @pulumi.getter(name="ifOrientations")
    def if_orientations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfOrientationArgs']]:
        return pulumi.get(self, "if_orientations")

    @if_orientations.setter
    def if_orientations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationIfOrientationArgs']]):
        pulumi.set(self, "if_orientations", value)

    @_builtins.property
    @pulumi.getter(name="imQueries")
    def im_queries(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgs']]:
        """
        Apply artistic transformations to images quickly and dynamically by specifying transformations with a query string appendedto the image URL.
        """
        return pulumi.get(self, "im_queries")

    @im_queries.setter
    def im_queries(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationImQueryArgs']]):
        pulumi.set(self, "im_queries", value)

    @_builtins.property
    @pulumi.getter(name="maxColors")
    def max_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgs']]:
        """
        Set the maximum number of colors in the images palette. Reducing the number of colors in an image can help to reduce file size.
        """
        return pulumi.get(self, "max_colors")

    @max_colors.setter
    def max_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMaxColorArgs']]):
        pulumi.set(self, "max_colors", value)

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgs']]:
        """
        Flips an image horizontally, vertically, or both.
        """
        return pulumi.get(self, "mirrors")

    @mirrors.setter
    def mirrors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMirrorArgs']]):
        pulumi.set(self, "mirrors", value)

    @_builtins.property
    @pulumi.getter(name="monoHues")
    def mono_hues(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgs']]:
        """
        Allows you to set all hues in an image to a single specified hue of your choosing. Mono Hue maintains the original colors lightness and saturation but sets the hue to that of the specified value. This has the effect of making the image shades of the specified hue.
        """
        return pulumi.get(self, "mono_hues")

    @mono_hues.setter
    def mono_hues(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationMonoHueArgs']]):
        pulumi.set(self, "mono_hues", value)

    @_builtins.property
    @pulumi.getter
    def opacities(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgs']]:
        """
        Adjusts the level of transparency of an image. Use this transformation to make an image more or less transparent.
        """
        return pulumi.get(self, "opacities")

    @opacities.setter
    def opacities(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationOpacityArgs']]):
        pulumi.set(self, "opacities", value)

    @_builtins.property
    @pulumi.getter(name="regionOfInterestCrops")
    def region_of_interest_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs']]:
        """
        Crops to a region around a specified area of interest relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "region_of_interest_crops")

    @region_of_interest_crops.setter
    def region_of_interest_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs']]):
        pulumi.set(self, "region_of_interest_crops", value)

    @_builtins.property
    @pulumi.getter(name="relativeCrops")
    def relative_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgs']]:
        """
        Shrinks or expands an image relative to the image's specified dimensions. Image and Video Manager fills the expanded areas with transparency. Positive values shrink the side, while negative values expand it.
        """
        return pulumi.get(self, "relative_crops")

    @relative_crops.setter
    def relative_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRelativeCropArgs']]):
        pulumi.set(self, "relative_crops", value)

    @_builtins.property
    @pulumi.getter(name="removeColors")
    def remove_colors(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgs']]:
        """
        Removes a specified color from an image and replaces it with transparent pixels. This transformation is ideal for removing solid background colors from product images photographed on clean, consistent backgrounds without any shadows.
        """
        return pulumi.get(self, "remove_colors")

    @remove_colors.setter
    def remove_colors(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRemoveColorArgs']]):
        pulumi.set(self, "remove_colors", value)

    @_builtins.property
    @pulumi.getter
    def resizes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationResizeArgs']]:
        """
        Resizes an image to a particular, absolute dimension. If you don't enter a `width` or a `height`, the image is resized with the `fit` aspect preservation mode, which selects a value for the missing dimension that preserves the image's aspect.
        """
        return pulumi.get(self, "resizes")

    @resizes.setter
    def resizes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationResizeArgs']]):
        pulumi.set(self, "resizes", value)

    @_builtins.property
    @pulumi.getter
    def rotates(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRotateArgs']]:
        """
        Rotate the image around its center by indicating the degrees of rotation.
        """
        return pulumi.get(self, "rotates")

    @rotates.setter
    def rotates(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRotateArgs']]):
        pulumi.set(self, "rotates", value)

    @_builtins.property
    @pulumi.getter
    def scales(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationScaleArgs']]:
        """
        Changes the image's size to different dimensions relative to its starting size.
        """
        return pulumi.get(self, "scales")

    @scales.setter
    def scales(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationScaleArgs']]):
        pulumi.set(self, "scales", value)

    @_builtins.property
    @pulumi.getter
    def shears(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationShearsArgs']]:
        """
        Slants an image into a parallelogram, as a percent of the starting dimension as represented in decimal format. You need to specify at least one axis property. Transparent pixels fill empty areas around the sheared image as needed, so it's often useful to use a `BackgroundColor` transformation for these areas.
        """
        return pulumi.get(self, "shears")

    @shears.setter
    def shears(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationShearsArgs']]):
        pulumi.set(self, "shears", value)

    @_builtins.property
    @pulumi.getter(name="smartCrops")
    def smart_crops(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgs']]:
        """
        Crops around whatever is most important in the image, to a region around a specified area of interest relative to the specified `width` and `height` values. The crop detects any faces present, otherwise features.
        """
        return pulumi.get(self, "smart_crops")

    @smart_crops.setter
    def smart_crops(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationSmartCropArgs']]):
        pulumi.set(self, "smart_crops", value)

    @_builtins.property
    @pulumi.getter
    def trims(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationTrimArgs']]:
        """
        Automatically crops uniform backgrounds from the edges of an image.
        """
        return pulumi.get(self, "trims")

    @trims.setter
    def trims(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationTrimArgs']]):
        pulumi.set(self, "trims", value)

    @_builtins.property
    @pulumi.getter(name="unsharpMasks")
    def unsharp_masks(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs']]:
        """
        Emphasizes edges and details in source images without distorting the colors. Although this effect is often referred to as _sharpening_ an image, it actually creates a blurred, inverted copy of the image known as an unsharp mask. Image and Video Manager combines the unsharp mask with the source image to create an image perceived as clearer.
        """
        return pulumi.get(self, "unsharp_masks")

    @unsharp_masks.setter
    def unsharp_masks(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs']]):
        pulumi.set(self, "unsharp_masks", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendArgsDict(TypedDict):
        image: 'GetImagingPolicyImagePolicyTransformationAppendImageArgsDict'
        gravity: NotRequired[_builtins.str]
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        gravity_priority: NotRequired[_builtins.str]
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        gravity_priority_var: NotRequired[_builtins.str]
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        preserve_minor_dimension: NotRequired[_builtins.str]
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        preserve_minor_dimension_var: NotRequired[_builtins.str]
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendArgs:
    def __init__(__self__, *,
                 image: 'GetImagingPolicyImagePolicyTransformationAppendImageArgs',
                 gravity: Optional[_builtins.str] = None,
                 gravity_priority: Optional[_builtins.str] = None,
                 gravity_priority_var: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 preserve_minor_dimension: Optional[_builtins.str] = None,
                 preserve_minor_dimension_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        :param _builtins.str gravity_priority: Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        :param _builtins.str gravity_priority_var: Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        :param _builtins.str gravity_var: Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        :param _builtins.str preserve_minor_dimension: Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        :param _builtins.str preserve_minor_dimension_var: Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_priority is not None:
            pulumi.set(__self__, "gravity_priority", gravity_priority)
        if gravity_priority_var is not None:
            pulumi.set(__self__, "gravity_priority_var", gravity_priority_var)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if preserve_minor_dimension is not None:
            pulumi.set(__self__, "preserve_minor_dimension", preserve_minor_dimension)
        if preserve_minor_dimension_var is not None:
            pulumi.set(__self__, "preserve_minor_dimension_var", preserve_minor_dimension_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'GetImagingPolicyImagePolicyTransformationAppendImageArgs':
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: 'GetImagingPolicyImagePolicyTransformationAppendImageArgs'):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityPriority")
    def gravity_priority(self) -> Optional[_builtins.str]:
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        return pulumi.get(self, "gravity_priority")

    @gravity_priority.setter
    def gravity_priority(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_priority", value)

    @_builtins.property
    @pulumi.getter(name="gravityPriorityVar")
    def gravity_priority_var(self) -> Optional[_builtins.str]:
        """
        Determines the exact placement of the `image` when `gravity` is `Center` or a diagonal. The value is either `horizontal` or `vertical`. Use `horizontal` to append an `image` east or west of the source image. This aligns the `image` on the vertical gravity component, placing `Center` gravity east. Use `vertical` to append an `image` north or south of the source image. This aligns the `image` on the horizontal gravity component, placing `Center` gravity south.
        """
        return pulumi.get(self, "gravity_priority_var")

    @gravity_priority_var.setter
    def gravity_priority_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_priority_var", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Specifies where to place the `image` relative to the source image. The available values represent the eight cardinal directions (`North`, `South`, `East`, `West`, `NorthEast`, `NorthWest`, `SouthEast`, `SouthWest`) and a `Center` by default.
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter(name="preserveMinorDimension")
    def preserve_minor_dimension(self) -> Optional[_builtins.str]:
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        return pulumi.get(self, "preserve_minor_dimension")

    @preserve_minor_dimension.setter
    def preserve_minor_dimension(self, value: Optional[_builtins.str]):
        pulumi.set(self, "preserve_minor_dimension", value)

    @_builtins.property
    @pulumi.getter(name="preserveMinorDimensionVar")
    def preserve_minor_dimension_var(self) -> Optional[_builtins.str]:
        """
        Whether to preserve the source image's minor dimension, `false` by default. The minor dimension is the dimension opposite the dimension that the appending `image` is placed. For example, the dimensions of the source image are 100 &times; 100 pixels. The dimensions of the appending `image` are 50 &times; 150 pixels. The `gravity` is set to `East`. This makes the major dimension horizontal and the source image's minor dimension vertical. To preserve the source image's minor dimension at 100 pixels, the `preserveMinorDimension` is set to `true`. As a result of the append, the major dimension expanded with the appended image to 150 pixels. The source image's minor dimension was maintained at 100 pixels. The total combined dimension of the image is 150 &times; 100 pixels.
        """
        return pulumi.get(self, "preserve_minor_dimension_var")

    @preserve_minor_dimension_var.setter
    def preserve_minor_dimension_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "preserve_minor_dimension_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendImageArgsDict(TypedDict):
        box_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        circle_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        text_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgsDict']]
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        url_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgsDict']]
        """
        An image loaded from a URL.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendImageArgs:
    def __init__(__self__, *,
                 box_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs']] = None,
                 circle_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs']] = None,
                 text_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs']] = None,
                 url_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @box_images.setter
    def box_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs']]):
        pulumi.set(self, "box_images", value)

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @circle_images.setter
    def circle_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs']]):
        pulumi.set(self, "circle_images", value)

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @text_images.setter
    def text_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs']]):
        pulumi.set(self, "text_images", value)

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")

    @url_images.setter
    def url_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs']]):
        pulumi.set(self, "url_images", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        height: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendImageBoxImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        diameter: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        diameter_var: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendImageCircleImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @diameter.setter
    def diameter(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter", value)

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @diameter_var.setter
    def diameter_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgsDict(TypedDict):
        fill: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        fill_var: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        size: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        size_var: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        stroke: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        stroke_size: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_size_var: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_var: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        text: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        text_var: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        typeface: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        typeface_var: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendImageTextImageArgs:
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @fill.setter
    def fill(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill", value)

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @fill_var.setter
    def fill_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill_var", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @size_var.setter
    def size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size_var", value)

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @stroke.setter
    def stroke(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke", value)

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @stroke_size.setter
    def stroke_size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size", value)

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @stroke_size_var.setter
    def stroke_size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size_var", value)

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @stroke_var.setter
    def stroke_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_var", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @text_var.setter
    def text_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @typeface.setter
    def typeface(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface", value)

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")

    @typeface_var.setter
    def typeface_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgsDict(TypedDict):
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        url: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
        url_var: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAppendImageUrlImageArgs:
    def __init__(__self__, *,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")

    @url_var.setter
    def url_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationAspectCropArgsDict(TypedDict):
        allow_expansion: NotRequired[_builtins.str]
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        allow_expansion_var: NotRequired[_builtins.str]
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        height: NotRequired[_builtins.str]
        """
        The height term of the aspect ratio to crop.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height term of the aspect ratio to crop.
        """
        width: NotRequired[_builtins.str]
        """
        The width term of the aspect ratio to crop.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width term of the aspect ratio to crop.
        """
        x_position: NotRequired[_builtins.str]
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        x_position_var: NotRequired[_builtins.str]
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        y_position: NotRequired[_builtins.str]
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        y_position_var: NotRequired[_builtins.str]
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationAspectCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationAspectCropArgs:
    def __init__(__self__, *,
                 allow_expansion: Optional[_builtins.str] = None,
                 allow_expansion_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_expansion: Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        :param _builtins.str allow_expansion_var: Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        :param _builtins.str height: The height term of the aspect ratio to crop.
        :param _builtins.str height_var: The height term of the aspect ratio to crop.
        :param _builtins.str width: The width term of the aspect ratio to crop.
        :param _builtins.str width_var: The width term of the aspect ratio to crop.
        :param _builtins.str x_position: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str x_position_var: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str y_position: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        :param _builtins.str y_position_var: Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        if allow_expansion is not None:
            pulumi.set(__self__, "allow_expansion", allow_expansion)
        if allow_expansion_var is not None:
            pulumi.set(__self__, "allow_expansion_var", allow_expansion_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter(name="allowExpansion")
    def allow_expansion(self) -> Optional[_builtins.str]:
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        return pulumi.get(self, "allow_expansion")

    @allow_expansion.setter
    def allow_expansion(self, value: Optional[_builtins.str]):
        pulumi.set(self, "allow_expansion", value)

    @_builtins.property
    @pulumi.getter(name="allowExpansionVar")
    def allow_expansion_var(self) -> Optional[_builtins.str]:
        """
        Increases the size of the image canvas to achieve the requested aspect ratio instead of cropping the image. Use the Horizontal Offset and Vertical Offset settings to determine where to add the fully transparent pixels on the expanded image canvas.
        """
        return pulumi.get(self, "allow_expansion_var")

    @allow_expansion_var.setter
    def allow_expansion_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "allow_expansion_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height term of the aspect ratio to crop.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height term of the aspect ratio to crop.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width term of the aspect ratio to crop.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width term of the aspect ratio to crop.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position", value)

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "x_position_var")

    @x_position_var.setter
    def x_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position_var", value)

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position", value)

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        Specifies the horizontal portion of the image you want to keep when the aspect ratio cropping is applied. When using Allow Expansion this setting defines the horizontal position of the image on the new expanded image canvas.
        """
        return pulumi.get(self, "y_position_var")

    @y_position_var.setter
    def y_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationBackgroundColorArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value for the background.
        """
        color_var: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value for the background.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationBackgroundColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationBackgroundColorArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value for the background.
        :param _builtins.str color_var: The hexadecimal CSS color value for the background.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value for the background.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationBlurArgsDict(TypedDict):
        sigma: NotRequired[_builtins.str]
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        sigma_var: NotRequired[_builtins.str]
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationBlurArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationBlurArgs:
    def __init__(__self__, *,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str sigma: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        :param _builtins.str sigma_var: The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma")

    @sigma.setter
    def sigma(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma", value)

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
        """
        return pulumi.get(self, "sigma_var")

    @sigma_var.setter
    def sigma_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationChromaKeyArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        hue_feather: NotRequired[_builtins.str]
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        hue_feather_var: NotRequired[_builtins.str]
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        hue_tolerance: NotRequired[_builtins.str]
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        hue_tolerance_var: NotRequired[_builtins.str]
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        lightness_feather: NotRequired[_builtins.str]
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        lightness_feather_var: NotRequired[_builtins.str]
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        lightness_tolerance: NotRequired[_builtins.str]
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        lightness_tolerance_var: NotRequired[_builtins.str]
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        saturation_feather: NotRequired[_builtins.str]
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        saturation_feather_var: NotRequired[_builtins.str]
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        saturation_tolerance: NotRequired[_builtins.str]
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        saturation_tolerance_var: NotRequired[_builtins.str]
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationChromaKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationChromaKeyArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_feather: Optional[_builtins.str] = None,
                 hue_feather_var: Optional[_builtins.str] = None,
                 hue_tolerance: Optional[_builtins.str] = None,
                 hue_tolerance_var: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness_feather: Optional[_builtins.str] = None,
                 lightness_feather_var: Optional[_builtins.str] = None,
                 lightness_tolerance: Optional[_builtins.str] = None,
                 lightness_tolerance_var: Optional[_builtins.str] = None,
                 saturation_feather: Optional[_builtins.str] = None,
                 saturation_feather_var: Optional[_builtins.str] = None,
                 saturation_tolerance: Optional[_builtins.str] = None,
                 saturation_tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        :param _builtins.str hue_feather: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        :param _builtins.str hue_feather_var: How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        :param _builtins.str hue_tolerance: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        :param _builtins.str hue_tolerance_var: How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        :param _builtins.str hue_var: The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        :param _builtins.str lightness_feather: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_feather_var: How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        :param _builtins.str lightness_tolerance: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str lightness_tolerance_var: How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        :param _builtins.str saturation_feather: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_feather_var: How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        :param _builtins.str saturation_tolerance: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        :param _builtins.str saturation_tolerance_var: How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_feather is not None:
            pulumi.set(__self__, "hue_feather", hue_feather)
        if hue_feather_var is not None:
            pulumi.set(__self__, "hue_feather_var", hue_feather_var)
        if hue_tolerance is not None:
            pulumi.set(__self__, "hue_tolerance", hue_tolerance)
        if hue_tolerance_var is not None:
            pulumi.set(__self__, "hue_tolerance_var", hue_tolerance_var)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness_feather is not None:
            pulumi.set(__self__, "lightness_feather", lightness_feather)
        if lightness_feather_var is not None:
            pulumi.set(__self__, "lightness_feather_var", lightness_feather_var)
        if lightness_tolerance is not None:
            pulumi.set(__self__, "lightness_tolerance", lightness_tolerance)
        if lightness_tolerance_var is not None:
            pulumi.set(__self__, "lightness_tolerance_var", lightness_tolerance_var)
        if saturation_feather is not None:
            pulumi.set(__self__, "saturation_feather", saturation_feather)
        if saturation_feather_var is not None:
            pulumi.set(__self__, "saturation_feather_var", saturation_feather_var)
        if saturation_tolerance is not None:
            pulumi.set(__self__, "saturation_tolerance", saturation_tolerance)
        if saturation_tolerance_var is not None:
            pulumi.set(__self__, "saturation_tolerance_var", saturation_tolerance_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueFeather")
    def hue_feather(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather")

    @hue_feather.setter
    def hue_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_feather", value)

    @_builtins.property
    @pulumi.getter(name="hueFeatherVar")
    def hue_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30 around the Hue Tolerance.
        """
        return pulumi.get(self, "hue_feather_var")

    @hue_feather_var.setter
    def hue_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="hueTolerance")
    def hue_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance")

    @hue_tolerance.setter
    def hue_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="hueToleranceVar")
    def hue_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30 around the specified hue.
        """
        return pulumi.get(self, "hue_tolerance_var")

    @hue_tolerance_var.setter
    def hue_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_tolerance_var", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120 on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter(name="lightnessFeather")
    def lightness_feather(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather")

    @lightness_feather.setter
    def lightness_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_feather", value)

    @_builtins.property
    @pulumi.getter(name="lightnessFeatherVar")
    def lightness_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
        """
        return pulumi.get(self, "lightness_feather_var")

    @lightness_feather_var.setter
    def lightness_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="lightnessTolerance")
    def lightness_tolerance(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance")

    @lightness_tolerance.setter
    def lightness_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="lightnessToleranceVar")
    def lightness_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
        """
        return pulumi.get(self, "lightness_tolerance_var")

    @lightness_tolerance_var.setter
    def lightness_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_tolerance_var", value)

    @_builtins.property
    @pulumi.getter(name="saturationFeather")
    def saturation_feather(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather")

    @saturation_feather.setter
    def saturation_feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_feather", value)

    @_builtins.property
    @pulumi.getter(name="saturationFeatherVar")
    def saturation_feather_var(self) -> Optional[_builtins.str]:
        """
        How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
        """
        return pulumi.get(self, "saturation_feather_var")

    @saturation_feather_var.setter
    def saturation_feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_feather_var", value)

    @_builtins.property
    @pulumi.getter(name="saturationTolerance")
    def saturation_tolerance(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance")

    @saturation_tolerance.setter
    def saturation_tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_tolerance", value)

    @_builtins.property
    @pulumi.getter(name="saturationToleranceVar")
    def saturation_tolerance_var(self) -> Optional[_builtins.str]:
        """
        How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
        """
        return pulumi.get(self, "saturation_tolerance_var")

    @saturation_tolerance_var.setter
    def saturation_tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_tolerance_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeArgsDict(TypedDict):
        image: 'GetImagingPolicyImagePolicyTransformationCompositeImageArgsDict'
        gravity: NotRequired[_builtins.str]
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        placement: NotRequired[_builtins.str]
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        placement_var: NotRequired[_builtins.str]
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        scale: NotRequired[_builtins.str]
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        scale_dimension: NotRequired[_builtins.str]
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        scale_dimension_var: NotRequired[_builtins.str]
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        scale_var: NotRequired[_builtins.str]
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        x_position: NotRequired[_builtins.str]
        """
        The x-axis position of the image to apply.
        """
        x_position_var: NotRequired[_builtins.str]
        """
        The x-axis position of the image to apply.
        """
        y_position: NotRequired[_builtins.str]
        """
        The y-axis position of the image to apply.
        """
        y_position_var: NotRequired[_builtins.str]
        """
        The y-axis position of the image to apply.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeArgs:
    def __init__(__self__, *,
                 image: 'GetImagingPolicyImagePolicyTransformationCompositeImageArgs',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 placement: Optional[_builtins.str] = None,
                 placement_var: Optional[_builtins.str] = None,
                 scale: Optional[_builtins.str] = None,
                 scale_dimension: Optional[_builtins.str] = None,
                 scale_dimension_var: Optional[_builtins.str] = None,
                 scale_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str gravity_var: Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        :param _builtins.str placement: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str placement_var: Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        :param _builtins.str scale: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str scale_dimension: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_dimension_var: The dimension, either `width` or `height`, of the source image to scale.
        :param _builtins.str scale_var: A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        :param _builtins.str x_position: The x-axis position of the image to apply.
        :param _builtins.str x_position_var: The x-axis position of the image to apply.
        :param _builtins.str y_position: The y-axis position of the image to apply.
        :param _builtins.str y_position_var: The y-axis position of the image to apply.
        """
        pulumi.set(__self__, "image", image)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if placement_var is not None:
            pulumi.set(__self__, "placement_var", placement_var)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if scale_dimension is not None:
            pulumi.set(__self__, "scale_dimension", scale_dimension)
        if scale_dimension_var is not None:
            pulumi.set(__self__, "scale_dimension_var", scale_dimension_var)
        if scale_var is not None:
            pulumi.set(__self__, "scale_var", scale_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'GetImagingPolicyImagePolicyTransformationCompositeImageArgs':
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: 'GetImagingPolicyImagePolicyTransformationCompositeImageArgs'):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="placementVar")
    def placement_var(self) -> Optional[_builtins.str]:
        """
        Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
        """
        return pulumi.get(self, "placement_var")

    @placement_var.setter
    def placement_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placement_var", value)

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale", value)

    @_builtins.property
    @pulumi.getter(name="scaleDimension")
    def scale_dimension(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension")

    @scale_dimension.setter
    def scale_dimension(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_dimension", value)

    @_builtins.property
    @pulumi.getter(name="scaleDimensionVar")
    def scale_dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension, either `width` or `height`, of the source image to scale.
        """
        return pulumi.get(self, "scale_dimension_var")

    @scale_dimension_var.setter
    def scale_dimension_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_dimension_var", value)

    @_builtins.property
    @pulumi.getter(name="scaleVar")
    def scale_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
        """
        return pulumi.get(self, "scale_var")

    @scale_var.setter
    def scale_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_var", value)

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position", value)

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to apply.
        """
        return pulumi.get(self, "x_position_var")

    @x_position_var.setter
    def x_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position_var", value)

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position", value)

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to apply.
        """
        return pulumi.get(self, "y_position_var")

    @y_position_var.setter
    def y_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeImageArgsDict(TypedDict):
        box_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        circle_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgsDict']]
        """
        A rectangular box, with a specified color and applied transformation.
        """
        text_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgsDict']]
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        url_images: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgsDict']]
        """
        An image loaded from a URL.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeImageArgs:
    def __init__(__self__, *,
                 box_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs']] = None,
                 circle_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs']] = None,
                 text_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs']] = None,
                 url_images: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs'] box_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs'] circle_images: A rectangular box, with a specified color and applied transformation.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs'] text_images: A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        :param Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs'] url_images: An image loaded from a URL.
        """
        if box_images is not None:
            pulumi.set(__self__, "box_images", box_images)
        if circle_images is not None:
            pulumi.set(__self__, "circle_images", circle_images)
        if text_images is not None:
            pulumi.set(__self__, "text_images", text_images)
        if url_images is not None:
            pulumi.set(__self__, "url_images", url_images)

    @_builtins.property
    @pulumi.getter(name="boxImages")
    def box_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "box_images")

    @box_images.setter
    def box_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs']]):
        pulumi.set(self, "box_images", value)

    @_builtins.property
    @pulumi.getter(name="circleImages")
    def circle_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs']]:
        """
        A rectangular box, with a specified color and applied transformation.
        """
        return pulumi.get(self, "circle_images")

    @circle_images.setter
    def circle_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs']]):
        pulumi.set(self, "circle_images", value)

    @_builtins.property
    @pulumi.getter(name="textImages")
    def text_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs']]:
        """
        A snippet of text. Defines font family and size, fill color, and outline stroke width and color.
        """
        return pulumi.get(self, "text_images")

    @text_images.setter
    def text_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs']]):
        pulumi.set(self, "text_images", value)

    @_builtins.property
    @pulumi.getter(name="urlImages")
    def url_images(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs']]:
        """
        An image loaded from a URL.
        """
        return pulumi.get(self, "url_images")

    @url_images.setter
    def url_images(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs']]):
        pulumi.set(self, "url_images", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        height: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height of the box in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeImageBoxImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str height: The height of the box in pixels.
        :param _builtins.str height_var: The height of the box in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the box in pixels.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        color_var: NotRequired[_builtins.str]
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        diameter: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        diameter_var: NotRequired[_builtins.str]
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        width: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the box in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeImageCircleImageArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 diameter: Optional[_builtins.str] = None,
                 diameter_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str color_var: The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        :param _builtins.str diameter: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str diameter_var: The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        :param _builtins.str width: The width of the box in pixels.
        :param _builtins.str width_var: The width of the box in pixels.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if diameter is not None:
            pulumi.set(__self__, "diameter", diameter)
        if diameter_var is not None:
            pulumi.set(__self__, "diameter_var", diameter_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def diameter(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter")

    @diameter.setter
    def diameter(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter", value)

    @_builtins.property
    @pulumi.getter(name="diameterVar")
    def diameter_var(self) -> Optional[_builtins.str]:
        """
        The diameter of the circle. The diameter will be the width and the height of the image in pixels.
        """
        return pulumi.get(self, "diameter_var")

    @diameter_var.setter
    def diameter_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "diameter_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the box in pixels.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgsDict(TypedDict):
        fill: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        fill_var: NotRequired[_builtins.str]
        """
        The main fill color of the text.
        """
        size: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        size_var: NotRequired[_builtins.str]
        """
        The size in pixels to render the text.
        """
        stroke: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        stroke_size: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_size_var: NotRequired[_builtins.str]
        """
        The thickness in points for the outline of the text.
        """
        stroke_var: NotRequired[_builtins.str]
        """
        The color for the outline of the text.
        """
        text: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        text_var: NotRequired[_builtins.str]
        """
        The line of text to render.
        """
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        typeface: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        typeface_var: NotRequired[_builtins.str]
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeImageTextImageArgs:
    def __init__(__self__, *,
                 fill: Optional[_builtins.str] = None,
                 fill_var: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 size_var: Optional[_builtins.str] = None,
                 stroke: Optional[_builtins.str] = None,
                 stroke_size: Optional[_builtins.str] = None,
                 stroke_size_var: Optional[_builtins.str] = None,
                 stroke_var: Optional[_builtins.str] = None,
                 text: Optional[_builtins.str] = None,
                 text_var: Optional[_builtins.str] = None,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 typeface: Optional[_builtins.str] = None,
                 typeface_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fill: The main fill color of the text.
        :param _builtins.str fill_var: The main fill color of the text.
        :param _builtins.str size: The size in pixels to render the text.
        :param _builtins.str size_var: The size in pixels to render the text.
        :param _builtins.str stroke: The color for the outline of the text.
        :param _builtins.str stroke_size: The thickness in points for the outline of the text.
        :param _builtins.str stroke_size_var: The thickness in points for the outline of the text.
        :param _builtins.str stroke_var: The color for the outline of the text.
        :param _builtins.str text: The line of text to render.
        :param _builtins.str text_var: The line of text to render.
        :param _builtins.str typeface: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        :param _builtins.str typeface_var: The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        if fill is not None:
            pulumi.set(__self__, "fill", fill)
        if fill_var is not None:
            pulumi.set(__self__, "fill_var", fill_var)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_var is not None:
            pulumi.set(__self__, "size_var", size_var)
        if stroke is not None:
            pulumi.set(__self__, "stroke", stroke)
        if stroke_size is not None:
            pulumi.set(__self__, "stroke_size", stroke_size)
        if stroke_size_var is not None:
            pulumi.set(__self__, "stroke_size_var", stroke_size_var)
        if stroke_var is not None:
            pulumi.set(__self__, "stroke_var", stroke_var)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_var is not None:
            pulumi.set(__self__, "text_var", text_var)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if typeface is not None:
            pulumi.set(__self__, "typeface", typeface)
        if typeface_var is not None:
            pulumi.set(__self__, "typeface_var", typeface_var)

    @_builtins.property
    @pulumi.getter
    def fill(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill")

    @fill.setter
    def fill(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill", value)

    @_builtins.property
    @pulumi.getter(name="fillVar")
    def fill_var(self) -> Optional[_builtins.str]:
        """
        The main fill color of the text.
        """
        return pulumi.get(self, "fill_var")

    @fill_var.setter
    def fill_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fill_var", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sizeVar")
    def size_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels to render the text.
        """
        return pulumi.get(self, "size_var")

    @size_var.setter
    def size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size_var", value)

    @_builtins.property
    @pulumi.getter
    def stroke(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke")

    @stroke.setter
    def stroke(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke", value)

    @_builtins.property
    @pulumi.getter(name="strokeSize")
    def stroke_size(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size")

    @stroke_size.setter
    def stroke_size(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size", value)

    @_builtins.property
    @pulumi.getter(name="strokeSizeVar")
    def stroke_size_var(self) -> Optional[_builtins.str]:
        """
        The thickness in points for the outline of the text.
        """
        return pulumi.get(self, "stroke_size_var")

    @stroke_size_var.setter
    def stroke_size_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_size_var", value)

    @_builtins.property
    @pulumi.getter(name="strokeVar")
    def stroke_var(self) -> Optional[_builtins.str]:
        """
        The color for the outline of the text.
        """
        return pulumi.get(self, "stroke_var")

    @stroke_var.setter
    def stroke_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "stroke_var", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textVar")
    def text_var(self) -> Optional[_builtins.str]:
        """
        The line of text to render.
        """
        return pulumi.get(self, "text_var")

    @text_var.setter
    def text_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "text_var", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def typeface(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface")

    @typeface.setter
    def typeface(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface", value)

    @_builtins.property
    @pulumi.getter(name="typefaceVar")
    def typeface_var(self) -> Optional[_builtins.str]:
        """
        The font family to apply to the text image. This may be a URL to a TrueType or WOFF (v1) typeface, or a string that refers to one of the standard built-in browser fonts.
        """
        return pulumi.get(self, "typeface_var")

    @typeface_var.setter
    def typeface_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "typeface_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgsDict(TypedDict):
        transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        url: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
        url_var: NotRequired[_builtins.str]
        """
        The URL of the image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompositeImageUrlImageArgs:
    def __init__(__self__, *,
                 transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 url: Optional[_builtins.str] = None,
                 url_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: The URL of the image.
        :param _builtins.str url_var: The URL of the image.
        """
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_var is not None:
            pulumi.set(__self__, "url_var", url_var)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "transformation", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="urlVar")
    def url_var(self) -> Optional[_builtins.str]:
        """
        The URL of the image.
        """
        return pulumi.get(self, "url_var")

    @url_var.setter
    def url_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCompoundArgsDict(TypedDict):
        transformations: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationArgsDict']]
elif False:
    GetImagingPolicyImagePolicyTransformationCompoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCompoundArgs:
    def __init__(__self__, *,
                 transformations: Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']] = None):
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']]:
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationArgs']]):
        pulumi.set(self, "transformations", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationContrastArgsDict(TypedDict):
        brightness: NotRequired[_builtins.str]
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        brightness_var: NotRequired[_builtins.str]
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        contrast: NotRequired[_builtins.str]
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        contrast_var: NotRequired[_builtins.str]
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationContrastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationContrastArgs:
    def __init__(__self__, *,
                 brightness: Optional[_builtins.str] = None,
                 brightness_var: Optional[_builtins.str] = None,
                 contrast: Optional[_builtins.str] = None,
                 contrast_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str brightness: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str brightness_var: Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        :param _builtins.str contrast: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        :param _builtins.str contrast_var: Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if brightness_var is not None:
            pulumi.set(__self__, "brightness_var", brightness_var)
        if contrast is not None:
            pulumi.set(__self__, "contrast", contrast)
        if contrast_var is not None:
            pulumi.set(__self__, "contrast_var", contrast_var)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness")

    @brightness.setter
    def brightness(self, value: Optional[_builtins.str]):
        pulumi.set(self, "brightness", value)

    @_builtins.property
    @pulumi.getter(name="brightnessVar")
    def brightness_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
        """
        return pulumi.get(self, "brightness_var")

    @brightness_var.setter
    def brightness_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "brightness_var", value)

    @_builtins.property
    @pulumi.getter
    def contrast(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast")

    @contrast.setter
    def contrast(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contrast", value)

    @_builtins.property
    @pulumi.getter(name="contrastVar")
    def contrast_var(self) -> Optional[_builtins.str]:
        """
        Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
        """
        return pulumi.get(self, "contrast_var")

    @contrast_var.setter
    def contrast_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contrast_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationCropArgsDict(TypedDict):
        allow_expansion: NotRequired[_builtins.str]
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        allow_expansion_var: NotRequired[_builtins.str]
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        gravity: NotRequired[_builtins.str]
        """
        Frame of reference for X and Y Positions.
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Frame of reference for X and Y Positions.
        """
        height: NotRequired[_builtins.str]
        """
        The number of pixels to crop along the y-axis.
        """
        height_var: NotRequired[_builtins.str]
        """
        The number of pixels to crop along the y-axis.
        """
        width: NotRequired[_builtins.str]
        """
        The number of pixels to crop along the x-axis.
        """
        width_var: NotRequired[_builtins.str]
        """
        The number of pixels to crop along the x-axis.
        """
        x_position: NotRequired[_builtins.str]
        """
        The x-axis position of the image to crop from.
        """
        x_position_var: NotRequired[_builtins.str]
        """
        The x-axis position of the image to crop from.
        """
        y_position: NotRequired[_builtins.str]
        """
        The y-axis position of the image to crop from.
        """
        y_position_var: NotRequired[_builtins.str]
        """
        The y-axis position of the image to crop from.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationCropArgs:
    def __init__(__self__, *,
                 allow_expansion: Optional[_builtins.str] = None,
                 allow_expansion_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None,
                 x_position: Optional[_builtins.str] = None,
                 x_position_var: Optional[_builtins.str] = None,
                 y_position: Optional[_builtins.str] = None,
                 y_position_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str allow_expansion: If cropping an area outside of the existing canvas, expands the image canvas.
        :param _builtins.str allow_expansion_var: If cropping an area outside of the existing canvas, expands the image canvas.
        :param _builtins.str gravity: Frame of reference for X and Y Positions.
        :param _builtins.str gravity_var: Frame of reference for X and Y Positions.
        :param _builtins.str height: The number of pixels to crop along the y-axis.
        :param _builtins.str height_var: The number of pixels to crop along the y-axis.
        :param _builtins.str width: The number of pixels to crop along the x-axis.
        :param _builtins.str width_var: The number of pixels to crop along the x-axis.
        :param _builtins.str x_position: The x-axis position of the image to crop from.
        :param _builtins.str x_position_var: The x-axis position of the image to crop from.
        :param _builtins.str y_position: The y-axis position of the image to crop from.
        :param _builtins.str y_position_var: The y-axis position of the image to crop from.
        """
        if allow_expansion is not None:
            pulumi.set(__self__, "allow_expansion", allow_expansion)
        if allow_expansion_var is not None:
            pulumi.set(__self__, "allow_expansion_var", allow_expansion_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)
        if x_position is not None:
            pulumi.set(__self__, "x_position", x_position)
        if x_position_var is not None:
            pulumi.set(__self__, "x_position_var", x_position_var)
        if y_position is not None:
            pulumi.set(__self__, "y_position", y_position)
        if y_position_var is not None:
            pulumi.set(__self__, "y_position_var", y_position_var)

    @_builtins.property
    @pulumi.getter(name="allowExpansion")
    def allow_expansion(self) -> Optional[_builtins.str]:
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        return pulumi.get(self, "allow_expansion")

    @allow_expansion.setter
    def allow_expansion(self, value: Optional[_builtins.str]):
        pulumi.set(self, "allow_expansion", value)

    @_builtins.property
    @pulumi.getter(name="allowExpansionVar")
    def allow_expansion_var(self) -> Optional[_builtins.str]:
        """
        If cropping an area outside of the existing canvas, expands the image canvas.
        """
        return pulumi.get(self, "allow_expansion_var")

    @allow_expansion_var.setter
    def allow_expansion_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "allow_expansion_var", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Frame of reference for X and Y Positions.
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Frame of reference for X and Y Positions.
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the y-axis.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the y-axis.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the x-axis.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to crop along the x-axis.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)

    @_builtins.property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to crop from.
        """
        return pulumi.get(self, "x_position")

    @x_position.setter
    def x_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position", value)

    @_builtins.property
    @pulumi.getter(name="xPositionVar")
    def x_position_var(self) -> Optional[_builtins.str]:
        """
        The x-axis position of the image to crop from.
        """
        return pulumi.get(self, "x_position_var")

    @x_position_var.setter
    def x_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_position_var", value)

    @_builtins.property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to crop from.
        """
        return pulumi.get(self, "y_position")

    @y_position.setter
    def y_position(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position", value)

    @_builtins.property
    @pulumi.getter(name="yPositionVar")
    def y_position_var(self) -> Optional[_builtins.str]:
        """
        The y-axis position of the image to crop from.
        """
        return pulumi.get(self, "y_position_var")

    @y_position_var.setter
    def y_position_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_position_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationFaceCropArgsDict(TypedDict):
        algorithm: NotRequired[_builtins.str]
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        algorithm_var: NotRequired[_builtins.str]
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        confidence: NotRequired[_builtins.str]
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        confidence_var: NotRequired[_builtins.str]
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        fail_gravity: NotRequired[_builtins.str]
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        fail_gravity_var: NotRequired[_builtins.str]
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        focus: NotRequired[_builtins.str]
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        focus_var: NotRequired[_builtins.str]
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        gravity: NotRequired[_builtins.str]
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        height: NotRequired[_builtins.str]
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        padding: NotRequired[_builtins.str]
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        padding_var: NotRequired[_builtins.str]
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        style: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        style_var: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        width: NotRequired[_builtins.str]
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationFaceCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationFaceCropArgs:
    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 algorithm_var: Optional[_builtins.str] = None,
                 confidence: Optional[_builtins.str] = None,
                 confidence_var: Optional[_builtins.str] = None,
                 fail_gravity: Optional[_builtins.str] = None,
                 fail_gravity_var: Optional[_builtins.str] = None,
                 focus: Optional[_builtins.str] = None,
                 focus_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str algorithm: Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        :param _builtins.str algorithm_var: Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        :param _builtins.str confidence: With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        :param _builtins.str confidence_var: With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        :param _builtins.str fail_gravity: Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str fail_gravity_var: Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str focus: Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        :param _builtins.str focus_var: Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        :param _builtins.str gravity: Controls placement of the crop. Directions are relative to the face(s) plus padding.
        :param _builtins.str gravity_var: Controls placement of the crop. Directions are relative to the face(s) plus padding.
        :param _builtins.str height: The height of the output image in pixels relative to the specified `style` value.
        :param _builtins.str height_var: The height of the output image in pixels relative to the specified `style` value.
        :param _builtins.str padding: The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        :param _builtins.str padding_var: The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str width: The width of the output image in pixels relative to the specified `style` value.
        :param _builtins.str width_var: The width of the output image in pixels relative to the specified `style` value.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if algorithm_var is not None:
            pulumi.set(__self__, "algorithm_var", algorithm_var)
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if confidence_var is not None:
            pulumi.set(__self__, "confidence_var", confidence_var)
        if fail_gravity is not None:
            pulumi.set(__self__, "fail_gravity", fail_gravity)
        if fail_gravity_var is not None:
            pulumi.set(__self__, "fail_gravity_var", fail_gravity_var)
        if focus is not None:
            pulumi.set(__self__, "focus", focus)
        if focus_var is not None:
            pulumi.set(__self__, "focus_var", focus_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[_builtins.str]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="algorithmVar")
    def algorithm_var(self) -> Optional[_builtins.str]:
        """
        Specifies the type of algorithm used to detect faces in the image, either `cascade` for the cascade classifier algorithm or `dnn` for the deep neural network algorithm, `cascade` by default.
        """
        return pulumi.get(self, "algorithm_var")

    @algorithm_var.setter
    def algorithm_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "algorithm_var", value)

    @_builtins.property
    @pulumi.getter
    def confidence(self) -> Optional[_builtins.str]:
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[_builtins.str]):
        pulumi.set(self, "confidence", value)

    @_builtins.property
    @pulumi.getter(name="confidenceVar")
    def confidence_var(self) -> Optional[_builtins.str]:
        """
        With `algorithm` set to `dnn`, specifies the minimum confidence needed to detect faces in the image. Values range from `0` to `1` for increased confidence, and possibly fewer faces detected.
        """
        return pulumi.get(self, "confidence_var")

    @confidence_var.setter
    def confidence_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "confidence_var", value)

    @_builtins.property
    @pulumi.getter(name="failGravity")
    def fail_gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity")

    @fail_gravity.setter
    def fail_gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fail_gravity", value)

    @_builtins.property
    @pulumi.getter(name="failGravityVar")
    def fail_gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any faces in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity_var")

    @fail_gravity_var.setter
    def fail_gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fail_gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def focus(self) -> Optional[_builtins.str]:
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        return pulumi.get(self, "focus")

    @focus.setter
    def focus(self, value: Optional[_builtins.str]):
        pulumi.set(self, "focus", value)

    @_builtins.property
    @pulumi.getter(name="focusVar")
    def focus_var(self) -> Optional[_builtins.str]:
        """
        Distinguishes the faces detected, either `biggestFace` or `allFaces` to place the crop rectangle around the full set of faces, `all` by default.
        """
        return pulumi.get(self, "focus_var")

    @focus_var.setter
    def focus_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "focus_var", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the face(s) plus padding.
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding", value)

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        The padding ratio based on the dimensions of the biggest face detected, `0.5` by default. Larger values increase padding.
        """
        return pulumi.get(self, "padding_var")

    @padding_var.setter
    def padding_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding_var", value)

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style", value)

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the faces detected in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places a raw crop around the faces, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and faces as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the faces, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style_var")

    @style_var.setter
    def style_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width of the output image in pixels relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationFeatureCropArgsDict(TypedDict):
        fail_gravity: NotRequired[_builtins.str]
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        fail_gravity_var: NotRequired[_builtins.str]
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        feature_radius: NotRequired[_builtins.str]
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        feature_radius_var: NotRequired[_builtins.str]
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        gravity: NotRequired[_builtins.str]
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        gravity_var: NotRequired[_builtins.str]
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        height: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        max_features: NotRequired[_builtins.str]
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        max_features_var: NotRequired[_builtins.str]
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        min_feature_quality: NotRequired[_builtins.str]
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        min_feature_quality_var: NotRequired[_builtins.str]
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        padding: NotRequired[_builtins.str]
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        padding_var: NotRequired[_builtins.str]
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        style: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        style_var: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        width: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationFeatureCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationFeatureCropArgs:
    def __init__(__self__, *,
                 fail_gravity: Optional[_builtins.str] = None,
                 fail_gravity_var: Optional[_builtins.str] = None,
                 feature_radius: Optional[_builtins.str] = None,
                 feature_radius_var: Optional[_builtins.str] = None,
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 max_features: Optional[_builtins.str] = None,
                 max_features_var: Optional[_builtins.str] = None,
                 min_feature_quality: Optional[_builtins.str] = None,
                 min_feature_quality_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fail_gravity: Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str fail_gravity_var: Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        :param _builtins.str feature_radius: The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        :param _builtins.str feature_radius_var: The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        :param _builtins.str gravity: Controls placement of the crop. Directions are relative to the region of interest plus padding.
        :param _builtins.str gravity_var: Controls placement of the crop. Directions are relative to the region of interest plus padding.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str max_features: The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        :param _builtins.str max_features_var: The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        :param _builtins.str min_feature_quality: Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        :param _builtins.str min_feature_quality_var: Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        :param _builtins.str padding: Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        :param _builtins.str padding_var: Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        if fail_gravity is not None:
            pulumi.set(__self__, "fail_gravity", fail_gravity)
        if fail_gravity_var is not None:
            pulumi.set(__self__, "fail_gravity_var", fail_gravity_var)
        if feature_radius is not None:
            pulumi.set(__self__, "feature_radius", feature_radius)
        if feature_radius_var is not None:
            pulumi.set(__self__, "feature_radius_var", feature_radius_var)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if max_features is not None:
            pulumi.set(__self__, "max_features", max_features)
        if max_features_var is not None:
            pulumi.set(__self__, "max_features_var", max_features_var)
        if min_feature_quality is not None:
            pulumi.set(__self__, "min_feature_quality", min_feature_quality)
        if min_feature_quality_var is not None:
            pulumi.set(__self__, "min_feature_quality_var", min_feature_quality_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="failGravity")
    def fail_gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity")

    @fail_gravity.setter
    def fail_gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fail_gravity", value)

    @_builtins.property
    @pulumi.getter(name="failGravityVar")
    def fail_gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop if Image and Video Manager does not detect any features in the image. Directions are relative to the edges of the image being transformed.
        """
        return pulumi.get(self, "fail_gravity_var")

    @fail_gravity_var.setter
    def fail_gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fail_gravity_var", value)

    @_builtins.property
    @pulumi.getter(name="featureRadius")
    def feature_radius(self) -> Optional[_builtins.str]:
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        return pulumi.get(self, "feature_radius")

    @feature_radius.setter
    def feature_radius(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feature_radius", value)

    @_builtins.property
    @pulumi.getter(name="featureRadiusVar")
    def feature_radius_var(self) -> Optional[_builtins.str]:
        """
        The size in pixels of the important features to search for. If identified, two features never appear closer together than this value, `8.0` by default.
        """
        return pulumi.get(self, "feature_radius_var")

    @feature_radius_var.setter
    def feature_radius_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feature_radius_var", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        Controls placement of the crop. Directions are relative to the region of interest plus padding.
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter(name="maxFeatures")
    def max_features(self) -> Optional[_builtins.str]:
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        return pulumi.get(self, "max_features")

    @max_features.setter
    def max_features(self, value: Optional[_builtins.str]):
        pulumi.set(self, "max_features", value)

    @_builtins.property
    @pulumi.getter(name="maxFeaturesVar")
    def max_features_var(self) -> Optional[_builtins.str]:
        """
        The maximum number of features to identify as important features, `32` by default. The strongest features are always chosen.
        """
        return pulumi.get(self, "max_features_var")

    @max_features_var.setter
    def max_features_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "max_features_var", value)

    @_builtins.property
    @pulumi.getter(name="minFeatureQuality")
    def min_feature_quality(self) -> Optional[_builtins.str]:
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        return pulumi.get(self, "min_feature_quality")

    @min_feature_quality.setter
    def min_feature_quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "min_feature_quality", value)

    @_builtins.property
    @pulumi.getter(name="minFeatureQualityVar")
    def min_feature_quality_var(self) -> Optional[_builtins.str]:
        """
        Determines the minimum quality level of the feature identified. To consider a feature important, the feature needs to surpass this value.  Image and Video Manager measures quality on a scale from `0` for the lowest quality to `1` for the highest quality, `.1` by default.
        """
        return pulumi.get(self, "min_feature_quality_var")

    @min_feature_quality_var.setter
    def min_feature_quality_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "min_feature_quality_var", value)

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding", value)

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        Adds space around the region of interest. The amount of padding added is directly related to the size of the bounding box of the selected features. Specifically, the region of interest is expanded in all directions by the largest dimension of the bounding box of the selected features multiplied by this value.
        """
        return pulumi.get(self, "padding_var")

    @padding_var.setter
    def padding_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding_var", value)

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style", value)

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the features identified in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` performs a raw crop around the features, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and features as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the features, relative to the specified `width` and `height` values. Allows Variable substitution.
        """
        return pulumi.get(self, "style_var")

    @style_var.setter
    def style_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationFitAndFillArgsDict(TypedDict):
        fill_transformation: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        height: NotRequired[_builtins.str]
        """
        The height value of the resized image.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height value of the resized image.
        """
        width: NotRequired[_builtins.str]
        """
        The width value of the resized image.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width value of the resized image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationFitAndFillArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationFitAndFillArgs:
    def __init__(__self__, *,
                 fill_transformation: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: The height value of the resized image.
        :param _builtins.str height_var: The height value of the resized image.
        :param _builtins.str width: The width value of the resized image.
        :param _builtins.str width_var: The width value of the resized image.
        """
        if fill_transformation is not None:
            pulumi.set(__self__, "fill_transformation", fill_transformation)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="fillTransformation")
    def fill_transformation(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "fill_transformation")

    @fill_transformation.setter
    def fill_transformation(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "fill_transformation", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height value of the resized image.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height value of the resized image.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width value of the resized image.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width value of the resized image.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationGoopArgsDict(TypedDict):
        chaos: NotRequired[_builtins.str]
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        chaos_var: NotRequired[_builtins.str]
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        density: NotRequired[_builtins.str]
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        density_var: NotRequired[_builtins.str]
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        power: NotRequired[_builtins.str]
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        power_var: NotRequired[_builtins.str]
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        seed: NotRequired[_builtins.str]
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        seed_var: NotRequired[_builtins.str]
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationGoopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationGoopArgs:
    def __init__(__self__, *,
                 chaos: Optional[_builtins.str] = None,
                 chaos_var: Optional[_builtins.str] = None,
                 density: Optional[_builtins.str] = None,
                 density_var: Optional[_builtins.str] = None,
                 power: Optional[_builtins.str] = None,
                 power_var: Optional[_builtins.str] = None,
                 seed: Optional[_builtins.str] = None,
                 seed_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str chaos: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str chaos_var: Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        :param _builtins.str density: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str density_var: Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        :param _builtins.str power: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str power_var: By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        :param _builtins.str seed: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        :param _builtins.str seed_var: Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        if chaos is not None:
            pulumi.set(__self__, "chaos", chaos)
        if chaos_var is not None:
            pulumi.set(__self__, "chaos_var", chaos_var)
        if density is not None:
            pulumi.set(__self__, "density", density)
        if density_var is not None:
            pulumi.set(__self__, "density_var", density_var)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_var is not None:
            pulumi.set(__self__, "power_var", power_var)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)
        if seed_var is not None:
            pulumi.set(__self__, "seed_var", seed_var)

    @_builtins.property
    @pulumi.getter
    def chaos(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos")

    @chaos.setter
    def chaos(self, value: Optional[_builtins.str]):
        pulumi.set(self, "chaos", value)

    @_builtins.property
    @pulumi.getter(name="chaosVar")
    def chaos_var(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
        """
        return pulumi.get(self, "chaos_var")

    @chaos_var.setter
    def chaos_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "chaos_var", value)

    @_builtins.property
    @pulumi.getter
    def density(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density")

    @density.setter
    def density(self, value: Optional[_builtins.str]):
        pulumi.set(self, "density", value)

    @_builtins.property
    @pulumi.getter(name="densityVar")
    def density_var(self) -> Optional[_builtins.str]:
        """
        Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
        """
        return pulumi.get(self, "density_var")

    @density_var.setter
    def density_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "density_var", value)

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[_builtins.str]):
        pulumi.set(self, "power", value)

    @_builtins.property
    @pulumi.getter(name="powerVar")
    def power_var(self) -> Optional[_builtins.str]:
        """
        By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
        """
        return pulumi.get(self, "power_var")

    @power_var.setter
    def power_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "power_var", value)

    @_builtins.property
    @pulumi.getter
    def seed(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed")

    @seed.setter
    def seed(self, value: Optional[_builtins.str]):
        pulumi.set(self, "seed", value)

    @_builtins.property
    @pulumi.getter(name="seedVar")
    def seed_var(self) -> Optional[_builtins.str]:
        """
        Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
        """
        return pulumi.get(self, "seed_var")

    @seed_var.setter
    def seed_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "seed_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationGrayscaleArgsDict(TypedDict):
        type: NotRequired[_builtins.str]
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        type_var: NotRequired[_builtins.str]
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationGrayscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationGrayscaleArgs:
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        :param _builtins.str type_var: The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
        """
        return pulumi.get(self, "type_var")

    @type_var.setter
    def type_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationHslArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        lightness: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        lightness_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        saturation: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        saturation_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationHslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationHslArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 lightness: Optional[_builtins.str] = None,
                 lightness_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0` by default.
        :param _builtins.str lightness: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str lightness_var: A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if lightness is not None:
            pulumi.set(__self__, "lightness", lightness)
        if lightness_var is not None:
            pulumi.set(__self__, "lightness_var", lightness_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0` by default.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter
    def lightness(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness")

    @lightness.setter
    def lightness(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness", value)

    @_builtins.property
    @pulumi.getter(name="lightnessVar")
    def lightness_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
        """
        return pulumi.get(self, "lightness_var")

    @lightness_var.setter
    def lightness_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "lightness_var", value)

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @saturation.setter
    def saturation(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation", value)

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @saturation_var.setter
    def saturation_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationHsvArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        hue_var: NotRequired[_builtins.str]
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        saturation: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        saturation_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        value: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        value_var: NotRequired[_builtins.str]
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationHsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationHsvArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None,
                 saturation: Optional[_builtins.str] = None,
                 saturation_var: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str hue_var: The number of degrees to rotate colors around the color wheel, `0.0` by default.
        :param _builtins.str saturation: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str saturation_var: A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        :param _builtins.str value: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        :param _builtins.str value_var: A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)
        if saturation is not None:
            pulumi.set(__self__, "saturation", saturation)
        if saturation_var is not None:
            pulumi.set(__self__, "saturation_var", saturation_var)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        The number of degrees to rotate colors around the color wheel, `0.0` by default.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)

    @_builtins.property
    @pulumi.getter
    def saturation(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation")

    @saturation.setter
    def saturation(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation", value)

    @_builtins.property
    @pulumi.getter(name="saturationVar")
    def saturation_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
        """
        return pulumi.get(self, "saturation_var")

    @saturation_var.setter
    def saturation_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "saturation_var", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
        """
        return pulumi.get(self, "value_var")

    @value_var.setter
    def value_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationIfDimensionArgsDict(TypedDict):
        default: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        dimension: NotRequired[_builtins.str]
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        dimension_var: NotRequired[_builtins.str]
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        equal: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        greater_than: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        less_than: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        value: NotRequired[_builtins.str]
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        value_var: NotRequired[_builtins.str]
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationIfDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationIfDimensionArgs:
    def __init__(__self__, *,
                 default: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 dimension: Optional[_builtins.str] = None,
                 dimension_var: Optional[_builtins.str] = None,
                 equal: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 greater_than: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 less_than: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 value: Optional[_builtins.str] = None,
                 value_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str dimension: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str dimension_var: The dimension to use to select the transformation, either `height`, `width`, or `both`.
        :param _builtins.str value: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        :param _builtins.str value_var: The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_var is not None:
            pulumi.set(__self__, "dimension_var", dimension_var)
        if equal is not None:
            pulumi.set(__self__, "equal", equal)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_var is not None:
            pulumi.set(__self__, "value_var", value_var)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[_builtins.str]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="dimensionVar")
    def dimension_var(self) -> Optional[_builtins.str]:
        """
        The dimension to use to select the transformation, either `height`, `width`, or `both`.
        """
        return pulumi.get(self, "dimension_var")

    @dimension_var.setter
    def dimension_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "dimension_var", value)

    @_builtins.property
    @pulumi.getter
    def equal(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "equal")

    @equal.setter
    def equal(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "equal", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueVar")
    def value_var(self) -> Optional[_builtins.str]:
        """
        The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
        """
        return pulumi.get(self, "value_var")

    @value_var.setter
    def value_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationIfOrientationArgsDict(TypedDict):
        default: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        landscape: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        portrait: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
        square: NotRequired['GetImagingPolicyImagePolicyTransformationArgsDict']
elif False:
    GetImagingPolicyImagePolicyTransformationIfOrientationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationIfOrientationArgs:
    def __init__(__self__, *,
                 default: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 landscape: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 portrait: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None,
                 square: Optional['GetImagingPolicyImagePolicyTransformationArgs'] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if landscape is not None:
            pulumi.set(__self__, "landscape", landscape)
        if portrait is not None:
            pulumi.set(__self__, "portrait", portrait)
        if square is not None:
            pulumi.set(__self__, "square", square)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def landscape(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "landscape")

    @landscape.setter
    def landscape(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "landscape", value)

    @_builtins.property
    @pulumi.getter
    def portrait(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "portrait")

    @portrait.setter
    def portrait(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "portrait", value)

    @_builtins.property
    @pulumi.getter
    def square(self) -> Optional['GetImagingPolicyImagePolicyTransformationArgs']:
        return pulumi.get(self, "square")

    @square.setter
    def square(self, value: Optional['GetImagingPolicyImagePolicyTransformationArgs']):
        pulumi.set(self, "square", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationImQueryArgsDict(TypedDict):
        allowed_transformations: Sequence[_builtins.str]
        """
        Specifies the transformations that can be applied using the query string parameter.
        """
        query_var: _builtins.str
elif False:
    GetImagingPolicyImagePolicyTransformationImQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationImQueryArgs:
    def __init__(__self__, *,
                 allowed_transformations: Sequence[_builtins.str],
                 query_var: _builtins.str):
        """
        :param Sequence[_builtins.str] allowed_transformations: Specifies the transformations that can be applied using the query string parameter.
        """
        pulumi.set(__self__, "allowed_transformations", allowed_transformations)
        pulumi.set(__self__, "query_var", query_var)

    @_builtins.property
    @pulumi.getter(name="allowedTransformations")
    def allowed_transformations(self) -> Sequence[_builtins.str]:
        """
        Specifies the transformations that can be applied using the query string parameter.
        """
        return pulumi.get(self, "allowed_transformations")

    @allowed_transformations.setter
    def allowed_transformations(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "allowed_transformations", value)

    @_builtins.property
    @pulumi.getter(name="queryVar")
    def query_var(self) -> _builtins.str:
        return pulumi.get(self, "query_var")

    @query_var.setter
    def query_var(self, value: _builtins.str):
        pulumi.set(self, "query_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationMaxColorArgsDict(TypedDict):
        colors: NotRequired[_builtins.str]
        """
        The value representing the maximum number of colors to use with the source image.
        """
        colors_var: NotRequired[_builtins.str]
        """
        The value representing the maximum number of colors to use with the source image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationMaxColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationMaxColorArgs:
    def __init__(__self__, *,
                 colors: Optional[_builtins.str] = None,
                 colors_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str colors: The value representing the maximum number of colors to use with the source image.
        :param _builtins.str colors_var: The value representing the maximum number of colors to use with the source image.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if colors_var is not None:
            pulumi.set(__self__, "colors_var", colors_var)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[_builtins.str]):
        pulumi.set(self, "colors", value)

    @_builtins.property
    @pulumi.getter(name="colorsVar")
    def colors_var(self) -> Optional[_builtins.str]:
        """
        The value representing the maximum number of colors to use with the source image.
        """
        return pulumi.get(self, "colors_var")

    @colors_var.setter
    def colors_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "colors_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationMirrorArgsDict(TypedDict):
        horizontal: NotRequired[_builtins.str]
        """
        Flips the image horizontally.
        """
        horizontal_var: NotRequired[_builtins.str]
        """
        Flips the image horizontally.
        """
        vertical: NotRequired[_builtins.str]
        """
        Flips the image vertically.
        """
        vertical_var: NotRequired[_builtins.str]
        """
        Flips the image vertically.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationMirrorArgs:
    def __init__(__self__, *,
                 horizontal: Optional[_builtins.str] = None,
                 horizontal_var: Optional[_builtins.str] = None,
                 vertical: Optional[_builtins.str] = None,
                 vertical_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str horizontal: Flips the image horizontally.
        :param _builtins.str horizontal_var: Flips the image horizontally.
        :param _builtins.str vertical: Flips the image vertically.
        :param _builtins.str vertical_var: Flips the image vertically.
        """
        if horizontal is not None:
            pulumi.set(__self__, "horizontal", horizontal)
        if horizontal_var is not None:
            pulumi.set(__self__, "horizontal_var", horizontal_var)
        if vertical is not None:
            pulumi.set(__self__, "vertical", vertical)
        if vertical_var is not None:
            pulumi.set(__self__, "vertical_var", vertical_var)

    @_builtins.property
    @pulumi.getter
    def horizontal(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal")

    @horizontal.setter
    def horizontal(self, value: Optional[_builtins.str]):
        pulumi.set(self, "horizontal", value)

    @_builtins.property
    @pulumi.getter(name="horizontalVar")
    def horizontal_var(self) -> Optional[_builtins.str]:
        """
        Flips the image horizontally.
        """
        return pulumi.get(self, "horizontal_var")

    @horizontal_var.setter
    def horizontal_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "horizontal_var", value)

    @_builtins.property
    @pulumi.getter
    def vertical(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical")

    @vertical.setter
    def vertical(self, value: Optional[_builtins.str]):
        pulumi.set(self, "vertical", value)

    @_builtins.property
    @pulumi.getter(name="verticalVar")
    def vertical_var(self) -> Optional[_builtins.str]:
        """
        Flips the image vertically.
        """
        return pulumi.get(self, "vertical_var")

    @vertical_var.setter
    def vertical_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "vertical_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationMonoHueArgsDict(TypedDict):
        hue: NotRequired[_builtins.str]
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        hue_var: NotRequired[_builtins.str]
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationMonoHueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationMonoHueArgs:
    def __init__(__self__, *,
                 hue: Optional[_builtins.str] = None,
                 hue_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str hue: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        :param _builtins.str hue_var: Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        if hue is not None:
            pulumi.set(__self__, "hue", hue)
        if hue_var is not None:
            pulumi.set(__self__, "hue_var", hue_var)

    @_builtins.property
    @pulumi.getter
    def hue(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue")

    @hue.setter
    def hue(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue", value)

    @_builtins.property
    @pulumi.getter(name="hueVar")
    def hue_var(self) -> Optional[_builtins.str]:
        """
        Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
        """
        return pulumi.get(self, "hue_var")

    @hue_var.setter
    def hue_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hue_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationOpacityArgsDict(TypedDict):
        opacity: NotRequired[_builtins.str]
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        opacity_var: NotRequired[_builtins.str]
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationOpacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationOpacityArgs:
    def __init__(__self__, *,
                 opacity: Optional[_builtins.str] = None,
                 opacity_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str opacity: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        :param _builtins.str opacity_var: Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if opacity_var is not None:
            pulumi.set(__self__, "opacity_var", opacity_var)

    @_builtins.property
    @pulumi.getter
    def opacity(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity")

    @opacity.setter
    def opacity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "opacity", value)

    @_builtins.property
    @pulumi.getter(name="opacityVar")
    def opacity_var(self) -> Optional[_builtins.str]:
        """
        Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
        """
        return pulumi.get(self, "opacity_var")

    @opacity_var.setter
    def opacity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "opacity_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgsDict(TypedDict):
        region_of_interest: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgsDict'
        gravity: NotRequired[_builtins.str]
        """
        The placement of the crop area relative to the specified area of interest.
        """
        gravity_var: NotRequired[_builtins.str]
        """
        The placement of the crop area relative to the specified area of interest.
        """
        height: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        style: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        style_var: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        width: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropArgs:
    def __init__(__self__, *,
                 region_of_interest: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgs',
                 gravity: Optional[_builtins.str] = None,
                 gravity_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gravity: The placement of the crop area relative to the specified area of interest.
        :param _builtins.str gravity_var: The placement of the crop area relative to the specified area of interest.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        pulumi.set(__self__, "region_of_interest", region_of_interest)
        if gravity is not None:
            pulumi.set(__self__, "gravity", gravity)
        if gravity_var is not None:
            pulumi.set(__self__, "gravity_var", gravity_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter(name="regionOfInterest")
    def region_of_interest(self) -> 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgs':
        return pulumi.get(self, "region_of_interest")

    @region_of_interest.setter
    def region_of_interest(self, value: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgs'):
        pulumi.set(self, "region_of_interest", value)

    @_builtins.property
    @pulumi.getter
    def gravity(self) -> Optional[_builtins.str]:
        """
        The placement of the crop area relative to the specified area of interest.
        """
        return pulumi.get(self, "gravity")

    @gravity.setter
    def gravity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity", value)

    @_builtins.property
    @pulumi.getter(name="gravityVar")
    def gravity_var(self) -> Optional[_builtins.str]:
        """
        The placement of the crop area relative to the specified area of interest.
        """
        return pulumi.get(self, "gravity_var")

    @gravity_var.setter
    def gravity_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gravity_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style", value)

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `zoom` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest, relative to the specified `gravity` value.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style_var")

    @style_var.setter
    def style_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgsDict(TypedDict):
        circle_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgsDict']]
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        point_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgsDict']]
        polygon_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgsDict']]
        """
        Defines a polygon from a series of connected points.
        """
        rectangle_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgsDict']]
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        union_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgsDict']]
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestArgs:
    def __init__(__self__, *,
                 circle_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs']] = None,
                 point_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgs']] = None,
                 polygon_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs']] = None,
                 rectangle_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs']] = None,
                 union_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs'] circle_shapes: Defines a circle with a specified `radius` from its `center` point.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs'] polygon_shapes: Defines a polygon from a series of connected points.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs'] rectangle_shapes: Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs'] union_shapes: Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        if circle_shapes is not None:
            pulumi.set(__self__, "circle_shapes", circle_shapes)
        if point_shapes is not None:
            pulumi.set(__self__, "point_shapes", point_shapes)
        if polygon_shapes is not None:
            pulumi.set(__self__, "polygon_shapes", polygon_shapes)
        if rectangle_shapes is not None:
            pulumi.set(__self__, "rectangle_shapes", rectangle_shapes)
        if union_shapes is not None:
            pulumi.set(__self__, "union_shapes", union_shapes)

    @_builtins.property
    @pulumi.getter(name="circleShapes")
    def circle_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs']]:
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        return pulumi.get(self, "circle_shapes")

    @circle_shapes.setter
    def circle_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs']]):
        pulumi.set(self, "circle_shapes", value)

    @_builtins.property
    @pulumi.getter(name="pointShapes")
    def point_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgs']]:
        return pulumi.get(self, "point_shapes")

    @point_shapes.setter
    def point_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgs']]):
        pulumi.set(self, "point_shapes", value)

    @_builtins.property
    @pulumi.getter(name="polygonShapes")
    def polygon_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs']]:
        """
        Defines a polygon from a series of connected points.
        """
        return pulumi.get(self, "polygon_shapes")

    @polygon_shapes.setter
    def polygon_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs']]):
        pulumi.set(self, "polygon_shapes", value)

    @_builtins.property
    @pulumi.getter(name="rectangleShapes")
    def rectangle_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs']]:
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        return pulumi.get(self, "rectangle_shapes")

    @rectangle_shapes.setter
    def rectangle_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs']]):
        pulumi.set(self, "rectangle_shapes", value)

    @_builtins.property
    @pulumi.getter(name="unionShapes")
    def union_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs']]:
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        return pulumi.get(self, "union_shapes")

    @union_shapes.setter
    def union_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs']]):
        pulumi.set(self, "union_shapes", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgsDict(TypedDict):
        center: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgsDict'
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        radius: NotRequired[_builtins.str]
        """
        The radius of the circle measured in pixels.
        """
        radius_var: NotRequired[_builtins.str]
        """
        The radius of the circle measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeArgs:
    def __init__(__self__, *,
                 center: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs',
                 radius: Optional[_builtins.str] = None,
                 radius_var: Optional[_builtins.str] = None):
        """
        :param 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs' center: Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        :param _builtins.str radius: The radius of the circle measured in pixels.
        :param _builtins.str radius_var: The radius of the circle measured in pixels.
        """
        pulumi.set(__self__, "center", center)
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if radius_var is not None:
            pulumi.set(__self__, "radius_var", radius_var)

    @_builtins.property
    @pulumi.getter
    def center(self) -> 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs':
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        return pulumi.get(self, "center")

    @center.setter
    def center(self, value: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs'):
        pulumi.set(self, "center", value)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius")

    @radius.setter
    def radius(self, value: Optional[_builtins.str]):
        pulumi.set(self, "radius", value)

    @_builtins.property
    @pulumi.getter(name="radiusVar")
    def radius_var(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius_var")

    @radius_var.setter
    def radius_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "radius_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestCircleShapeCenterArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPointShapeArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgsDict(TypedDict):
        points: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgsDict']
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapeArgs:
    def __init__(__self__, *,
                 points: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs']):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs'] points: Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        pulumi.set(__self__, "points", points)

    @_builtins.property
    @pulumi.getter
    def points(self) -> Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs']:
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        return pulumi.get(self, "points")

    @points.setter
    def points(self, value: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs']):
        pulumi.set(self, "points", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestPolygonShapePointArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgsDict(TypedDict):
        anchor: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgsDict'
        height: NotRequired[_builtins.str]
        """
        Extends the rectangle down from the `anchor` point.
        """
        height_var: NotRequired[_builtins.str]
        """
        Extends the rectangle down from the `anchor` point.
        """
        width: NotRequired[_builtins.str]
        """
        Extends the rectangle right from the `anchor` point.
        """
        width_var: NotRequired[_builtins.str]
        """
        Extends the rectangle right from the `anchor` point.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeArgs:
    def __init__(__self__, *,
                 anchor: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgs',
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Extends the rectangle down from the `anchor` point.
        :param _builtins.str height_var: Extends the rectangle down from the `anchor` point.
        :param _builtins.str width: Extends the rectangle right from the `anchor` point.
        :param _builtins.str width_var: Extends the rectangle right from the `anchor` point.
        """
        pulumi.set(__self__, "anchor", anchor)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def anchor(self) -> 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgs':
        return pulumi.get(self, "anchor")

    @anchor.setter
    def anchor(self, value: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgs'):
        pulumi.set(self, "anchor", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestRectangleShapeAnchorArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgsDict(TypedDict):
        shapes: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgsDict']
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeArgs:
    def __init__(__self__, *,
                 shapes: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgs']):
        pulumi.set(__self__, "shapes", shapes)

    @_builtins.property
    @pulumi.getter
    def shapes(self) -> Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgs']:
        return pulumi.get(self, "shapes")

    @shapes.setter
    def shapes(self, value: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgs']):
        pulumi.set(self, "shapes", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgsDict(TypedDict):
        circle_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgsDict']]
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        point_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgsDict']]
        polygon_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgsDict']]
        """
        Defines a polygon from a series of connected points.
        """
        rectangle_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgsDict']]
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        union_shapes: NotRequired[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgsDict']]
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeArgs:
    def __init__(__self__, *,
                 circle_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs']] = None,
                 point_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgs']] = None,
                 polygon_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs']] = None,
                 rectangle_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs']] = None,
                 union_shapes: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs']] = None):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs'] circle_shapes: Defines a circle with a specified `radius` from its `center` point.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs'] polygon_shapes: Defines a polygon from a series of connected points.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs'] rectangle_shapes: Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs'] union_shapes: Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        if circle_shapes is not None:
            pulumi.set(__self__, "circle_shapes", circle_shapes)
        if point_shapes is not None:
            pulumi.set(__self__, "point_shapes", point_shapes)
        if polygon_shapes is not None:
            pulumi.set(__self__, "polygon_shapes", polygon_shapes)
        if rectangle_shapes is not None:
            pulumi.set(__self__, "rectangle_shapes", rectangle_shapes)
        if union_shapes is not None:
            pulumi.set(__self__, "union_shapes", union_shapes)

    @_builtins.property
    @pulumi.getter(name="circleShapes")
    def circle_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs']]:
        """
        Defines a circle with a specified `radius` from its `center` point.
        """
        return pulumi.get(self, "circle_shapes")

    @circle_shapes.setter
    def circle_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs']]):
        pulumi.set(self, "circle_shapes", value)

    @_builtins.property
    @pulumi.getter(name="pointShapes")
    def point_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgs']]:
        return pulumi.get(self, "point_shapes")

    @point_shapes.setter
    def point_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgs']]):
        pulumi.set(self, "point_shapes", value)

    @_builtins.property
    @pulumi.getter(name="polygonShapes")
    def polygon_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs']]:
        """
        Defines a polygon from a series of connected points.
        """
        return pulumi.get(self, "polygon_shapes")

    @polygon_shapes.setter
    def polygon_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs']]):
        pulumi.set(self, "polygon_shapes", value)

    @_builtins.property
    @pulumi.getter(name="rectangleShapes")
    def rectangle_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs']]:
        """
        Defines a rectangle's `width` and `height` relative to an `anchor` point at the top left corner.
        """
        return pulumi.get(self, "rectangle_shapes")

    @rectangle_shapes.setter
    def rectangle_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs']]):
        pulumi.set(self, "rectangle_shapes", value)

    @_builtins.property
    @pulumi.getter(name="unionShapes")
    def union_shapes(self) -> Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs']]:
        """
        Identifies a combined shape based on a set of other shapes. You can use a full JSON object to represent a union or an array of shapes that describe it.
        """
        return pulumi.get(self, "union_shapes")

    @union_shapes.setter
    def union_shapes(self, value: Optional[Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs']]):
        pulumi.set(self, "union_shapes", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgsDict(TypedDict):
        center: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgsDict'
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        radius: NotRequired[_builtins.str]
        """
        The radius of the circle measured in pixels.
        """
        radius_var: NotRequired[_builtins.str]
        """
        The radius of the circle measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeArgs:
    def __init__(__self__, *,
                 center: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs',
                 radius: Optional[_builtins.str] = None,
                 radius_var: Optional[_builtins.str] = None):
        """
        :param 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs' center: Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        :param _builtins.str radius: The radius of the circle measured in pixels.
        :param _builtins.str radius_var: The radius of the circle measured in pixels.
        """
        pulumi.set(__self__, "center", center)
        if radius is not None:
            pulumi.set(__self__, "radius", radius)
        if radius_var is not None:
            pulumi.set(__self__, "radius_var", radius_var)

    @_builtins.property
    @pulumi.getter
    def center(self) -> 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs':
        """
        Defines coordinates for a single point, to help define polygons and rectangles. Each point may be an object with `x`and `y` members, or a two-element array.
        """
        return pulumi.get(self, "center")

    @center.setter
    def center(self, value: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs'):
        pulumi.set(self, "center", value)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius")

    @radius.setter
    def radius(self, value: Optional[_builtins.str]):
        pulumi.set(self, "radius", value)

    @_builtins.property
    @pulumi.getter(name="radiusVar")
    def radius_var(self) -> Optional[_builtins.str]:
        """
        The radius of the circle measured in pixels.
        """
        return pulumi.get(self, "radius_var")

    @radius_var.setter
    def radius_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "radius_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeCircleShapeCenterArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePointShapeArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgsDict(TypedDict):
        points: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgsDict']
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapeArgs:
    def __init__(__self__, *,
                 points: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs']):
        """
        :param Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs'] points: Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        pulumi.set(__self__, "points", points)

    @_builtins.property
    @pulumi.getter
    def points(self) -> Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs']:
        """
        Series of PointShapeType objects. The last and first points connect to close the shape automatically.
        """
        return pulumi.get(self, "points")

    @points.setter
    def points(self, value: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs']):
        pulumi.set(self, "points", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapePolygonShapePointArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgsDict(TypedDict):
        anchor: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgsDict'
        height: NotRequired[_builtins.str]
        """
        Extends the rectangle down from the `anchor` point.
        """
        height_var: NotRequired[_builtins.str]
        """
        Extends the rectangle down from the `anchor` point.
        """
        width: NotRequired[_builtins.str]
        """
        Extends the rectangle right from the `anchor` point.
        """
        width_var: NotRequired[_builtins.str]
        """
        Extends the rectangle right from the `anchor` point.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeArgs:
    def __init__(__self__, *,
                 anchor: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgs',
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Extends the rectangle down from the `anchor` point.
        :param _builtins.str height_var: Extends the rectangle down from the `anchor` point.
        :param _builtins.str width: Extends the rectangle right from the `anchor` point.
        :param _builtins.str width_var: Extends the rectangle right from the `anchor` point.
        """
        pulumi.set(__self__, "anchor", anchor)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def anchor(self) -> 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgs':
        return pulumi.get(self, "anchor")

    @anchor.setter
    def anchor(self, value: 'GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgs'):
        pulumi.set(self, "anchor", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle down from the `anchor` point.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Extends the rectangle right from the `anchor` point.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgsDict(TypedDict):
        x: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        x_var: NotRequired[_builtins.str]
        """
        The horizontal position of the point, measured in pixels.
        """
        y: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
        y_var: NotRequired[_builtins.str]
        """
        The vertical position of the point, measured in pixels.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeRectangleShapeAnchorArgs:
    def __init__(__self__, *,
                 x: Optional[_builtins.str] = None,
                 x_var: Optional[_builtins.str] = None,
                 y: Optional[_builtins.str] = None,
                 y_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x: The horizontal position of the point, measured in pixels.
        :param _builtins.str x_var: The horizontal position of the point, measured in pixels.
        :param _builtins.str y: The vertical position of the point, measured in pixels.
        :param _builtins.str y_var: The vertical position of the point, measured in pixels.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if x_var is not None:
            pulumi.set(__self__, "x_var", x_var)
        if y is not None:
            pulumi.set(__self__, "y", y)
        if y_var is not None:
            pulumi.set(__self__, "y_var", y_var)

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x", value)

    @_builtins.property
    @pulumi.getter(name="xVar")
    def x_var(self) -> Optional[_builtins.str]:
        """
        The horizontal position of the point, measured in pixels.
        """
        return pulumi.get(self, "x_var")

    @x_var.setter
    def x_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_var", value)

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y", value)

    @_builtins.property
    @pulumi.getter(name="yVar")
    def y_var(self) -> Optional[_builtins.str]:
        """
        The vertical position of the point, measured in pixels.
        """
        return pulumi.get(self, "y_var")

    @y_var.setter
    def y_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgsDict(TypedDict):
        shapes: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgsDict']
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeArgs:
    def __init__(__self__, *,
                 shapes: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgs']):
        pulumi.set(__self__, "shapes", shapes)

    @_builtins.property
    @pulumi.getter
    def shapes(self) -> Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgs']:
        return pulumi.get(self, "shapes")

    @shapes.setter
    def shapes(self, value: Sequence['GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgs']):
        pulumi.set(self, "shapes", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgsDict(TypedDict):
        pass
elif False:
    GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRegionOfInterestCropRegionOfInterestUnionShapeShapeUnionShapeShapeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRelativeCropArgsDict(TypedDict):
        east: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        east_var: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        north: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        north_var: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        south: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        south_var: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        west: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the left side of the image.
        """
        west_var: NotRequired[_builtins.str]
        """
        The number of pixels to shrink or expand the left side of the image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRelativeCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRelativeCropArgs:
    def __init__(__self__, *,
                 east: Optional[_builtins.str] = None,
                 east_var: Optional[_builtins.str] = None,
                 north: Optional[_builtins.str] = None,
                 north_var: Optional[_builtins.str] = None,
                 south: Optional[_builtins.str] = None,
                 south_var: Optional[_builtins.str] = None,
                 west: Optional[_builtins.str] = None,
                 west_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str east: The number of pixels to shrink or expand the right side of the image.
        :param _builtins.str east_var: The number of pixels to shrink or expand the right side of the image.
        :param _builtins.str north: The number of pixels to shrink or expand the top side of the image.
        :param _builtins.str north_var: The number of pixels to shrink or expand the top side of the image.
        :param _builtins.str south: The number of pixels to shrink or expand the bottom side of the image.
        :param _builtins.str south_var: The number of pixels to shrink or expand the bottom side of the image.
        :param _builtins.str west: The number of pixels to shrink or expand the left side of the image.
        :param _builtins.str west_var: The number of pixels to shrink or expand the left side of the image.
        """
        if east is not None:
            pulumi.set(__self__, "east", east)
        if east_var is not None:
            pulumi.set(__self__, "east_var", east_var)
        if north is not None:
            pulumi.set(__self__, "north", north)
        if north_var is not None:
            pulumi.set(__self__, "north_var", north_var)
        if south is not None:
            pulumi.set(__self__, "south", south)
        if south_var is not None:
            pulumi.set(__self__, "south_var", south_var)
        if west is not None:
            pulumi.set(__self__, "west", west)
        if west_var is not None:
            pulumi.set(__self__, "west_var", west_var)

    @_builtins.property
    @pulumi.getter
    def east(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        return pulumi.get(self, "east")

    @east.setter
    def east(self, value: Optional[_builtins.str]):
        pulumi.set(self, "east", value)

    @_builtins.property
    @pulumi.getter(name="eastVar")
    def east_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the right side of the image.
        """
        return pulumi.get(self, "east_var")

    @east_var.setter
    def east_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "east_var", value)

    @_builtins.property
    @pulumi.getter
    def north(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        return pulumi.get(self, "north")

    @north.setter
    def north(self, value: Optional[_builtins.str]):
        pulumi.set(self, "north", value)

    @_builtins.property
    @pulumi.getter(name="northVar")
    def north_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the top side of the image.
        """
        return pulumi.get(self, "north_var")

    @north_var.setter
    def north_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "north_var", value)

    @_builtins.property
    @pulumi.getter
    def south(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        return pulumi.get(self, "south")

    @south.setter
    def south(self, value: Optional[_builtins.str]):
        pulumi.set(self, "south", value)

    @_builtins.property
    @pulumi.getter(name="southVar")
    def south_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the bottom side of the image.
        """
        return pulumi.get(self, "south_var")

    @south_var.setter
    def south_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "south_var", value)

    @_builtins.property
    @pulumi.getter
    def west(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the left side of the image.
        """
        return pulumi.get(self, "west")

    @west.setter
    def west(self, value: Optional[_builtins.str]):
        pulumi.set(self, "west", value)

    @_builtins.property
    @pulumi.getter(name="westVar")
    def west_var(self) -> Optional[_builtins.str]:
        """
        The number of pixels to shrink or expand the left side of the image.
        """
        return pulumi.get(self, "west_var")

    @west_var.setter
    def west_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "west_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRemoveColorArgsDict(TypedDict):
        color: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value to remove.
        """
        color_var: NotRequired[_builtins.str]
        """
        The hexadecimal CSS color value to remove.
        """
        feather: NotRequired[_builtins.str]
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        feather_var: NotRequired[_builtins.str]
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        tolerance: NotRequired[_builtins.str]
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        tolerance_var: NotRequired[_builtins.str]
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRemoveColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRemoveColorArgs:
    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 color_var: Optional[_builtins.str] = None,
                 feather: Optional[_builtins.str] = None,
                 feather_var: Optional[_builtins.str] = None,
                 tolerance: Optional[_builtins.str] = None,
                 tolerance_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: The hexadecimal CSS color value to remove.
        :param _builtins.str color_var: The hexadecimal CSS color value to remove.
        :param _builtins.str feather: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str feather_var: The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        :param _builtins.str tolerance: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        :param _builtins.str tolerance_var: The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_var is not None:
            pulumi.set(__self__, "color_var", color_var)
        if feather is not None:
            pulumi.set(__self__, "feather", feather)
        if feather_var is not None:
            pulumi.set(__self__, "feather_var", feather_var)
        if tolerance is not None:
            pulumi.set(__self__, "tolerance", tolerance)
        if tolerance_var is not None:
            pulumi.set(__self__, "tolerance_var", tolerance_var)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter(name="colorVar")
    def color_var(self) -> Optional[_builtins.str]:
        """
        The hexadecimal CSS color value to remove.
        """
        return pulumi.get(self, "color_var")

    @color_var.setter
    def color_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "color_var", value)

    @_builtins.property
    @pulumi.getter
    def feather(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather")

    @feather.setter
    def feather(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feather", value)

    @_builtins.property
    @pulumi.getter(name="featherVar")
    def feather_var(self) -> Optional[_builtins.str]:
        """
        The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
        """
        return pulumi.get(self, "feather_var")

    @feather_var.setter
    def feather_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "feather_var", value)

    @_builtins.property
    @pulumi.getter
    def tolerance(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance")

    @tolerance.setter
    def tolerance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tolerance", value)

    @_builtins.property
    @pulumi.getter(name="toleranceVar")
    def tolerance_var(self) -> Optional[_builtins.str]:
        """
        The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
        """
        return pulumi.get(self, "tolerance_var")

    @tolerance_var.setter
    def tolerance_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tolerance_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationResizeArgsDict(TypedDict):
        aspect: NotRequired[_builtins.str]
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        aspect_var: NotRequired[_builtins.str]
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        height: NotRequired[_builtins.str]
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        type: NotRequired[_builtins.str]
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        type_var: NotRequired[_builtins.str]
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        width: NotRequired[_builtins.str]
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationResizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationResizeArgs:
    def __init__(__self__, *,
                 aspect: Optional[_builtins.str] = None,
                 aspect_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str aspect: Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        :param _builtins.str aspect_var: Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        :param _builtins.str height: The height to resize the source image to. Must be set if height is not specified.
        :param _builtins.str height_var: The height to resize the source image to. Must be set if height is not specified.
        :param _builtins.str type: Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        :param _builtins.str type_var: Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        :param _builtins.str width: The width to resize the source image to. Must be set if width is not specified.
        :param _builtins.str width_var: The width to resize the source image to. Must be set if width is not specified.
        """
        if aspect is not None:
            pulumi.set(__self__, "aspect", aspect)
        if aspect_var is not None:
            pulumi.set(__self__, "aspect_var", aspect_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_var is not None:
            pulumi.set(__self__, "type_var", type_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def aspect(self) -> Optional[_builtins.str]:
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        return pulumi.get(self, "aspect")

    @aspect.setter
    def aspect(self, value: Optional[_builtins.str]):
        pulumi.set(self, "aspect", value)

    @_builtins.property
    @pulumi.getter(name="aspectVar")
    def aspect_var(self) -> Optional[_builtins.str]:
        """
        Preserves the aspect ratio. Select `fit` to make the image fit entirely within the selected width and height. When using `fit`, the resulting image has the largest possible size for the specified dimensions. Select `fill` to size the image so it both completely fills the dimensions and has the smallest possible file size. Otherwise `ignore` changes the original aspect ratio to fit within an arbitrarily shaped rectangle.
        """
        return pulumi.get(self, "aspect_var")

    @aspect_var.setter
    def aspect_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "aspect_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height to resize the source image to. Must be set if height is not specified.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="typeVar")
    def type_var(self) -> Optional[_builtins.str]:
        """
        Sets constraints for the image resize. Select `normal` to resize in all cases, either increasing or decreasing the dimensions. Select `downsize` to ignore this transformation if the result would be larger than the original. Select `upsize` to ignore this transformation if the result would be smaller.
        """
        return pulumi.get(self, "type_var")

    @type_var.setter
    def type_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width to resize the source image to. Must be set if width is not specified.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationRotateArgsDict(TypedDict):
        degrees: NotRequired[_builtins.str]
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        degrees_var: NotRequired[_builtins.str]
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationRotateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationRotateArgs:
    def __init__(__self__, *,
                 degrees: Optional[_builtins.str] = None,
                 degrees_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str degrees: The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        :param _builtins.str degrees_var: The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        if degrees is not None:
            pulumi.set(__self__, "degrees", degrees)
        if degrees_var is not None:
            pulumi.set(__self__, "degrees_var", degrees_var)

    @_builtins.property
    @pulumi.getter
    def degrees(self) -> Optional[_builtins.str]:
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        return pulumi.get(self, "degrees")

    @degrees.setter
    def degrees(self, value: Optional[_builtins.str]):
        pulumi.set(self, "degrees", value)

    @_builtins.property
    @pulumi.getter(name="degreesVar")
    def degrees_var(self) -> Optional[_builtins.str]:
        """
        The value to rotate the image by. Positive values rotate clockwise, while negative values rotate counter-clockwise.
        """
        return pulumi.get(self, "degrees_var")

    @degrees_var.setter
    def degrees_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "degrees_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationScaleArgsDict(TypedDict):
        height: NotRequired[_builtins.str]
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        height_var: NotRequired[_builtins.str]
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        width: NotRequired[_builtins.str]
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        width_var: NotRequired[_builtins.str]
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationScaleArgs:
    def __init__(__self__, *,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str height: Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str height_var: Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str width: Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        :param _builtins.str width_var: Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input height to determine the output height of the image, where values between `0` and `1` decrease size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        Scaling factor for the input width to determine the output width of the image, where `1` leaves the width unchanged. Values greater than `1` increase the image size. Image dimensions need to be non-zero positive numbers.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationShearsArgsDict(TypedDict):
        x_shear: NotRequired[_builtins.str]
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        x_shear_var: NotRequired[_builtins.str]
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        y_shear: NotRequired[_builtins.str]
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        y_shear_var: NotRequired[_builtins.str]
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationShearsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationShearsArgs:
    def __init__(__self__, *,
                 x_shear: Optional[_builtins.str] = None,
                 x_shear_var: Optional[_builtins.str] = None,
                 y_shear: Optional[_builtins.str] = None,
                 y_shear_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str x_shear: The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        :param _builtins.str x_shear_var: The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        :param _builtins.str y_shear: The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        :param _builtins.str y_shear_var: The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        if x_shear is not None:
            pulumi.set(__self__, "x_shear", x_shear)
        if x_shear_var is not None:
            pulumi.set(__self__, "x_shear_var", x_shear_var)
        if y_shear is not None:
            pulumi.set(__self__, "y_shear", y_shear)
        if y_shear_var is not None:
            pulumi.set(__self__, "y_shear_var", y_shear_var)

    @_builtins.property
    @pulumi.getter(name="xShear")
    def x_shear(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        return pulumi.get(self, "x_shear")

    @x_shear.setter
    def x_shear(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_shear", value)

    @_builtins.property
    @pulumi.getter(name="xShearVar")
    def x_shear_var(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the x-axis, measured in multiples of the image's width. Must be set if yShear is not specified.
        """
        return pulumi.get(self, "x_shear_var")

    @x_shear_var.setter
    def x_shear_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "x_shear_var", value)

    @_builtins.property
    @pulumi.getter(name="yShear")
    def y_shear(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        return pulumi.get(self, "y_shear")

    @y_shear.setter
    def y_shear(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_shear", value)

    @_builtins.property
    @pulumi.getter(name="yShearVar")
    def y_shear_var(self) -> Optional[_builtins.str]:
        """
        The amount to shear along the y-axis, measured in multiples of the image's height. Must be set if xShear is not specified.
        """
        return pulumi.get(self, "y_shear_var")

    @y_shear_var.setter
    def y_shear_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "y_shear_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationSmartCropArgsDict(TypedDict):
        debug: NotRequired[_builtins.str]
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        debug_var: NotRequired[_builtins.str]
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        height: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        height_var: NotRequired[_builtins.str]
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        sloppy: NotRequired[_builtins.str]
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        sloppy_var: NotRequired[_builtins.str]
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        style: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        style_var: NotRequired[_builtins.str]
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        width: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        width_var: NotRequired[_builtins.str]
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationSmartCropArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationSmartCropArgs:
    def __init__(__self__, *,
                 debug: Optional[_builtins.str] = None,
                 debug_var: Optional[_builtins.str] = None,
                 height: Optional[_builtins.str] = None,
                 height_var: Optional[_builtins.str] = None,
                 sloppy: Optional[_builtins.str] = None,
                 sloppy_var: Optional[_builtins.str] = None,
                 style: Optional[_builtins.str] = None,
                 style_var: Optional[_builtins.str] = None,
                 width: Optional[_builtins.str] = None,
                 width_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str debug: When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        :param _builtins.str debug_var: When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        :param _builtins.str height: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str height_var: The height in pixels of the output image relative to the specified `style` value.
        :param _builtins.str sloppy: Whether to sacrifice any image fidelity for transformation performance.
        :param _builtins.str sloppy_var: Whether to sacrifice any image fidelity for transformation performance.
        :param _builtins.str style: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str style_var: Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        :param _builtins.str width: The width in pixels of the output image relative to the specified `style` value.
        :param _builtins.str width_var: The width in pixels of the output image relative to the specified `style` value.
        """
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if debug_var is not None:
            pulumi.set(__self__, "debug_var", debug_var)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if height_var is not None:
            pulumi.set(__self__, "height_var", height_var)
        if sloppy is not None:
            pulumi.set(__self__, "sloppy", sloppy)
        if sloppy_var is not None:
            pulumi.set(__self__, "sloppy_var", sloppy_var)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if style_var is not None:
            pulumi.set(__self__, "style_var", style_var)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if width_var is not None:
            pulumi.set(__self__, "width_var", width_var)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.str]:
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[_builtins.str]):
        pulumi.set(self, "debug", value)

    @_builtins.property
    @pulumi.getter(name="debugVar")
    def debug_var(self) -> Optional[_builtins.str]:
        """
        When enabled, the SmartCrop transformation doesn't actually execute. Instead, it outlines found faces or features, the region of interest, and the crop area.
        """
        return pulumi.get(self, "debug_var")

    @debug_var.setter
    def debug_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "debug_var", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter(name="heightVar")
    def height_var(self) -> Optional[_builtins.str]:
        """
        The height in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "height_var")

    @height_var.setter
    def height_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "height_var", value)

    @_builtins.property
    @pulumi.getter
    def sloppy(self) -> Optional[_builtins.str]:
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        return pulumi.get(self, "sloppy")

    @sloppy.setter
    def sloppy(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sloppy", value)

    @_builtins.property
    @pulumi.getter(name="sloppyVar")
    def sloppy_var(self) -> Optional[_builtins.str]:
        """
        Whether to sacrifice any image fidelity for transformation performance.
        """
        return pulumi.get(self, "sloppy_var")

    @sloppy_var.setter
    def sloppy_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sloppy_var", value)

    @_builtins.property
    @pulumi.getter
    def style(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style", value)

    @_builtins.property
    @pulumi.getter(name="styleVar")
    def style_var(self) -> Optional[_builtins.str]:
        """
        Specifies how to crop or scale a crop area for the specified area of interest in the source image, `fill` by default. The output image resizes to the specified `width` and `height` values. A value of `crop` places raw crop around the point of interest.  A value of `fill` scales the crop area to include as much of the image and point of interest as possible, relative to the specified `width` and `height` values. A value of `zoom` scales the crop area as small as possible to fit the point of interest, relative to the specified `width` and `height` values.
        """
        return pulumi.get(self, "style_var")

    @style_var.setter
    def style_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "style_var", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="widthVar")
    def width_var(self) -> Optional[_builtins.str]:
        """
        The width in pixels of the output image relative to the specified `style` value.
        """
        return pulumi.get(self, "width_var")

    @width_var.setter
    def width_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "width_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationTrimArgsDict(TypedDict):
        fuzz: NotRequired[_builtins.str]
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        fuzz_var: NotRequired[_builtins.str]
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        padding: NotRequired[_builtins.str]
        """
        The amount of padding in pixels to add to the trimmed image.
        """
        padding_var: NotRequired[_builtins.str]
        """
        The amount of padding in pixels to add to the trimmed image.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationTrimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationTrimArgs:
    def __init__(__self__, *,
                 fuzz: Optional[_builtins.str] = None,
                 fuzz_var: Optional[_builtins.str] = None,
                 padding: Optional[_builtins.str] = None,
                 padding_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str fuzz: The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        :param _builtins.str fuzz_var: The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        :param _builtins.str padding: The amount of padding in pixels to add to the trimmed image.
        :param _builtins.str padding_var: The amount of padding in pixels to add to the trimmed image.
        """
        if fuzz is not None:
            pulumi.set(__self__, "fuzz", fuzz)
        if fuzz_var is not None:
            pulumi.set(__self__, "fuzz_var", fuzz_var)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if padding_var is not None:
            pulumi.set(__self__, "padding_var", padding_var)

    @_builtins.property
    @pulumi.getter
    def fuzz(self) -> Optional[_builtins.str]:
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        return pulumi.get(self, "fuzz")

    @fuzz.setter
    def fuzz(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fuzz", value)

    @_builtins.property
    @pulumi.getter(name="fuzzVar")
    def fuzz_var(self) -> Optional[_builtins.str]:
        """
        The fuzz tolerance of the trim, a value between `0` and `1` that determines the acceptable amount of background variation before trimming stops.
        """
        return pulumi.get(self, "fuzz_var")

    @fuzz_var.setter
    def fuzz_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "fuzz_var", value)

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[_builtins.str]:
        """
        The amount of padding in pixels to add to the trimmed image.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding", value)

    @_builtins.property
    @pulumi.getter(name="paddingVar")
    def padding_var(self) -> Optional[_builtins.str]:
        """
        The amount of padding in pixels to add to the trimmed image.
        """
        return pulumi.get(self, "padding_var")

    @padding_var.setter
    def padding_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "padding_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyTransformationUnsharpMaskArgsDict(TypedDict):
        gain: NotRequired[_builtins.str]
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        gain_var: NotRequired[_builtins.str]
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        sigma: NotRequired[_builtins.str]
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        sigma_var: NotRequired[_builtins.str]
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        threshold: NotRequired[_builtins.str]
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        threshold_var: NotRequired[_builtins.str]
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
elif False:
    GetImagingPolicyImagePolicyTransformationUnsharpMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyTransformationUnsharpMaskArgs:
    def __init__(__self__, *,
                 gain: Optional[_builtins.str] = None,
                 gain_var: Optional[_builtins.str] = None,
                 sigma: Optional[_builtins.str] = None,
                 sigma_var: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None,
                 threshold_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str gain: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str gain_var: Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        :param _builtins.str sigma: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str sigma_var: The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        :param _builtins.str threshold: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        :param _builtins.str threshold_var: Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        if gain is not None:
            pulumi.set(__self__, "gain", gain)
        if gain_var is not None:
            pulumi.set(__self__, "gain_var", gain_var)
        if sigma is not None:
            pulumi.set(__self__, "sigma", sigma)
        if sigma_var is not None:
            pulumi.set(__self__, "sigma_var", sigma_var)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_var is not None:
            pulumi.set(__self__, "threshold_var", threshold_var)

    @_builtins.property
    @pulumi.getter
    def gain(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain")

    @gain.setter
    def gain(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gain", value)

    @_builtins.property
    @pulumi.getter(name="gainVar")
    def gain_var(self) -> Optional[_builtins.str]:
        """
        Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
        """
        return pulumi.get(self, "gain_var")

    @gain_var.setter
    def gain_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "gain_var", value)

    @_builtins.property
    @pulumi.getter
    def sigma(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma")

    @sigma.setter
    def sigma(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma", value)

    @_builtins.property
    @pulumi.getter(name="sigmaVar")
    def sigma_var(self) -> Optional[_builtins.str]:
        """
        The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
        """
        return pulumi.get(self, "sigma_var")

    @sigma_var.setter
    def sigma_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sigma_var", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[_builtins.str]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter(name="thresholdVar")
    def threshold_var(self) -> Optional[_builtins.str]:
        """
        Set the minimum change required to include a detail in the filter. Higher values discard more changes.
        """
        return pulumi.get(self, "threshold_var")

    @threshold_var.setter
    def threshold_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "threshold_var", value)


if not MYPY:
    class GetImagingPolicyImagePolicyVariableArgsDict(TypedDict):
        default_value: _builtins.str
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        name: _builtins.str
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        type: _builtins.str
        """
        The type of value for the variable.
        """
        enum_options: NotRequired[Sequence['GetImagingPolicyImagePolicyVariableEnumOptionArgsDict']]
        postfix: NotRequired[_builtins.str]
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        prefix: NotRequired[_builtins.str]
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
elif False:
    GetImagingPolicyImagePolicyVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyVariableArgs:
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 enum_options: Optional[Sequence['GetImagingPolicyImagePolicyVariableEnumOptionArgs']] = None,
                 postfix: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_value: The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        :param _builtins.str name: The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        :param _builtins.str type: The type of value for the variable.
        :param _builtins.str postfix: A postfix added to the value provided for the variable, or to the default value.
        :param _builtins.str prefix: A prefix added to the value provided for the variable, or to the default value.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if postfix is not None:
            pulumi.set(__self__, "postfix", postfix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: _builtins.str):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of value for the variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[Sequence['GetImagingPolicyImagePolicyVariableEnumOptionArgs']]:
        return pulumi.get(self, "enum_options")

    @enum_options.setter
    def enum_options(self, value: Optional[Sequence['GetImagingPolicyImagePolicyVariableEnumOptionArgs']]):
        pulumi.set(self, "enum_options", value)

    @_builtins.property
    @pulumi.getter
    def postfix(self) -> Optional[_builtins.str]:
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "postfix")

    @postfix.setter
    def postfix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "postfix", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GetImagingPolicyImagePolicyVariableEnumOptionArgsDict(TypedDict):
        id: _builtins.str
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        value: _builtins.str
        """
        The value of the variable when the `id` is provided.
        """
elif False:
    GetImagingPolicyImagePolicyVariableEnumOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyImagePolicyVariableEnumOptionArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for each enum value, up to 50 alphanumeric characters.
        :param _builtins.str value: The value of the variable when the `id` is provided.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable when the `id` is provided.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetImagingPolicyVideoPolicyArgsDict(TypedDict):
        breakpoints: NotRequired['GetImagingPolicyVideoPolicyBreakpointsArgsDict']
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        hosts: NotRequired[Sequence[_builtins.str]]
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        output: NotRequired['GetImagingPolicyVideoPolicyOutputArgsDict']
        """
        Dictates the output quality that are created for each resized video.
        """
        rollout_duration: NotRequired[_builtins.str]
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        variables: NotRequired[Sequence['GetImagingPolicyVideoPolicyVariableArgsDict']]
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
elif False:
    GetImagingPolicyVideoPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyVideoPolicyArgs:
    def __init__(__self__, *,
                 breakpoints: Optional['GetImagingPolicyVideoPolicyBreakpointsArgs'] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 output: Optional['GetImagingPolicyVideoPolicyOutputArgs'] = None,
                 rollout_duration: Optional[_builtins.str] = None,
                 variables: Optional[Sequence['GetImagingPolicyVideoPolicyVariableArgs']] = None):
        """
        :param 'GetImagingPolicyVideoPolicyBreakpointsArgs' breakpoints: The breakpoint widths (in pixels) to use to create derivative images/videos.
        :param Sequence[_builtins.str] hosts: Hosts that are allowed for image/video URLs within transformations or variables.
        :param 'GetImagingPolicyVideoPolicyOutputArgs' output: Dictates the output quality that are created for each resized video.
        :param _builtins.str rollout_duration: The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        :param Sequence['GetImagingPolicyVideoPolicyVariableArgs'] variables: Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        if breakpoints is not None:
            pulumi.set(__self__, "breakpoints", breakpoints)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if rollout_duration is not None:
            pulumi.set(__self__, "rollout_duration", rollout_duration)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def breakpoints(self) -> Optional['GetImagingPolicyVideoPolicyBreakpointsArgs']:
        """
        The breakpoint widths (in pixels) to use to create derivative images/videos.
        """
        return pulumi.get(self, "breakpoints")

    @breakpoints.setter
    def breakpoints(self, value: Optional['GetImagingPolicyVideoPolicyBreakpointsArgs']):
        pulumi.set(self, "breakpoints", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Hosts that are allowed for image/video URLs within transformations or variables.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['GetImagingPolicyVideoPolicyOutputArgs']:
        """
        Dictates the output quality that are created for each resized video.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional['GetImagingPolicyVideoPolicyOutputArgs']):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter(name="rolloutDuration")
    def rollout_duration(self) -> Optional[_builtins.str]:
        """
        The amount of time in seconds that the policy takes to rollout. During the rollout an increasing proportion of images/videos will begin to use the new policy instead of the cached images/videos from the previous version. This value has no effect on the staging network.
        """
        return pulumi.get(self, "rollout_duration")

    @rollout_duration.setter
    def rollout_duration(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rollout_duration", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['GetImagingPolicyVideoPolicyVariableArgs']]:
        """
        Declares variables for use within the policy. Any variable declared here can be invoked throughout transformations as a Variable object, so that you don't have to specify values separately. You can also pass in these variable names and values dynamically as query parameters in the image's request URL.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[Sequence['GetImagingPolicyVideoPolicyVariableArgs']]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class GetImagingPolicyVideoPolicyBreakpointsArgsDict(TypedDict):
        widths: NotRequired[Sequence[_builtins.int]]
elif False:
    GetImagingPolicyVideoPolicyBreakpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyVideoPolicyBreakpointsArgs:
    def __init__(__self__, *,
                 widths: Optional[Sequence[_builtins.int]] = None):
        if widths is not None:
            pulumi.set(__self__, "widths", widths)

    @_builtins.property
    @pulumi.getter
    def widths(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "widths")

    @widths.setter
    def widths(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "widths", value)


if not MYPY:
    class GetImagingPolicyVideoPolicyOutputArgsDict(TypedDict):
        perceptual_quality: NotRequired[_builtins.str]
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        perceptual_quality_var: NotRequired[_builtins.str]
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        placeholder_video_url: NotRequired[_builtins.str]
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        placeholder_video_url_var: NotRequired[_builtins.str]
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        video_adaptive_quality: NotRequired[_builtins.str]
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        video_adaptive_quality_var: NotRequired[_builtins.str]
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
elif False:
    GetImagingPolicyVideoPolicyOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyVideoPolicyOutputArgs:
    def __init__(__self__, *,
                 perceptual_quality: Optional[_builtins.str] = None,
                 perceptual_quality_var: Optional[_builtins.str] = None,
                 placeholder_video_url: Optional[_builtins.str] = None,
                 placeholder_video_url_var: Optional[_builtins.str] = None,
                 video_adaptive_quality: Optional[_builtins.str] = None,
                 video_adaptive_quality_var: Optional[_builtins.str] = None):
        """
        :param _builtins.str perceptual_quality: The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        :param _builtins.str perceptual_quality_var: The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        :param _builtins.str placeholder_video_url: Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        :param _builtins.str placeholder_video_url_var: Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        :param _builtins.str video_adaptive_quality: Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        :param _builtins.str video_adaptive_quality_var: Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        if perceptual_quality is not None:
            pulumi.set(__self__, "perceptual_quality", perceptual_quality)
        if perceptual_quality_var is not None:
            pulumi.set(__self__, "perceptual_quality_var", perceptual_quality_var)
        if placeholder_video_url is not None:
            pulumi.set(__self__, "placeholder_video_url", placeholder_video_url)
        if placeholder_video_url_var is not None:
            pulumi.set(__self__, "placeholder_video_url_var", placeholder_video_url_var)
        if video_adaptive_quality is not None:
            pulumi.set(__self__, "video_adaptive_quality", video_adaptive_quality)
        if video_adaptive_quality_var is not None:
            pulumi.set(__self__, "video_adaptive_quality_var", video_adaptive_quality_var)

    @_builtins.property
    @pulumi.getter(name="perceptualQuality")
    def perceptual_quality(self) -> Optional[_builtins.str]:
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        return pulumi.get(self, "perceptual_quality")

    @perceptual_quality.setter
    def perceptual_quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "perceptual_quality", value)

    @_builtins.property
    @pulumi.getter(name="perceptualQualityVar")
    def perceptual_quality_var(self) -> Optional[_builtins.str]:
        """
        The quality of derivative videos. High preserves video quality with reduced byte savings while low reduces video quality to increase byte savings.
        """
        return pulumi.get(self, "perceptual_quality_var")

    @perceptual_quality_var.setter
    def perceptual_quality_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "perceptual_quality_var", value)

    @_builtins.property
    @pulumi.getter(name="placeholderVideoUrl")
    def placeholder_video_url(self) -> Optional[_builtins.str]:
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        return pulumi.get(self, "placeholder_video_url")

    @placeholder_video_url.setter
    def placeholder_video_url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placeholder_video_url", value)

    @_builtins.property
    @pulumi.getter(name="placeholderVideoUrlVar")
    def placeholder_video_url_var(self) -> Optional[_builtins.str]:
        """
        Allows you to add a specific placeholder video that appears when a user first requests a video, but before Image & Video Manager processes the video. If not specified the original video plays during the processing time.
        """
        return pulumi.get(self, "placeholder_video_url_var")

    @placeholder_video_url_var.setter
    def placeholder_video_url_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "placeholder_video_url_var", value)

    @_builtins.property
    @pulumi.getter(name="videoAdaptiveQuality")
    def video_adaptive_quality(self) -> Optional[_builtins.str]:
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        return pulumi.get(self, "video_adaptive_quality")

    @video_adaptive_quality.setter
    def video_adaptive_quality(self, value: Optional[_builtins.str]):
        pulumi.set(self, "video_adaptive_quality", value)

    @_builtins.property
    @pulumi.getter(name="videoAdaptiveQualityVar")
    def video_adaptive_quality_var(self) -> Optional[_builtins.str]:
        """
        Override the quality of video to serve when Image & Video Manager detects a slow connection. Specifying lower values lets users with slow connections browse your site with reduced load times without impacting the quality of videos for users with faster connections.
        """
        return pulumi.get(self, "video_adaptive_quality_var")

    @video_adaptive_quality_var.setter
    def video_adaptive_quality_var(self, value: Optional[_builtins.str]):
        pulumi.set(self, "video_adaptive_quality_var", value)


if not MYPY:
    class GetImagingPolicyVideoPolicyVariableArgsDict(TypedDict):
        default_value: _builtins.str
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        name: _builtins.str
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        type: _builtins.str
        """
        The type of value for the variable.
        """
        enum_options: NotRequired[Sequence['GetImagingPolicyVideoPolicyVariableEnumOptionArgsDict']]
        postfix: NotRequired[_builtins.str]
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        prefix: NotRequired[_builtins.str]
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
elif False:
    GetImagingPolicyVideoPolicyVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyVideoPolicyVariableArgs:
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 enum_options: Optional[Sequence['GetImagingPolicyVideoPolicyVariableEnumOptionArgs']] = None,
                 postfix: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_value: The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        :param _builtins.str name: The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        :param _builtins.str type: The type of value for the variable.
        :param _builtins.str postfix: A postfix added to the value provided for the variable, or to the default value.
        :param _builtins.str prefix: A prefix added to the value provided for the variable, or to the default value.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if postfix is not None:
            pulumi.set(__self__, "postfix", postfix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        The default value of the variable if no query parameter is provided. It needs to be one of the `enumOptions` if any are provided.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: _builtins.str):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable, also available as the query parameter name to set the variable's value dynamically. Use up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of value for the variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[Sequence['GetImagingPolicyVideoPolicyVariableEnumOptionArgs']]:
        return pulumi.get(self, "enum_options")

    @enum_options.setter
    def enum_options(self, value: Optional[Sequence['GetImagingPolicyVideoPolicyVariableEnumOptionArgs']]):
        pulumi.set(self, "enum_options", value)

    @_builtins.property
    @pulumi.getter
    def postfix(self) -> Optional[_builtins.str]:
        """
        A postfix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "postfix")

    @postfix.setter
    def postfix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "postfix", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        A prefix added to the value provided for the variable, or to the default value.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class GetImagingPolicyVideoPolicyVariableEnumOptionArgsDict(TypedDict):
        id: _builtins.str
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        value: _builtins.str
        """
        The value of the variable when the `id` is provided.
        """
elif False:
    GetImagingPolicyVideoPolicyVariableEnumOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagingPolicyVideoPolicyVariableEnumOptionArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for each enum value, up to 50 alphanumeric characters.
        :param _builtins.str value: The value of the variable when the `id` is provided.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for each enum value, up to 50 alphanumeric characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable when the `id` is provided.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainArgsDict(TypedDict):
        account_id: _builtins.str
        """
        Your account's ID.
        """
        domain_name: _builtins.str
        """
        Your domain's name.
        """
        domain_status: _builtins.str
        """
        The domain's validation status. Possible values are: 
        * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
        * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
        * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
        * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
        * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        """
        validation_challenge: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgsDict'
        """
        The domain's validation challenge details.
        """
        validation_completed_date: _builtins.str
        """
        The timestamp indicating when the domain validation was completed.
        """
        validation_level: _builtins.str
        """
        The domain's validation level, either 'FQDN' (fully qualified domain name) or 'ROOT/WILDCARD'.
        """
        validation_method: _builtins.str
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
        * `MANUAL` - For this method, the DOM team manually performed the validation.
        """
        validation_requested_by: _builtins.str
        """
        The name of the user who requested the domain validation.
        """
        validation_requested_date: _builtins.str
        """
        The timestamp indicating when the domain validation was requested.
        """
        validation_scope: _builtins.str
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainArgs:
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 domain_name: _builtins.str,
                 domain_status: _builtins.str,
                 validation_challenge: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs',
                 validation_completed_date: _builtins.str,
                 validation_level: _builtins.str,
                 validation_method: _builtins.str,
                 validation_requested_by: _builtins.str,
                 validation_requested_date: _builtins.str,
                 validation_scope: _builtins.str):
        """
        :param _builtins.str account_id: Your account's ID.
        :param _builtins.str domain_name: Your domain's name.
        :param _builtins.str domain_status: The domain's validation status. Possible values are: 
               * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
               * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
               * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
               * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
               * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        :param 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs' validation_challenge: The domain's validation challenge details.
        :param _builtins.str validation_completed_date: The timestamp indicating when the domain validation was completed.
        :param _builtins.str validation_level: The domain's validation level, either 'FQDN' (fully qualified domain name) or 'ROOT/WILDCARD'.
        :param _builtins.str validation_method: The method used to validate the domain. Possible values are: 
               * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
               * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
               * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
               * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
               * `MANUAL` - For this method, the DOM team manually performed the validation.
        :param _builtins.str validation_requested_by: The name of the user who requested the domain validation.
        :param _builtins.str validation_requested_date: The timestamp indicating when the domain validation was requested.
        :param _builtins.str validation_scope: Your domain's validation scope. Possible values are: 
               * `HOST` - The scope is only the exactly specified domain.
               * `WILDCARD` - The scope covers any hostname within one subdomain level.
               * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "domain_status", domain_status)
        pulumi.set(__self__, "validation_challenge", validation_challenge)
        pulumi.set(__self__, "validation_completed_date", validation_completed_date)
        pulumi.set(__self__, "validation_level", validation_level)
        pulumi.set(__self__, "validation_method", validation_method)
        pulumi.set(__self__, "validation_requested_by", validation_requested_by)
        pulumi.set(__self__, "validation_requested_date", validation_requested_date)
        pulumi.set(__self__, "validation_scope", validation_scope)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        Your account's ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: _builtins.str):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Your domain's name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: _builtins.str):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="domainStatus")
    def domain_status(self) -> _builtins.str:
        """
        The domain's validation status. Possible values are: 
        * `REQUEST_ACCEPTED` - When you successfully submit the domain for validation.
        * `VALIDATION_IN_PROGRESS` - When the DOM background jobs are trying to validate the domain.
        * `VALIDATED` - When the validation is completed successfully. Akamai recognizes you as the domain owner.
        * `TOKEN_EXPIRED` - When you haven't completed the validation in the requested time frame and the challenge token is not valid anymore. You need to generate new validation challenges for the domain.
        * `INVALIDATED` - When the domain was invalidated and Akamai doesn't recognize you as its owner.
        """
        return pulumi.get(self, "domain_status")

    @domain_status.setter
    def domain_status(self, value: _builtins.str):
        pulumi.set(self, "domain_status", value)

    @_builtins.property
    @pulumi.getter(name="validationChallenge")
    def validation_challenge(self) -> 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs':
        """
        The domain's validation challenge details.
        """
        return pulumi.get(self, "validation_challenge")

    @validation_challenge.setter
    def validation_challenge(self, value: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs'):
        pulumi.set(self, "validation_challenge", value)

    @_builtins.property
    @pulumi.getter(name="validationCompletedDate")
    def validation_completed_date(self) -> _builtins.str:
        """
        The timestamp indicating when the domain validation was completed.
        """
        return pulumi.get(self, "validation_completed_date")

    @validation_completed_date.setter
    def validation_completed_date(self, value: _builtins.str):
        pulumi.set(self, "validation_completed_date", value)

    @_builtins.property
    @pulumi.getter(name="validationLevel")
    def validation_level(self) -> _builtins.str:
        """
        The domain's validation level, either 'FQDN' (fully qualified domain name) or 'ROOT/WILDCARD'.
        """
        return pulumi.get(self, "validation_level")

    @validation_level.setter
    def validation_level(self, value: _builtins.str):
        pulumi.set(self, "validation_level", value)

    @_builtins.property
    @pulumi.getter(name="validationMethod")
    def validation_method(self) -> _builtins.str:
        """
        The method used to validate the domain. Possible values are: 
        * `DNS_CNAME` - For this method, Akamai generates a `cname_record` that you copy as the `target` to a `CNAME` record of your DNS configuration. The record's name needs to be in the `_acme-challenge.domain-name` format.
        * `DNS_TXT` - For this method, Akamai generates a `txt_record` with a token `value` that you copy as the `target` to a `TXT` record of your DNS configuration. The record's name needs to be in the `_akamai-{host|wildcard|domain}-challenge.domainName` format based on the validation scope.
        * `HTTP` - Applies only to domains with the `HOST` validation scope. For this method, you create the file containing a token and place it on your HTTP server in the location specified by the `validation_challenge.http_file.path` or use a redirect to the `validation_challenge.http_redirect.to` with the token.
        * `SYSTEM` - This method refers to domains that were automatically validated before Domain Validation Manager (DOM) was introduced.
        * `MANUAL` - For this method, the DOM team manually performed the validation.
        """
        return pulumi.get(self, "validation_method")

    @validation_method.setter
    def validation_method(self, value: _builtins.str):
        pulumi.set(self, "validation_method", value)

    @_builtins.property
    @pulumi.getter(name="validationRequestedBy")
    def validation_requested_by(self) -> _builtins.str:
        """
        The name of the user who requested the domain validation.
        """
        return pulumi.get(self, "validation_requested_by")

    @validation_requested_by.setter
    def validation_requested_by(self, value: _builtins.str):
        pulumi.set(self, "validation_requested_by", value)

    @_builtins.property
    @pulumi.getter(name="validationRequestedDate")
    def validation_requested_date(self) -> _builtins.str:
        """
        The timestamp indicating when the domain validation was requested.
        """
        return pulumi.get(self, "validation_requested_date")

    @validation_requested_date.setter
    def validation_requested_date(self, value: _builtins.str):
        pulumi.set(self, "validation_requested_date", value)

    @_builtins.property
    @pulumi.getter(name="validationScope")
    def validation_scope(self) -> _builtins.str:
        """
        Your domain's validation scope. Possible values are: 
        * `HOST` - The scope is only the exactly specified domain.
        * `WILDCARD` - The scope covers any hostname within one subdomain level.
        * `DOMAIN` - The scope covers any hostnames under the domain, regardless of the level of subdomains.
        """
        return pulumi.get(self, "validation_scope")

    @validation_scope.setter
    def validation_scope(self, value: _builtins.str):
        pulumi.set(self, "validation_scope", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgsDict(TypedDict):
        cname_record: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgsDict'
        """
        The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        """
        expiration_date: _builtins.str
        """
        The timestamp indicating when the challenge data expires.
        """
        http_file: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgsDict'
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        """
        http_redirect: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgsDict'
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        """
        txt_record: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgsDict'
        """
        The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeArgs:
    def __init__(__self__, *,
                 cname_record: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs',
                 expiration_date: _builtins.str,
                 http_file: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs',
                 http_redirect: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs',
                 txt_record: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs'):
        """
        :param 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs' cname_record: The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        :param _builtins.str expiration_date: The timestamp indicating when the challenge data expires.
        :param 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs' http_file: Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        :param 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs' http_redirect: Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        :param 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs' txt_record: The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
        pulumi.set(__self__, "cname_record", cname_record)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "http_file", http_file)
        pulumi.set(__self__, "http_redirect", http_redirect)
        pulumi.set(__self__, "txt_record", txt_record)

    @_builtins.property
    @pulumi.getter(name="cnameRecord")
    def cname_record(self) -> 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs':
        """
        The details of the 'CNAME' record you copy to your DNS configuration to prove you own the domain. You should use the 'DNS_CNAME' method in most cases.
        """
        return pulumi.get(self, "cname_record")

    @cname_record.setter
    def cname_record(self, value: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs'):
        pulumi.set(self, "cname_record", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        The timestamp indicating when the challenge data expires.
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: _builtins.str):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="httpFile")
    def http_file(self) -> 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs':
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you create a file containing a token and save it on your HTTP server at the provided URL. Alternatively, you can use the 'http_redirect' method.
        """
        return pulumi.get(self, "http_file")

    @http_file.setter
    def http_file(self, value: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs'):
        pulumi.set(self, "http_file", value)

    @_builtins.property
    @pulumi.getter(name="httpRedirect")
    def http_redirect(self) -> 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs':
        """
        Available only for the 'HOST' validation scope. The details for the HTTP validation method in which you use a redirect URL with the token. Alternatively, you can use the 'http_file' method.
        """
        return pulumi.get(self, "http_redirect")

    @http_redirect.setter
    def http_redirect(self, value: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs'):
        pulumi.set(self, "http_redirect", value)

    @_builtins.property
    @pulumi.getter(name="txtRecord")
    def txt_record(self) -> 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs':
        """
        The details of the 'TXT' record with the challenge token that you copy to your DNS configuration to prove you own the domain.
        """
        return pulumi.get(self, "txt_record")

    @txt_record.setter
    def txt_record(self, value: 'GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs'):
        pulumi.set(self, "txt_record", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgsDict(TypedDict):
        name: _builtins.str
        """
        The 'CNAME' record for your domain that you add to the DNS configuration.
        """
        target: _builtins.str
        """
        The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeCnameRecordArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.str name: The 'CNAME' record for your domain that you add to the DNS configuration.
        :param _builtins.str target: The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The 'CNAME' record for your domain that you add to the DNS configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The 'target' value you set in the 'CNAME' record that validates the domain ownership.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.str):
        pulumi.set(self, "target", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgsDict(TypedDict):
        content: _builtins.str
        """
        The content of the file that you should place at the specified URL.
        """
        content_type: _builtins.str
        """
        The content type of the file containing the token.
        """
        path: _builtins.str
        """
        The URL where you should place the file containing the challenge token.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpFileArgs:
    def __init__(__self__, *,
                 content: _builtins.str,
                 content_type: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str content: The content of the file that you should place at the specified URL.
        :param _builtins.str content_type: The content type of the file containing the token.
        :param _builtins.str path: The URL where you should place the file containing the challenge token.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The content of the file that you should place at the specified URL.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: _builtins.str):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        """
        The content type of the file containing the token.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: _builtins.str):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The URL where you should place the file containing the challenge token.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgsDict(TypedDict):
        from_: _builtins.str
        """
        The location on your HTTP server where you set up the redirect.
        """
        to: _builtins.str
        """
        The redirect URL with the token that you place on your HTTP server.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeHttpRedirectArgs:
    def __init__(__self__, *,
                 from_: _builtins.str,
                 to: _builtins.str):
        """
        :param _builtins.str from_: The location on your HTTP server where you set up the redirect.
        :param _builtins.str to: The redirect URL with the token that you place on your HTTP server.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        """
        The location on your HTTP server where you set up the redirect.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: _builtins.str):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        """
        The redirect URL with the token that you place on your HTTP server.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: _builtins.str):
        pulumi.set(self, "to", value)


if not MYPY:
    class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgsDict(TypedDict):
        name: _builtins.str
        """
        The hostname where you should add the 'TXT' record to validate the domain ownership.
        """
        value: _builtins.str
        """
        The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
elif False:
    GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyDomainownershipSearchDomainsDomainValidationChallengeTxtRecordArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The hostname where you should add the 'TXT' record to validate the domain ownership.
        :param _builtins.str value: The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The hostname where you should add the 'TXT' record to validate the domain ownership.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The token you need to copy to the DNS 'TXT' record that validates the domain ownership.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetPropertyIncludesParentPropertyArgsDict(TypedDict):
        id: _builtins.str
        """
        The property's unique identifier
        """
        version: _builtins.int
        """
        The property's version for which the data is requested
        """
elif False:
    GetPropertyIncludesParentPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyIncludesParentPropertyArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str id: The property's unique identifier
        :param _builtins.int version: The property's version for which the data is requested
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The property's unique identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The property's version for which the data is requested
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: _builtins.int):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetPropertyRulesTemplateTemplateArgsDict(TypedDict):
        template_data: _builtins.str
        """
        Content of the template as string
        """
        template_dir: _builtins.str
        """
        Directory points to a folder, which contains snippets to include into template.
        """
elif False:
    GetPropertyRulesTemplateTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyRulesTemplateTemplateArgs:
    def __init__(__self__, *,
                 template_data: _builtins.str,
                 template_dir: _builtins.str):
        """
        :param _builtins.str template_data: Content of the template as string
        :param _builtins.str template_dir: Directory points to a folder, which contains snippets to include into template.
        """
        pulumi.set(__self__, "template_data", template_data)
        pulumi.set(__self__, "template_dir", template_dir)

    @_builtins.property
    @pulumi.getter(name="templateData")
    def template_data(self) -> _builtins.str:
        """
        Content of the template as string
        """
        return pulumi.get(self, "template_data")

    @template_data.setter
    def template_data(self, value: _builtins.str):
        pulumi.set(self, "template_data", value)

    @_builtins.property
    @pulumi.getter(name="templateDir")
    def template_dir(self) -> _builtins.str:
        """
        Directory points to a folder, which contains snippets to include into template.
        """
        return pulumi.get(self, "template_dir")

    @template_dir.setter
    def template_dir(self, value: _builtins.str):
        pulumi.set(self, "template_dir", value)


if not MYPY:
    class GetPropertyRulesTemplateVariableArgsDict(TypedDict):
        name: _builtins.str
        value: _builtins.str
        type: NotRequired[_builtins.str]
elif False:
    GetPropertyRulesTemplateVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPropertyRulesTemplateVariableArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


