// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package akamai

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-akamai/sdk/v8/go/akamai/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ImagingPolicyVideo struct {
	pulumi.CustomResourceState

	// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
	// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
	// it back to false only when there are any changes to the policy qualifying it for the new version.
	ActivateOnProduction pulumi.BoolPtrOutput `pulumi:"activateOnProduction"`
	// Unique identifier for the Akamai Contract containing the Policy Set(s)
	ContractId pulumi.StringOutput `pulumi:"contractId"`
	// A JSON encoded policy
	Json pulumi.StringOutput `pulumi:"json"`
	// Unique identifier for a Policy. It is not possible to modify the id of the policy.
	PolicyId pulumi.StringOutput `pulumi:"policyId"`
	// Unique identifier for the Image & Video Manager Policy Set.
	PolicysetId pulumi.StringOutput `pulumi:"policysetId"`
	// The version number of this policy version
	Version pulumi.IntOutput `pulumi:"version"`
}

// NewImagingPolicyVideo registers a new resource with the given unique name, arguments, and options.
func NewImagingPolicyVideo(ctx *pulumi.Context,
	name string, args *ImagingPolicyVideoArgs, opts ...pulumi.ResourceOption) (*ImagingPolicyVideo, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ContractId == nil {
		return nil, errors.New("invalid value for required argument 'ContractId'")
	}
	if args.Json == nil {
		return nil, errors.New("invalid value for required argument 'Json'")
	}
	if args.PolicyId == nil {
		return nil, errors.New("invalid value for required argument 'PolicyId'")
	}
	if args.PolicysetId == nil {
		return nil, errors.New("invalid value for required argument 'PolicysetId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ImagingPolicyVideo
	err := ctx.RegisterResource("akamai:index/imagingPolicyVideo:ImagingPolicyVideo", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetImagingPolicyVideo gets an existing ImagingPolicyVideo resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetImagingPolicyVideo(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ImagingPolicyVideoState, opts ...pulumi.ResourceOption) (*ImagingPolicyVideo, error) {
	var resource ImagingPolicyVideo
	err := ctx.ReadResource("akamai:index/imagingPolicyVideo:ImagingPolicyVideo", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ImagingPolicyVideo resources.
type imagingPolicyVideoState struct {
	// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
	// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
	// it back to false only when there are any changes to the policy qualifying it for the new version.
	ActivateOnProduction *bool `pulumi:"activateOnProduction"`
	// Unique identifier for the Akamai Contract containing the Policy Set(s)
	ContractId *string `pulumi:"contractId"`
	// A JSON encoded policy
	Json *string `pulumi:"json"`
	// Unique identifier for a Policy. It is not possible to modify the id of the policy.
	PolicyId *string `pulumi:"policyId"`
	// Unique identifier for the Image & Video Manager Policy Set.
	PolicysetId *string `pulumi:"policysetId"`
	// The version number of this policy version
	Version *int `pulumi:"version"`
}

type ImagingPolicyVideoState struct {
	// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
	// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
	// it back to false only when there are any changes to the policy qualifying it for the new version.
	ActivateOnProduction pulumi.BoolPtrInput
	// Unique identifier for the Akamai Contract containing the Policy Set(s)
	ContractId pulumi.StringPtrInput
	// A JSON encoded policy
	Json pulumi.StringPtrInput
	// Unique identifier for a Policy. It is not possible to modify the id of the policy.
	PolicyId pulumi.StringPtrInput
	// Unique identifier for the Image & Video Manager Policy Set.
	PolicysetId pulumi.StringPtrInput
	// The version number of this policy version
	Version pulumi.IntPtrInput
}

func (ImagingPolicyVideoState) ElementType() reflect.Type {
	return reflect.TypeOf((*imagingPolicyVideoState)(nil)).Elem()
}

type imagingPolicyVideoArgs struct {
	// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
	// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
	// it back to false only when there are any changes to the policy qualifying it for the new version.
	ActivateOnProduction *bool `pulumi:"activateOnProduction"`
	// Unique identifier for the Akamai Contract containing the Policy Set(s)
	ContractId string `pulumi:"contractId"`
	// A JSON encoded policy
	Json string `pulumi:"json"`
	// Unique identifier for a Policy. It is not possible to modify the id of the policy.
	PolicyId string `pulumi:"policyId"`
	// Unique identifier for the Image & Video Manager Policy Set.
	PolicysetId string `pulumi:"policysetId"`
}

// The set of arguments for constructing a ImagingPolicyVideo resource.
type ImagingPolicyVideoArgs struct {
	// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
	// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
	// it back to false only when there are any changes to the policy qualifying it for the new version.
	ActivateOnProduction pulumi.BoolPtrInput
	// Unique identifier for the Akamai Contract containing the Policy Set(s)
	ContractId pulumi.StringInput
	// A JSON encoded policy
	Json pulumi.StringInput
	// Unique identifier for a Policy. It is not possible to modify the id of the policy.
	PolicyId pulumi.StringInput
	// Unique identifier for the Image & Video Manager Policy Set.
	PolicysetId pulumi.StringInput
}

func (ImagingPolicyVideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*imagingPolicyVideoArgs)(nil)).Elem()
}

type ImagingPolicyVideoInput interface {
	pulumi.Input

	ToImagingPolicyVideoOutput() ImagingPolicyVideoOutput
	ToImagingPolicyVideoOutputWithContext(ctx context.Context) ImagingPolicyVideoOutput
}

func (*ImagingPolicyVideo) ElementType() reflect.Type {
	return reflect.TypeOf((**ImagingPolicyVideo)(nil)).Elem()
}

func (i *ImagingPolicyVideo) ToImagingPolicyVideoOutput() ImagingPolicyVideoOutput {
	return i.ToImagingPolicyVideoOutputWithContext(context.Background())
}

func (i *ImagingPolicyVideo) ToImagingPolicyVideoOutputWithContext(ctx context.Context) ImagingPolicyVideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImagingPolicyVideoOutput)
}

// ImagingPolicyVideoArrayInput is an input type that accepts ImagingPolicyVideoArray and ImagingPolicyVideoArrayOutput values.
// You can construct a concrete instance of `ImagingPolicyVideoArrayInput` via:
//
//	ImagingPolicyVideoArray{ ImagingPolicyVideoArgs{...} }
type ImagingPolicyVideoArrayInput interface {
	pulumi.Input

	ToImagingPolicyVideoArrayOutput() ImagingPolicyVideoArrayOutput
	ToImagingPolicyVideoArrayOutputWithContext(context.Context) ImagingPolicyVideoArrayOutput
}

type ImagingPolicyVideoArray []ImagingPolicyVideoInput

func (ImagingPolicyVideoArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ImagingPolicyVideo)(nil)).Elem()
}

func (i ImagingPolicyVideoArray) ToImagingPolicyVideoArrayOutput() ImagingPolicyVideoArrayOutput {
	return i.ToImagingPolicyVideoArrayOutputWithContext(context.Background())
}

func (i ImagingPolicyVideoArray) ToImagingPolicyVideoArrayOutputWithContext(ctx context.Context) ImagingPolicyVideoArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImagingPolicyVideoArrayOutput)
}

// ImagingPolicyVideoMapInput is an input type that accepts ImagingPolicyVideoMap and ImagingPolicyVideoMapOutput values.
// You can construct a concrete instance of `ImagingPolicyVideoMapInput` via:
//
//	ImagingPolicyVideoMap{ "key": ImagingPolicyVideoArgs{...} }
type ImagingPolicyVideoMapInput interface {
	pulumi.Input

	ToImagingPolicyVideoMapOutput() ImagingPolicyVideoMapOutput
	ToImagingPolicyVideoMapOutputWithContext(context.Context) ImagingPolicyVideoMapOutput
}

type ImagingPolicyVideoMap map[string]ImagingPolicyVideoInput

func (ImagingPolicyVideoMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ImagingPolicyVideo)(nil)).Elem()
}

func (i ImagingPolicyVideoMap) ToImagingPolicyVideoMapOutput() ImagingPolicyVideoMapOutput {
	return i.ToImagingPolicyVideoMapOutputWithContext(context.Background())
}

func (i ImagingPolicyVideoMap) ToImagingPolicyVideoMapOutputWithContext(ctx context.Context) ImagingPolicyVideoMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImagingPolicyVideoMapOutput)
}

type ImagingPolicyVideoOutput struct{ *pulumi.OutputState }

func (ImagingPolicyVideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImagingPolicyVideo)(nil)).Elem()
}

func (o ImagingPolicyVideoOutput) ToImagingPolicyVideoOutput() ImagingPolicyVideoOutput {
	return o
}

func (o ImagingPolicyVideoOutput) ToImagingPolicyVideoOutputWithContext(ctx context.Context) ImagingPolicyVideoOutput {
	return o
}

// With this flag set to false, the user can perform modifications on staging without affecting the version already saved
// to production. With this flag set to true, the policy will be saved on the production network. It is possible to change
// it back to false only when there are any changes to the policy qualifying it for the new version.
func (o ImagingPolicyVideoOutput) ActivateOnProduction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.BoolPtrOutput { return v.ActivateOnProduction }).(pulumi.BoolPtrOutput)
}

// Unique identifier for the Akamai Contract containing the Policy Set(s)
func (o ImagingPolicyVideoOutput) ContractId() pulumi.StringOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.StringOutput { return v.ContractId }).(pulumi.StringOutput)
}

// A JSON encoded policy
func (o ImagingPolicyVideoOutput) Json() pulumi.StringOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.StringOutput { return v.Json }).(pulumi.StringOutput)
}

// Unique identifier for a Policy. It is not possible to modify the id of the policy.
func (o ImagingPolicyVideoOutput) PolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.StringOutput { return v.PolicyId }).(pulumi.StringOutput)
}

// Unique identifier for the Image & Video Manager Policy Set.
func (o ImagingPolicyVideoOutput) PolicysetId() pulumi.StringOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.StringOutput { return v.PolicysetId }).(pulumi.StringOutput)
}

// The version number of this policy version
func (o ImagingPolicyVideoOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *ImagingPolicyVideo) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

type ImagingPolicyVideoArrayOutput struct{ *pulumi.OutputState }

func (ImagingPolicyVideoArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ImagingPolicyVideo)(nil)).Elem()
}

func (o ImagingPolicyVideoArrayOutput) ToImagingPolicyVideoArrayOutput() ImagingPolicyVideoArrayOutput {
	return o
}

func (o ImagingPolicyVideoArrayOutput) ToImagingPolicyVideoArrayOutputWithContext(ctx context.Context) ImagingPolicyVideoArrayOutput {
	return o
}

func (o ImagingPolicyVideoArrayOutput) Index(i pulumi.IntInput) ImagingPolicyVideoOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ImagingPolicyVideo {
		return vs[0].([]*ImagingPolicyVideo)[vs[1].(int)]
	}).(ImagingPolicyVideoOutput)
}

type ImagingPolicyVideoMapOutput struct{ *pulumi.OutputState }

func (ImagingPolicyVideoMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ImagingPolicyVideo)(nil)).Elem()
}

func (o ImagingPolicyVideoMapOutput) ToImagingPolicyVideoMapOutput() ImagingPolicyVideoMapOutput {
	return o
}

func (o ImagingPolicyVideoMapOutput) ToImagingPolicyVideoMapOutputWithContext(ctx context.Context) ImagingPolicyVideoMapOutput {
	return o
}

func (o ImagingPolicyVideoMapOutput) MapIndex(k pulumi.StringInput) ImagingPolicyVideoOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ImagingPolicyVideo {
		return vs[0].(map[string]*ImagingPolicyVideo)[vs[1].(string)]
	}).(ImagingPolicyVideoOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ImagingPolicyVideoInput)(nil)).Elem(), &ImagingPolicyVideo{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImagingPolicyVideoArrayInput)(nil)).Elem(), ImagingPolicyVideoArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImagingPolicyVideoMapInput)(nil)).Elem(), ImagingPolicyVideoMap{})
	pulumi.RegisterOutputType(ImagingPolicyVideoOutput{})
	pulumi.RegisterOutputType(ImagingPolicyVideoArrayOutput{})
	pulumi.RegisterOutputType(ImagingPolicyVideoMapOutput{})
}
