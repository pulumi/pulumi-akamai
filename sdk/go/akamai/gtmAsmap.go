// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package akamai

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use the `GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.
//
// You can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.
//
// > **Note** Import requires an ID with this format: `existingDomainName`:`existingMapName`.
//
// ## Example Usage
//
// Basic usage:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-akamai/sdk/v2/go/akamai"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := akamai.NewGtmAsmap(ctx, "demoAsmap", &akamai.GtmAsmapArgs{
// 			DefaultDatacenter: &GtmAsmapDefaultDatacenterArgs{
// 				DatacenterId: pulumi.Int(5400),
// 				Nickname:     pulumi.String("All Other AS numbers"),
// 			},
// 			Domain: pulumi.String("demo_domain.akadns.net"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Schema reference
//
// You can download the GTM AS Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#asmap) page.
type GtmAsmap struct {
	pulumi.CustomResourceState

	// Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
	Assignments GtmAsmapAssignmentArrayOutput `pulumi:"assignments"`
	// A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
	DefaultDatacenter GtmAsmapDefaultDatacenterOutput `pulumi:"defaultDatacenter"`
	// The GTM Domain name for the AS map.
	Domain pulumi.StringOutput `pulumi:"domain"`
	// A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
	Name pulumi.StringOutput `pulumi:"name"`
	// A boolean that, if `true`, waits for transaction to complete.
	WaitOnComplete pulumi.BoolPtrOutput `pulumi:"waitOnComplete"`
}

// NewGtmAsmap registers a new resource with the given unique name, arguments, and options.
func NewGtmAsmap(ctx *pulumi.Context,
	name string, args *GtmAsmapArgs, opts ...pulumi.ResourceOption) (*GtmAsmap, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultDatacenter == nil {
		return nil, errors.New("invalid value for required argument 'DefaultDatacenter'")
	}
	if args.Domain == nil {
		return nil, errors.New("invalid value for required argument 'Domain'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("akamai:trafficmanagement/gtmASmap:GtmASmap"),
		},
	})
	opts = append(opts, aliases)
	var resource GtmAsmap
	err := ctx.RegisterResource("akamai:index/gtmAsmap:GtmAsmap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGtmAsmap gets an existing GtmAsmap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGtmAsmap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GtmAsmapState, opts ...pulumi.ResourceOption) (*GtmAsmap, error) {
	var resource GtmAsmap
	err := ctx.ReadResource("akamai:index/gtmAsmap:GtmAsmap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GtmAsmap resources.
type gtmAsmapState struct {
	// Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
	Assignments []GtmAsmapAssignment `pulumi:"assignments"`
	// A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
	DefaultDatacenter *GtmAsmapDefaultDatacenter `pulumi:"defaultDatacenter"`
	// The GTM Domain name for the AS map.
	Domain *string `pulumi:"domain"`
	// A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
	Name *string `pulumi:"name"`
	// A boolean that, if `true`, waits for transaction to complete.
	WaitOnComplete *bool `pulumi:"waitOnComplete"`
}

type GtmAsmapState struct {
	// Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
	Assignments GtmAsmapAssignmentArrayInput
	// A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
	DefaultDatacenter GtmAsmapDefaultDatacenterPtrInput
	// The GTM Domain name for the AS map.
	Domain pulumi.StringPtrInput
	// A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
	Name pulumi.StringPtrInput
	// A boolean that, if `true`, waits for transaction to complete.
	WaitOnComplete pulumi.BoolPtrInput
}

func (GtmAsmapState) ElementType() reflect.Type {
	return reflect.TypeOf((*gtmAsmapState)(nil)).Elem()
}

type gtmAsmapArgs struct {
	// Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
	Assignments []GtmAsmapAssignment `pulumi:"assignments"`
	// A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
	DefaultDatacenter GtmAsmapDefaultDatacenter `pulumi:"defaultDatacenter"`
	// The GTM Domain name for the AS map.
	Domain string `pulumi:"domain"`
	// A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
	Name *string `pulumi:"name"`
	// A boolean that, if `true`, waits for transaction to complete.
	WaitOnComplete *bool `pulumi:"waitOnComplete"`
}

// The set of arguments for constructing a GtmAsmap resource.
type GtmAsmapArgs struct {
	// Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
	Assignments GtmAsmapAssignmentArrayInput
	// A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
	DefaultDatacenter GtmAsmapDefaultDatacenterInput
	// The GTM Domain name for the AS map.
	Domain pulumi.StringInput
	// A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
	Name pulumi.StringPtrInput
	// A boolean that, if `true`, waits for transaction to complete.
	WaitOnComplete pulumi.BoolPtrInput
}

func (GtmAsmapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*gtmAsmapArgs)(nil)).Elem()
}

type GtmAsmapInput interface {
	pulumi.Input

	ToGtmAsmapOutput() GtmAsmapOutput
	ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput
}

func (*GtmAsmap) ElementType() reflect.Type {
	return reflect.TypeOf((**GtmAsmap)(nil)).Elem()
}

func (i *GtmAsmap) ToGtmAsmapOutput() GtmAsmapOutput {
	return i.ToGtmAsmapOutputWithContext(context.Background())
}

func (i *GtmAsmap) ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapOutput)
}

// GtmAsmapArrayInput is an input type that accepts GtmAsmapArray and GtmAsmapArrayOutput values.
// You can construct a concrete instance of `GtmAsmapArrayInput` via:
//
//          GtmAsmapArray{ GtmAsmapArgs{...} }
type GtmAsmapArrayInput interface {
	pulumi.Input

	ToGtmAsmapArrayOutput() GtmAsmapArrayOutput
	ToGtmAsmapArrayOutputWithContext(context.Context) GtmAsmapArrayOutput
}

type GtmAsmapArray []GtmAsmapInput

func (GtmAsmapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GtmAsmap)(nil)).Elem()
}

func (i GtmAsmapArray) ToGtmAsmapArrayOutput() GtmAsmapArrayOutput {
	return i.ToGtmAsmapArrayOutputWithContext(context.Background())
}

func (i GtmAsmapArray) ToGtmAsmapArrayOutputWithContext(ctx context.Context) GtmAsmapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapArrayOutput)
}

// GtmAsmapMapInput is an input type that accepts GtmAsmapMap and GtmAsmapMapOutput values.
// You can construct a concrete instance of `GtmAsmapMapInput` via:
//
//          GtmAsmapMap{ "key": GtmAsmapArgs{...} }
type GtmAsmapMapInput interface {
	pulumi.Input

	ToGtmAsmapMapOutput() GtmAsmapMapOutput
	ToGtmAsmapMapOutputWithContext(context.Context) GtmAsmapMapOutput
}

type GtmAsmapMap map[string]GtmAsmapInput

func (GtmAsmapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GtmAsmap)(nil)).Elem()
}

func (i GtmAsmapMap) ToGtmAsmapMapOutput() GtmAsmapMapOutput {
	return i.ToGtmAsmapMapOutputWithContext(context.Background())
}

func (i GtmAsmapMap) ToGtmAsmapMapOutputWithContext(ctx context.Context) GtmAsmapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GtmAsmapMapOutput)
}

type GtmAsmapOutput struct{ *pulumi.OutputState }

func (GtmAsmapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GtmAsmap)(nil)).Elem()
}

func (o GtmAsmapOutput) ToGtmAsmapOutput() GtmAsmapOutput {
	return o
}

func (o GtmAsmapOutput) ToGtmAsmapOutputWithContext(ctx context.Context) GtmAsmapOutput {
	return o
}

type GtmAsmapArrayOutput struct{ *pulumi.OutputState }

func (GtmAsmapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GtmAsmap)(nil)).Elem()
}

func (o GtmAsmapArrayOutput) ToGtmAsmapArrayOutput() GtmAsmapArrayOutput {
	return o
}

func (o GtmAsmapArrayOutput) ToGtmAsmapArrayOutputWithContext(ctx context.Context) GtmAsmapArrayOutput {
	return o
}

func (o GtmAsmapArrayOutput) Index(i pulumi.IntInput) GtmAsmapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GtmAsmap {
		return vs[0].([]*GtmAsmap)[vs[1].(int)]
	}).(GtmAsmapOutput)
}

type GtmAsmapMapOutput struct{ *pulumi.OutputState }

func (GtmAsmapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GtmAsmap)(nil)).Elem()
}

func (o GtmAsmapMapOutput) ToGtmAsmapMapOutput() GtmAsmapMapOutput {
	return o
}

func (o GtmAsmapMapOutput) ToGtmAsmapMapOutputWithContext(ctx context.Context) GtmAsmapMapOutput {
	return o
}

func (o GtmAsmapMapOutput) MapIndex(k pulumi.StringInput) GtmAsmapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GtmAsmap {
		return vs[0].(map[string]*GtmAsmap)[vs[1].(string)]
	}).(GtmAsmapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapInput)(nil)).Elem(), &GtmAsmap{})
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapArrayInput)(nil)).Elem(), GtmAsmapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GtmAsmapMapInput)(nil)).Elem(), GtmAsmapMap{})
	pulumi.RegisterOutputType(GtmAsmapOutput{})
	pulumi.RegisterOutputType(GtmAsmapArrayOutput{})
	pulumi.RegisterOutputType(GtmAsmapMapOutput{})
}
