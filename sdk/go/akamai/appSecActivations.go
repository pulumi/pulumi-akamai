// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package akamai

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// **Scopes**: Security configuration
//
// Activates or deactivates a security configuration. Security configurations activated on the staging network can be used for testing and fine-tuning; security configurations activated on the production network are used to protect your actual websites.
//
// Note that activation fails if the security configuration includes one or more invalid hostnames. You can find these names in the resulting activation error message. To activate the configuration, remove the invalid hosts and try again.
//
// **Related API Endpoint**: [/appsec/v1/activations](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postactivations)
//
// ## Example Usage
//
// Basic usage:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-akamai/sdk/v2/go/akamai"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		configuration, err := akamai.LookupAppSecConfiguration(ctx, &GetAppSecConfigurationArgs{
// 			Name: pulumi.StringRef("Documentation"),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = akamai.NewAppSecActivations(ctx, "activation", &akamai.AppSecActivationsArgs{
// 			ConfigId: pulumi.Int(configuration.ConfigId),
// 			Network:  pulumi.String("STAGING"),
// 			Notes:    pulumi.String("This configuration was activated for testing purposes only."),
// 			NotificationEmails: pulumi.StringArray{
// 				pulumi.String("user@example.com"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Output Options
//
// The following options can be used to determine the information returned, and how that returned information is formatted:
//
// - `status`. Status of the operation. Valid values are:
//
//   *   **ACTIVATED**
//   *   **DEACTIVATED**
//   *   **FAILED**
type AppSecActivations struct {
	pulumi.CustomResourceState

	// . Set to **true** to activate the specified security configuration; set to **false** to deactivate the configuration. If not included, the security configuration will be activated.
	Activate pulumi.BoolPtrOutput `pulumi:"activate"`
	// . Unique identifier of the security configuration being activated.
	ConfigId pulumi.IntOutput `pulumi:"configId"`
	// . Network on which activation will occur; allowed values are:
	Network pulumi.StringPtrOutput `pulumi:"network"`
	// . Brief description of the activation/deactivation process. Note that, if no attributes have changed since the last time you called the AppSecActivations resource, neither activation nor deactivation takes place: that's because *something* must be different in order to trigger the activation/deactivation process. With that in mind, it's recommended that you always update the `notes` argument. That ensures that the resource will be called and that activation or deactivation will occur.
	Notes pulumi.StringOutput `pulumi:"notes"`
	// . JSON array containing the email addresses of the people to be notified when activation is complete.
	NotificationEmails pulumi.StringArrayOutput `pulumi:"notificationEmails"`
	Status             pulumi.StringOutput      `pulumi:"status"`
}

// NewAppSecActivations registers a new resource with the given unique name, arguments, and options.
func NewAppSecActivations(ctx *pulumi.Context,
	name string, args *AppSecActivationsArgs, opts ...pulumi.ResourceOption) (*AppSecActivations, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConfigId == nil {
		return nil, errors.New("invalid value for required argument 'ConfigId'")
	}
	if args.Notes == nil {
		return nil, errors.New("invalid value for required argument 'Notes'")
	}
	if args.NotificationEmails == nil {
		return nil, errors.New("invalid value for required argument 'NotificationEmails'")
	}
	var resource AppSecActivations
	err := ctx.RegisterResource("akamai:index/appSecActivations:AppSecActivations", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAppSecActivations gets an existing AppSecActivations resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAppSecActivations(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AppSecActivationsState, opts ...pulumi.ResourceOption) (*AppSecActivations, error) {
	var resource AppSecActivations
	err := ctx.ReadResource("akamai:index/appSecActivations:AppSecActivations", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AppSecActivations resources.
type appSecActivationsState struct {
	// . Set to **true** to activate the specified security configuration; set to **false** to deactivate the configuration. If not included, the security configuration will be activated.
	Activate *bool `pulumi:"activate"`
	// . Unique identifier of the security configuration being activated.
	ConfigId *int `pulumi:"configId"`
	// . Network on which activation will occur; allowed values are:
	Network *string `pulumi:"network"`
	// . Brief description of the activation/deactivation process. Note that, if no attributes have changed since the last time you called the AppSecActivations resource, neither activation nor deactivation takes place: that's because *something* must be different in order to trigger the activation/deactivation process. With that in mind, it's recommended that you always update the `notes` argument. That ensures that the resource will be called and that activation or deactivation will occur.
	Notes *string `pulumi:"notes"`
	// . JSON array containing the email addresses of the people to be notified when activation is complete.
	NotificationEmails []string `pulumi:"notificationEmails"`
	Status             *string  `pulumi:"status"`
}

type AppSecActivationsState struct {
	// . Set to **true** to activate the specified security configuration; set to **false** to deactivate the configuration. If not included, the security configuration will be activated.
	Activate pulumi.BoolPtrInput
	// . Unique identifier of the security configuration being activated.
	ConfigId pulumi.IntPtrInput
	// . Network on which activation will occur; allowed values are:
	Network pulumi.StringPtrInput
	// . Brief description of the activation/deactivation process. Note that, if no attributes have changed since the last time you called the AppSecActivations resource, neither activation nor deactivation takes place: that's because *something* must be different in order to trigger the activation/deactivation process. With that in mind, it's recommended that you always update the `notes` argument. That ensures that the resource will be called and that activation or deactivation will occur.
	Notes pulumi.StringPtrInput
	// . JSON array containing the email addresses of the people to be notified when activation is complete.
	NotificationEmails pulumi.StringArrayInput
	Status             pulumi.StringPtrInput
}

func (AppSecActivationsState) ElementType() reflect.Type {
	return reflect.TypeOf((*appSecActivationsState)(nil)).Elem()
}

type appSecActivationsArgs struct {
	// . Set to **true** to activate the specified security configuration; set to **false** to deactivate the configuration. If not included, the security configuration will be activated.
	Activate *bool `pulumi:"activate"`
	// . Unique identifier of the security configuration being activated.
	ConfigId int `pulumi:"configId"`
	// . Network on which activation will occur; allowed values are:
	Network *string `pulumi:"network"`
	// . Brief description of the activation/deactivation process. Note that, if no attributes have changed since the last time you called the AppSecActivations resource, neither activation nor deactivation takes place: that's because *something* must be different in order to trigger the activation/deactivation process. With that in mind, it's recommended that you always update the `notes` argument. That ensures that the resource will be called and that activation or deactivation will occur.
	Notes string `pulumi:"notes"`
	// . JSON array containing the email addresses of the people to be notified when activation is complete.
	NotificationEmails []string `pulumi:"notificationEmails"`
}

// The set of arguments for constructing a AppSecActivations resource.
type AppSecActivationsArgs struct {
	// . Set to **true** to activate the specified security configuration; set to **false** to deactivate the configuration. If not included, the security configuration will be activated.
	Activate pulumi.BoolPtrInput
	// . Unique identifier of the security configuration being activated.
	ConfigId pulumi.IntInput
	// . Network on which activation will occur; allowed values are:
	Network pulumi.StringPtrInput
	// . Brief description of the activation/deactivation process. Note that, if no attributes have changed since the last time you called the AppSecActivations resource, neither activation nor deactivation takes place: that's because *something* must be different in order to trigger the activation/deactivation process. With that in mind, it's recommended that you always update the `notes` argument. That ensures that the resource will be called and that activation or deactivation will occur.
	Notes pulumi.StringInput
	// . JSON array containing the email addresses of the people to be notified when activation is complete.
	NotificationEmails pulumi.StringArrayInput
}

func (AppSecActivationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*appSecActivationsArgs)(nil)).Elem()
}

type AppSecActivationsInput interface {
	pulumi.Input

	ToAppSecActivationsOutput() AppSecActivationsOutput
	ToAppSecActivationsOutputWithContext(ctx context.Context) AppSecActivationsOutput
}

func (*AppSecActivations) ElementType() reflect.Type {
	return reflect.TypeOf((**AppSecActivations)(nil)).Elem()
}

func (i *AppSecActivations) ToAppSecActivationsOutput() AppSecActivationsOutput {
	return i.ToAppSecActivationsOutputWithContext(context.Background())
}

func (i *AppSecActivations) ToAppSecActivationsOutputWithContext(ctx context.Context) AppSecActivationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppSecActivationsOutput)
}

// AppSecActivationsArrayInput is an input type that accepts AppSecActivationsArray and AppSecActivationsArrayOutput values.
// You can construct a concrete instance of `AppSecActivationsArrayInput` via:
//
//          AppSecActivationsArray{ AppSecActivationsArgs{...} }
type AppSecActivationsArrayInput interface {
	pulumi.Input

	ToAppSecActivationsArrayOutput() AppSecActivationsArrayOutput
	ToAppSecActivationsArrayOutputWithContext(context.Context) AppSecActivationsArrayOutput
}

type AppSecActivationsArray []AppSecActivationsInput

func (AppSecActivationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppSecActivations)(nil)).Elem()
}

func (i AppSecActivationsArray) ToAppSecActivationsArrayOutput() AppSecActivationsArrayOutput {
	return i.ToAppSecActivationsArrayOutputWithContext(context.Background())
}

func (i AppSecActivationsArray) ToAppSecActivationsArrayOutputWithContext(ctx context.Context) AppSecActivationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppSecActivationsArrayOutput)
}

// AppSecActivationsMapInput is an input type that accepts AppSecActivationsMap and AppSecActivationsMapOutput values.
// You can construct a concrete instance of `AppSecActivationsMapInput` via:
//
//          AppSecActivationsMap{ "key": AppSecActivationsArgs{...} }
type AppSecActivationsMapInput interface {
	pulumi.Input

	ToAppSecActivationsMapOutput() AppSecActivationsMapOutput
	ToAppSecActivationsMapOutputWithContext(context.Context) AppSecActivationsMapOutput
}

type AppSecActivationsMap map[string]AppSecActivationsInput

func (AppSecActivationsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppSecActivations)(nil)).Elem()
}

func (i AppSecActivationsMap) ToAppSecActivationsMapOutput() AppSecActivationsMapOutput {
	return i.ToAppSecActivationsMapOutputWithContext(context.Background())
}

func (i AppSecActivationsMap) ToAppSecActivationsMapOutputWithContext(ctx context.Context) AppSecActivationsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppSecActivationsMapOutput)
}

type AppSecActivationsOutput struct{ *pulumi.OutputState }

func (AppSecActivationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppSecActivations)(nil)).Elem()
}

func (o AppSecActivationsOutput) ToAppSecActivationsOutput() AppSecActivationsOutput {
	return o
}

func (o AppSecActivationsOutput) ToAppSecActivationsOutputWithContext(ctx context.Context) AppSecActivationsOutput {
	return o
}

type AppSecActivationsArrayOutput struct{ *pulumi.OutputState }

func (AppSecActivationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppSecActivations)(nil)).Elem()
}

func (o AppSecActivationsArrayOutput) ToAppSecActivationsArrayOutput() AppSecActivationsArrayOutput {
	return o
}

func (o AppSecActivationsArrayOutput) ToAppSecActivationsArrayOutputWithContext(ctx context.Context) AppSecActivationsArrayOutput {
	return o
}

func (o AppSecActivationsArrayOutput) Index(i pulumi.IntInput) AppSecActivationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AppSecActivations {
		return vs[0].([]*AppSecActivations)[vs[1].(int)]
	}).(AppSecActivationsOutput)
}

type AppSecActivationsMapOutput struct{ *pulumi.OutputState }

func (AppSecActivationsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppSecActivations)(nil)).Elem()
}

func (o AppSecActivationsMapOutput) ToAppSecActivationsMapOutput() AppSecActivationsMapOutput {
	return o
}

func (o AppSecActivationsMapOutput) ToAppSecActivationsMapOutputWithContext(ctx context.Context) AppSecActivationsMapOutput {
	return o
}

func (o AppSecActivationsMapOutput) MapIndex(k pulumi.StringInput) AppSecActivationsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AppSecActivations {
		return vs[0].(map[string]*AppSecActivations)[vs[1].(string)]
	}).(AppSecActivationsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AppSecActivationsInput)(nil)).Elem(), &AppSecActivations{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppSecActivationsArrayInput)(nil)).Elem(), AppSecActivationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppSecActivationsMapInput)(nil)).Elem(), AppSecActivationsMap{})
	pulumi.RegisterOutputType(AppSecActivationsOutput{})
	pulumi.RegisterOutputType(AppSecActivationsArrayOutput{})
	pulumi.RegisterOutputType(AppSecActivationsMapOutput{})
}
