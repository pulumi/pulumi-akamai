// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs extends com.pulumi.resources.ResourceArgs {

    public static final GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs Empty = new GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs();

    /**
     * Specifies the algorithm to apply.
     * 
     */
    @Import(name="algorithm")
    private @Nullable Output<String> algorithm;

    /**
     * @return Specifies the algorithm to apply.
     * 
     */
    public Optional<Output<String>> algorithm() {
        return Optional.ofNullable(this.algorithm);
    }

    /**
     * Enabling this makes all matches case sensitive.
     * 
     */
    @Import(name="caseSensitive")
    private @Nullable Output<Boolean> caseSensitive;

    /**
     * @return Enabling this makes all matches case sensitive.
     * 
     */
    public Optional<Output<Boolean>> caseSensitive() {
        return Optional.ofNullable(this.caseSensitive);
    }

    /**
     * Specifies the certificate&#39;s content.
     * 
     */
    @Import(name="certificateFieldName")
    private @Nullable Output<String> certificateFieldName;

    /**
     * @return Specifies the certificate&#39;s content.
     * 
     */
    public Optional<Output<String>> certificateFieldName() {
        return Optional.ofNullable(this.certificateFieldName);
    }

    /**
     * Specifies the name of the cookie to extract.
     * 
     */
    @Import(name="cookieName")
    private @Nullable Output<String> cookieName;

    /**
     * @return Specifies the name of the cookie to extract.
     * 
     */
    public Optional<Output<String>> cookieName() {
        return Optional.ofNullable(this.cookieName);
    }

    /**
     * Specifies the client device attribute. Possible values specify information about the client device, including device type, size and browser. For details on fields, see `Device Characterization`.
     * 
     */
    @Import(name="deviceProfile")
    private @Nullable Output<String> deviceProfile;

    /**
     * @return Specifies the client device attribute. Possible values specify information about the client device, including device type, size and browser. For details on fields, see `Device Characterization`.
     * 
     */
    public Optional<Output<String>> deviceProfile() {
        return Optional.ofNullable(this.deviceProfile);
    }

    /**
     * Specifies the encryption hex key. For `ALG_3DES` it needs to be 48 characters long, 32 characters for `ALG_AES128`, and 64 characters for `ALG_AES256`.
     * 
     */
    @Import(name="encryptionKey")
    private @Nullable Output<String> encryptionKey;

    /**
     * @return Specifies the encryption hex key. For `ALG_3DES` it needs to be 48 characters long, 32 characters for `ALG_AES128`, and 64 characters for `ALG_AES256`.
     * 
     */
    public Optional<Output<String>> encryptionKey() {
        return Optional.ofNullable(this.encryptionKey);
    }

    /**
     * Specifies the encryption mode.
     * 
     */
    @Import(name="encryptionMode")
    private @Nullable Output<String> encryptionMode;

    /**
     * @return Specifies the encryption mode.
     * 
     */
    public Optional<Output<String>> encryptionMode() {
        return Optional.ofNullable(this.encryptionMode);
    }

    /**
     * Specifies the zero-based character offset at the end of the substring, without including the character at that index position. Negative indexes specify the offset from the end of the string.
     * 
     */
    @Import(name="endIndex")
    private @Nullable Output<Integer> endIndex;

    /**
     * @return Specifies the zero-based character offset at the end of the substring, without including the character at that index position. Negative indexes specify the offset from the end of the string.
     * 
     */
    public Optional<Output<Integer>> endIndex() {
        return Optional.ofNullable(this.endIndex);
    }

    /**
     * Specifies characters `not` to encode, possibly overriding the default set.
     * 
     */
    @Import(name="exceptChars")
    private @Nullable Output<String> exceptChars;

    /**
     * @return Specifies characters `not` to encode, possibly overriding the default set.
     * 
     */
    public Optional<Output<String>> exceptChars() {
        return Optional.ofNullable(this.exceptChars);
    }

    /**
     * This specifies from where to get the value.
     * 
     */
    @Import(name="extractLocation")
    private @Nullable Output<String> extractLocation;

    /**
     * @return This specifies from where to get the value.
     * 
     */
    public Optional<Output<String>> extractLocation() {
        return Optional.ofNullable(this.extractLocation);
    }

    /**
     * Specifies characters to encode, possibly overriding the default set.
     * 
     */
    @Import(name="forceChars")
    private @Nullable Output<String> forceChars;

    /**
     * @return Specifies characters to encode, possibly overriding the default set.
     * 
     */
    public Optional<Output<String>> forceChars() {
        return Optional.ofNullable(this.forceChars);
    }

    /**
     * Specifies an optional format string for the conversion, using format codes such as `%m/%d/%y` as specified by `strftime`. A blank value defaults to RFC-2616 format.
     * 
     */
    @Import(name="formatString")
    private @Nullable Output<String> formatString;

    /**
     * @return Specifies an optional format string for the conversion, using format codes such as `%m/%d/%y` as specified by `strftime`. A blank value defaults to RFC-2616 format.
     * 
     */
    public Optional<Output<String>> formatString() {
        return Optional.ofNullable(this.formatString);
    }

    /**
     * This specifies the type of value to generate.
     * 
     */
    @Import(name="generator")
    private @Nullable Output<String> generator;

    /**
     * @return This specifies the type of value to generate.
     * 
     */
    public Optional<Output<String>> generator() {
        return Optional.ofNullable(this.generator);
    }

    /**
     * Replaces all matches in the string, not just the first.
     * 
     */
    @Import(name="globalSubstitution")
    private @Nullable Output<Boolean> globalSubstitution;

    /**
     * @return Replaces all matches in the string, not just the first.
     * 
     */
    public Optional<Output<Boolean>> globalSubstitution() {
        return Optional.ofNullable(this.globalSubstitution);
    }

    /**
     * Specifies the case-insensitive name of the HTTP header to extract.
     * 
     */
    @Import(name="headerName")
    private @Nullable Output<String> headerName;

    /**
     * @return Specifies the case-insensitive name of the HTTP header to extract.
     * 
     */
    public Optional<Output<String>> headerName() {
        return Optional.ofNullable(this.headerName);
    }

    /**
     * Specifies the algorithm to use to generate the base64-encoded digest.
     * 
     */
    @Import(name="hmacAlgorithm")
    private @Nullable Output<String> hmacAlgorithm;

    /**
     * @return Specifies the algorithm to use to generate the base64-encoded digest.
     * 
     */
    public Optional<Output<String>> hmacAlgorithm() {
        return Optional.ofNullable(this.hmacAlgorithm);
    }

    /**
     * Specifies the secret to use in generating the base64-encoded digest.
     * 
     */
    @Import(name="hmacKey")
    private @Nullable Output<String> hmacKey;

    /**
     * @return Specifies the secret to use in generating the base64-encoded digest.
     * 
     */
    public Optional<Output<String>> hmacKey() {
        return Optional.ofNullable(this.hmacKey);
    }

    /**
     * Specifies a one-time number as an initialization vector.  It needs to be 15 characters long for `ALG_3DES`, and 32 characters for both `ALG_AES128` and `ALG_AES256`.
     * 
     */
    @Import(name="initializationVector")
    private @Nullable Output<String> initializationVector;

    /**
     * @return Specifies a one-time number as an initialization vector.  It needs to be 15 characters long for `ALG_3DES`, and 32 characters for both `ALG_AES128` and `ALG_AES256`.
     * 
     */
    public Optional<Output<String>> initializationVector() {
        return Optional.ofNullable(this.initializationVector);
    }

    /**
     * Specifies the IP version under which a subnet mask generates.
     * 
     */
    @Import(name="ipVersion")
    private @Nullable Output<String> ipVersion;

    /**
     * @return Specifies the IP version under which a subnet mask generates.
     * 
     */
    public Optional<Output<String>> ipVersion() {
        return Optional.ofNullable(this.ipVersion);
    }

    /**
     * Specifies the prefix of the IPV4 address, a value between 0 and 32.
     * 
     */
    @Import(name="ipv4Prefix")
    private @Nullable Output<Integer> ipv4Prefix;

    /**
     * @return Specifies the prefix of the IPV4 address, a value between 0 and 32.
     * 
     */
    public Optional<Output<Integer>> ipv4Prefix() {
        return Optional.ofNullable(this.ipv4Prefix);
    }

    /**
     * Specifies the prefix of the IPV6 address, a value between 0 and 128.
     * 
     */
    @Import(name="ipv6Prefix")
    private @Nullable Output<Integer> ipv6Prefix;

    /**
     * @return Specifies the prefix of the IPV6 address, a value between 0 and 128.
     * 
     */
    public Optional<Output<Integer>> ipv6Prefix() {
        return Optional.ofNullable(this.ipv6Prefix);
    }

    /**
     * Specifies the `X-Akamai-Edgescape` header&#39;s field name. Possible values specify basic geolocation, various geographic standards, and information about the client&#39;s network. For details on EdgeScape header fields, see the `EdgeScape User Guide`.
     * 
     */
    @Import(name="locationId")
    private @Nullable Output<String> locationId;

    /**
     * @return Specifies the `X-Akamai-Edgescape` header&#39;s field name. Possible values specify basic geolocation, various geographic standards, and information about the client&#39;s network. For details on EdgeScape header fields, see the `EdgeScape User Guide`.
     * 
     */
    public Optional<Output<String>> locationId() {
        return Optional.ofNullable(this.locationId);
    }

    /**
     * Indicates that your Akamai representative has locked this behavior or criteria so that you can&#39;t modify it. This option is for internal usage only.
     * 
     */
    @Import(name="locked")
    private @Nullable Output<Boolean> locked;

    /**
     * @return Indicates that your Akamai representative has locked this behavior or criteria so that you can&#39;t modify it. This option is for internal usage only.
     * 
     */
    public Optional<Output<Boolean>> locked() {
        return Optional.ofNullable(this.locked);
    }

    /**
     * Specifies a maximum value for the generated integer.
     * 
     */
    @Import(name="max")
    private @Nullable Output<Integer> max;

    /**
     * @return Specifies a maximum value for the generated integer.
     * 
     */
    public Optional<Output<Integer>> max() {
        return Optional.ofNullable(this.max);
    }

    /**
     * Specifies the upper bound of the random number.
     * 
     */
    @Import(name="maxRandomNumber")
    private @Nullable Output<Integer> maxRandomNumber;

    /**
     * @return Specifies the upper bound of the random number.
     * 
     */
    public Optional<Output<Integer>> maxRandomNumber() {
        return Optional.ofNullable(this.maxRandomNumber);
    }

    /**
     * Specifies a minimum value for the generated integer.
     * 
     */
    @Import(name="min")
    private @Nullable Output<Integer> min;

    /**
     * @return Specifies a minimum value for the generated integer.
     * 
     */
    public Optional<Output<Integer>> min() {
        return Optional.ofNullable(this.min);
    }

    /**
     * Specifies the lower bound of the random number.
     * 
     */
    @Import(name="minRandomNumber")
    private @Nullable Output<Integer> minRandomNumber;

    /**
     * @return Specifies the lower bound of the random number.
     * 
     */
    public Optional<Output<Integer>> minRandomNumber() {
        return Optional.ofNullable(this.minRandomNumber);
    }

    /**
     * Specifies the one-time number used for encryption.
     * 
     */
    @Import(name="nonce")
    private @Nullable Output<String> nonce;

    /**
     * @return Specifies the one-time number used for encryption.
     * 
     */
    public Optional<Output<String>> nonce() {
        return Optional.ofNullable(this.nonce);
    }

    /**
     * Specifies the number of random hex bytes to generate.
     * 
     */
    @Import(name="numberOfBytes")
    private @Nullable Output<Integer> numberOfBytes;

    /**
     * @return Specifies the number of random hex bytes to generate.
     * 
     */
    public Optional<Output<Integer>> numberOfBytes() {
        return Optional.ofNullable(this.numberOfBytes);
    }

    /**
     * Specifies an additional operand when the `transform` function is set to various arithmetic functions (`ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`, or `MODULO`) or bitwise functions (`BITWISE_AND`, `BITWISE_OR`, or `BITWISE_XOR`).
     * 
     */
    @Import(name="operandOne")
    private @Nullable Output<String> operandOne;

    /**
     * @return Specifies an additional operand when the `transform` function is set to various arithmetic functions (`ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`, or `MODULO`) or bitwise functions (`BITWISE_AND`, `BITWISE_OR`, or `BITWISE_XOR`).
     * 
     */
    public Optional<Output<String>> operandOne() {
        return Optional.ofNullable(this.operandOne);
    }

    /**
     * Extracts the value for the specified parameter name from a string that contains key/value pairs. (Use `separator` below to parse them.)
     * 
     */
    @Import(name="paramName")
    private @Nullable Output<String> paramName;

    /**
     * @return Extracts the value for the specified parameter name from a string that contains key/value pairs. (Use `separator` below to parse them.)
     * 
     */
    public Optional<Output<String>> paramName() {
        return Optional.ofNullable(this.paramName);
    }

    /**
     * This specifies a portion of the path.  The indexing starts from `1`, so a value of `/path/to/nested/filename.html` and an offset of `1` yields `path`, and `3` yields `nested`. Negative indexes offset from the right, so `-2` also yields `nested`.
     * 
     */
    @Import(name="pathComponentOffset")
    private @Nullable Output<String> pathComponentOffset;

    /**
     * @return This specifies a portion of the path.  The indexing starts from `1`, so a value of `/path/to/nested/filename.html` and an offset of `1` yields `path`, and `3` yields `nested`. Negative indexes offset from the right, so `-2` also yields `nested`.
     * 
     */
    public Optional<Output<String>> pathComponentOffset() {
        return Optional.ofNullable(this.pathComponentOffset);
    }

    /**
     * Specifies a number of random bytes to prepend to the key.
     * 
     */
    @Import(name="prependBytes")
    private @Nullable Output<Boolean> prependBytes;

    /**
     * @return Specifies a number of random bytes to prepend to the key.
     * 
     */
    public Optional<Output<Boolean>> prependBytes() {
        return Optional.ofNullable(this.prependBytes);
    }

    /**
     * Specifies the name of the query parameter from which to extract the value.
     * 
     */
    @Import(name="queryParameterName")
    private @Nullable Output<String> queryParameterName;

    /**
     * @return Specifies the name of the query parameter from which to extract the value.
     * 
     */
    public Optional<Output<String>> queryParameterName() {
        return Optional.ofNullable(this.queryParameterName);
    }

    /**
     * Specifies the regular expression pattern (PCRE) to match the value.
     * 
     */
    @Import(name="regex")
    private @Nullable Output<String> regex;

    /**
     * @return Specifies the regular expression pattern (PCRE) to match the value.
     * 
     */
    public Optional<Output<String>> regex() {
        return Optional.ofNullable(this.regex);
    }

    /**
     * Specifies the replacement string. Reinsert grouped items from the match into the replacement using `$1`, `$2` ... `$n`.
     * 
     */
    @Import(name="replacement")
    private @Nullable Output<String> replacement;

    /**
     * @return Specifies the replacement string. Reinsert grouped items from the match into the replacement using `$1`, `$2` ... `$n`.
     * 
     */
    public Optional<Output<String>> replacement() {
        return Optional.ofNullable(this.replacement);
    }

    /**
     * Specifies the case-insensitive name of the HTTP header to extract.
     * 
     */
    @Import(name="responseHeaderName")
    private @Nullable Output<String> responseHeaderName;

    /**
     * @return Specifies the case-insensitive name of the HTTP header to extract.
     * 
     */
    public Optional<Output<String>> responseHeaderName() {
        return Optional.ofNullable(this.responseHeaderName);
    }

    /**
     * Specifies the character that separates pairs of values within the string.
     * 
     */
    @Import(name="separator")
    private @Nullable Output<String> separator;

    /**
     * @return Specifies the character that separates pairs of values within the string.
     * 
     */
    public Optional<Output<String>> separator() {
        return Optional.ofNullable(this.separator);
    }

    /**
     * Specifies the name of the origin&#39;s `Set-Cookie` response header.
     * 
     */
    @Import(name="setCookieName")
    private @Nullable Output<String> setCookieName;

    /**
     * @return Specifies the name of the origin&#39;s `Set-Cookie` response header.
     * 
     */
    public Optional<Output<String>> setCookieName() {
        return Optional.ofNullable(this.setCookieName);
    }

    /**
     * Specifies the zero-based character offset at the start of the substring. Negative indexes specify the offset from the end of the string.
     * 
     */
    @Import(name="startIndex")
    private @Nullable Output<Integer> startIndex;

    /**
     * @return Specifies the zero-based character offset at the start of the substring. Negative indexes specify the offset from the end of the string.
     * 
     */
    public Optional<Output<Integer>> startIndex() {
        return Optional.ofNullable(this.startIndex);
    }

    /**
     * Specifies a substring for which the returned value represents a zero-based offset of where it appears in the original string, or `-1` if there&#39;s no match.
     * 
     */
    @Import(name="subString")
    private @Nullable Output<String> subString;

    /**
     * @return Specifies a substring for which the returned value represents a zero-based offset of where it appears in the original string, or `-1` if there&#39;s no match.
     * 
     */
    public Optional<Output<String>> subString() {
        return Optional.ofNullable(this.subString);
    }

    /**
     * This option is for internal usage only.
     * 
     */
    @Import(name="templateUuid")
    private @Nullable Output<String> templateUuid;

    /**
     * @return This option is for internal usage only.
     * 
     */
    public Optional<Output<String>> templateUuid() {
        return Optional.ofNullable(this.templateUuid);
    }

    /**
     * Specifies a function to transform the value. For more details on each transform function, see `Set Variable: Operations`.
     * 
     */
    @Import(name="transform")
    private @Nullable Output<String> transform;

    /**
     * @return Specifies a function to transform the value. For more details on each transform function, see `Set Variable: Operations`.
     * 
     */
    public Optional<Output<String>> transform() {
        return Optional.ofNullable(this.transform);
    }

    /**
     * A uuid member indicates that at least one of its component behaviors or criteria is advanced and read-only. You need to preserve this uuid as well when modifying the rule tree. This option is for internal usage only.
     * 
     */
    @Import(name="uuid")
    private @Nullable Output<String> uuid;

    /**
     * @return A uuid member indicates that at least one of its component behaviors or criteria is advanced and read-only. You need to preserve this uuid as well when modifying the rule tree. This option is for internal usage only.
     * 
     */
    public Optional<Output<String>> uuid() {
        return Optional.ofNullable(this.uuid);
    }

    /**
     * Determines how you want to set the value.
     * 
     */
    @Import(name="valueSource")
    private @Nullable Output<String> valueSource;

    /**
     * @return Determines how you want to set the value.
     * 
     */
    public Optional<Output<String>> valueSource() {
        return Optional.ofNullable(this.valueSource);
    }

    /**
     * Specifies the predeclared root name of the variable to modify.  When you declare a variable name such as `VAR`, its name is preprended with `PMUSER_` and accessible in a `user` namespace, so that you invoke it in subsequent text fields within the rule tree as `{{user.PMUSER_VAR}}`. In deployed `XML metadata`, it appears as `%(PMUSER_VAR)`.
     * 
     */
    @Import(name="variableName")
    private @Nullable Output<String> variableName;

    /**
     * @return Specifies the predeclared root name of the variable to modify.  When you declare a variable name such as `VAR`, its name is preprended with `PMUSER_` and accessible in a `user` namespace, so that you invoke it in subsequent text fields within the rule tree as `{{user.PMUSER_VAR}}`. In deployed `XML metadata`, it appears as `%(PMUSER_VAR)`.
     * 
     */
    public Optional<Output<String>> variableName() {
        return Optional.ofNullable(this.variableName);
    }

    /**
     * This directly specifies the value to assign to the variable. The expression may include a mix of static text and other variables, such as `new_filename.{{builtin.AK_EXTENSION}}` to embed a system variable.
     * 
     */
    @Import(name="variableValue")
    private @Nullable Output<String> variableValue;

    /**
     * @return This directly specifies the value to assign to the variable. The expression may include a mix of static text and other variables, such as `new_filename.{{builtin.AK_EXTENSION}}` to embed a system variable.
     * 
     */
    public Optional<Output<String>> variableValue() {
        return Optional.ofNullable(this.variableValue);
    }

    private GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs() {}

    private GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs(GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs $) {
        this.algorithm = $.algorithm;
        this.caseSensitive = $.caseSensitive;
        this.certificateFieldName = $.certificateFieldName;
        this.cookieName = $.cookieName;
        this.deviceProfile = $.deviceProfile;
        this.encryptionKey = $.encryptionKey;
        this.encryptionMode = $.encryptionMode;
        this.endIndex = $.endIndex;
        this.exceptChars = $.exceptChars;
        this.extractLocation = $.extractLocation;
        this.forceChars = $.forceChars;
        this.formatString = $.formatString;
        this.generator = $.generator;
        this.globalSubstitution = $.globalSubstitution;
        this.headerName = $.headerName;
        this.hmacAlgorithm = $.hmacAlgorithm;
        this.hmacKey = $.hmacKey;
        this.initializationVector = $.initializationVector;
        this.ipVersion = $.ipVersion;
        this.ipv4Prefix = $.ipv4Prefix;
        this.ipv6Prefix = $.ipv6Prefix;
        this.locationId = $.locationId;
        this.locked = $.locked;
        this.max = $.max;
        this.maxRandomNumber = $.maxRandomNumber;
        this.min = $.min;
        this.minRandomNumber = $.minRandomNumber;
        this.nonce = $.nonce;
        this.numberOfBytes = $.numberOfBytes;
        this.operandOne = $.operandOne;
        this.paramName = $.paramName;
        this.pathComponentOffset = $.pathComponentOffset;
        this.prependBytes = $.prependBytes;
        this.queryParameterName = $.queryParameterName;
        this.regex = $.regex;
        this.replacement = $.replacement;
        this.responseHeaderName = $.responseHeaderName;
        this.separator = $.separator;
        this.setCookieName = $.setCookieName;
        this.startIndex = $.startIndex;
        this.subString = $.subString;
        this.templateUuid = $.templateUuid;
        this.transform = $.transform;
        this.uuid = $.uuid;
        this.valueSource = $.valueSource;
        this.variableName = $.variableName;
        this.variableValue = $.variableValue;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs $;

        public Builder() {
            $ = new GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs();
        }

        public Builder(GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs defaults) {
            $ = new GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param algorithm Specifies the algorithm to apply.
         * 
         * @return builder
         * 
         */
        public Builder algorithm(@Nullable Output<String> algorithm) {
            $.algorithm = algorithm;
            return this;
        }

        /**
         * @param algorithm Specifies the algorithm to apply.
         * 
         * @return builder
         * 
         */
        public Builder algorithm(String algorithm) {
            return algorithm(Output.of(algorithm));
        }

        /**
         * @param caseSensitive Enabling this makes all matches case sensitive.
         * 
         * @return builder
         * 
         */
        public Builder caseSensitive(@Nullable Output<Boolean> caseSensitive) {
            $.caseSensitive = caseSensitive;
            return this;
        }

        /**
         * @param caseSensitive Enabling this makes all matches case sensitive.
         * 
         * @return builder
         * 
         */
        public Builder caseSensitive(Boolean caseSensitive) {
            return caseSensitive(Output.of(caseSensitive));
        }

        /**
         * @param certificateFieldName Specifies the certificate&#39;s content.
         * 
         * @return builder
         * 
         */
        public Builder certificateFieldName(@Nullable Output<String> certificateFieldName) {
            $.certificateFieldName = certificateFieldName;
            return this;
        }

        /**
         * @param certificateFieldName Specifies the certificate&#39;s content.
         * 
         * @return builder
         * 
         */
        public Builder certificateFieldName(String certificateFieldName) {
            return certificateFieldName(Output.of(certificateFieldName));
        }

        /**
         * @param cookieName Specifies the name of the cookie to extract.
         * 
         * @return builder
         * 
         */
        public Builder cookieName(@Nullable Output<String> cookieName) {
            $.cookieName = cookieName;
            return this;
        }

        /**
         * @param cookieName Specifies the name of the cookie to extract.
         * 
         * @return builder
         * 
         */
        public Builder cookieName(String cookieName) {
            return cookieName(Output.of(cookieName));
        }

        /**
         * @param deviceProfile Specifies the client device attribute. Possible values specify information about the client device, including device type, size and browser. For details on fields, see `Device Characterization`.
         * 
         * @return builder
         * 
         */
        public Builder deviceProfile(@Nullable Output<String> deviceProfile) {
            $.deviceProfile = deviceProfile;
            return this;
        }

        /**
         * @param deviceProfile Specifies the client device attribute. Possible values specify information about the client device, including device type, size and browser. For details on fields, see `Device Characterization`.
         * 
         * @return builder
         * 
         */
        public Builder deviceProfile(String deviceProfile) {
            return deviceProfile(Output.of(deviceProfile));
        }

        /**
         * @param encryptionKey Specifies the encryption hex key. For `ALG_3DES` it needs to be 48 characters long, 32 characters for `ALG_AES128`, and 64 characters for `ALG_AES256`.
         * 
         * @return builder
         * 
         */
        public Builder encryptionKey(@Nullable Output<String> encryptionKey) {
            $.encryptionKey = encryptionKey;
            return this;
        }

        /**
         * @param encryptionKey Specifies the encryption hex key. For `ALG_3DES` it needs to be 48 characters long, 32 characters for `ALG_AES128`, and 64 characters for `ALG_AES256`.
         * 
         * @return builder
         * 
         */
        public Builder encryptionKey(String encryptionKey) {
            return encryptionKey(Output.of(encryptionKey));
        }

        /**
         * @param encryptionMode Specifies the encryption mode.
         * 
         * @return builder
         * 
         */
        public Builder encryptionMode(@Nullable Output<String> encryptionMode) {
            $.encryptionMode = encryptionMode;
            return this;
        }

        /**
         * @param encryptionMode Specifies the encryption mode.
         * 
         * @return builder
         * 
         */
        public Builder encryptionMode(String encryptionMode) {
            return encryptionMode(Output.of(encryptionMode));
        }

        /**
         * @param endIndex Specifies the zero-based character offset at the end of the substring, without including the character at that index position. Negative indexes specify the offset from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder endIndex(@Nullable Output<Integer> endIndex) {
            $.endIndex = endIndex;
            return this;
        }

        /**
         * @param endIndex Specifies the zero-based character offset at the end of the substring, without including the character at that index position. Negative indexes specify the offset from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder endIndex(Integer endIndex) {
            return endIndex(Output.of(endIndex));
        }

        /**
         * @param exceptChars Specifies characters `not` to encode, possibly overriding the default set.
         * 
         * @return builder
         * 
         */
        public Builder exceptChars(@Nullable Output<String> exceptChars) {
            $.exceptChars = exceptChars;
            return this;
        }

        /**
         * @param exceptChars Specifies characters `not` to encode, possibly overriding the default set.
         * 
         * @return builder
         * 
         */
        public Builder exceptChars(String exceptChars) {
            return exceptChars(Output.of(exceptChars));
        }

        /**
         * @param extractLocation This specifies from where to get the value.
         * 
         * @return builder
         * 
         */
        public Builder extractLocation(@Nullable Output<String> extractLocation) {
            $.extractLocation = extractLocation;
            return this;
        }

        /**
         * @param extractLocation This specifies from where to get the value.
         * 
         * @return builder
         * 
         */
        public Builder extractLocation(String extractLocation) {
            return extractLocation(Output.of(extractLocation));
        }

        /**
         * @param forceChars Specifies characters to encode, possibly overriding the default set.
         * 
         * @return builder
         * 
         */
        public Builder forceChars(@Nullable Output<String> forceChars) {
            $.forceChars = forceChars;
            return this;
        }

        /**
         * @param forceChars Specifies characters to encode, possibly overriding the default set.
         * 
         * @return builder
         * 
         */
        public Builder forceChars(String forceChars) {
            return forceChars(Output.of(forceChars));
        }

        /**
         * @param formatString Specifies an optional format string for the conversion, using format codes such as `%m/%d/%y` as specified by `strftime`. A blank value defaults to RFC-2616 format.
         * 
         * @return builder
         * 
         */
        public Builder formatString(@Nullable Output<String> formatString) {
            $.formatString = formatString;
            return this;
        }

        /**
         * @param formatString Specifies an optional format string for the conversion, using format codes such as `%m/%d/%y` as specified by `strftime`. A blank value defaults to RFC-2616 format.
         * 
         * @return builder
         * 
         */
        public Builder formatString(String formatString) {
            return formatString(Output.of(formatString));
        }

        /**
         * @param generator This specifies the type of value to generate.
         * 
         * @return builder
         * 
         */
        public Builder generator(@Nullable Output<String> generator) {
            $.generator = generator;
            return this;
        }

        /**
         * @param generator This specifies the type of value to generate.
         * 
         * @return builder
         * 
         */
        public Builder generator(String generator) {
            return generator(Output.of(generator));
        }

        /**
         * @param globalSubstitution Replaces all matches in the string, not just the first.
         * 
         * @return builder
         * 
         */
        public Builder globalSubstitution(@Nullable Output<Boolean> globalSubstitution) {
            $.globalSubstitution = globalSubstitution;
            return this;
        }

        /**
         * @param globalSubstitution Replaces all matches in the string, not just the first.
         * 
         * @return builder
         * 
         */
        public Builder globalSubstitution(Boolean globalSubstitution) {
            return globalSubstitution(Output.of(globalSubstitution));
        }

        /**
         * @param headerName Specifies the case-insensitive name of the HTTP header to extract.
         * 
         * @return builder
         * 
         */
        public Builder headerName(@Nullable Output<String> headerName) {
            $.headerName = headerName;
            return this;
        }

        /**
         * @param headerName Specifies the case-insensitive name of the HTTP header to extract.
         * 
         * @return builder
         * 
         */
        public Builder headerName(String headerName) {
            return headerName(Output.of(headerName));
        }

        /**
         * @param hmacAlgorithm Specifies the algorithm to use to generate the base64-encoded digest.
         * 
         * @return builder
         * 
         */
        public Builder hmacAlgorithm(@Nullable Output<String> hmacAlgorithm) {
            $.hmacAlgorithm = hmacAlgorithm;
            return this;
        }

        /**
         * @param hmacAlgorithm Specifies the algorithm to use to generate the base64-encoded digest.
         * 
         * @return builder
         * 
         */
        public Builder hmacAlgorithm(String hmacAlgorithm) {
            return hmacAlgorithm(Output.of(hmacAlgorithm));
        }

        /**
         * @param hmacKey Specifies the secret to use in generating the base64-encoded digest.
         * 
         * @return builder
         * 
         */
        public Builder hmacKey(@Nullable Output<String> hmacKey) {
            $.hmacKey = hmacKey;
            return this;
        }

        /**
         * @param hmacKey Specifies the secret to use in generating the base64-encoded digest.
         * 
         * @return builder
         * 
         */
        public Builder hmacKey(String hmacKey) {
            return hmacKey(Output.of(hmacKey));
        }

        /**
         * @param initializationVector Specifies a one-time number as an initialization vector.  It needs to be 15 characters long for `ALG_3DES`, and 32 characters for both `ALG_AES128` and `ALG_AES256`.
         * 
         * @return builder
         * 
         */
        public Builder initializationVector(@Nullable Output<String> initializationVector) {
            $.initializationVector = initializationVector;
            return this;
        }

        /**
         * @param initializationVector Specifies a one-time number as an initialization vector.  It needs to be 15 characters long for `ALG_3DES`, and 32 characters for both `ALG_AES128` and `ALG_AES256`.
         * 
         * @return builder
         * 
         */
        public Builder initializationVector(String initializationVector) {
            return initializationVector(Output.of(initializationVector));
        }

        /**
         * @param ipVersion Specifies the IP version under which a subnet mask generates.
         * 
         * @return builder
         * 
         */
        public Builder ipVersion(@Nullable Output<String> ipVersion) {
            $.ipVersion = ipVersion;
            return this;
        }

        /**
         * @param ipVersion Specifies the IP version under which a subnet mask generates.
         * 
         * @return builder
         * 
         */
        public Builder ipVersion(String ipVersion) {
            return ipVersion(Output.of(ipVersion));
        }

        /**
         * @param ipv4Prefix Specifies the prefix of the IPV4 address, a value between 0 and 32.
         * 
         * @return builder
         * 
         */
        public Builder ipv4Prefix(@Nullable Output<Integer> ipv4Prefix) {
            $.ipv4Prefix = ipv4Prefix;
            return this;
        }

        /**
         * @param ipv4Prefix Specifies the prefix of the IPV4 address, a value between 0 and 32.
         * 
         * @return builder
         * 
         */
        public Builder ipv4Prefix(Integer ipv4Prefix) {
            return ipv4Prefix(Output.of(ipv4Prefix));
        }

        /**
         * @param ipv6Prefix Specifies the prefix of the IPV6 address, a value between 0 and 128.
         * 
         * @return builder
         * 
         */
        public Builder ipv6Prefix(@Nullable Output<Integer> ipv6Prefix) {
            $.ipv6Prefix = ipv6Prefix;
            return this;
        }

        /**
         * @param ipv6Prefix Specifies the prefix of the IPV6 address, a value between 0 and 128.
         * 
         * @return builder
         * 
         */
        public Builder ipv6Prefix(Integer ipv6Prefix) {
            return ipv6Prefix(Output.of(ipv6Prefix));
        }

        /**
         * @param locationId Specifies the `X-Akamai-Edgescape` header&#39;s field name. Possible values specify basic geolocation, various geographic standards, and information about the client&#39;s network. For details on EdgeScape header fields, see the `EdgeScape User Guide`.
         * 
         * @return builder
         * 
         */
        public Builder locationId(@Nullable Output<String> locationId) {
            $.locationId = locationId;
            return this;
        }

        /**
         * @param locationId Specifies the `X-Akamai-Edgescape` header&#39;s field name. Possible values specify basic geolocation, various geographic standards, and information about the client&#39;s network. For details on EdgeScape header fields, see the `EdgeScape User Guide`.
         * 
         * @return builder
         * 
         */
        public Builder locationId(String locationId) {
            return locationId(Output.of(locationId));
        }

        /**
         * @param locked Indicates that your Akamai representative has locked this behavior or criteria so that you can&#39;t modify it. This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder locked(@Nullable Output<Boolean> locked) {
            $.locked = locked;
            return this;
        }

        /**
         * @param locked Indicates that your Akamai representative has locked this behavior or criteria so that you can&#39;t modify it. This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder locked(Boolean locked) {
            return locked(Output.of(locked));
        }

        /**
         * @param max Specifies a maximum value for the generated integer.
         * 
         * @return builder
         * 
         */
        public Builder max(@Nullable Output<Integer> max) {
            $.max = max;
            return this;
        }

        /**
         * @param max Specifies a maximum value for the generated integer.
         * 
         * @return builder
         * 
         */
        public Builder max(Integer max) {
            return max(Output.of(max));
        }

        /**
         * @param maxRandomNumber Specifies the upper bound of the random number.
         * 
         * @return builder
         * 
         */
        public Builder maxRandomNumber(@Nullable Output<Integer> maxRandomNumber) {
            $.maxRandomNumber = maxRandomNumber;
            return this;
        }

        /**
         * @param maxRandomNumber Specifies the upper bound of the random number.
         * 
         * @return builder
         * 
         */
        public Builder maxRandomNumber(Integer maxRandomNumber) {
            return maxRandomNumber(Output.of(maxRandomNumber));
        }

        /**
         * @param min Specifies a minimum value for the generated integer.
         * 
         * @return builder
         * 
         */
        public Builder min(@Nullable Output<Integer> min) {
            $.min = min;
            return this;
        }

        /**
         * @param min Specifies a minimum value for the generated integer.
         * 
         * @return builder
         * 
         */
        public Builder min(Integer min) {
            return min(Output.of(min));
        }

        /**
         * @param minRandomNumber Specifies the lower bound of the random number.
         * 
         * @return builder
         * 
         */
        public Builder minRandomNumber(@Nullable Output<Integer> minRandomNumber) {
            $.minRandomNumber = minRandomNumber;
            return this;
        }

        /**
         * @param minRandomNumber Specifies the lower bound of the random number.
         * 
         * @return builder
         * 
         */
        public Builder minRandomNumber(Integer minRandomNumber) {
            return minRandomNumber(Output.of(minRandomNumber));
        }

        /**
         * @param nonce Specifies the one-time number used for encryption.
         * 
         * @return builder
         * 
         */
        public Builder nonce(@Nullable Output<String> nonce) {
            $.nonce = nonce;
            return this;
        }

        /**
         * @param nonce Specifies the one-time number used for encryption.
         * 
         * @return builder
         * 
         */
        public Builder nonce(String nonce) {
            return nonce(Output.of(nonce));
        }

        /**
         * @param numberOfBytes Specifies the number of random hex bytes to generate.
         * 
         * @return builder
         * 
         */
        public Builder numberOfBytes(@Nullable Output<Integer> numberOfBytes) {
            $.numberOfBytes = numberOfBytes;
            return this;
        }

        /**
         * @param numberOfBytes Specifies the number of random hex bytes to generate.
         * 
         * @return builder
         * 
         */
        public Builder numberOfBytes(Integer numberOfBytes) {
            return numberOfBytes(Output.of(numberOfBytes));
        }

        /**
         * @param operandOne Specifies an additional operand when the `transform` function is set to various arithmetic functions (`ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`, or `MODULO`) or bitwise functions (`BITWISE_AND`, `BITWISE_OR`, or `BITWISE_XOR`).
         * 
         * @return builder
         * 
         */
        public Builder operandOne(@Nullable Output<String> operandOne) {
            $.operandOne = operandOne;
            return this;
        }

        /**
         * @param operandOne Specifies an additional operand when the `transform` function is set to various arithmetic functions (`ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`, or `MODULO`) or bitwise functions (`BITWISE_AND`, `BITWISE_OR`, or `BITWISE_XOR`).
         * 
         * @return builder
         * 
         */
        public Builder operandOne(String operandOne) {
            return operandOne(Output.of(operandOne));
        }

        /**
         * @param paramName Extracts the value for the specified parameter name from a string that contains key/value pairs. (Use `separator` below to parse them.)
         * 
         * @return builder
         * 
         */
        public Builder paramName(@Nullable Output<String> paramName) {
            $.paramName = paramName;
            return this;
        }

        /**
         * @param paramName Extracts the value for the specified parameter name from a string that contains key/value pairs. (Use `separator` below to parse them.)
         * 
         * @return builder
         * 
         */
        public Builder paramName(String paramName) {
            return paramName(Output.of(paramName));
        }

        /**
         * @param pathComponentOffset This specifies a portion of the path.  The indexing starts from `1`, so a value of `/path/to/nested/filename.html` and an offset of `1` yields `path`, and `3` yields `nested`. Negative indexes offset from the right, so `-2` also yields `nested`.
         * 
         * @return builder
         * 
         */
        public Builder pathComponentOffset(@Nullable Output<String> pathComponentOffset) {
            $.pathComponentOffset = pathComponentOffset;
            return this;
        }

        /**
         * @param pathComponentOffset This specifies a portion of the path.  The indexing starts from `1`, so a value of `/path/to/nested/filename.html` and an offset of `1` yields `path`, and `3` yields `nested`. Negative indexes offset from the right, so `-2` also yields `nested`.
         * 
         * @return builder
         * 
         */
        public Builder pathComponentOffset(String pathComponentOffset) {
            return pathComponentOffset(Output.of(pathComponentOffset));
        }

        /**
         * @param prependBytes Specifies a number of random bytes to prepend to the key.
         * 
         * @return builder
         * 
         */
        public Builder prependBytes(@Nullable Output<Boolean> prependBytes) {
            $.prependBytes = prependBytes;
            return this;
        }

        /**
         * @param prependBytes Specifies a number of random bytes to prepend to the key.
         * 
         * @return builder
         * 
         */
        public Builder prependBytes(Boolean prependBytes) {
            return prependBytes(Output.of(prependBytes));
        }

        /**
         * @param queryParameterName Specifies the name of the query parameter from which to extract the value.
         * 
         * @return builder
         * 
         */
        public Builder queryParameterName(@Nullable Output<String> queryParameterName) {
            $.queryParameterName = queryParameterName;
            return this;
        }

        /**
         * @param queryParameterName Specifies the name of the query parameter from which to extract the value.
         * 
         * @return builder
         * 
         */
        public Builder queryParameterName(String queryParameterName) {
            return queryParameterName(Output.of(queryParameterName));
        }

        /**
         * @param regex Specifies the regular expression pattern (PCRE) to match the value.
         * 
         * @return builder
         * 
         */
        public Builder regex(@Nullable Output<String> regex) {
            $.regex = regex;
            return this;
        }

        /**
         * @param regex Specifies the regular expression pattern (PCRE) to match the value.
         * 
         * @return builder
         * 
         */
        public Builder regex(String regex) {
            return regex(Output.of(regex));
        }

        /**
         * @param replacement Specifies the replacement string. Reinsert grouped items from the match into the replacement using `$1`, `$2` ... `$n`.
         * 
         * @return builder
         * 
         */
        public Builder replacement(@Nullable Output<String> replacement) {
            $.replacement = replacement;
            return this;
        }

        /**
         * @param replacement Specifies the replacement string. Reinsert grouped items from the match into the replacement using `$1`, `$2` ... `$n`.
         * 
         * @return builder
         * 
         */
        public Builder replacement(String replacement) {
            return replacement(Output.of(replacement));
        }

        /**
         * @param responseHeaderName Specifies the case-insensitive name of the HTTP header to extract.
         * 
         * @return builder
         * 
         */
        public Builder responseHeaderName(@Nullable Output<String> responseHeaderName) {
            $.responseHeaderName = responseHeaderName;
            return this;
        }

        /**
         * @param responseHeaderName Specifies the case-insensitive name of the HTTP header to extract.
         * 
         * @return builder
         * 
         */
        public Builder responseHeaderName(String responseHeaderName) {
            return responseHeaderName(Output.of(responseHeaderName));
        }

        /**
         * @param separator Specifies the character that separates pairs of values within the string.
         * 
         * @return builder
         * 
         */
        public Builder separator(@Nullable Output<String> separator) {
            $.separator = separator;
            return this;
        }

        /**
         * @param separator Specifies the character that separates pairs of values within the string.
         * 
         * @return builder
         * 
         */
        public Builder separator(String separator) {
            return separator(Output.of(separator));
        }

        /**
         * @param setCookieName Specifies the name of the origin&#39;s `Set-Cookie` response header.
         * 
         * @return builder
         * 
         */
        public Builder setCookieName(@Nullable Output<String> setCookieName) {
            $.setCookieName = setCookieName;
            return this;
        }

        /**
         * @param setCookieName Specifies the name of the origin&#39;s `Set-Cookie` response header.
         * 
         * @return builder
         * 
         */
        public Builder setCookieName(String setCookieName) {
            return setCookieName(Output.of(setCookieName));
        }

        /**
         * @param startIndex Specifies the zero-based character offset at the start of the substring. Negative indexes specify the offset from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder startIndex(@Nullable Output<Integer> startIndex) {
            $.startIndex = startIndex;
            return this;
        }

        /**
         * @param startIndex Specifies the zero-based character offset at the start of the substring. Negative indexes specify the offset from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder startIndex(Integer startIndex) {
            return startIndex(Output.of(startIndex));
        }

        /**
         * @param subString Specifies a substring for which the returned value represents a zero-based offset of where it appears in the original string, or `-1` if there&#39;s no match.
         * 
         * @return builder
         * 
         */
        public Builder subString(@Nullable Output<String> subString) {
            $.subString = subString;
            return this;
        }

        /**
         * @param subString Specifies a substring for which the returned value represents a zero-based offset of where it appears in the original string, or `-1` if there&#39;s no match.
         * 
         * @return builder
         * 
         */
        public Builder subString(String subString) {
            return subString(Output.of(subString));
        }

        /**
         * @param templateUuid This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder templateUuid(@Nullable Output<String> templateUuid) {
            $.templateUuid = templateUuid;
            return this;
        }

        /**
         * @param templateUuid This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder templateUuid(String templateUuid) {
            return templateUuid(Output.of(templateUuid));
        }

        /**
         * @param transform Specifies a function to transform the value. For more details on each transform function, see `Set Variable: Operations`.
         * 
         * @return builder
         * 
         */
        public Builder transform(@Nullable Output<String> transform) {
            $.transform = transform;
            return this;
        }

        /**
         * @param transform Specifies a function to transform the value. For more details on each transform function, see `Set Variable: Operations`.
         * 
         * @return builder
         * 
         */
        public Builder transform(String transform) {
            return transform(Output.of(transform));
        }

        /**
         * @param uuid A uuid member indicates that at least one of its component behaviors or criteria is advanced and read-only. You need to preserve this uuid as well when modifying the rule tree. This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder uuid(@Nullable Output<String> uuid) {
            $.uuid = uuid;
            return this;
        }

        /**
         * @param uuid A uuid member indicates that at least one of its component behaviors or criteria is advanced and read-only. You need to preserve this uuid as well when modifying the rule tree. This option is for internal usage only.
         * 
         * @return builder
         * 
         */
        public Builder uuid(String uuid) {
            return uuid(Output.of(uuid));
        }

        /**
         * @param valueSource Determines how you want to set the value.
         * 
         * @return builder
         * 
         */
        public Builder valueSource(@Nullable Output<String> valueSource) {
            $.valueSource = valueSource;
            return this;
        }

        /**
         * @param valueSource Determines how you want to set the value.
         * 
         * @return builder
         * 
         */
        public Builder valueSource(String valueSource) {
            return valueSource(Output.of(valueSource));
        }

        /**
         * @param variableName Specifies the predeclared root name of the variable to modify.  When you declare a variable name such as `VAR`, its name is preprended with `PMUSER_` and accessible in a `user` namespace, so that you invoke it in subsequent text fields within the rule tree as `{{user.PMUSER_VAR}}`. In deployed `XML metadata`, it appears as `%(PMUSER_VAR)`.
         * 
         * @return builder
         * 
         */
        public Builder variableName(@Nullable Output<String> variableName) {
            $.variableName = variableName;
            return this;
        }

        /**
         * @param variableName Specifies the predeclared root name of the variable to modify.  When you declare a variable name such as `VAR`, its name is preprended with `PMUSER_` and accessible in a `user` namespace, so that you invoke it in subsequent text fields within the rule tree as `{{user.PMUSER_VAR}}`. In deployed `XML metadata`, it appears as `%(PMUSER_VAR)`.
         * 
         * @return builder
         * 
         */
        public Builder variableName(String variableName) {
            return variableName(Output.of(variableName));
        }

        /**
         * @param variableValue This directly specifies the value to assign to the variable. The expression may include a mix of static text and other variables, such as `new_filename.{{builtin.AK_EXTENSION}}` to embed a system variable.
         * 
         * @return builder
         * 
         */
        public Builder variableValue(@Nullable Output<String> variableValue) {
            $.variableValue = variableValue;
            return this;
        }

        /**
         * @param variableValue This directly specifies the value to assign to the variable. The expression may include a mix of static text and other variables, such as `new_filename.{{builtin.AK_EXTENSION}}` to embed a system variable.
         * 
         * @return builder
         * 
         */
        public Builder variableValue(String variableValue) {
            return variableValue(Output.of(variableValue));
        }

        public GetPropertyRulesBuilderRulesV20240531BehaviorSetVariableArgs build() {
            return $;
        }
    }

}
