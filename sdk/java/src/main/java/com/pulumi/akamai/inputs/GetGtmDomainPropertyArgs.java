// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.inputs;

import com.pulumi.akamai.inputs.GetGtmDomainPropertyLinkArgs;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyLivenessTestArgs;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyStaticRrSetArgs;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyTrafficTargetArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetGtmDomainPropertyArgs extends com.pulumi.resources.ResourceArgs {

    public static final GetGtmDomainPropertyArgs Empty = new GetGtmDomainPropertyArgs();

    /**
     * Specifies a backup CNAME.
     * 
     */
    @Import(name="backupCname", required=true)
    private Output<String> backupCname;

    /**
     * @return Specifies a backup CNAME.
     * 
     */
    public Output<String> backupCname() {
        return this.backupCname;
    }

    /**
     * Specifies a backup IP.
     * 
     */
    @Import(name="backupIp", required=true)
    private Output<String> backupIp;

    /**
     * @return Specifies a backup IP.
     * 
     */
    public Output<String> backupIp() {
        return this.backupIp;
    }

    /**
     * Indicates whether download score based load balancing is enabled.
     * 
     */
    @Import(name="balanceByDownloadScore", required=true)
    private Output<Boolean> balanceByDownloadScore;

    /**
     * @return Indicates whether download score based load balancing is enabled.
     * 
     */
    public Output<Boolean> balanceByDownloadScore() {
        return this.balanceByDownloadScore;
    }

    /**
     * Indicates the fully qualified name aliased to a particular property.
     * 
     */
    @Import(name="cname", required=true)
    private Output<String> cname;

    /**
     * @return Indicates the fully qualified name aliased to a particular property.
     * 
     */
    public Output<String> cname() {
        return this.cname;
    }

    /**
     * Descriptive comments for the property.
     * 
     */
    @Import(name="comments", required=true)
    private Output<String> comments;

    /**
     * @return Descriptive comments for the property.
     * 
     */
    public Output<String> comments() {
        return this.comments;
    }

    /**
     * Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    @Import(name="dynamicTtl", required=true)
    private Output<Integer> dynamicTtl;

    /**
     * @return Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    public Output<Integer> dynamicTtl() {
        return this.dynamicTtl;
    }

    /**
     * Specifies the failback delay in seconds.
     * 
     */
    @Import(name="failbackDelay", required=true)
    private Output<Integer> failbackDelay;

    /**
     * @return Specifies the failback delay in seconds.
     * 
     */
    public Output<Integer> failbackDelay() {
        return this.failbackDelay;
    }

    /**
     * Specifies the failover delay in seconds.
     * 
     */
    @Import(name="failoverDelay", required=true)
    private Output<Integer> failoverDelay;

    /**
     * @return Specifies the failover delay in seconds.
     * 
     */
    public Output<Integer> failoverDelay() {
        return this.failoverDelay;
    }

    /**
     * Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    @Import(name="ghostDemandReporting", required=true)
    private Output<Boolean> ghostDemandReporting;

    /**
     * @return Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    public Output<Boolean> ghostDemandReporting() {
        return this.ghostDemandReporting;
    }

    /**
     * Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    @Import(name="handoutLimit", required=true)
    private Output<Integer> handoutLimit;

    /**
     * @return Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    public Output<Integer> handoutLimit() {
        return this.handoutLimit;
    }

    /**
     * Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    @Import(name="handoutMode", required=true)
    private Output<String> handoutMode;

    /**
     * @return Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    public Output<String> handoutMode() {
        return this.handoutMode;
    }

    /**
     * Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    @Import(name="healthMax", required=true)
    private Output<Double> healthMax;

    /**
     * @return Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    public Output<Double> healthMax() {
        return this.healthMax;
    }

    /**
     * Configures a cutoff value that is computed from the median scores.
     * 
     */
    @Import(name="healthMultiplier", required=true)
    private Output<Double> healthMultiplier;

    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Output<Double> healthMultiplier() {
        return this.healthMultiplier;
    }

    /**
     * Configures a cutoff value that is computed from the median scores.
     * 
     */
    @Import(name="healthThreshold", required=true)
    private Output<Double> healthThreshold;

    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Output<Double> healthThreshold() {
        return this.healthThreshold;
    }

    /**
     * Indicates the type of IP address handed out by a property.
     * 
     */
    @Import(name="ipv6", required=true)
    private Output<Boolean> ipv6;

    /**
     * @return Indicates the type of IP address handed out by a property.
     * 
     */
    public Output<Boolean> ipv6() {
        return this.ipv6;
    }

    /**
     * An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    @Import(name="lastModified", required=true)
    private Output<String> lastModified;

    /**
     * @return An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    public Output<String> lastModified() {
        return this.lastModified;
    }

    /**
     * Provides a URL path that allows direct navigation to the property.
     * 
     */
    @Import(name="links")
    private @Nullable Output<List<GetGtmDomainPropertyLinkArgs>> links;

    /**
     * @return Provides a URL path that allows direct navigation to the property.
     * 
     */
    public Optional<Output<List<GetGtmDomainPropertyLinkArgs>>> links() {
        return Optional.ofNullable(this.links);
    }

    /**
     * Contains information about liveness tests.
     * 
     */
    @Import(name="livenessTests")
    private @Nullable Output<List<GetGtmDomainPropertyLivenessTestArgs>> livenessTests;

    /**
     * @return Contains information about liveness tests.
     * 
     */
    public Optional<Output<List<GetGtmDomainPropertyLivenessTestArgs>>> livenessTests() {
        return Optional.ofNullable(this.livenessTests);
    }

    /**
     * Indicates the percent of load imbalance factor for the domain.
     * 
     */
    @Import(name="loadImbalancePercentage", required=true)
    private Output<Double> loadImbalancePercentage;

    /**
     * @return Indicates the percent of load imbalance factor for the domain.
     * 
     */
    public Output<Double> loadImbalancePercentage() {
        return this.loadImbalancePercentage;
    }

    /**
     * A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    @Import(name="mapName", required=true)
    private Output<String> mapName;

    /**
     * @return A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    public Output<String> mapName() {
        return this.mapName;
    }

    /**
     * For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    @Import(name="maxUnreachablePenalty", required=true)
    private Output<Integer> maxUnreachablePenalty;

    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    public Output<Integer> maxUnreachablePenalty() {
        return this.maxUnreachablePenalty;
    }

    /**
     * Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    @Import(name="minLiveFraction", required=true)
    private Output<Double> minLiveFraction;

    /**
     * @return Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    public Output<Double> minLiveFraction() {
        return this.minLiveFraction;
    }

    /**
     * A descriptive label for the property.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return A descriptive label for the property.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    @Import(name="scoreAggregationType", required=true)
    private Output<String> scoreAggregationType;

    /**
     * @return Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    public Output<String> scoreAggregationType() {
        return this.scoreAggregationType;
    }

    /**
     * Contains static recordsets.
     * 
     */
    @Import(name="staticRrSets")
    private @Nullable Output<List<GetGtmDomainPropertyStaticRrSetArgs>> staticRrSets;

    /**
     * @return Contains static recordsets.
     * 
     */
    public Optional<Output<List<GetGtmDomainPropertyStaticRrSetArgs>>> staticRrSets() {
        return Optional.ofNullable(this.staticRrSets);
    }

    /**
     * Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    @Import(name="staticTtl", required=true)
    private Output<Integer> staticTtl;

    /**
     * @return Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    public Output<Integer> staticTtl() {
        return this.staticTtl;
    }

    /**
     * Specifies a percentage used to configure data center affinity.
     * 
     */
    @Import(name="sticknessBonusConstant", required=true)
    private Output<Integer> sticknessBonusConstant;

    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Output<Integer> sticknessBonusConstant() {
        return this.sticknessBonusConstant;
    }

    /**
     * Specifies a percentage used to configure data center affinity.
     * 
     */
    @Import(name="sticknessBonusPercentage", required=true)
    private Output<Integer> sticknessBonusPercentage;

    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Output<Integer> sticknessBonusPercentage() {
        return this.sticknessBonusPercentage;
    }

    /**
     * Traffic targets for the property.
     * 
     */
    @Import(name="trafficTargets")
    private @Nullable Output<List<GetGtmDomainPropertyTrafficTargetArgs>> trafficTargets;

    /**
     * @return Traffic targets for the property.
     * 
     */
    public Optional<Output<List<GetGtmDomainPropertyTrafficTargetArgs>>> trafficTargets() {
        return Optional.ofNullable(this.trafficTargets);
    }

    /**
     * Specifies the load balancing behvior for the property.
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return Specifies the load balancing behvior for the property.
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    /**
     * For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    @Import(name="unreachableThreshold", required=true)
    private Output<Double> unreachableThreshold;

    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    public Output<Double> unreachableThreshold() {
        return this.unreachableThreshold;
    }

    /**
     * For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    @Import(name="useComputedTargets", required=true)
    private Output<Boolean> useComputedTargets;

    /**
     * @return For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    public Output<Boolean> useComputedTargets() {
        return this.useComputedTargets;
    }

    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    @Import(name="weightedHashBitsForIpv4", required=true)
    private Output<Integer> weightedHashBitsForIpv4;

    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    public Output<Integer> weightedHashBitsForIpv4() {
        return this.weightedHashBitsForIpv4;
    }

    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    @Import(name="weightedHashBitsForIpv6", required=true)
    private Output<Integer> weightedHashBitsForIpv6;

    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    public Output<Integer> weightedHashBitsForIpv6() {
        return this.weightedHashBitsForIpv6;
    }

    private GetGtmDomainPropertyArgs() {}

    private GetGtmDomainPropertyArgs(GetGtmDomainPropertyArgs $) {
        this.backupCname = $.backupCname;
        this.backupIp = $.backupIp;
        this.balanceByDownloadScore = $.balanceByDownloadScore;
        this.cname = $.cname;
        this.comments = $.comments;
        this.dynamicTtl = $.dynamicTtl;
        this.failbackDelay = $.failbackDelay;
        this.failoverDelay = $.failoverDelay;
        this.ghostDemandReporting = $.ghostDemandReporting;
        this.handoutLimit = $.handoutLimit;
        this.handoutMode = $.handoutMode;
        this.healthMax = $.healthMax;
        this.healthMultiplier = $.healthMultiplier;
        this.healthThreshold = $.healthThreshold;
        this.ipv6 = $.ipv6;
        this.lastModified = $.lastModified;
        this.links = $.links;
        this.livenessTests = $.livenessTests;
        this.loadImbalancePercentage = $.loadImbalancePercentage;
        this.mapName = $.mapName;
        this.maxUnreachablePenalty = $.maxUnreachablePenalty;
        this.minLiveFraction = $.minLiveFraction;
        this.name = $.name;
        this.scoreAggregationType = $.scoreAggregationType;
        this.staticRrSets = $.staticRrSets;
        this.staticTtl = $.staticTtl;
        this.sticknessBonusConstant = $.sticknessBonusConstant;
        this.sticknessBonusPercentage = $.sticknessBonusPercentage;
        this.trafficTargets = $.trafficTargets;
        this.type = $.type;
        this.unreachableThreshold = $.unreachableThreshold;
        this.useComputedTargets = $.useComputedTargets;
        this.weightedHashBitsForIpv4 = $.weightedHashBitsForIpv4;
        this.weightedHashBitsForIpv6 = $.weightedHashBitsForIpv6;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetGtmDomainPropertyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetGtmDomainPropertyArgs $;

        public Builder() {
            $ = new GetGtmDomainPropertyArgs();
        }

        public Builder(GetGtmDomainPropertyArgs defaults) {
            $ = new GetGtmDomainPropertyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param backupCname Specifies a backup CNAME.
         * 
         * @return builder
         * 
         */
        public Builder backupCname(Output<String> backupCname) {
            $.backupCname = backupCname;
            return this;
        }

        /**
         * @param backupCname Specifies a backup CNAME.
         * 
         * @return builder
         * 
         */
        public Builder backupCname(String backupCname) {
            return backupCname(Output.of(backupCname));
        }

        /**
         * @param backupIp Specifies a backup IP.
         * 
         * @return builder
         * 
         */
        public Builder backupIp(Output<String> backupIp) {
            $.backupIp = backupIp;
            return this;
        }

        /**
         * @param backupIp Specifies a backup IP.
         * 
         * @return builder
         * 
         */
        public Builder backupIp(String backupIp) {
            return backupIp(Output.of(backupIp));
        }

        /**
         * @param balanceByDownloadScore Indicates whether download score based load balancing is enabled.
         * 
         * @return builder
         * 
         */
        public Builder balanceByDownloadScore(Output<Boolean> balanceByDownloadScore) {
            $.balanceByDownloadScore = balanceByDownloadScore;
            return this;
        }

        /**
         * @param balanceByDownloadScore Indicates whether download score based load balancing is enabled.
         * 
         * @return builder
         * 
         */
        public Builder balanceByDownloadScore(Boolean balanceByDownloadScore) {
            return balanceByDownloadScore(Output.of(balanceByDownloadScore));
        }

        /**
         * @param cname Indicates the fully qualified name aliased to a particular property.
         * 
         * @return builder
         * 
         */
        public Builder cname(Output<String> cname) {
            $.cname = cname;
            return this;
        }

        /**
         * @param cname Indicates the fully qualified name aliased to a particular property.
         * 
         * @return builder
         * 
         */
        public Builder cname(String cname) {
            return cname(Output.of(cname));
        }

        /**
         * @param comments Descriptive comments for the property.
         * 
         * @return builder
         * 
         */
        public Builder comments(Output<String> comments) {
            $.comments = comments;
            return this;
        }

        /**
         * @param comments Descriptive comments for the property.
         * 
         * @return builder
         * 
         */
        public Builder comments(String comments) {
            return comments(Output.of(comments));
        }

        /**
         * @param dynamicTtl Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
         * 
         * @return builder
         * 
         */
        public Builder dynamicTtl(Output<Integer> dynamicTtl) {
            $.dynamicTtl = dynamicTtl;
            return this;
        }

        /**
         * @param dynamicTtl Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
         * 
         * @return builder
         * 
         */
        public Builder dynamicTtl(Integer dynamicTtl) {
            return dynamicTtl(Output.of(dynamicTtl));
        }

        /**
         * @param failbackDelay Specifies the failback delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failbackDelay(Output<Integer> failbackDelay) {
            $.failbackDelay = failbackDelay;
            return this;
        }

        /**
         * @param failbackDelay Specifies the failback delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failbackDelay(Integer failbackDelay) {
            return failbackDelay(Output.of(failbackDelay));
        }

        /**
         * @param failoverDelay Specifies the failover delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failoverDelay(Output<Integer> failoverDelay) {
            $.failoverDelay = failoverDelay;
            return this;
        }

        /**
         * @param failoverDelay Specifies the failover delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failoverDelay(Integer failoverDelay) {
            return failoverDelay(Output.of(failoverDelay));
        }

        /**
         * @param ghostDemandReporting Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
         * 
         * @return builder
         * 
         */
        public Builder ghostDemandReporting(Output<Boolean> ghostDemandReporting) {
            $.ghostDemandReporting = ghostDemandReporting;
            return this;
        }

        /**
         * @param ghostDemandReporting Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
         * 
         * @return builder
         * 
         */
        public Builder ghostDemandReporting(Boolean ghostDemandReporting) {
            return ghostDemandReporting(Output.of(ghostDemandReporting));
        }

        /**
         * @param handoutLimit Indicates the limit for the number of live IPs handed out to a DNS request.
         * 
         * @return builder
         * 
         */
        public Builder handoutLimit(Output<Integer> handoutLimit) {
            $.handoutLimit = handoutLimit;
            return this;
        }

        /**
         * @param handoutLimit Indicates the limit for the number of live IPs handed out to a DNS request.
         * 
         * @return builder
         * 
         */
        public Builder handoutLimit(Integer handoutLimit) {
            return handoutLimit(Output.of(handoutLimit));
        }

        /**
         * @param handoutMode Specifies how IPs are returned when more than one IP is alive and available.
         * 
         * @return builder
         * 
         */
        public Builder handoutMode(Output<String> handoutMode) {
            $.handoutMode = handoutMode;
            return this;
        }

        /**
         * @param handoutMode Specifies how IPs are returned when more than one IP is alive and available.
         * 
         * @return builder
         * 
         */
        public Builder handoutMode(String handoutMode) {
            return handoutMode(Output.of(handoutMode));
        }

        /**
         * @param healthMax Defines the absolute limit beyond which IPs are declared unhealthy.
         * 
         * @return builder
         * 
         */
        public Builder healthMax(Output<Double> healthMax) {
            $.healthMax = healthMax;
            return this;
        }

        /**
         * @param healthMax Defines the absolute limit beyond which IPs are declared unhealthy.
         * 
         * @return builder
         * 
         */
        public Builder healthMax(Double healthMax) {
            return healthMax(Output.of(healthMax));
        }

        /**
         * @param healthMultiplier Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthMultiplier(Output<Double> healthMultiplier) {
            $.healthMultiplier = healthMultiplier;
            return this;
        }

        /**
         * @param healthMultiplier Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthMultiplier(Double healthMultiplier) {
            return healthMultiplier(Output.of(healthMultiplier));
        }

        /**
         * @param healthThreshold Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthThreshold(Output<Double> healthThreshold) {
            $.healthThreshold = healthThreshold;
            return this;
        }

        /**
         * @param healthThreshold Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthThreshold(Double healthThreshold) {
            return healthThreshold(Output.of(healthThreshold));
        }

        /**
         * @param ipv6 Indicates the type of IP address handed out by a property.
         * 
         * @return builder
         * 
         */
        public Builder ipv6(Output<Boolean> ipv6) {
            $.ipv6 = ipv6;
            return this;
        }

        /**
         * @param ipv6 Indicates the type of IP address handed out by a property.
         * 
         * @return builder
         * 
         */
        public Builder ipv6(Boolean ipv6) {
            return ipv6(Output.of(ipv6));
        }

        /**
         * @param lastModified An ISO 8601 timestamp that indicates when the property was last changed.
         * 
         * @return builder
         * 
         */
        public Builder lastModified(Output<String> lastModified) {
            $.lastModified = lastModified;
            return this;
        }

        /**
         * @param lastModified An ISO 8601 timestamp that indicates when the property was last changed.
         * 
         * @return builder
         * 
         */
        public Builder lastModified(String lastModified) {
            return lastModified(Output.of(lastModified));
        }

        /**
         * @param links Provides a URL path that allows direct navigation to the property.
         * 
         * @return builder
         * 
         */
        public Builder links(@Nullable Output<List<GetGtmDomainPropertyLinkArgs>> links) {
            $.links = links;
            return this;
        }

        /**
         * @param links Provides a URL path that allows direct navigation to the property.
         * 
         * @return builder
         * 
         */
        public Builder links(List<GetGtmDomainPropertyLinkArgs> links) {
            return links(Output.of(links));
        }

        /**
         * @param links Provides a URL path that allows direct navigation to the property.
         * 
         * @return builder
         * 
         */
        public Builder links(GetGtmDomainPropertyLinkArgs... links) {
            return links(List.of(links));
        }

        /**
         * @param livenessTests Contains information about liveness tests.
         * 
         * @return builder
         * 
         */
        public Builder livenessTests(@Nullable Output<List<GetGtmDomainPropertyLivenessTestArgs>> livenessTests) {
            $.livenessTests = livenessTests;
            return this;
        }

        /**
         * @param livenessTests Contains information about liveness tests.
         * 
         * @return builder
         * 
         */
        public Builder livenessTests(List<GetGtmDomainPropertyLivenessTestArgs> livenessTests) {
            return livenessTests(Output.of(livenessTests));
        }

        /**
         * @param livenessTests Contains information about liveness tests.
         * 
         * @return builder
         * 
         */
        public Builder livenessTests(GetGtmDomainPropertyLivenessTestArgs... livenessTests) {
            return livenessTests(List.of(livenessTests));
        }

        /**
         * @param loadImbalancePercentage Indicates the percent of load imbalance factor for the domain.
         * 
         * @return builder
         * 
         */
        public Builder loadImbalancePercentage(Output<Double> loadImbalancePercentage) {
            $.loadImbalancePercentage = loadImbalancePercentage;
            return this;
        }

        /**
         * @param loadImbalancePercentage Indicates the percent of load imbalance factor for the domain.
         * 
         * @return builder
         * 
         */
        public Builder loadImbalancePercentage(Double loadImbalancePercentage) {
            return loadImbalancePercentage(Output.of(loadImbalancePercentage));
        }

        /**
         * @param mapName A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
         * 
         * @return builder
         * 
         */
        public Builder mapName(Output<String> mapName) {
            $.mapName = mapName;
            return this;
        }

        /**
         * @param mapName A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
         * 
         * @return builder
         * 
         */
        public Builder mapName(String mapName) {
            return mapName(Output.of(mapName));
        }

        /**
         * @param maxUnreachablePenalty For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
         * 
         * @return builder
         * 
         */
        public Builder maxUnreachablePenalty(Output<Integer> maxUnreachablePenalty) {
            $.maxUnreachablePenalty = maxUnreachablePenalty;
            return this;
        }

        /**
         * @param maxUnreachablePenalty For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
         * 
         * @return builder
         * 
         */
        public Builder maxUnreachablePenalty(Integer maxUnreachablePenalty) {
            return maxUnreachablePenalty(Output.of(maxUnreachablePenalty));
        }

        /**
         * @param minLiveFraction Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
         * 
         * @return builder
         * 
         */
        public Builder minLiveFraction(Output<Double> minLiveFraction) {
            $.minLiveFraction = minLiveFraction;
            return this;
        }

        /**
         * @param minLiveFraction Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
         * 
         * @return builder
         * 
         */
        public Builder minLiveFraction(Double minLiveFraction) {
            return minLiveFraction(Output.of(minLiveFraction));
        }

        /**
         * @param name A descriptive label for the property.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A descriptive label for the property.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param scoreAggregationType Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
         * 
         * @return builder
         * 
         */
        public Builder scoreAggregationType(Output<String> scoreAggregationType) {
            $.scoreAggregationType = scoreAggregationType;
            return this;
        }

        /**
         * @param scoreAggregationType Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
         * 
         * @return builder
         * 
         */
        public Builder scoreAggregationType(String scoreAggregationType) {
            return scoreAggregationType(Output.of(scoreAggregationType));
        }

        /**
         * @param staticRrSets Contains static recordsets.
         * 
         * @return builder
         * 
         */
        public Builder staticRrSets(@Nullable Output<List<GetGtmDomainPropertyStaticRrSetArgs>> staticRrSets) {
            $.staticRrSets = staticRrSets;
            return this;
        }

        /**
         * @param staticRrSets Contains static recordsets.
         * 
         * @return builder
         * 
         */
        public Builder staticRrSets(List<GetGtmDomainPropertyStaticRrSetArgs> staticRrSets) {
            return staticRrSets(Output.of(staticRrSets));
        }

        /**
         * @param staticRrSets Contains static recordsets.
         * 
         * @return builder
         * 
         */
        public Builder staticRrSets(GetGtmDomainPropertyStaticRrSetArgs... staticRrSets) {
            return staticRrSets(List.of(staticRrSets));
        }

        /**
         * @param staticTtl Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
         * 
         * @return builder
         * 
         */
        public Builder staticTtl(Output<Integer> staticTtl) {
            $.staticTtl = staticTtl;
            return this;
        }

        /**
         * @param staticTtl Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
         * 
         * @return builder
         * 
         */
        public Builder staticTtl(Integer staticTtl) {
            return staticTtl(Output.of(staticTtl));
        }

        /**
         * @param sticknessBonusConstant Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusConstant(Output<Integer> sticknessBonusConstant) {
            $.sticknessBonusConstant = sticknessBonusConstant;
            return this;
        }

        /**
         * @param sticknessBonusConstant Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusConstant(Integer sticknessBonusConstant) {
            return sticknessBonusConstant(Output.of(sticknessBonusConstant));
        }

        /**
         * @param sticknessBonusPercentage Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusPercentage(Output<Integer> sticknessBonusPercentage) {
            $.sticknessBonusPercentage = sticknessBonusPercentage;
            return this;
        }

        /**
         * @param sticknessBonusPercentage Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusPercentage(Integer sticknessBonusPercentage) {
            return sticknessBonusPercentage(Output.of(sticknessBonusPercentage));
        }

        /**
         * @param trafficTargets Traffic targets for the property.
         * 
         * @return builder
         * 
         */
        public Builder trafficTargets(@Nullable Output<List<GetGtmDomainPropertyTrafficTargetArgs>> trafficTargets) {
            $.trafficTargets = trafficTargets;
            return this;
        }

        /**
         * @param trafficTargets Traffic targets for the property.
         * 
         * @return builder
         * 
         */
        public Builder trafficTargets(List<GetGtmDomainPropertyTrafficTargetArgs> trafficTargets) {
            return trafficTargets(Output.of(trafficTargets));
        }

        /**
         * @param trafficTargets Traffic targets for the property.
         * 
         * @return builder
         * 
         */
        public Builder trafficTargets(GetGtmDomainPropertyTrafficTargetArgs... trafficTargets) {
            return trafficTargets(List.of(trafficTargets));
        }

        /**
         * @param type Specifies the load balancing behvior for the property.
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type Specifies the load balancing behvior for the property.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param unreachableThreshold For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
         * 
         * @return builder
         * 
         */
        public Builder unreachableThreshold(Output<Double> unreachableThreshold) {
            $.unreachableThreshold = unreachableThreshold;
            return this;
        }

        /**
         * @param unreachableThreshold For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
         * 
         * @return builder
         * 
         */
        public Builder unreachableThreshold(Double unreachableThreshold) {
            return unreachableThreshold(Output.of(unreachableThreshold));
        }

        /**
         * @param useComputedTargets For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
         * 
         * @return builder
         * 
         */
        public Builder useComputedTargets(Output<Boolean> useComputedTargets) {
            $.useComputedTargets = useComputedTargets;
            return this;
        }

        /**
         * @param useComputedTargets For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
         * 
         * @return builder
         * 
         */
        public Builder useComputedTargets(Boolean useComputedTargets) {
            return useComputedTargets(Output.of(useComputedTargets));
        }

        /**
         * @param weightedHashBitsForIpv4 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv4(Output<Integer> weightedHashBitsForIpv4) {
            $.weightedHashBitsForIpv4 = weightedHashBitsForIpv4;
            return this;
        }

        /**
         * @param weightedHashBitsForIpv4 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv4(Integer weightedHashBitsForIpv4) {
            return weightedHashBitsForIpv4(Output.of(weightedHashBitsForIpv4));
        }

        /**
         * @param weightedHashBitsForIpv6 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv6(Output<Integer> weightedHashBitsForIpv6) {
            $.weightedHashBitsForIpv6 = weightedHashBitsForIpv6;
            return this;
        }

        /**
         * @param weightedHashBitsForIpv6 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv6(Integer weightedHashBitsForIpv6) {
            return weightedHashBitsForIpv6(Output.of(weightedHashBitsForIpv6));
        }

        public GetGtmDomainPropertyArgs build() {
            if ($.backupCname == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "backupCname");
            }
            if ($.backupIp == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "backupIp");
            }
            if ($.balanceByDownloadScore == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "balanceByDownloadScore");
            }
            if ($.cname == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "cname");
            }
            if ($.comments == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "comments");
            }
            if ($.dynamicTtl == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "dynamicTtl");
            }
            if ($.failbackDelay == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "failbackDelay");
            }
            if ($.failoverDelay == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "failoverDelay");
            }
            if ($.ghostDemandReporting == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "ghostDemandReporting");
            }
            if ($.handoutLimit == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "handoutLimit");
            }
            if ($.handoutMode == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "handoutMode");
            }
            if ($.healthMax == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "healthMax");
            }
            if ($.healthMultiplier == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "healthMultiplier");
            }
            if ($.healthThreshold == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "healthThreshold");
            }
            if ($.ipv6 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "ipv6");
            }
            if ($.lastModified == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "lastModified");
            }
            if ($.loadImbalancePercentage == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "loadImbalancePercentage");
            }
            if ($.mapName == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "mapName");
            }
            if ($.maxUnreachablePenalty == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "maxUnreachablePenalty");
            }
            if ($.minLiveFraction == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "minLiveFraction");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "name");
            }
            if ($.scoreAggregationType == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "scoreAggregationType");
            }
            if ($.staticTtl == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "staticTtl");
            }
            if ($.sticknessBonusConstant == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "sticknessBonusConstant");
            }
            if ($.sticknessBonusPercentage == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "sticknessBonusPercentage");
            }
            if ($.type == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "type");
            }
            if ($.unreachableThreshold == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "unreachableThreshold");
            }
            if ($.useComputedTargets == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "useComputedTargets");
            }
            if ($.weightedHashBitsForIpv4 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "weightedHashBitsForIpv4");
            }
            if ($.weightedHashBitsForIpv6 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainPropertyArgs", "weightedHashBitsForIpv6");
            }
            return $;
        }
    }

}
