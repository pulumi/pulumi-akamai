// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.inputs;

import com.pulumi.akamai.inputs.GetGtmDomainPropertyLink;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyLivenessTest;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyStaticRrSet;
import com.pulumi.akamai.inputs.GetGtmDomainPropertyTrafficTarget;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetGtmDomainProperty extends com.pulumi.resources.InvokeArgs {

    public static final GetGtmDomainProperty Empty = new GetGtmDomainProperty();

    /**
     * Specifies a backup CNAME.
     * 
     */
    @Import(name="backupCname", required=true)
    private String backupCname;

    /**
     * @return Specifies a backup CNAME.
     * 
     */
    public String backupCname() {
        return this.backupCname;
    }

    /**
     * Specifies a backup IP.
     * 
     */
    @Import(name="backupIp", required=true)
    private String backupIp;

    /**
     * @return Specifies a backup IP.
     * 
     */
    public String backupIp() {
        return this.backupIp;
    }

    /**
     * Indicates whether download score based load balancing is enabled.
     * 
     */
    @Import(name="balanceByDownloadScore", required=true)
    private Boolean balanceByDownloadScore;

    /**
     * @return Indicates whether download score based load balancing is enabled.
     * 
     */
    public Boolean balanceByDownloadScore() {
        return this.balanceByDownloadScore;
    }

    /**
     * Indicates the fully qualified name aliased to a particular property.
     * 
     */
    @Import(name="cname", required=true)
    private String cname;

    /**
     * @return Indicates the fully qualified name aliased to a particular property.
     * 
     */
    public String cname() {
        return this.cname;
    }

    /**
     * Descriptive comments for the property.
     * 
     */
    @Import(name="comments", required=true)
    private String comments;

    /**
     * @return Descriptive comments for the property.
     * 
     */
    public String comments() {
        return this.comments;
    }

    /**
     * Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    @Import(name="dynamicTtl", required=true)
    private Integer dynamicTtl;

    /**
     * @return Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    public Integer dynamicTtl() {
        return this.dynamicTtl;
    }

    /**
     * Specifies the failback delay in seconds.
     * 
     */
    @Import(name="failbackDelay", required=true)
    private Integer failbackDelay;

    /**
     * @return Specifies the failback delay in seconds.
     * 
     */
    public Integer failbackDelay() {
        return this.failbackDelay;
    }

    /**
     * Specifies the failover delay in seconds.
     * 
     */
    @Import(name="failoverDelay", required=true)
    private Integer failoverDelay;

    /**
     * @return Specifies the failover delay in seconds.
     * 
     */
    public Integer failoverDelay() {
        return this.failoverDelay;
    }

    /**
     * Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    @Import(name="ghostDemandReporting", required=true)
    private Boolean ghostDemandReporting;

    /**
     * @return Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    public Boolean ghostDemandReporting() {
        return this.ghostDemandReporting;
    }

    /**
     * Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    @Import(name="handoutLimit", required=true)
    private Integer handoutLimit;

    /**
     * @return Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    public Integer handoutLimit() {
        return this.handoutLimit;
    }

    /**
     * Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    @Import(name="handoutMode", required=true)
    private String handoutMode;

    /**
     * @return Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    public String handoutMode() {
        return this.handoutMode;
    }

    /**
     * Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    @Import(name="healthMax", required=true)
    private Double healthMax;

    /**
     * @return Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    public Double healthMax() {
        return this.healthMax;
    }

    /**
     * Configures a cutoff value that is computed from the median scores.
     * 
     */
    @Import(name="healthMultiplier", required=true)
    private Double healthMultiplier;

    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Double healthMultiplier() {
        return this.healthMultiplier;
    }

    /**
     * Configures a cutoff value that is computed from the median scores.
     * 
     */
    @Import(name="healthThreshold", required=true)
    private Double healthThreshold;

    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Double healthThreshold() {
        return this.healthThreshold;
    }

    /**
     * Indicates the type of IP address handed out by a property.
     * 
     */
    @Import(name="ipv6", required=true)
    private Boolean ipv6;

    /**
     * @return Indicates the type of IP address handed out by a property.
     * 
     */
    public Boolean ipv6() {
        return this.ipv6;
    }

    /**
     * An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    @Import(name="lastModified", required=true)
    private String lastModified;

    /**
     * @return An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    public String lastModified() {
        return this.lastModified;
    }

    /**
     * Provides a URL path that allows direct navigation to the property.
     * 
     */
    @Import(name="links")
    private @Nullable List<GetGtmDomainPropertyLink> links;

    /**
     * @return Provides a URL path that allows direct navigation to the property.
     * 
     */
    public Optional<List<GetGtmDomainPropertyLink>> links() {
        return Optional.ofNullable(this.links);
    }

    /**
     * Contains information about liveness tests.
     * 
     */
    @Import(name="livenessTests")
    private @Nullable List<GetGtmDomainPropertyLivenessTest> livenessTests;

    /**
     * @return Contains information about liveness tests.
     * 
     */
    public Optional<List<GetGtmDomainPropertyLivenessTest>> livenessTests() {
        return Optional.ofNullable(this.livenessTests);
    }

    /**
     * Indicates the percent of load imbalance factor for the domain.
     * 
     */
    @Import(name="loadImbalancePercentage", required=true)
    private Double loadImbalancePercentage;

    /**
     * @return Indicates the percent of load imbalance factor for the domain.
     * 
     */
    public Double loadImbalancePercentage() {
        return this.loadImbalancePercentage;
    }

    /**
     * A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    @Import(name="mapName", required=true)
    private String mapName;

    /**
     * @return A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    public String mapName() {
        return this.mapName;
    }

    /**
     * For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    @Import(name="maxUnreachablePenalty", required=true)
    private Integer maxUnreachablePenalty;

    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    public Integer maxUnreachablePenalty() {
        return this.maxUnreachablePenalty;
    }

    /**
     * Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    @Import(name="minLiveFraction", required=true)
    private Double minLiveFraction;

    /**
     * @return Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    public Double minLiveFraction() {
        return this.minLiveFraction;
    }

    /**
     * A descriptive label for the property.
     * 
     */
    @Import(name="name", required=true)
    private String name;

    /**
     * @return A descriptive label for the property.
     * 
     */
    public String name() {
        return this.name;
    }

    /**
     * Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    @Import(name="scoreAggregationType", required=true)
    private String scoreAggregationType;

    /**
     * @return Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    public String scoreAggregationType() {
        return this.scoreAggregationType;
    }

    /**
     * Contains static recordsets.
     * 
     */
    @Import(name="staticRrSets")
    private @Nullable List<GetGtmDomainPropertyStaticRrSet> staticRrSets;

    /**
     * @return Contains static recordsets.
     * 
     */
    public Optional<List<GetGtmDomainPropertyStaticRrSet>> staticRrSets() {
        return Optional.ofNullable(this.staticRrSets);
    }

    /**
     * Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    @Import(name="staticTtl", required=true)
    private Integer staticTtl;

    /**
     * @return Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    public Integer staticTtl() {
        return this.staticTtl;
    }

    /**
     * Specifies a percentage used to configure data center affinity.
     * 
     */
    @Import(name="sticknessBonusConstant", required=true)
    private Integer sticknessBonusConstant;

    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Integer sticknessBonusConstant() {
        return this.sticknessBonusConstant;
    }

    /**
     * Specifies a percentage used to configure data center affinity.
     * 
     */
    @Import(name="sticknessBonusPercentage", required=true)
    private Integer sticknessBonusPercentage;

    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Integer sticknessBonusPercentage() {
        return this.sticknessBonusPercentage;
    }

    /**
     * Traffic targets for the property.
     * 
     */
    @Import(name="trafficTargets")
    private @Nullable List<GetGtmDomainPropertyTrafficTarget> trafficTargets;

    /**
     * @return Traffic targets for the property.
     * 
     */
    public Optional<List<GetGtmDomainPropertyTrafficTarget>> trafficTargets() {
        return Optional.ofNullable(this.trafficTargets);
    }

    /**
     * Specifies the load balancing behvior for the property.
     * 
     */
    @Import(name="type", required=true)
    private String type;

    /**
     * @return Specifies the load balancing behvior for the property.
     * 
     */
    public String type() {
        return this.type;
    }

    /**
     * For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    @Import(name="unreachableThreshold", required=true)
    private Double unreachableThreshold;

    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    public Double unreachableThreshold() {
        return this.unreachableThreshold;
    }

    /**
     * For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    @Import(name="useComputedTargets", required=true)
    private Boolean useComputedTargets;

    /**
     * @return For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    public Boolean useComputedTargets() {
        return this.useComputedTargets;
    }

    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    @Import(name="weightedHashBitsForIpv4", required=true)
    private Integer weightedHashBitsForIpv4;

    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    public Integer weightedHashBitsForIpv4() {
        return this.weightedHashBitsForIpv4;
    }

    /**
     * For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    @Import(name="weightedHashBitsForIpv6", required=true)
    private Integer weightedHashBitsForIpv6;

    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    public Integer weightedHashBitsForIpv6() {
        return this.weightedHashBitsForIpv6;
    }

    private GetGtmDomainProperty() {}

    private GetGtmDomainProperty(GetGtmDomainProperty $) {
        this.backupCname = $.backupCname;
        this.backupIp = $.backupIp;
        this.balanceByDownloadScore = $.balanceByDownloadScore;
        this.cname = $.cname;
        this.comments = $.comments;
        this.dynamicTtl = $.dynamicTtl;
        this.failbackDelay = $.failbackDelay;
        this.failoverDelay = $.failoverDelay;
        this.ghostDemandReporting = $.ghostDemandReporting;
        this.handoutLimit = $.handoutLimit;
        this.handoutMode = $.handoutMode;
        this.healthMax = $.healthMax;
        this.healthMultiplier = $.healthMultiplier;
        this.healthThreshold = $.healthThreshold;
        this.ipv6 = $.ipv6;
        this.lastModified = $.lastModified;
        this.links = $.links;
        this.livenessTests = $.livenessTests;
        this.loadImbalancePercentage = $.loadImbalancePercentage;
        this.mapName = $.mapName;
        this.maxUnreachablePenalty = $.maxUnreachablePenalty;
        this.minLiveFraction = $.minLiveFraction;
        this.name = $.name;
        this.scoreAggregationType = $.scoreAggregationType;
        this.staticRrSets = $.staticRrSets;
        this.staticTtl = $.staticTtl;
        this.sticknessBonusConstant = $.sticknessBonusConstant;
        this.sticknessBonusPercentage = $.sticknessBonusPercentage;
        this.trafficTargets = $.trafficTargets;
        this.type = $.type;
        this.unreachableThreshold = $.unreachableThreshold;
        this.useComputedTargets = $.useComputedTargets;
        this.weightedHashBitsForIpv4 = $.weightedHashBitsForIpv4;
        this.weightedHashBitsForIpv6 = $.weightedHashBitsForIpv6;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetGtmDomainProperty defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetGtmDomainProperty $;

        public Builder() {
            $ = new GetGtmDomainProperty();
        }

        public Builder(GetGtmDomainProperty defaults) {
            $ = new GetGtmDomainProperty(Objects.requireNonNull(defaults));
        }

        /**
         * @param backupCname Specifies a backup CNAME.
         * 
         * @return builder
         * 
         */
        public Builder backupCname(String backupCname) {
            $.backupCname = backupCname;
            return this;
        }

        /**
         * @param backupIp Specifies a backup IP.
         * 
         * @return builder
         * 
         */
        public Builder backupIp(String backupIp) {
            $.backupIp = backupIp;
            return this;
        }

        /**
         * @param balanceByDownloadScore Indicates whether download score based load balancing is enabled.
         * 
         * @return builder
         * 
         */
        public Builder balanceByDownloadScore(Boolean balanceByDownloadScore) {
            $.balanceByDownloadScore = balanceByDownloadScore;
            return this;
        }

        /**
         * @param cname Indicates the fully qualified name aliased to a particular property.
         * 
         * @return builder
         * 
         */
        public Builder cname(String cname) {
            $.cname = cname;
            return this;
        }

        /**
         * @param comments Descriptive comments for the property.
         * 
         * @return builder
         * 
         */
        public Builder comments(String comments) {
            $.comments = comments;
            return this;
        }

        /**
         * @param dynamicTtl Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
         * 
         * @return builder
         * 
         */
        public Builder dynamicTtl(Integer dynamicTtl) {
            $.dynamicTtl = dynamicTtl;
            return this;
        }

        /**
         * @param failbackDelay Specifies the failback delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failbackDelay(Integer failbackDelay) {
            $.failbackDelay = failbackDelay;
            return this;
        }

        /**
         * @param failoverDelay Specifies the failover delay in seconds.
         * 
         * @return builder
         * 
         */
        public Builder failoverDelay(Integer failoverDelay) {
            $.failoverDelay = failoverDelay;
            return this;
        }

        /**
         * @param ghostDemandReporting Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
         * 
         * @return builder
         * 
         */
        public Builder ghostDemandReporting(Boolean ghostDemandReporting) {
            $.ghostDemandReporting = ghostDemandReporting;
            return this;
        }

        /**
         * @param handoutLimit Indicates the limit for the number of live IPs handed out to a DNS request.
         * 
         * @return builder
         * 
         */
        public Builder handoutLimit(Integer handoutLimit) {
            $.handoutLimit = handoutLimit;
            return this;
        }

        /**
         * @param handoutMode Specifies how IPs are returned when more than one IP is alive and available.
         * 
         * @return builder
         * 
         */
        public Builder handoutMode(String handoutMode) {
            $.handoutMode = handoutMode;
            return this;
        }

        /**
         * @param healthMax Defines the absolute limit beyond which IPs are declared unhealthy.
         * 
         * @return builder
         * 
         */
        public Builder healthMax(Double healthMax) {
            $.healthMax = healthMax;
            return this;
        }

        /**
         * @param healthMultiplier Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthMultiplier(Double healthMultiplier) {
            $.healthMultiplier = healthMultiplier;
            return this;
        }

        /**
         * @param healthThreshold Configures a cutoff value that is computed from the median scores.
         * 
         * @return builder
         * 
         */
        public Builder healthThreshold(Double healthThreshold) {
            $.healthThreshold = healthThreshold;
            return this;
        }

        /**
         * @param ipv6 Indicates the type of IP address handed out by a property.
         * 
         * @return builder
         * 
         */
        public Builder ipv6(Boolean ipv6) {
            $.ipv6 = ipv6;
            return this;
        }

        /**
         * @param lastModified An ISO 8601 timestamp that indicates when the property was last changed.
         * 
         * @return builder
         * 
         */
        public Builder lastModified(String lastModified) {
            $.lastModified = lastModified;
            return this;
        }

        /**
         * @param links Provides a URL path that allows direct navigation to the property.
         * 
         * @return builder
         * 
         */
        public Builder links(@Nullable List<GetGtmDomainPropertyLink> links) {
            $.links = links;
            return this;
        }

        /**
         * @param links Provides a URL path that allows direct navigation to the property.
         * 
         * @return builder
         * 
         */
        public Builder links(GetGtmDomainPropertyLink... links) {
            return links(List.of(links));
        }

        /**
         * @param livenessTests Contains information about liveness tests.
         * 
         * @return builder
         * 
         */
        public Builder livenessTests(@Nullable List<GetGtmDomainPropertyLivenessTest> livenessTests) {
            $.livenessTests = livenessTests;
            return this;
        }

        /**
         * @param livenessTests Contains information about liveness tests.
         * 
         * @return builder
         * 
         */
        public Builder livenessTests(GetGtmDomainPropertyLivenessTest... livenessTests) {
            return livenessTests(List.of(livenessTests));
        }

        /**
         * @param loadImbalancePercentage Indicates the percent of load imbalance factor for the domain.
         * 
         * @return builder
         * 
         */
        public Builder loadImbalancePercentage(Double loadImbalancePercentage) {
            $.loadImbalancePercentage = loadImbalancePercentage;
            return this;
        }

        /**
         * @param mapName A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
         * 
         * @return builder
         * 
         */
        public Builder mapName(String mapName) {
            $.mapName = mapName;
            return this;
        }

        /**
         * @param maxUnreachablePenalty For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
         * 
         * @return builder
         * 
         */
        public Builder maxUnreachablePenalty(Integer maxUnreachablePenalty) {
            $.maxUnreachablePenalty = maxUnreachablePenalty;
            return this;
        }

        /**
         * @param minLiveFraction Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
         * 
         * @return builder
         * 
         */
        public Builder minLiveFraction(Double minLiveFraction) {
            $.minLiveFraction = minLiveFraction;
            return this;
        }

        /**
         * @param name A descriptive label for the property.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            $.name = name;
            return this;
        }

        /**
         * @param scoreAggregationType Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
         * 
         * @return builder
         * 
         */
        public Builder scoreAggregationType(String scoreAggregationType) {
            $.scoreAggregationType = scoreAggregationType;
            return this;
        }

        /**
         * @param staticRrSets Contains static recordsets.
         * 
         * @return builder
         * 
         */
        public Builder staticRrSets(@Nullable List<GetGtmDomainPropertyStaticRrSet> staticRrSets) {
            $.staticRrSets = staticRrSets;
            return this;
        }

        /**
         * @param staticRrSets Contains static recordsets.
         * 
         * @return builder
         * 
         */
        public Builder staticRrSets(GetGtmDomainPropertyStaticRrSet... staticRrSets) {
            return staticRrSets(List.of(staticRrSets));
        }

        /**
         * @param staticTtl Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
         * 
         * @return builder
         * 
         */
        public Builder staticTtl(Integer staticTtl) {
            $.staticTtl = staticTtl;
            return this;
        }

        /**
         * @param sticknessBonusConstant Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusConstant(Integer sticknessBonusConstant) {
            $.sticknessBonusConstant = sticknessBonusConstant;
            return this;
        }

        /**
         * @param sticknessBonusPercentage Specifies a percentage used to configure data center affinity.
         * 
         * @return builder
         * 
         */
        public Builder sticknessBonusPercentage(Integer sticknessBonusPercentage) {
            $.sticknessBonusPercentage = sticknessBonusPercentage;
            return this;
        }

        /**
         * @param trafficTargets Traffic targets for the property.
         * 
         * @return builder
         * 
         */
        public Builder trafficTargets(@Nullable List<GetGtmDomainPropertyTrafficTarget> trafficTargets) {
            $.trafficTargets = trafficTargets;
            return this;
        }

        /**
         * @param trafficTargets Traffic targets for the property.
         * 
         * @return builder
         * 
         */
        public Builder trafficTargets(GetGtmDomainPropertyTrafficTarget... trafficTargets) {
            return trafficTargets(List.of(trafficTargets));
        }

        /**
         * @param type Specifies the load balancing behvior for the property.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            $.type = type;
            return this;
        }

        /**
         * @param unreachableThreshold For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
         * 
         * @return builder
         * 
         */
        public Builder unreachableThreshold(Double unreachableThreshold) {
            $.unreachableThreshold = unreachableThreshold;
            return this;
        }

        /**
         * @param useComputedTargets For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
         * 
         * @return builder
         * 
         */
        public Builder useComputedTargets(Boolean useComputedTargets) {
            $.useComputedTargets = useComputedTargets;
            return this;
        }

        /**
         * @param weightedHashBitsForIpv4 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv4(Integer weightedHashBitsForIpv4) {
            $.weightedHashBitsForIpv4 = weightedHashBitsForIpv4;
            return this;
        }

        /**
         * @param weightedHashBitsForIpv6 For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
         * 
         * @return builder
         * 
         */
        public Builder weightedHashBitsForIpv6(Integer weightedHashBitsForIpv6) {
            $.weightedHashBitsForIpv6 = weightedHashBitsForIpv6;
            return this;
        }

        public GetGtmDomainProperty build() {
            if ($.backupCname == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "backupCname");
            }
            if ($.backupIp == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "backupIp");
            }
            if ($.balanceByDownloadScore == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "balanceByDownloadScore");
            }
            if ($.cname == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "cname");
            }
            if ($.comments == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "comments");
            }
            if ($.dynamicTtl == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "dynamicTtl");
            }
            if ($.failbackDelay == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "failbackDelay");
            }
            if ($.failoverDelay == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "failoverDelay");
            }
            if ($.ghostDemandReporting == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "ghostDemandReporting");
            }
            if ($.handoutLimit == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "handoutLimit");
            }
            if ($.handoutMode == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "handoutMode");
            }
            if ($.healthMax == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthMax");
            }
            if ($.healthMultiplier == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthMultiplier");
            }
            if ($.healthThreshold == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthThreshold");
            }
            if ($.ipv6 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "ipv6");
            }
            if ($.lastModified == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "lastModified");
            }
            if ($.loadImbalancePercentage == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "loadImbalancePercentage");
            }
            if ($.mapName == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "mapName");
            }
            if ($.maxUnreachablePenalty == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "maxUnreachablePenalty");
            }
            if ($.minLiveFraction == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "minLiveFraction");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "name");
            }
            if ($.scoreAggregationType == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "scoreAggregationType");
            }
            if ($.staticTtl == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "staticTtl");
            }
            if ($.sticknessBonusConstant == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "sticknessBonusConstant");
            }
            if ($.sticknessBonusPercentage == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "sticknessBonusPercentage");
            }
            if ($.type == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "type");
            }
            if ($.unreachableThreshold == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "unreachableThreshold");
            }
            if ($.useComputedTargets == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "useComputedTargets");
            }
            if ($.weightedHashBitsForIpv4 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "weightedHashBitsForIpv4");
            }
            if ($.weightedHashBitsForIpv6 == null) {
                throw new MissingRequiredPropertyException("GetGtmDomainProperty", "weightedHashBitsForIpv6");
            }
            return $;
        }
    }

}
