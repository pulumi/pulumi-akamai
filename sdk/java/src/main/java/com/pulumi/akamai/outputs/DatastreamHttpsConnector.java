// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class DatastreamHttpsConnector {
    /**
     * @return Either NONE for no authentication, or BASIC for username and password authentication
     * 
     */
    private String authenticationType;
    /**
     * @return The certification authority (CA) certificate used to verify the origin server&#39;s certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    private @Nullable String caCert;
    /**
     * @return The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     * 
     */
    private @Nullable String clientCert;
    /**
     * @return The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    private @Nullable String clientKey;
    /**
     * @return Indicates whether the logs should be compressed
     * 
     */
    private @Nullable Boolean compressLogs;
    /**
     * @return Content type to pass in the log file header
     * 
     */
    private @Nullable String contentType;
    /**
     * @return The name of custom header passed with the request to the destination
     * 
     */
    private @Nullable String customHeaderName;
    /**
     * @return The custom header&#39;s contents passed with the request to the destination
     * 
     */
    private @Nullable String customHeaderValue;
    /**
     * @return The name of the connector
     * 
     */
    private String displayName;
    /**
     * @return URL where logs will be stored
     * 
     */
    private String endpoint;
    /**
     * @return Indicates whether mTLS is enabled or not.
     * 
     */
    private @Nullable Boolean mTls;
    /**
     * @return Password set for custom HTTPS endpoint for authentication
     * 
     */
    private @Nullable String password;
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    private @Nullable String tlsHostname;
    /**
     * @return Username used for authentication
     * 
     */
    private @Nullable String userName;

    private DatastreamHttpsConnector() {}
    /**
     * @return Either NONE for no authentication, or BASIC for username and password authentication
     * 
     */
    public String authenticationType() {
        return this.authenticationType;
    }
    /**
     * @return The certification authority (CA) certificate used to verify the origin server&#39;s certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    public Optional<String> caCert() {
        return Optional.ofNullable(this.caCert);
    }
    /**
     * @return The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     * 
     */
    public Optional<String> clientCert() {
        return Optional.ofNullable(this.clientCert);
    }
    /**
     * @return The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    public Optional<String> clientKey() {
        return Optional.ofNullable(this.clientKey);
    }
    /**
     * @return Indicates whether the logs should be compressed
     * 
     */
    public Optional<Boolean> compressLogs() {
        return Optional.ofNullable(this.compressLogs);
    }
    /**
     * @return Content type to pass in the log file header
     * 
     */
    public Optional<String> contentType() {
        return Optional.ofNullable(this.contentType);
    }
    /**
     * @return The name of custom header passed with the request to the destination
     * 
     */
    public Optional<String> customHeaderName() {
        return Optional.ofNullable(this.customHeaderName);
    }
    /**
     * @return The custom header&#39;s contents passed with the request to the destination
     * 
     */
    public Optional<String> customHeaderValue() {
        return Optional.ofNullable(this.customHeaderValue);
    }
    /**
     * @return The name of the connector
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return URL where logs will be stored
     * 
     */
    public String endpoint() {
        return this.endpoint;
    }
    /**
     * @return Indicates whether mTLS is enabled or not.
     * 
     */
    public Optional<Boolean> mTls() {
        return Optional.ofNullable(this.mTls);
    }
    /**
     * @return Password set for custom HTTPS endpoint for authentication
     * 
     */
    public Optional<String> password() {
        return Optional.ofNullable(this.password);
    }
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    public Optional<String> tlsHostname() {
        return Optional.ofNullable(this.tlsHostname);
    }
    /**
     * @return Username used for authentication
     * 
     */
    public Optional<String> userName() {
        return Optional.ofNullable(this.userName);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(DatastreamHttpsConnector defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String authenticationType;
        private @Nullable String caCert;
        private @Nullable String clientCert;
        private @Nullable String clientKey;
        private @Nullable Boolean compressLogs;
        private @Nullable String contentType;
        private @Nullable String customHeaderName;
        private @Nullable String customHeaderValue;
        private String displayName;
        private String endpoint;
        private @Nullable Boolean mTls;
        private @Nullable String password;
        private @Nullable String tlsHostname;
        private @Nullable String userName;
        public Builder() {}
        public Builder(DatastreamHttpsConnector defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.authenticationType = defaults.authenticationType;
    	      this.caCert = defaults.caCert;
    	      this.clientCert = defaults.clientCert;
    	      this.clientKey = defaults.clientKey;
    	      this.compressLogs = defaults.compressLogs;
    	      this.contentType = defaults.contentType;
    	      this.customHeaderName = defaults.customHeaderName;
    	      this.customHeaderValue = defaults.customHeaderValue;
    	      this.displayName = defaults.displayName;
    	      this.endpoint = defaults.endpoint;
    	      this.mTls = defaults.mTls;
    	      this.password = defaults.password;
    	      this.tlsHostname = defaults.tlsHostname;
    	      this.userName = defaults.userName;
        }

        @CustomType.Setter
        public Builder authenticationType(String authenticationType) {
            if (authenticationType == null) {
              throw new MissingRequiredPropertyException("DatastreamHttpsConnector", "authenticationType");
            }
            this.authenticationType = authenticationType;
            return this;
        }
        @CustomType.Setter
        public Builder caCert(@Nullable String caCert) {

            this.caCert = caCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientCert(@Nullable String clientCert) {

            this.clientCert = clientCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientKey(@Nullable String clientKey) {

            this.clientKey = clientKey;
            return this;
        }
        @CustomType.Setter
        public Builder compressLogs(@Nullable Boolean compressLogs) {

            this.compressLogs = compressLogs;
            return this;
        }
        @CustomType.Setter
        public Builder contentType(@Nullable String contentType) {

            this.contentType = contentType;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderName(@Nullable String customHeaderName) {

            this.customHeaderName = customHeaderName;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderValue(@Nullable String customHeaderValue) {

            this.customHeaderValue = customHeaderValue;
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            if (displayName == null) {
              throw new MissingRequiredPropertyException("DatastreamHttpsConnector", "displayName");
            }
            this.displayName = displayName;
            return this;
        }
        @CustomType.Setter
        public Builder endpoint(String endpoint) {
            if (endpoint == null) {
              throw new MissingRequiredPropertyException("DatastreamHttpsConnector", "endpoint");
            }
            this.endpoint = endpoint;
            return this;
        }
        @CustomType.Setter
        public Builder mTls(@Nullable Boolean mTls) {

            this.mTls = mTls;
            return this;
        }
        @CustomType.Setter
        public Builder password(@Nullable String password) {

            this.password = password;
            return this;
        }
        @CustomType.Setter
        public Builder tlsHostname(@Nullable String tlsHostname) {

            this.tlsHostname = tlsHostname;
            return this;
        }
        @CustomType.Setter
        public Builder userName(@Nullable String userName) {

            this.userName = userName;
            return this;
        }
        public DatastreamHttpsConnector build() {
            final var _resultValue = new DatastreamHttpsConnector();
            _resultValue.authenticationType = authenticationType;
            _resultValue.caCert = caCert;
            _resultValue.clientCert = clientCert;
            _resultValue.clientKey = clientKey;
            _resultValue.compressLogs = compressLogs;
            _resultValue.contentType = contentType;
            _resultValue.customHeaderName = customHeaderName;
            _resultValue.customHeaderValue = customHeaderValue;
            _resultValue.displayName = displayName;
            _resultValue.endpoint = endpoint;
            _resultValue.mTls = mTls;
            _resultValue.password = password;
            _resultValue.tlsHostname = tlsHostname;
            _resultValue.userName = userName;
            return _resultValue;
        }
    }
}
