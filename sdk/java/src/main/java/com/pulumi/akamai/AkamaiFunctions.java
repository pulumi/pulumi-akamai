// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai;

import com.pulumi.akamai.Utilities;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsLoggingArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsLoggingPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;
import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;
import com.pulumi.akamai.inputs.GetAppSecApiEndpointsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;
import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;
import com.pulumi.akamai.inputs.GetAppSecAttackGroupsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;
import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
import com.pulumi.akamai.inputs.GetAppSecConfigurationPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecConfigurationVersionArgs;
import com.pulumi.akamai.inputs.GetAppSecConfigurationVersionPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
import com.pulumi.akamai.inputs.GetAppSecContractsGroupsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomDenyPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
import com.pulumi.akamai.inputs.GetAppSecCustomRulesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalGroupsArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalGroupsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;
import com.pulumi.akamai.inputs.GetAppSecEvalRulesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;
import com.pulumi.akamai.inputs.GetAppSecExportConfigurationPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;
import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;
import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;
import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;
import com.pulumi.akamai.inputs.GetAppSecIPGeoPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;
import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;
import com.pulumi.akamai.inputs.GetAppSecMatchTargetsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;
import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;
import com.pulumi.akamai.inputs.GetAppSecRatePoliciesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;
import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;
import com.pulumi.akamai.inputs.GetAppSecReputationProfilesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;
import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecRulesArgs;
import com.pulumi.akamai.inputs.GetAppSecRulesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyArgs;
import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;
import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;
import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;
import com.pulumi.akamai.inputs.GetAppSecSiemSettingsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;
import com.pulumi.akamai.inputs.GetAppSecSlowPostPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;
import com.pulumi.akamai.inputs.GetAppSecThreatIntelPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;
import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;
import com.pulumi.akamai.inputs.GetAppSecVersionNotesPlainArgs;
import com.pulumi.akamai.inputs.GetAppSecWafModeArgs;
import com.pulumi.akamai.inputs.GetAppSecWafModePlainArgs;
import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;
import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesPlainArgs;
import com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;
import com.pulumi.akamai.inputs.GetAuthoritiesSetPlainArgs;
import com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;
import com.pulumi.akamai.inputs.GetCPSEnrollmentPlainArgs;
import com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;
import com.pulumi.akamai.inputs.GetCPSEnrollmentsPlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;
import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerPlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;
import com.pulumi.akamai.inputs.GetCloudletsPolicyPlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetCloudletsVisitorPrioritizationMatchRuleArgs;
import com.pulumi.akamai.inputs.GetCloudletsVisitorPrioritizationMatchRulePlainArgs;
import com.pulumi.akamai.inputs.GetContractArgs;
import com.pulumi.akamai.inputs.GetContractPlainArgs;
import com.pulumi.akamai.inputs.GetCpCodeArgs;
import com.pulumi.akamai.inputs.GetCpCodePlainArgs;
import com.pulumi.akamai.inputs.GetCpsCsrArgs;
import com.pulumi.akamai.inputs.GetCpsCsrPlainArgs;
import com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;
import com.pulumi.akamai.inputs.GetCpsDeploymentsPlainArgs;
import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;
import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryPlainArgs;
import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsPlainArgs;
import com.pulumi.akamai.inputs.GetDatastreamsArgs;
import com.pulumi.akamai.inputs.GetDatastreamsPlainArgs;
import com.pulumi.akamai.inputs.GetDnsRecordSetArgs;
import com.pulumi.akamai.inputs.GetDnsRecordSetPlainArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkerActivationPlainArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkerArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkerPlainArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkersPropertyRulesArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkersPropertyRulesPlainArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;
import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierPlainArgs;
import com.pulumi.akamai.inputs.GetGroupArgs;
import com.pulumi.akamai.inputs.GetGroupPlainArgs;
import com.pulumi.akamai.inputs.GetGtmDefaultDatacenterArgs;
import com.pulumi.akamai.inputs.GetGtmDefaultDatacenterPlainArgs;
import com.pulumi.akamai.inputs.GetIamStatesArgs;
import com.pulumi.akamai.inputs.GetIamStatesPlainArgs;
import com.pulumi.akamai.inputs.GetNetworkListsArgs;
import com.pulumi.akamai.inputs.GetNetworkListsPlainArgs;
import com.pulumi.akamai.inputs.GetPropertiesArgs;
import com.pulumi.akamai.inputs.GetPropertiesPlainArgs;
import com.pulumi.akamai.inputs.GetPropertiesSearchArgs;
import com.pulumi.akamai.inputs.GetPropertiesSearchPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyArgs;
import com.pulumi.akamai.inputs.GetPropertyHostnamesArgs;
import com.pulumi.akamai.inputs.GetPropertyHostnamesPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeActivationArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeActivationPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeParentsPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludePlainArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludeRulesPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludesArgs;
import com.pulumi.akamai.inputs.GetPropertyIncludesPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyProductsArgs;
import com.pulumi.akamai.inputs.GetPropertyProductsPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyRulesArgs;
import com.pulumi.akamai.inputs.GetPropertyRulesPlainArgs;
import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
import com.pulumi.akamai.inputs.GetPropertyRulesTemplatePlainArgs;
import com.pulumi.akamai.outputs.GetAppSecAdvancedSettingsEvasivePathMatchResult;
import com.pulumi.akamai.outputs.GetAppSecAdvancedSettingsLoggingResult;
import com.pulumi.akamai.outputs.GetAppSecAdvancedSettingsPragmaHeaderResult;
import com.pulumi.akamai.outputs.GetAppSecAdvancedSettingsPrefetchResult;
import com.pulumi.akamai.outputs.GetAppSecApiEndpointsResult;
import com.pulumi.akamai.outputs.GetAppSecApiRequestConstraintsResult;
import com.pulumi.akamai.outputs.GetAppSecAttackGroupsResult;
import com.pulumi.akamai.outputs.GetAppSecBypassNetworkListsResult;
import com.pulumi.akamai.outputs.GetAppSecConfigurationResult;
import com.pulumi.akamai.outputs.GetAppSecConfigurationVersionResult;
import com.pulumi.akamai.outputs.GetAppSecContractsGroupsResult;
import com.pulumi.akamai.outputs.GetAppSecCustomDenyResult;
import com.pulumi.akamai.outputs.GetAppSecCustomRuleActionsResult;
import com.pulumi.akamai.outputs.GetAppSecCustomRulesResult;
import com.pulumi.akamai.outputs.GetAppSecEvalGroupsResult;
import com.pulumi.akamai.outputs.GetAppSecEvalPenaltyBoxResult;
import com.pulumi.akamai.outputs.GetAppSecEvalResult;
import com.pulumi.akamai.outputs.GetAppSecEvalRulesResult;
import com.pulumi.akamai.outputs.GetAppSecExportConfigurationResult;
import com.pulumi.akamai.outputs.GetAppSecFailoverHostnamesResult;
import com.pulumi.akamai.outputs.GetAppSecHostnameCoverageMatchTargetsResult;
import com.pulumi.akamai.outputs.GetAppSecHostnameCoverageOverlappingResult;
import com.pulumi.akamai.outputs.GetAppSecHostnameCoverageResult;
import com.pulumi.akamai.outputs.GetAppSecIPGeoResult;
import com.pulumi.akamai.outputs.GetAppSecMalwareContentTypesResult;
import com.pulumi.akamai.outputs.GetAppSecMalwarePoliciesResult;
import com.pulumi.akamai.outputs.GetAppSecMalwarePolicyActionsResult;
import com.pulumi.akamai.outputs.GetAppSecMatchTargetsResult;
import com.pulumi.akamai.outputs.GetAppSecPenaltyBoxResult;
import com.pulumi.akamai.outputs.GetAppSecRatePoliciesResult;
import com.pulumi.akamai.outputs.GetAppSecRatePolicyActionsResult;
import com.pulumi.akamai.outputs.GetAppSecReputationProfileActionsResult;
import com.pulumi.akamai.outputs.GetAppSecReputationProfileAnalysisResult;
import com.pulumi.akamai.outputs.GetAppSecReputationProfilesResult;
import com.pulumi.akamai.outputs.GetAppSecRuleUpgradeDetailsResult;
import com.pulumi.akamai.outputs.GetAppSecRulesResult;
import com.pulumi.akamai.outputs.GetAppSecSecurityPolicyProtectionsResult;
import com.pulumi.akamai.outputs.GetAppSecSecurityPolicyResult;
import com.pulumi.akamai.outputs.GetAppSecSelectableHostnamesResult;
import com.pulumi.akamai.outputs.GetAppSecSelectedHostnamesResult;
import com.pulumi.akamai.outputs.GetAppSecSiemDefinitionsResult;
import com.pulumi.akamai.outputs.GetAppSecSiemSettingsResult;
import com.pulumi.akamai.outputs.GetAppSecSlowPostResult;
import com.pulumi.akamai.outputs.GetAppSecThreatIntelResult;
import com.pulumi.akamai.outputs.GetAppSecTuningRecommendationsResult;
import com.pulumi.akamai.outputs.GetAppSecVersionNotesResult;
import com.pulumi.akamai.outputs.GetAppSecWafModeResult;
import com.pulumi.akamai.outputs.GetAppSecWapSelectedHostnamesResult;
import com.pulumi.akamai.outputs.GetAuthoritiesSetResult;
import com.pulumi.akamai.outputs.GetCPSEnrollmentResult;
import com.pulumi.akamai.outputs.GetCPSEnrollmentsResult;
import com.pulumi.akamai.outputs.GetCloudletsApiPrioritizationMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsApplicationLoadBalancerMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsApplicationLoadBalancerResult;
import com.pulumi.akamai.outputs.GetCloudletsAudienceSegmentationMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsEdgeRedirectorMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsForwardRewriteMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsPhasedReleaseMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsPolicyResult;
import com.pulumi.akamai.outputs.GetCloudletsRequestControlMatchRuleResult;
import com.pulumi.akamai.outputs.GetCloudletsVisitorPrioritizationMatchRuleResult;
import com.pulumi.akamai.outputs.GetContractResult;
import com.pulumi.akamai.outputs.GetContractsResult;
import com.pulumi.akamai.outputs.GetCpCodeResult;
import com.pulumi.akamai.outputs.GetCpsCsrResult;
import com.pulumi.akamai.outputs.GetCpsDeploymentsResult;
import com.pulumi.akamai.outputs.GetCpsWarningsResult;
import com.pulumi.akamai.outputs.GetDatastreamActivationHistoryResult;
import com.pulumi.akamai.outputs.GetDatastreamDatasetFieldsResult;
import com.pulumi.akamai.outputs.GetDatastreamsResult;
import com.pulumi.akamai.outputs.GetDnsRecordSetResult;
import com.pulumi.akamai.outputs.GetEdgeWorkerActivationResult;
import com.pulumi.akamai.outputs.GetEdgeWorkerResult;
import com.pulumi.akamai.outputs.GetEdgeWorkersPropertyRulesResult;
import com.pulumi.akamai.outputs.GetEdgeWorkersResourceTierResult;
import com.pulumi.akamai.outputs.GetGroupResult;
import com.pulumi.akamai.outputs.GetGroupsResult;
import com.pulumi.akamai.outputs.GetGtmDefaultDatacenterResult;
import com.pulumi.akamai.outputs.GetIamContactTypesResult;
import com.pulumi.akamai.outputs.GetIamCountriesResult;
import com.pulumi.akamai.outputs.GetIamGrantableRolesResult;
import com.pulumi.akamai.outputs.GetIamRolesResult;
import com.pulumi.akamai.outputs.GetIamStatesResult;
import com.pulumi.akamai.outputs.GetIamSupportedLangsResult;
import com.pulumi.akamai.outputs.GetIamTimeoutPoliciesResult;
import com.pulumi.akamai.outputs.GetIamTimezonesResult;
import com.pulumi.akamai.outputs.GetNetworkListsResult;
import com.pulumi.akamai.outputs.GetPropertiesResult;
import com.pulumi.akamai.outputs.GetPropertiesSearchResult;
import com.pulumi.akamai.outputs.GetPropertyHostnamesResult;
import com.pulumi.akamai.outputs.GetPropertyIncludeActivationResult;
import com.pulumi.akamai.outputs.GetPropertyIncludeParentsResult;
import com.pulumi.akamai.outputs.GetPropertyIncludeResult;
import com.pulumi.akamai.outputs.GetPropertyIncludeRulesResult;
import com.pulumi.akamai.outputs.GetPropertyIncludesResult;
import com.pulumi.akamai.outputs.GetPropertyProductsResult;
import com.pulumi.akamai.outputs.GetPropertyResult;
import com.pulumi.akamai.outputs.GetPropertyRuleFormatsResult;
import com.pulumi.akamai.outputs.GetPropertyRulesResult;
import com.pulumi.akamai.outputs.GetPropertyRulesTemplateResult;
import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.resources.InvokeArgs;
import java.util.concurrent.CompletableFuture;

public final class AkamaiFunctions {
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Use the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the `security_policy_id` parameter. For more information, see [Get evasive path match setting](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchOutput&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchJson&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *         final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchOutput&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchJson&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAppSecAdvancedSettingsEvasivePathMatchResult> getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs args) {
        return getAppSecAdvancedSettingsEvasivePathMatch(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Use the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the `security_policy_id` parameter. For more information, see [Get evasive path match setting](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchOutput&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchJson&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *         final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchOutput&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchJson&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsEvasivePathMatchResult> getAppSecAdvancedSettingsEvasivePathMatchPlain(GetAppSecAdvancedSettingsEvasivePathMatchPlainArgs args) {
        return getAppSecAdvancedSettingsEvasivePathMatchPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Use the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the `security_policy_id` parameter. For more information, see [Get evasive path match setting](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchOutput&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchJson&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *         final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchOutput&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchJson&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAppSecAdvancedSettingsEvasivePathMatchResult> getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecAdvancedSettingsEvasivePathMatch:getAppSecAdvancedSettingsEvasivePathMatch", TypeShape.of(GetAppSecAdvancedSettingsEvasivePathMatchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Use the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the `security_policy_id` parameter. For more information, see [Get evasive path match setting](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchOutput&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsEvasivePathMatchJson&#34;, evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *         final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchOutput&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyEvasivePathMatchJson&#34;, policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -&gt; getAppSecAdvancedSettingsEvasivePathMatchResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsEvasivePathMatchResult> getAppSecAdvancedSettingsEvasivePathMatchPlain(GetAppSecAdvancedSettingsEvasivePathMatchPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecAdvancedSettingsEvasivePathMatch:getAppSecAdvancedSettingsEvasivePathMatch", TypeShape.of(GetAppSecAdvancedSettingsEvasivePathMatchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the logging settings.
     * - `output_text`. Tabular report showing the logging settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsLoggingResult> getAppSecAdvancedSettingsLogging(GetAppSecAdvancedSettingsLoggingArgs args) {
        return getAppSecAdvancedSettingsLogging(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the logging settings.
     * - `output_text`. Tabular report showing the logging settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsLoggingResult> getAppSecAdvancedSettingsLoggingPlain(GetAppSecAdvancedSettingsLoggingPlainArgs args) {
        return getAppSecAdvancedSettingsLoggingPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the logging settings.
     * - `output_text`. Tabular report showing the logging settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsLoggingResult> getAppSecAdvancedSettingsLogging(GetAppSecAdvancedSettingsLoggingArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecAdvancedSettingsLogging:getAppSecAdvancedSettingsLogging", TypeShape.of(GetAppSecAdvancedSettingsLoggingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the logging settings.
     * - `output_text`. Tabular report showing the logging settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsLoggingResult> getAppSecAdvancedSettingsLoggingPlain(GetAppSecAdvancedSettingsLoggingPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecAdvancedSettingsLogging:getAppSecAdvancedSettingsLogging", TypeShape.of(GetAppSecAdvancedSettingsLoggingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPragmaHeaderOutput&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPragmaHeaderJson&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *         final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderOutput&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderJson&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the pragma header settings.
     * - `output_text`. Tabular report showing the pragma header settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsPragmaHeaderResult> getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs args) {
        return getAppSecAdvancedSettingsPragmaHeader(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPragmaHeaderOutput&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPragmaHeaderJson&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *         final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderOutput&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderJson&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the pragma header settings.
     * - `output_text`. Tabular report showing the pragma header settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsPragmaHeaderResult> getAppSecAdvancedSettingsPragmaHeaderPlain(GetAppSecAdvancedSettingsPragmaHeaderPlainArgs args) {
        return getAppSecAdvancedSettingsPragmaHeaderPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPragmaHeaderOutput&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPragmaHeaderJson&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *         final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderOutput&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderJson&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the pragma header settings.
     * - `output_text`. Tabular report showing the pragma header settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsPragmaHeaderResult> getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecAdvancedSettingsPragmaHeader:getAppSecAdvancedSettingsPragmaHeader", TypeShape.of(GetAppSecAdvancedSettingsPragmaHeaderResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPragmaHeaderOutput&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPragmaHeaderJson&#34;, pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *         final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderOutput&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPolicyPragmaHeaderJson&#34;, policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -&gt; getAppSecAdvancedSettingsPragmaHeaderResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the pragma header settings.
     * - `output_text`. Tabular report showing the pragma header settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsPragmaHeaderResult> getAppSecAdvancedSettingsPragmaHeaderPlain(GetAppSecAdvancedSettingsPragmaHeaderPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecAdvancedSettingsPragmaHeader:getAppSecAdvancedSettingsPragmaHeader", TypeShape.of(GetAppSecAdvancedSettingsPragmaHeaderResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai&#39;s edge servers. When prefetch is enabled, requests between your origin servers and Akamai&#39;s edge servers can also be inspected by the firewall.
     * 
     * **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPrefetchOutput&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPrefetchJson&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the prefetch request settings.
     * - `output_text`. Tabular report showing the prefetch request settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsPrefetchResult> getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs args) {
        return getAppSecAdvancedSettingsPrefetch(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai&#39;s edge servers. When prefetch is enabled, requests between your origin servers and Akamai&#39;s edge servers can also be inspected by the firewall.
     * 
     * **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPrefetchOutput&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPrefetchJson&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the prefetch request settings.
     * - `output_text`. Tabular report showing the prefetch request settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsPrefetchResult> getAppSecAdvancedSettingsPrefetchPlain(GetAppSecAdvancedSettingsPrefetchPlainArgs args) {
        return getAppSecAdvancedSettingsPrefetchPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai&#39;s edge servers. When prefetch is enabled, requests between your origin servers and Akamai&#39;s edge servers can also be inspected by the firewall.
     * 
     * **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPrefetchOutput&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPrefetchJson&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the prefetch request settings.
     * - `output_text`. Tabular report showing the prefetch request settings.
     * 
     */
    public static Output<GetAppSecAdvancedSettingsPrefetchResult> getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecAdvancedSettingsPrefetch:getAppSecAdvancedSettingsPrefetch", TypeShape.of(GetAppSecAdvancedSettingsPrefetchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai&#39;s edge servers. When prefetch is enabled, requests between your origin servers and Akamai&#39;s edge servers can also be inspected by the firewall.
     * 
     * **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;advancedSettingsPrefetchOutput&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.outputText()));
     *         ctx.export(&#34;advancedSettingsPrefetchJson&#34;, prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -&gt; getAppSecAdvancedSettingsPrefetchResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the prefetch request settings.
     * - `output_text`. Tabular report showing the prefetch request settings.
     * 
     */
    public static CompletableFuture<GetAppSecAdvancedSettingsPrefetchResult> getAppSecAdvancedSettingsPrefetchPlain(GetAppSecAdvancedSettingsPrefetchPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecAdvancedSettingsPrefetch:getAppSecAdvancedSettingsPrefetch", TypeShape.of(GetAppSecAdvancedSettingsPrefetchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the API endpoints associated with a security policy or configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()
     *             .apiName(&#34;Contracts&#34;)
     *             .configId(58843)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `id_list`. List of API endpoint IDs.
     * - `json`. JSON-formatted list of information about the API endpoints.
     * - `output_text`. Tabular report showing the ID and name of the API endpoints.
     * 
     */
    public static Output<GetAppSecApiEndpointsResult> getAppSecApiEndpoints(GetAppSecApiEndpointsArgs args) {
        return getAppSecApiEndpoints(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the API endpoints associated with a security policy or configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()
     *             .apiName(&#34;Contracts&#34;)
     *             .configId(58843)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `id_list`. List of API endpoint IDs.
     * - `json`. JSON-formatted list of information about the API endpoints.
     * - `output_text`. Tabular report showing the ID and name of the API endpoints.
     * 
     */
    public static CompletableFuture<GetAppSecApiEndpointsResult> getAppSecApiEndpointsPlain(GetAppSecApiEndpointsPlainArgs args) {
        return getAppSecApiEndpointsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the API endpoints associated with a security policy or configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()
     *             .apiName(&#34;Contracts&#34;)
     *             .configId(58843)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `id_list`. List of API endpoint IDs.
     * - `json`. JSON-formatted list of information about the API endpoints.
     * - `output_text`. Tabular report showing the ID and name of the API endpoints.
     * 
     */
    public static Output<GetAppSecApiEndpointsResult> getAppSecApiEndpoints(GetAppSecApiEndpointsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecApiEndpoints:getAppSecApiEndpoints", TypeShape.of(GetAppSecApiEndpointsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the API endpoints associated with a security policy or configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()
     *             .apiName(&#34;Contracts&#34;)
     *             .configId(58843)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `id_list`. List of API endpoint IDs.
     * - `json`. JSON-formatted list of information about the API endpoints.
     * - `output_text`. Tabular report showing the ID and name of the API endpoints.
     * 
     */
    public static CompletableFuture<GetAppSecApiEndpointsResult> getAppSecApiEndpointsPlain(GetAppSecApiEndpointsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecApiEndpoints:getAppSecApiEndpoints", TypeShape.of(GetAppSecApiEndpointsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; API endpoint
     * 
     * Returns information about API endpoint constraints and actions.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;apisConstraintsText&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apisConstraintsJson&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *         final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .apiId(624913)
     *             .build());
     * 
     *         ctx.export(&#34;apiConstraintsText&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apiConstraintsJson&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.
     * - `output_text`. Tabular report of the APIs, their constraints, and their actions.
     * 
     */
    public static Output<GetAppSecApiRequestConstraintsResult> getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs args) {
        return getAppSecApiRequestConstraints(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; API endpoint
     * 
     * Returns information about API endpoint constraints and actions.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;apisConstraintsText&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apisConstraintsJson&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *         final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .apiId(624913)
     *             .build());
     * 
     *         ctx.export(&#34;apiConstraintsText&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apiConstraintsJson&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.
     * - `output_text`. Tabular report of the APIs, their constraints, and their actions.
     * 
     */
    public static CompletableFuture<GetAppSecApiRequestConstraintsResult> getAppSecApiRequestConstraintsPlain(GetAppSecApiRequestConstraintsPlainArgs args) {
        return getAppSecApiRequestConstraintsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; API endpoint
     * 
     * Returns information about API endpoint constraints and actions.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;apisConstraintsText&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apisConstraintsJson&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *         final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .apiId(624913)
     *             .build());
     * 
     *         ctx.export(&#34;apiConstraintsText&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apiConstraintsJson&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.
     * - `output_text`. Tabular report of the APIs, their constraints, and their actions.
     * 
     */
    public static Output<GetAppSecApiRequestConstraintsResult> getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecApiRequestConstraints:getAppSecApiRequestConstraints", TypeShape.of(GetAppSecApiRequestConstraintsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; API endpoint
     * 
     * Returns information about API endpoint constraints and actions.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;apisConstraintsText&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apisConstraintsJson&#34;, apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *         final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .apiId(624913)
     *             .build());
     * 
     *         ctx.export(&#34;apiConstraintsText&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.outputText()));
     *         ctx.export(&#34;apiConstraintsJson&#34;, apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -&gt; getAppSecApiRequestConstraintsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.
     * - `output_text`. Tabular report of the APIs, their constraints, and their actions.
     * 
     */
    public static CompletableFuture<GetAppSecApiRequestConstraintsResult> getAppSecApiRequestConstraintsPlain(GetAppSecApiRequestConstraintsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecApiRequestConstraints:getAppSecApiRequestConstraints", TypeShape.of(GetAppSecApiRequestConstraintsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; attack group
     * 
     * Returns the action and the condition-exception information for an attack group or set of attack groups. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups](https://techdocs.akamai.com/application-security/reference/get-policy-attack-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var attackGroup = AkamaiFunctions.getAppSecAttackGroups(GetAppSecAttackGroupsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .attackGroup(&#34;SQL&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupAction&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.attackGroupAction()));
     *         ctx.export(&#34;conditionException&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.conditionException()));
     *         ctx.export(&#34;json&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.json()));
     *         ctx.export(&#34;outputText&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `attack_group_action`. Action taken anytime the attack group is triggered. This information is returned only when a single attack group is retrieved. Valid values are:
     *   - **alert**. The event is recorded.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. No action is taken.
     * - `condition_exception`. Conditions and exceptions assigned to the attack group. This information is returned only when a single attack group is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the attack group. This information is returned only when a single attack group is retrieved.
     * - `output_text`. Tabular report showing the attack group&#39;s action as well as Boolean values indicating whether conditions and exceptions have been configured for the group.
     * 
     */
    public static Output<GetAppSecAttackGroupsResult> getAppSecAttackGroups(GetAppSecAttackGroupsArgs args) {
        return getAppSecAttackGroups(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; attack group
     * 
     * Returns the action and the condition-exception information for an attack group or set of attack groups. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups](https://techdocs.akamai.com/application-security/reference/get-policy-attack-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var attackGroup = AkamaiFunctions.getAppSecAttackGroups(GetAppSecAttackGroupsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .attackGroup(&#34;SQL&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupAction&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.attackGroupAction()));
     *         ctx.export(&#34;conditionException&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.conditionException()));
     *         ctx.export(&#34;json&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.json()));
     *         ctx.export(&#34;outputText&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `attack_group_action`. Action taken anytime the attack group is triggered. This information is returned only when a single attack group is retrieved. Valid values are:
     *   - **alert**. The event is recorded.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. No action is taken.
     * - `condition_exception`. Conditions and exceptions assigned to the attack group. This information is returned only when a single attack group is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the attack group. This information is returned only when a single attack group is retrieved.
     * - `output_text`. Tabular report showing the attack group&#39;s action as well as Boolean values indicating whether conditions and exceptions have been configured for the group.
     * 
     */
    public static CompletableFuture<GetAppSecAttackGroupsResult> getAppSecAttackGroupsPlain(GetAppSecAttackGroupsPlainArgs args) {
        return getAppSecAttackGroupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; attack group
     * 
     * Returns the action and the condition-exception information for an attack group or set of attack groups. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups](https://techdocs.akamai.com/application-security/reference/get-policy-attack-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var attackGroup = AkamaiFunctions.getAppSecAttackGroups(GetAppSecAttackGroupsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .attackGroup(&#34;SQL&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupAction&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.attackGroupAction()));
     *         ctx.export(&#34;conditionException&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.conditionException()));
     *         ctx.export(&#34;json&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.json()));
     *         ctx.export(&#34;outputText&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `attack_group_action`. Action taken anytime the attack group is triggered. This information is returned only when a single attack group is retrieved. Valid values are:
     *   - **alert**. The event is recorded.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. No action is taken.
     * - `condition_exception`. Conditions and exceptions assigned to the attack group. This information is returned only when a single attack group is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the attack group. This information is returned only when a single attack group is retrieved.
     * - `output_text`. Tabular report showing the attack group&#39;s action as well as Boolean values indicating whether conditions and exceptions have been configured for the group.
     * 
     */
    public static Output<GetAppSecAttackGroupsResult> getAppSecAttackGroups(GetAppSecAttackGroupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecAttackGroups:getAppSecAttackGroups", TypeShape.of(GetAppSecAttackGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; attack group
     * 
     * Returns the action and the condition-exception information for an attack group or set of attack groups. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups](https://techdocs.akamai.com/application-security/reference/get-policy-attack-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var attackGroup = AkamaiFunctions.getAppSecAttackGroups(GetAppSecAttackGroupsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .attackGroup(&#34;SQL&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupAction&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.attackGroupAction()));
     *         ctx.export(&#34;conditionException&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.conditionException()));
     *         ctx.export(&#34;json&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.json()));
     *         ctx.export(&#34;outputText&#34;, attackGroup.applyValue(getAppSecAttackGroupsResult -&gt; getAppSecAttackGroupsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `attack_group_action`. Action taken anytime the attack group is triggered. This information is returned only when a single attack group is retrieved. Valid values are:
     *   - **alert**. The event is recorded.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. No action is taken.
     * - `condition_exception`. Conditions and exceptions assigned to the attack group. This information is returned only when a single attack group is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the attack group. This information is returned only when a single attack group is retrieved.
     * - `output_text`. Tabular report showing the attack group&#39;s action as well as Boolean values indicating whether conditions and exceptions have been configured for the group.
     * 
     */
    public static CompletableFuture<GetAppSecAttackGroupsResult> getAppSecAttackGroupsPlain(GetAppSecAttackGroupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecAttackGroups:getAppSecAttackGroups", TypeShape.of(GetAppSecAttackGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
     * 
     * Note that this data source is only applicable to WAP (Web Application Protector) configurations.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;bypassNetworkListsOutput&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.outputText()));
     *         ctx.export(&#34;bypassNetworkListsJson&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.json()));
     *         ctx.export(&#34;bypassNetworkListsIdList&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.bypassNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `bypass_network_list`. List of network IDs.
     * - `json`. JSON-formatted list of information about the bypass networks.
     * - `output_text`. Tabular report showing the bypass network list information.
     * 
     */
    public static Output<GetAppSecBypassNetworkListsResult> getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs args) {
        return getAppSecBypassNetworkLists(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
     * 
     * Note that this data source is only applicable to WAP (Web Application Protector) configurations.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;bypassNetworkListsOutput&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.outputText()));
     *         ctx.export(&#34;bypassNetworkListsJson&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.json()));
     *         ctx.export(&#34;bypassNetworkListsIdList&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.bypassNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `bypass_network_list`. List of network IDs.
     * - `json`. JSON-formatted list of information about the bypass networks.
     * - `output_text`. Tabular report showing the bypass network list information.
     * 
     */
    public static CompletableFuture<GetAppSecBypassNetworkListsResult> getAppSecBypassNetworkListsPlain(GetAppSecBypassNetworkListsPlainArgs args) {
        return getAppSecBypassNetworkListsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
     * 
     * Note that this data source is only applicable to WAP (Web Application Protector) configurations.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;bypassNetworkListsOutput&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.outputText()));
     *         ctx.export(&#34;bypassNetworkListsJson&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.json()));
     *         ctx.export(&#34;bypassNetworkListsIdList&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.bypassNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `bypass_network_list`. List of network IDs.
     * - `json`. JSON-formatted list of information about the bypass networks.
     * - `output_text`. Tabular report showing the bypass network list information.
     * 
     */
    public static Output<GetAppSecBypassNetworkListsResult> getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists", TypeShape.of(GetAppSecBypassNetworkListsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
     * 
     * Note that this data source is only applicable to WAP (Web Application Protector) configurations.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;bypassNetworkListsOutput&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.outputText()));
     *         ctx.export(&#34;bypassNetworkListsJson&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.json()));
     *         ctx.export(&#34;bypassNetworkListsIdList&#34;, bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -&gt; getAppSecBypassNetworkListsResult.bypassNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `bypass_network_list`. List of network IDs.
     * - `json`. JSON-formatted list of information about the bypass networks.
     * - `output_text`. Tabular report showing the bypass network list information.
     * 
     */
    public static CompletableFuture<GetAppSecBypassNetworkListsResult> getAppSecBypassNetworkListsPlain(GetAppSecBypassNetworkListsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists", TypeShape.of(GetAppSecBypassNetworkListsResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecConfigurationResult> getAppSecConfiguration() {
        return getAppSecConfiguration(GetAppSecConfigurationArgs.Empty, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecConfigurationResult> getAppSecConfigurationPlain() {
        return getAppSecConfigurationPlain(GetAppSecConfigurationPlainArgs.Empty, InvokeOptions.Empty);
    }
    public static Output<GetAppSecConfigurationResult> getAppSecConfiguration(GetAppSecConfigurationArgs args) {
        return getAppSecConfiguration(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecConfigurationResult> getAppSecConfigurationPlain(GetAppSecConfigurationPlainArgs args) {
        return getAppSecConfigurationPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecConfigurationResult> getAppSecConfiguration(GetAppSecConfigurationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecConfiguration:getAppSecConfiguration", TypeShape.of(GetAppSecConfigurationResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecConfigurationResult> getAppSecConfigurationPlain(GetAppSecConfigurationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecConfiguration:getAppSecConfiguration", TypeShape.of(GetAppSecConfigurationResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecConfigurationVersionResult> getAppSecConfigurationVersion(GetAppSecConfigurationVersionArgs args) {
        return getAppSecConfigurationVersion(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecConfigurationVersionResult> getAppSecConfigurationVersionPlain(GetAppSecConfigurationVersionPlainArgs args) {
        return getAppSecConfigurationVersionPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecConfigurationVersionResult> getAppSecConfigurationVersion(GetAppSecConfigurationVersionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecConfigurationVersion:getAppSecConfigurationVersion", TypeShape.of(GetAppSecConfigurationVersionResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecConfigurationVersionResult> getAppSecConfigurationVersionPlain(GetAppSecConfigurationVersionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecConfigurationVersion:getAppSecConfigurationVersion", TypeShape.of(GetAppSecConfigurationVersionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static Output<GetAppSecContractsGroupsResult> getAppSecContractsGroups() {
        return getAppSecContractsGroups(GetAppSecContractsGroupsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static CompletableFuture<GetAppSecContractsGroupsResult> getAppSecContractsGroupsPlain() {
        return getAppSecContractsGroupsPlain(GetAppSecContractsGroupsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static Output<GetAppSecContractsGroupsResult> getAppSecContractsGroups(GetAppSecContractsGroupsArgs args) {
        return getAppSecContractsGroups(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static CompletableFuture<GetAppSecContractsGroupsResult> getAppSecContractsGroupsPlain(GetAppSecContractsGroupsPlainArgs args) {
        return getAppSecContractsGroupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static Output<GetAppSecContractsGroupsResult> getAppSecContractsGroups(GetAppSecContractsGroupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecContractsGroups:getAppSecContractsGroups", TypeShape.of(GetAppSecContractsGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Contract; group
     * 
     * Returns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()
     *             .contractid(&#34;5-2WA382&#34;)
     *             .groupid(12198)
     *             .build());
     * 
     *         ctx.export(&#34;contractsGroupsList&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.outputText()));
     *         ctx.export(&#34;contractsGroupsJson&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.json()));
     *         ctx.export(&#34;contractGroupsDefaultContractid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultContractid()));
     *         ctx.export(&#34;contractGroupsDefaultGroupid&#34;, contractsGroups.applyValue(getAppSecContractsGroupsResult -&gt; getAppSecContractsGroupsResult.defaultGroupid()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of contract and group information.
     * - `output_text`. Tabular report of contract and group information.
     * - `default_contractid`. Default contract ID for the specified contract and group.
     * - `default_groupid`. Default group ID for the specified contract and group.
     * 
     */
    public static CompletableFuture<GetAppSecContractsGroupsResult> getAppSecContractsGroupsPlain(GetAppSecContractsGroupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecContractsGroups:getAppSecContractsGroups", TypeShape.of(GetAppSecContractsGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; custom deny
     * 
     * Returns information about custom deny actions. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customDenyListOutput&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *         ctx.export(&#34;customDenyListJson&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customDenyId(&#34;deny_custom_64386&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customDenyJson&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         ctx.export(&#34;customDenyOutput&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of custom deny information.
     * - `output_text`. Tabular report of the custom deny information.
     * 
     */
    public static Output<GetAppSecCustomDenyResult> getAppSecCustomDeny(GetAppSecCustomDenyArgs args) {
        return getAppSecCustomDeny(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; custom deny
     * 
     * Returns information about custom deny actions. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customDenyListOutput&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *         ctx.export(&#34;customDenyListJson&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customDenyId(&#34;deny_custom_64386&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customDenyJson&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         ctx.export(&#34;customDenyOutput&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of custom deny information.
     * - `output_text`. Tabular report of the custom deny information.
     * 
     */
    public static CompletableFuture<GetAppSecCustomDenyResult> getAppSecCustomDenyPlain(GetAppSecCustomDenyPlainArgs args) {
        return getAppSecCustomDenyPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; custom deny
     * 
     * Returns information about custom deny actions. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customDenyListOutput&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *         ctx.export(&#34;customDenyListJson&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customDenyId(&#34;deny_custom_64386&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customDenyJson&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         ctx.export(&#34;customDenyOutput&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of custom deny information.
     * - `output_text`. Tabular report of the custom deny information.
     * 
     */
    public static Output<GetAppSecCustomDenyResult> getAppSecCustomDeny(GetAppSecCustomDenyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecCustomDeny:getAppSecCustomDeny", TypeShape.of(GetAppSecCustomDenyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; custom deny
     * 
     * Returns information about custom deny actions. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customDenyListOutput&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *         ctx.export(&#34;customDenyListJson&#34;, customDenyList.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customDenyId(&#34;deny_custom_64386&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customDenyJson&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.json()));
     *         ctx.export(&#34;customDenyOutput&#34;, customDeny.applyValue(getAppSecCustomDenyResult -&gt; getAppSecCustomDenyResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of custom deny information.
     * - `output_text`. Tabular report of the custom deny information.
     * 
     */
    public static CompletableFuture<GetAppSecCustomDenyResult> getAppSecCustomDenyPlain(GetAppSecCustomDenyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecCustomDeny:getAppSecCustomDeny", TypeShape.of(GetAppSecCustomDenyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; custom rule
     * 
     * Retrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren&#39;t part of Akamai&#39;s Kona Rule Set.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customRuleActions&#34;, customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -&gt; getAppSecCustomRuleActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, name, and action of the custom rules.
     * 
     */
    public static Output<GetAppSecCustomRuleActionsResult> getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs args) {
        return getAppSecCustomRuleActions(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; custom rule
     * 
     * Retrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren&#39;t part of Akamai&#39;s Kona Rule Set.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customRuleActions&#34;, customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -&gt; getAppSecCustomRuleActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, name, and action of the custom rules.
     * 
     */
    public static CompletableFuture<GetAppSecCustomRuleActionsResult> getAppSecCustomRuleActionsPlain(GetAppSecCustomRuleActionsPlainArgs args) {
        return getAppSecCustomRuleActionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; custom rule
     * 
     * Retrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren&#39;t part of Akamai&#39;s Kona Rule Set.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customRuleActions&#34;, customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -&gt; getAppSecCustomRuleActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, name, and action of the custom rules.
     * 
     */
    public static Output<GetAppSecCustomRuleActionsResult> getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecCustomRuleActions:getAppSecCustomRuleActions", TypeShape.of(GetAppSecCustomRuleActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; custom rule
     * 
     * Retrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren&#39;t part of Akamai&#39;s Kona Rule Set.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;customRuleActions&#34;, customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -&gt; getAppSecCustomRuleActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, name, and action of the custom rules.
     * 
     */
    public static CompletableFuture<GetAppSecCustomRuleActionsResult> getAppSecCustomRuleActionsPlain(GetAppSecCustomRuleActionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecCustomRuleActions:getAppSecCustomRuleActions", TypeShape.of(GetAppSecCustomRuleActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; custom rule
     * 
     * Returns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the custom rule information.
     * - `json`. JSON-formatted report of the custom rule information.
     * 
     */
    public static Output<GetAppSecCustomRulesResult> getAppSecCustomRules(GetAppSecCustomRulesArgs args) {
        return getAppSecCustomRules(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; custom rule
     * 
     * Returns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the custom rule information.
     * - `json`. JSON-formatted report of the custom rule information.
     * 
     */
    public static CompletableFuture<GetAppSecCustomRulesResult> getAppSecCustomRulesPlain(GetAppSecCustomRulesPlainArgs args) {
        return getAppSecCustomRulesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; custom rule
     * 
     * Returns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the custom rule information.
     * - `json`. JSON-formatted report of the custom rule information.
     * 
     */
    public static Output<GetAppSecCustomRulesResult> getAppSecCustomRules(GetAppSecCustomRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecCustomRules:getAppSecCustomRules", TypeShape.of(GetAppSecCustomRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; custom rule
     * 
     * Returns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;customRulesOutputText&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.outputText()));
     *         ctx.export(&#34;customRulesJson&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *         ctx.export(&#34;customRulesConfigId&#34;, customRules.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.configId()));
     *         final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .customRuleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;specificCustomRuleJson&#34;, specificCustomRule.applyValue(getAppSecCustomRulesResult -&gt; getAppSecCustomRulesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the custom rule information.
     * - `json`. JSON-formatted report of the custom rule information.
     * 
     */
    public static CompletableFuture<GetAppSecCustomRulesResult> getAppSecCustomRulesPlain(GetAppSecCustomRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecCustomRules:getAppSecCustomRules", TypeShape.of(GetAppSecCustomRulesResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecEvalResult> getAppSecEval(GetAppSecEvalArgs args) {
        return getAppSecEval(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecEvalResult> getAppSecEvalPlain(GetAppSecEvalPlainArgs args) {
        return getAppSecEvalPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecEvalResult> getAppSecEval(GetAppSecEvalArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecEval:getAppSecEval", TypeShape.of(GetAppSecEvalResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecEvalResult> getAppSecEvalPlain(GetAppSecEvalPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecEval:getAppSecEval", TypeShape.of(GetAppSecEvalResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecEvalGroupsResult> getAppSecEvalGroups(GetAppSecEvalGroupsArgs args) {
        return getAppSecEvalGroups(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecEvalGroupsResult> getAppSecEvalGroupsPlain(GetAppSecEvalGroupsPlainArgs args) {
        return getAppSecEvalGroupsPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecEvalGroupsResult> getAppSecEvalGroups(GetAppSecEvalGroupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecEvalGroups:getAppSecEvalGroups", TypeShape.of(GetAppSecEvalGroupsResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecEvalGroupsResult> getAppSecEvalGroupsPlain(GetAppSecEvalGroupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecEvalGroups:getAppSecEvalGroups", TypeShape.of(GetAppSecEvalGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     *  __ASE_Beta__.:
     * Returns the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
     * When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalPenaltyBoxAction&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.action()));
     *         ctx.export(&#34;evalPenaltyBoxEnabled&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;evalPenaltyBoxText&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.
     * - `output_text`. Tabular report of evaluation penalty box protection settings.
     * 
     */
    public static Output<GetAppSecEvalPenaltyBoxResult> getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs args) {
        return getAppSecEvalPenaltyBox(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     *  __ASE_Beta__.:
     * Returns the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
     * When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalPenaltyBoxAction&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.action()));
     *         ctx.export(&#34;evalPenaltyBoxEnabled&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;evalPenaltyBoxText&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.
     * - `output_text`. Tabular report of evaluation penalty box protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecEvalPenaltyBoxResult> getAppSecEvalPenaltyBoxPlain(GetAppSecEvalPenaltyBoxPlainArgs args) {
        return getAppSecEvalPenaltyBoxPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     *  __ASE_Beta__.:
     * Returns the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
     * When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalPenaltyBoxAction&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.action()));
     *         ctx.export(&#34;evalPenaltyBoxEnabled&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;evalPenaltyBoxText&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.
     * - `output_text`. Tabular report of evaluation penalty box protection settings.
     * 
     */
    public static Output<GetAppSecEvalPenaltyBoxResult> getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecEvalPenaltyBox:getAppSecEvalPenaltyBox", TypeShape.of(GetAppSecEvalPenaltyBoxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     *  __ASE_Beta__.:
     * Returns the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
     * When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalPenaltyBoxAction&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.action()));
     *         ctx.export(&#34;evalPenaltyBoxEnabled&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;evalPenaltyBoxText&#34;, evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -&gt; getAppSecEvalPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.
     * - `output_text`. Tabular report of evaluation penalty box protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecEvalPenaltyBoxResult> getAppSecEvalPenaltyBoxPlain(GetAppSecEvalPenaltyBoxPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecEvalPenaltyBox:getAppSecEvalPenaltyBox", TypeShape.of(GetAppSecEvalPenaltyBoxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; evaluation rule
     * 
     * Returns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .ruleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalRuleAction&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.evalRuleAction()));
     *         ctx.export(&#34;conditionException&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.conditionException()));
     *         ctx.export(&#34;json&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.json()));
     *         ctx.export(&#34;outputText&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `eval_rule_action`. Action taken anytime the evaluation rule is triggered. This information is returned only when a single rule is retrieved. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Reject the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `condition_exception`. Conditions and exceptions associated with the rule. This information is returned only when a single rule is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the rule. This information is returned only when a single rule is retrieved.
     * - `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.
     * 
     */
    public static Output<GetAppSecEvalRulesResult> getAppSecEvalRules(GetAppSecEvalRulesArgs args) {
        return getAppSecEvalRules(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; evaluation rule
     * 
     * Returns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .ruleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalRuleAction&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.evalRuleAction()));
     *         ctx.export(&#34;conditionException&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.conditionException()));
     *         ctx.export(&#34;json&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.json()));
     *         ctx.export(&#34;outputText&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `eval_rule_action`. Action taken anytime the evaluation rule is triggered. This information is returned only when a single rule is retrieved. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Reject the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `condition_exception`. Conditions and exceptions associated with the rule. This information is returned only when a single rule is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the rule. This information is returned only when a single rule is retrieved.
     * - `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.
     * 
     */
    public static CompletableFuture<GetAppSecEvalRulesResult> getAppSecEvalRulesPlain(GetAppSecEvalRulesPlainArgs args) {
        return getAppSecEvalRulesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; evaluation rule
     * 
     * Returns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .ruleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalRuleAction&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.evalRuleAction()));
     *         ctx.export(&#34;conditionException&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.conditionException()));
     *         ctx.export(&#34;json&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.json()));
     *         ctx.export(&#34;outputText&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `eval_rule_action`. Action taken anytime the evaluation rule is triggered. This information is returned only when a single rule is retrieved. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Reject the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `condition_exception`. Conditions and exceptions associated with the rule. This information is returned only when a single rule is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the rule. This information is returned only when a single rule is retrieved.
     * - `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.
     * 
     */
    public static Output<GetAppSecEvalRulesResult> getAppSecEvalRules(GetAppSecEvalRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecEvalRules:getAppSecEvalRules", TypeShape.of(GetAppSecEvalRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; evaluation rule
     * 
     * Returns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .ruleId(&#34;60029316&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;evalRuleAction&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.evalRuleAction()));
     *         ctx.export(&#34;conditionException&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.conditionException()));
     *         ctx.export(&#34;json&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.json()));
     *         ctx.export(&#34;outputText&#34;, evalRule.applyValue(getAppSecEvalRulesResult -&gt; getAppSecEvalRulesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `eval_rule_action`. Action taken anytime the evaluation rule is triggered. This information is returned only when a single rule is retrieved. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Reject the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `condition_exception`. Conditions and exceptions associated with the rule. This information is returned only when a single rule is retrieved.
     * - `json`. JSON-formatted list of the action and the condition-exception information for the rule. This information is returned only when a single rule is retrieved.
     * - `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.
     * 
     */
    public static CompletableFuture<GetAppSecEvalRulesResult> getAppSecEvalRulesPlain(GetAppSecEvalRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecEvalRules:getAppSecEvalRules", TypeShape.of(GetAppSecEvalRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .version(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.latestVersion()))
     *             .searches(            
     *                 &#34;securityPolicies&#34;,
     *                 &#34;selectedHosts&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;json&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.json()));
     *         ctx.export(&#34;text&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
     * - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
     * 
     */
    public static Output<GetAppSecExportConfigurationResult> getAppSecExportConfiguration(GetAppSecExportConfigurationArgs args) {
        return getAppSecExportConfiguration(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .version(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.latestVersion()))
     *             .searches(            
     *                 &#34;securityPolicies&#34;,
     *                 &#34;selectedHosts&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;json&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.json()));
     *         ctx.export(&#34;text&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
     * - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
     * 
     */
    public static CompletableFuture<GetAppSecExportConfigurationResult> getAppSecExportConfigurationPlain(GetAppSecExportConfigurationPlainArgs args) {
        return getAppSecExportConfigurationPlain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .version(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.latestVersion()))
     *             .searches(            
     *                 &#34;securityPolicies&#34;,
     *                 &#34;selectedHosts&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;json&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.json()));
     *         ctx.export(&#34;text&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
     * - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
     * 
     */
    public static Output<GetAppSecExportConfigurationResult> getAppSecExportConfiguration(GetAppSecExportConfigurationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecExportConfiguration:getAppSecExportConfiguration", TypeShape.of(GetAppSecExportConfigurationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .version(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.latestVersion()))
     *             .searches(            
     *                 &#34;securityPolicies&#34;,
     *                 &#34;selectedHosts&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;json&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.json()));
     *         ctx.export(&#34;text&#34;, export.applyValue(getAppSecExportConfigurationResult -&gt; getAppSecExportConfigurationResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
     * - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
     * 
     */
    public static CompletableFuture<GetAppSecExportConfigurationResult> getAppSecExportConfigurationPlain(GetAppSecExportConfigurationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecExportConfiguration:getAppSecExportConfiguration", TypeShape.of(GetAppSecExportConfigurationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the failover hostnames in a configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;failoverHostnames&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.hostnames()));
     *         ctx.export(&#34;failoverHostnamesOutput&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.outputText()));
     *         ctx.export(&#34;failoverHostnamesJson&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of the failover hostnames.
     * - `json`. JSON-formatted list of the failover hostnames.
     * 
     */
    public static Output<GetAppSecFailoverHostnamesResult> getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs args) {
        return getAppSecFailoverHostnames(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the failover hostnames in a configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;failoverHostnames&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.hostnames()));
     *         ctx.export(&#34;failoverHostnamesOutput&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.outputText()));
     *         ctx.export(&#34;failoverHostnamesJson&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of the failover hostnames.
     * - `json`. JSON-formatted list of the failover hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecFailoverHostnamesResult> getAppSecFailoverHostnamesPlain(GetAppSecFailoverHostnamesPlainArgs args) {
        return getAppSecFailoverHostnamesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the failover hostnames in a configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;failoverHostnames&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.hostnames()));
     *         ctx.export(&#34;failoverHostnamesOutput&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.outputText()));
     *         ctx.export(&#34;failoverHostnamesJson&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of the failover hostnames.
     * - `json`. JSON-formatted list of the failover hostnames.
     * 
     */
    public static Output<GetAppSecFailoverHostnamesResult> getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecFailoverHostnames:getAppSecFailoverHostnames", TypeShape.of(GetAppSecFailoverHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the failover hostnames in a configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;failoverHostnames&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.hostnames()));
     *         ctx.export(&#34;failoverHostnamesOutput&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.outputText()));
     *         ctx.export(&#34;failoverHostnamesJson&#34;, failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -&gt; getAppSecFailoverHostnamesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of the failover hostnames.
     * - `json`. JSON-formatted list of the failover hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecFailoverHostnamesResult> getAppSecFailoverHostnamesPlain(GetAppSecFailoverHostnamesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecFailoverHostnames:getAppSecFailoverHostnames", TypeShape.of(GetAppSecFailoverHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageResult> getAppSecHostnameCoverage() {
        return getAppSecHostnameCoverage(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageResult> getAppSecHostnameCoveragePlain() {
        return getAppSecHostnameCoveragePlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageResult> getAppSecHostnameCoverage(InvokeArgs args) {
        return getAppSecHostnameCoverage(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageResult> getAppSecHostnameCoveragePlain(InvokeArgs args) {
        return getAppSecHostnameCoveragePlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageResult> getAppSecHostnameCoverage(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecHostnameCoverage:getAppSecHostnameCoverage", TypeShape.of(GetAppSecHostnameCoverageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Individual account
     * 
     * Returns information about the hostnames associated with your account. The returned data includes the hostname&#39;s protections, activation status, and other summary information.
     * 
     * **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();
     * 
     *         ctx.export(&#34;hostnameCoverageListJson&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.json()));
     *         ctx.export(&#34;hostnameCoverageListOutput&#34;, hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -&gt; getAppSecHostnameCoverageResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the hostname coverage information.
     * - `output_text`. Tabular report of the hostname coverage information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageResult> getAppSecHostnameCoveragePlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecHostnameCoverage:getAppSecHostnameCoverage", TypeShape.of(GetAppSecHostnameCoverageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Hostname
     * 
     * Returns information about the API and website match targets used to protect a hostname.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the coverage information.
     * - `output_text`. Tabular report of the coverage information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageMatchTargetsResult> getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs args) {
        return getAppSecHostnameCoverageMatchTargets(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Hostname
     * 
     * Returns information about the API and website match targets used to protect a hostname.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the coverage information.
     * - `output_text`. Tabular report of the coverage information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageMatchTargetsResult> getAppSecHostnameCoverageMatchTargetsPlain(GetAppSecHostnameCoverageMatchTargetsPlainArgs args) {
        return getAppSecHostnameCoverageMatchTargetsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Hostname
     * 
     * Returns information about the API and website match targets used to protect a hostname.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the coverage information.
     * - `output_text`. Tabular report of the coverage information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageMatchTargetsResult> getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecHostnameCoverageMatchTargets:getAppSecHostnameCoverageMatchTargets", TypeShape.of(GetAppSecHostnameCoverageMatchTargetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Hostname
     * 
     * Returns information about the API and website match targets used to protect a hostname.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the coverage information.
     * - `output_text`. Tabular report of the coverage information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageMatchTargetsResult> getAppSecHostnameCoverageMatchTargetsPlain(GetAppSecHostnameCoverageMatchTargetsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecHostnameCoverageMatchTargets:getAppSecHostnameCoverageMatchTargets", TypeShape.of(GetAppSecHostnameCoverageMatchTargetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; hostname
     * 
     * Returns information about any other configuration versions that contain a hostname found in the current configuration version.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the overlap information.
     * - `output_text`. Tabular report of the overlap information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageOverlappingResult> getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs args) {
        return getAppSecHostnameCoverageOverlapping(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; hostname
     * 
     * Returns information about any other configuration versions that contain a hostname found in the current configuration version.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the overlap information.
     * - `output_text`. Tabular report of the overlap information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageOverlappingResult> getAppSecHostnameCoverageOverlappingPlain(GetAppSecHostnameCoverageOverlappingPlainArgs args) {
        return getAppSecHostnameCoverageOverlappingPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; hostname
     * 
     * Returns information about any other configuration versions that contain a hostname found in the current configuration version.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the overlap information.
     * - `output_text`. Tabular report of the overlap information.
     * 
     */
    public static Output<GetAppSecHostnameCoverageOverlappingResult> getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecHostnameCoverageOverlapping:getAppSecHostnameCoverageOverlapping", TypeShape.of(GetAppSecHostnameCoverageOverlappingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; hostname
     * 
     * Returns information about any other configuration versions that contain a hostname found in the current configuration version.
     * 
     * **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .hostname(&#34;documentation.akamai.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the overlap information.
     * - `output_text`. Tabular report of the overlap information.
     * 
     */
    public static CompletableFuture<GetAppSecHostnameCoverageOverlappingResult> getAppSecHostnameCoverageOverlappingPlain(GetAppSecHostnameCoverageOverlappingPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecHostnameCoverageOverlapping:getAppSecHostnameCoverageOverlapping", TypeShape.of(GetAppSecHostnameCoverageOverlappingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ipGeoMode&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.mode()));
     *         ctx.export(&#34;geoNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.geoNetworkLists()));
     *         ctx.export(&#34;ipNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.ipNetworkLists()));
     *         ctx.export(&#34;exceptionIpNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.exceptionIpNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:
     *   - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.
     *   - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.
     * - `geo_network_lists`. Network lists blocked or allowed based on geographic location.
     * - `ip_network_lists`. Network lists blocked or allowed based on IP address.
     * - `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.
     * - `output_text`. Tabular report of the IP/Geo firewall settings.
     * 
     */
    public static Output<GetAppSecIPGeoResult> getAppSecIPGeo(GetAppSecIPGeoArgs args) {
        return getAppSecIPGeo(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ipGeoMode&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.mode()));
     *         ctx.export(&#34;geoNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.geoNetworkLists()));
     *         ctx.export(&#34;ipNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.ipNetworkLists()));
     *         ctx.export(&#34;exceptionIpNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.exceptionIpNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:
     *   - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.
     *   - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.
     * - `geo_network_lists`. Network lists blocked or allowed based on geographic location.
     * - `ip_network_lists`. Network lists blocked or allowed based on IP address.
     * - `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.
     * - `output_text`. Tabular report of the IP/Geo firewall settings.
     * 
     */
    public static CompletableFuture<GetAppSecIPGeoResult> getAppSecIPGeoPlain(GetAppSecIPGeoPlainArgs args) {
        return getAppSecIPGeoPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ipGeoMode&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.mode()));
     *         ctx.export(&#34;geoNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.geoNetworkLists()));
     *         ctx.export(&#34;ipNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.ipNetworkLists()));
     *         ctx.export(&#34;exceptionIpNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.exceptionIpNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:
     *   - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.
     *   - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.
     * - `geo_network_lists`. Network lists blocked or allowed based on geographic location.
     * - `ip_network_lists`. Network lists blocked or allowed based on IP address.
     * - `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.
     * - `output_text`. Tabular report of the IP/Geo firewall settings.
     * 
     */
    public static Output<GetAppSecIPGeoResult> getAppSecIPGeo(GetAppSecIPGeoArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecIPGeo:getAppSecIPGeo", TypeShape.of(GetAppSecIPGeoResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; security policy
     * 
     * Returns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ipGeoMode&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.mode()));
     *         ctx.export(&#34;geoNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.geoNetworkLists()));
     *         ctx.export(&#34;ipNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.ipNetworkLists()));
     *         ctx.export(&#34;exceptionIpNetworkLists&#34;, ipGeo.applyValue(getAppSecIPGeoResult -&gt; getAppSecIPGeoResult.exceptionIpNetworkLists()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:
     *   - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.
     *   - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.
     * - `geo_network_lists`. Network lists blocked or allowed based on geographic location.
     * - `ip_network_lists`. Network lists blocked or allowed based on IP address.
     * - `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.
     * - `output_text`. Tabular report of the IP/Geo firewall settings.
     * 
     */
    public static CompletableFuture<GetAppSecIPGeoResult> getAppSecIPGeoPlain(GetAppSecIPGeoPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecIPGeo:getAppSecIPGeo", TypeShape.of(GetAppSecIPGeoResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy&#39;s actions are applied.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwareContentTypes = AkamaiFunctions.getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwareContentTypesOutput&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.outputText()));
     *         ctx.export(&#34;malwareContentTypesJson&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the available content types.
     * - `json`. JSON-formatted list of the available content types.
     * 
     */
    public static Output<GetAppSecMalwareContentTypesResult> getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs args) {
        return getAppSecMalwareContentTypes(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy&#39;s actions are applied.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwareContentTypes = AkamaiFunctions.getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwareContentTypesOutput&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.outputText()));
     *         ctx.export(&#34;malwareContentTypesJson&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the available content types.
     * - `json`. JSON-formatted list of the available content types.
     * 
     */
    public static CompletableFuture<GetAppSecMalwareContentTypesResult> getAppSecMalwareContentTypesPlain(GetAppSecMalwareContentTypesPlainArgs args) {
        return getAppSecMalwareContentTypesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy&#39;s actions are applied.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwareContentTypes = AkamaiFunctions.getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwareContentTypesOutput&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.outputText()));
     *         ctx.export(&#34;malwareContentTypesJson&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the available content types.
     * - `json`. JSON-formatted list of the available content types.
     * 
     */
    public static Output<GetAppSecMalwareContentTypesResult> getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecMalwareContentTypes:getAppSecMalwareContentTypes", TypeShape.of(GetAppSecMalwareContentTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy&#39;s actions are applied.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwareContentTypes = AkamaiFunctions.getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwareContentTypesOutput&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.outputText()));
     *         ctx.export(&#34;malwareContentTypesJson&#34;, malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -&gt; getAppSecMalwareContentTypesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the available content types.
     * - `json`. JSON-formatted list of the available content types.
     * 
     */
    public static CompletableFuture<GetAppSecMalwareContentTypesResult> getAppSecMalwareContentTypesPlain(GetAppSecMalwareContentTypesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecMalwareContentTypes:getAppSecMalwareContentTypes", TypeShape.of(GetAppSecMalwareContentTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about your malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicies = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwarePoliciesOutput&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *         ctx.export(&#34;malwarePoliciesJson&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         final var malwarePolicy = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .malwarePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyJson&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         ctx.export(&#34;malwarePolicyOutput&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the malware policies.
     * - `json`. JSON-formatted list of the malware policy information.
     * 
     */
    public static Output<GetAppSecMalwarePoliciesResult> getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs args) {
        return getAppSecMalwarePolicies(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about your malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicies = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwarePoliciesOutput&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *         ctx.export(&#34;malwarePoliciesJson&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         final var malwarePolicy = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .malwarePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyJson&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         ctx.export(&#34;malwarePolicyOutput&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the malware policies.
     * - `json`. JSON-formatted list of the malware policy information.
     * 
     */
    public static CompletableFuture<GetAppSecMalwarePoliciesResult> getAppSecMalwarePoliciesPlain(GetAppSecMalwarePoliciesPlainArgs args) {
        return getAppSecMalwarePoliciesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about your malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicies = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwarePoliciesOutput&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *         ctx.export(&#34;malwarePoliciesJson&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         final var malwarePolicy = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .malwarePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyJson&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         ctx.export(&#34;malwarePolicyOutput&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the malware policies.
     * - `json`. JSON-formatted list of the malware policy information.
     * 
     */
    public static Output<GetAppSecMalwarePoliciesResult> getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecMalwarePolicies:getAppSecMalwarePolicies", TypeShape.of(GetAppSecMalwarePoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; malware protection
     * 
     * Returns information about your malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicies = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;malwarePoliciesOutput&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *         ctx.export(&#34;malwarePoliciesJson&#34;, malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         final var malwarePolicy = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .malwarePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyJson&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.json()));
     *         ctx.export(&#34;malwarePolicyOutput&#34;, malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -&gt; getAppSecMalwarePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the malware policies.
     * - `json`. JSON-formatted list of the malware policy information.
     * 
     */
    public static CompletableFuture<GetAppSecMalwarePoliciesResult> getAppSecMalwarePoliciesPlain(GetAppSecMalwarePoliciesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecMalwarePolicies:getAppSecMalwarePolicies", TypeShape.of(GetAppSecMalwarePoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; malware protection
     * 
     * Returns information about your malware policy actions. Actions specify what happens any time a malware policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicyActionsAppSecMalwarePolicyActions = AkamaiFunctions.getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyActions&#34;, malwarePolicyActionsAppSecMalwarePolicyActions.applyValue(getAppSecMalwarePolicyActionsResult -&gt; getAppSecMalwarePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, scanned action, and unscanned action of the malware policy or policies.
     * 
     */
    public static Output<GetAppSecMalwarePolicyActionsResult> getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs args) {
        return getAppSecMalwarePolicyActions(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; malware protection
     * 
     * Returns information about your malware policy actions. Actions specify what happens any time a malware policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicyActionsAppSecMalwarePolicyActions = AkamaiFunctions.getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyActions&#34;, malwarePolicyActionsAppSecMalwarePolicyActions.applyValue(getAppSecMalwarePolicyActionsResult -&gt; getAppSecMalwarePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, scanned action, and unscanned action of the malware policy or policies.
     * 
     */
    public static CompletableFuture<GetAppSecMalwarePolicyActionsResult> getAppSecMalwarePolicyActionsPlain(GetAppSecMalwarePolicyActionsPlainArgs args) {
        return getAppSecMalwarePolicyActionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; malware protection
     * 
     * Returns information about your malware policy actions. Actions specify what happens any time a malware policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicyActionsAppSecMalwarePolicyActions = AkamaiFunctions.getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyActions&#34;, malwarePolicyActionsAppSecMalwarePolicyActions.applyValue(getAppSecMalwarePolicyActionsResult -&gt; getAppSecMalwarePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, scanned action, and unscanned action of the malware policy or policies.
     * 
     */
    public static Output<GetAppSecMalwarePolicyActionsResult> getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecMalwarePolicyActions:getAppSecMalwarePolicyActions", TypeShape.of(GetAppSecMalwarePolicyActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; malware protection
     * 
     * Returns information about your malware policy actions. Actions specify what happens any time a malware policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var malwarePolicyActionsAppSecMalwarePolicyActions = AkamaiFunctions.getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;malwarePolicyActions&#34;, malwarePolicyActionsAppSecMalwarePolicyActions.applyValue(getAppSecMalwarePolicyActionsResult -&gt; getAppSecMalwarePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, scanned action, and unscanned action of the malware policy or policies.
     * 
     */
    public static CompletableFuture<GetAppSecMalwarePolicyActionsResult> getAppSecMalwarePolicyActionsPlain(GetAppSecMalwarePolicyActionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecMalwarePolicyActions:getAppSecMalwarePolicyActions", TypeShape.of(GetAppSecMalwarePolicyActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; match target
     * 
     * Returns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;matchTargets&#34;, matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *         final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .matchTargetId(&#34;2712938&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;matchTargetOutput&#34;, matchTarget.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and security policy ID of your match targets.
     * - `json`. JSON-formatted list of the match target information.
     * 
     */
    public static Output<GetAppSecMatchTargetsResult> getAppSecMatchTargets(GetAppSecMatchTargetsArgs args) {
        return getAppSecMatchTargets(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; match target
     * 
     * Returns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;matchTargets&#34;, matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *         final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .matchTargetId(&#34;2712938&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;matchTargetOutput&#34;, matchTarget.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and security policy ID of your match targets.
     * - `json`. JSON-formatted list of the match target information.
     * 
     */
    public static CompletableFuture<GetAppSecMatchTargetsResult> getAppSecMatchTargetsPlain(GetAppSecMatchTargetsPlainArgs args) {
        return getAppSecMatchTargetsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; match target
     * 
     * Returns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;matchTargets&#34;, matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *         final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .matchTargetId(&#34;2712938&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;matchTargetOutput&#34;, matchTarget.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and security policy ID of your match targets.
     * - `json`. JSON-formatted list of the match target information.
     * 
     */
    public static Output<GetAppSecMatchTargetsResult> getAppSecMatchTargets(GetAppSecMatchTargetsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecMatchTargets:getAppSecMatchTargets", TypeShape.of(GetAppSecMatchTargetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; match target
     * 
     * Returns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;matchTargets&#34;, matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *         final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .matchTargetId(&#34;2712938&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;matchTargetOutput&#34;, matchTarget.applyValue(getAppSecMatchTargetsResult -&gt; getAppSecMatchTargetsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and security policy ID of your match targets.
     * - `json`. JSON-formatted list of the match target information.
     * 
     */
    public static CompletableFuture<GetAppSecMatchTargetsResult> getAppSecMatchTargetsPlain(GetAppSecMatchTargetsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecMatchTargets:getAppSecMatchTargets", TypeShape.of(GetAppSecMatchTargetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns penalty box settings for the specified security policy.
     * When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;penaltyBoxAction&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.action()));
     *         ctx.export(&#34;penaltyBoxEnabled&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;penaltyBoxText&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.
     * - `output_text`. Tabular report of penalty box protection settings.
     * 
     */
    public static Output<GetAppSecPenaltyBoxResult> getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs args) {
        return getAppSecPenaltyBox(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns penalty box settings for the specified security policy.
     * When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;penaltyBoxAction&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.action()));
     *         ctx.export(&#34;penaltyBoxEnabled&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;penaltyBoxText&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.
     * - `output_text`. Tabular report of penalty box protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecPenaltyBoxResult> getAppSecPenaltyBoxPlain(GetAppSecPenaltyBoxPlainArgs args) {
        return getAppSecPenaltyBoxPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns penalty box settings for the specified security policy.
     * When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;penaltyBoxAction&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.action()));
     *         ctx.export(&#34;penaltyBoxEnabled&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;penaltyBoxText&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.
     * - `output_text`. Tabular report of penalty box protection settings.
     * 
     */
    public static Output<GetAppSecPenaltyBoxResult> getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecPenaltyBox:getAppSecPenaltyBox", TypeShape.of(GetAppSecPenaltyBoxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns penalty box settings for the specified security policy.
     * When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.
     * There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;penaltyBoxAction&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.action()));
     *         ctx.export(&#34;penaltyBoxEnabled&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.enabled()));
     *         ctx.export(&#34;penaltyBoxText&#34;, penaltyBox.applyValue(getAppSecPenaltyBoxResult -&gt; getAppSecPenaltyBoxResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the penalty box is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. The request is blocked.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.
     * - `output_text`. Tabular report of penalty box protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecPenaltyBoxResult> getAppSecPenaltyBoxPlain(GetAppSecPenaltyBoxPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecPenaltyBox:getAppSecPenaltyBox", TypeShape.of(GetAppSecPenaltyBoxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; rate policy
     * 
     * Returns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;ratePoliciesOutput&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *         ctx.export(&#34;ratePoliciesJson&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .ratePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyJson&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         ctx.export(&#34;ratePolicyOutput&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the rate policies.
     * - `json`. JSON-formatted list of the rate policy information.
     * 
     */
    public static Output<GetAppSecRatePoliciesResult> getAppSecRatePolicies(GetAppSecRatePoliciesArgs args) {
        return getAppSecRatePolicies(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; rate policy
     * 
     * Returns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;ratePoliciesOutput&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *         ctx.export(&#34;ratePoliciesJson&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .ratePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyJson&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         ctx.export(&#34;ratePolicyOutput&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the rate policies.
     * - `json`. JSON-formatted list of the rate policy information.
     * 
     */
    public static CompletableFuture<GetAppSecRatePoliciesResult> getAppSecRatePoliciesPlain(GetAppSecRatePoliciesPlainArgs args) {
        return getAppSecRatePoliciesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; rate policy
     * 
     * Returns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;ratePoliciesOutput&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *         ctx.export(&#34;ratePoliciesJson&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .ratePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyJson&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         ctx.export(&#34;ratePolicyOutput&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the rate policies.
     * - `json`. JSON-formatted list of the rate policy information.
     * 
     */
    public static Output<GetAppSecRatePoliciesResult> getAppSecRatePolicies(GetAppSecRatePoliciesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecRatePolicies:getAppSecRatePolicies", TypeShape.of(GetAppSecRatePoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; rate policy
     * 
     * Returns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;ratePoliciesOutput&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *         ctx.export(&#34;ratePoliciesJson&#34;, ratePolicies.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .ratePolicyId(&#34;122149&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyJson&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.json()));
     *         ctx.export(&#34;ratePolicyOutput&#34;, ratePolicy.applyValue(getAppSecRatePoliciesResult -&gt; getAppSecRatePoliciesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID and name of the rate policies.
     * - `json`. JSON-formatted list of the rate policy information.
     * 
     */
    public static CompletableFuture<GetAppSecRatePoliciesResult> getAppSecRatePoliciesPlain(GetAppSecRatePoliciesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecRatePolicies:getAppSecRatePolicies", TypeShape.of(GetAppSecRatePoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; rate policy
     * 
     * Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyActions&#34;, ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -&gt; getAppSecRatePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
     * 
     */
    public static Output<GetAppSecRatePolicyActionsResult> getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs args) {
        return getAppSecRatePolicyActions(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; rate policy
     * 
     * Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyActions&#34;, ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -&gt; getAppSecRatePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
     * 
     */
    public static CompletableFuture<GetAppSecRatePolicyActionsResult> getAppSecRatePolicyActionsPlain(GetAppSecRatePolicyActionsPlainArgs args) {
        return getAppSecRatePolicyActionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy; rate policy
     * 
     * Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyActions&#34;, ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -&gt; getAppSecRatePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
     * 
     */
    public static Output<GetAppSecRatePolicyActionsResult> getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecRatePolicyActions:getAppSecRatePolicyActions", TypeShape.of(GetAppSecRatePolicyActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy; rate policy
     * 
     * Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;ratePolicyActions&#34;, ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -&gt; getAppSecRatePolicyActionsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
     * 
     */
    public static CompletableFuture<GetAppSecRatePolicyActionsResult> getAppSecRatePolicyActionsPlain(GetAppSecRatePolicyActionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecRatePolicyActions:getAppSecRatePolicyActions", TypeShape.of(GetAppSecRatePolicyActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## akamai.getAppSecReputationProfileActions
     * 
     * **Scopes**: Security policy; reputation profile
     * 
     * Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActionsText&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.outputText()));
     *         ctx.export(&#34;reputationProfileActionsJson&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.json()));
     *         final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActions2&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.action()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the reputation profile is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Block the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `json`. JSON-formatted report of the reputation profile action information.
     * - `output_text`. Tabular report of the reputation profile action information.
     * 
     */
    public static Output<GetAppSecReputationProfileActionsResult> getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs args) {
        return getAppSecReputationProfileActions(args, InvokeOptions.Empty);
    }
    /**
     * ## akamai.getAppSecReputationProfileActions
     * 
     * **Scopes**: Security policy; reputation profile
     * 
     * Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActionsText&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.outputText()));
     *         ctx.export(&#34;reputationProfileActionsJson&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.json()));
     *         final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActions2&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.action()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the reputation profile is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Block the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `json`. JSON-formatted report of the reputation profile action information.
     * - `output_text`. Tabular report of the reputation profile action information.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfileActionsResult> getAppSecReputationProfileActionsPlain(GetAppSecReputationProfileActionsPlainArgs args) {
        return getAppSecReputationProfileActionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * ## akamai.getAppSecReputationProfileActions
     * 
     * **Scopes**: Security policy; reputation profile
     * 
     * Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActionsText&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.outputText()));
     *         ctx.export(&#34;reputationProfileActionsJson&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.json()));
     *         final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActions2&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.action()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the reputation profile is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Block the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `json`. JSON-formatted report of the reputation profile action information.
     * - `output_text`. Tabular report of the reputation profile action information.
     * 
     */
    public static Output<GetAppSecReputationProfileActionsResult> getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions", TypeShape.of(GetAppSecReputationProfileActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## akamai.getAppSecReputationProfileActions
     * 
     * **Scopes**: Security policy; reputation profile
     * 
     * Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActionsText&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.outputText()));
     *         ctx.export(&#34;reputationProfileActionsJson&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.json()));
     *         final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileActions2&#34;, reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -&gt; getAppSecReputationProfileActionsResult.action()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `action`. Action taken any time the reputation profile is triggered. Valid values are:
     *   - **alert**. Record the event.
     *   - **deny**. Block the request.
     *   - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
     *   - **none**. Take no action.
     * - `json`. JSON-formatted report of the reputation profile action information.
     * - `output_text`. Tabular report of the reputation profile action information.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfileActionsResult> getAppSecReputationProfileActionsPlain(GetAppSecReputationProfileActionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions", TypeShape.of(GetAppSecReputationProfileActionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the following two reputation analysis settings:
     * 
     * - `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.
     * - `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationAnalysisText&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.outputText()));
     *         ctx.export(&#34;reputationAnalysisJson&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the reputation analysis settings.
     * - `output_text`. Tabular report showing the reputation analysis settings.
     * 
     */
    public static Output<GetAppSecReputationProfileAnalysisResult> getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs args) {
        return getAppSecReputationProfileAnalysis(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the following two reputation analysis settings:
     * 
     * - `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.
     * - `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationAnalysisText&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.outputText()));
     *         ctx.export(&#34;reputationAnalysisJson&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the reputation analysis settings.
     * - `output_text`. Tabular report showing the reputation analysis settings.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfileAnalysisResult> getAppSecReputationProfileAnalysisPlain(GetAppSecReputationProfileAnalysisPlainArgs args) {
        return getAppSecReputationProfileAnalysisPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the following two reputation analysis settings:
     * 
     * - `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.
     * - `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationAnalysisText&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.outputText()));
     *         ctx.export(&#34;reputationAnalysisJson&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the reputation analysis settings.
     * - `output_text`. Tabular report showing the reputation analysis settings.
     * 
     */
    public static Output<GetAppSecReputationProfileAnalysisResult> getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecReputationProfileAnalysis:getAppSecReputationProfileAnalysis", TypeShape.of(GetAppSecReputationProfileAnalysisResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the following two reputation analysis settings:
     * 
     * - `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.
     * - `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationAnalysisText&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.outputText()));
     *         ctx.export(&#34;reputationAnalysisJson&#34;, reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -&gt; getAppSecReputationProfileAnalysisResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the reputation analysis settings.
     * - `output_text`. Tabular report showing the reputation analysis settings.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfileAnalysisResult> getAppSecReputationProfileAnalysisPlain(GetAppSecReputationProfileAnalysisPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecReputationProfileAnalysis:getAppSecReputationProfileAnalysis", TypeShape.of(GetAppSecReputationProfileAnalysisResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; reputation profile
     * 
     * Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfilesOutput&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *         ctx.export(&#34;reputationProfilesJson&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileJson&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         ctx.export(&#34;reputationProfileOutput&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
     * - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
     * 
     */
    public static Output<GetAppSecReputationProfilesResult> getAppSecReputationProfiles(GetAppSecReputationProfilesArgs args) {
        return getAppSecReputationProfiles(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; reputation profile
     * 
     * Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfilesOutput&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *         ctx.export(&#34;reputationProfilesJson&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileJson&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         ctx.export(&#34;reputationProfileOutput&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
     * - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfilesResult> getAppSecReputationProfilesPlain(GetAppSecReputationProfilesPlainArgs args) {
        return getAppSecReputationProfilesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; reputation profile
     * 
     * Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfilesOutput&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *         ctx.export(&#34;reputationProfilesJson&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileJson&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         ctx.export(&#34;reputationProfileOutput&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
     * - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
     * 
     */
    public static Output<GetAppSecReputationProfilesResult> getAppSecReputationProfiles(GetAppSecReputationProfilesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecReputationProfiles:getAppSecReputationProfiles", TypeShape.of(GetAppSecReputationProfilesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; reputation profile
     * 
     * Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfilesOutput&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *         ctx.export(&#34;reputationProfilesJson&#34;, reputationProfiles.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .reputationProfileId(&#34;12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;reputationProfileJson&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.json()));
     *         ctx.export(&#34;reputationProfileOutput&#34;, reputationProfile.applyValue(getAppSecReputationProfilesResult -&gt; getAppSecReputationProfilesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
     * - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
     * 
     */
    public static CompletableFuture<GetAppSecReputationProfilesResult> getAppSecReputationProfilesPlain(GetAppSecReputationProfilesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecReputationProfiles:getAppSecReputationProfiles", TypeShape.of(GetAppSecReputationProfilesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;upgradeDetailsText&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.outputText()));
     *         ctx.export(&#34;upgradeDetailsJson&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.
     * - `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.
     * 
     */
    public static Output<GetAppSecRuleUpgradeDetailsResult> getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs args) {
        return getAppSecRuleUpgradeDetails(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;upgradeDetailsText&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.outputText()));
     *         ctx.export(&#34;upgradeDetailsJson&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.
     * - `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.
     * 
     */
    public static CompletableFuture<GetAppSecRuleUpgradeDetailsResult> getAppSecRuleUpgradeDetailsPlain(GetAppSecRuleUpgradeDetailsPlainArgs args) {
        return getAppSecRuleUpgradeDetailsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;upgradeDetailsText&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.outputText()));
     *         ctx.export(&#34;upgradeDetailsJson&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.
     * - `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.
     * 
     */
    public static Output<GetAppSecRuleUpgradeDetailsResult> getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecRuleUpgradeDetails:getAppSecRuleUpgradeDetails", TypeShape.of(GetAppSecRuleUpgradeDetailsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;upgradeDetailsText&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.outputText()));
     *         ctx.export(&#34;upgradeDetailsJson&#34;, upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -&gt; getAppSecRuleUpgradeDetailsResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.
     * - `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.
     * 
     */
    public static CompletableFuture<GetAppSecRuleUpgradeDetailsResult> getAppSecRuleUpgradeDetailsPlain(GetAppSecRuleUpgradeDetailsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecRuleUpgradeDetails:getAppSecRuleUpgradeDetails", TypeShape.of(GetAppSecRuleUpgradeDetailsResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecRulesResult> getAppSecRules(GetAppSecRulesArgs args) {
        return getAppSecRules(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecRulesResult> getAppSecRulesPlain(GetAppSecRulesPlainArgs args) {
        return getAppSecRulesPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecRulesResult> getAppSecRules(GetAppSecRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecRules:getAppSecRules", TypeShape.of(GetAppSecRulesResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecRulesResult> getAppSecRulesPlain(GetAppSecRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecRules:getAppSecRules", TypeShape.of(GetAppSecRulesResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetAppSecSecurityPolicyResult> getAppSecSecurityPolicy(GetAppSecSecurityPolicyArgs args) {
        return getAppSecSecurityPolicy(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetAppSecSecurityPolicyResult> getAppSecSecurityPolicyPlain(GetAppSecSecurityPolicyPlainArgs args) {
        return getAppSecSecurityPolicyPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetAppSecSecurityPolicyResult> getAppSecSecurityPolicy(GetAppSecSecurityPolicyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSecurityPolicy:getAppSecSecurityPolicy", TypeShape.of(GetAppSecSecurityPolicyResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetAppSecSecurityPolicyResult> getAppSecSecurityPolicyPlain(GetAppSecSecurityPolicyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSecurityPolicy:getAppSecSecurityPolicy", TypeShape.of(GetAppSecSecurityPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the protections in effect for the specified security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectionsJson&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.json()));
     *         ctx.export(&#34;protectionsApplyApiConstraints&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));
     *         ctx.export(&#34;protectionsApplyApplicationLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));
     *         ctx.export(&#34;protectionsApplyBotmanControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));
     *         ctx.export(&#34;protectionsApplyMalwareControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyMalwareControls()));
     *         ctx.export(&#34;protectionsApplyNetworkLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));
     *         ctx.export(&#34;protectionsApplyRateControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyRateControls()));
     *         ctx.export(&#34;protectionsApplyReputationControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));
     *         ctx.export(&#34;protectionsApplySlowPostControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.
     * - `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.
     * - `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.
     * - `apply_malware_controls`. Returns **true** if malware controls are enabled; returns **false** if they are not.
     * - `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.
     * - `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.
     * - `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.
     * - `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.
     * - `json`. JSON-formatted list showing the status of the protection settings.
     * - `output_text`. Tabular report showing the status of the protection settings.
     * 
     */
    public static Output<GetAppSecSecurityPolicyProtectionsResult> getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs args) {
        return getAppSecSecurityPolicyProtections(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the protections in effect for the specified security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectionsJson&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.json()));
     *         ctx.export(&#34;protectionsApplyApiConstraints&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));
     *         ctx.export(&#34;protectionsApplyApplicationLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));
     *         ctx.export(&#34;protectionsApplyBotmanControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));
     *         ctx.export(&#34;protectionsApplyMalwareControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyMalwareControls()));
     *         ctx.export(&#34;protectionsApplyNetworkLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));
     *         ctx.export(&#34;protectionsApplyRateControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyRateControls()));
     *         ctx.export(&#34;protectionsApplyReputationControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));
     *         ctx.export(&#34;protectionsApplySlowPostControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.
     * - `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.
     * - `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.
     * - `apply_malware_controls`. Returns **true** if malware controls are enabled; returns **false** if they are not.
     * - `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.
     * - `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.
     * - `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.
     * - `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.
     * - `json`. JSON-formatted list showing the status of the protection settings.
     * - `output_text`. Tabular report showing the status of the protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecSecurityPolicyProtectionsResult> getAppSecSecurityPolicyProtectionsPlain(GetAppSecSecurityPolicyProtectionsPlainArgs args) {
        return getAppSecSecurityPolicyProtectionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the protections in effect for the specified security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectionsJson&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.json()));
     *         ctx.export(&#34;protectionsApplyApiConstraints&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));
     *         ctx.export(&#34;protectionsApplyApplicationLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));
     *         ctx.export(&#34;protectionsApplyBotmanControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));
     *         ctx.export(&#34;protectionsApplyMalwareControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyMalwareControls()));
     *         ctx.export(&#34;protectionsApplyNetworkLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));
     *         ctx.export(&#34;protectionsApplyRateControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyRateControls()));
     *         ctx.export(&#34;protectionsApplyReputationControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));
     *         ctx.export(&#34;protectionsApplySlowPostControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.
     * - `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.
     * - `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.
     * - `apply_malware_controls`. Returns **true** if malware controls are enabled; returns **false** if they are not.
     * - `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.
     * - `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.
     * - `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.
     * - `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.
     * - `json`. JSON-formatted list showing the status of the protection settings.
     * - `output_text`. Tabular report showing the status of the protection settings.
     * 
     */
    public static Output<GetAppSecSecurityPolicyProtectionsResult> getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSecurityPolicyProtections:getAppSecSecurityPolicyProtections", TypeShape.of(GetAppSecSecurityPolicyProtectionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about the protections in effect for the specified security policy.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectionsJson&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.json()));
     *         ctx.export(&#34;protectionsApplyApiConstraints&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));
     *         ctx.export(&#34;protectionsApplyApplicationLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));
     *         ctx.export(&#34;protectionsApplyBotmanControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));
     *         ctx.export(&#34;protectionsApplyMalwareControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyMalwareControls()));
     *         ctx.export(&#34;protectionsApplyNetworkLayerControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));
     *         ctx.export(&#34;protectionsApplyRateControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyRateControls()));
     *         ctx.export(&#34;protectionsApplyReputationControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));
     *         ctx.export(&#34;protectionsApplySlowPostControls&#34;, protections.applyValue(getAppSecSecurityPolicyProtectionsResult -&gt; getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.
     * - `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.
     * - `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.
     * - `apply_malware_controls`. Returns **true** if malware controls are enabled; returns **false** if they are not.
     * - `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.
     * - `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.
     * - `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.
     * - `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.
     * - `json`. JSON-formatted list showing the status of the protection settings.
     * - `output_text`. Tabular report showing the status of the protection settings.
     * 
     */
    public static CompletableFuture<GetAppSecSecurityPolicyProtectionsResult> getAppSecSecurityPolicyProtectionsPlain(GetAppSecSecurityPolicyProtectionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSecurityPolicyProtections:getAppSecSecurityPolicyProtections", TypeShape.of(GetAppSecSecurityPolicyProtectionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static Output<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnames() {
        return getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static CompletableFuture<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnamesPlain() {
        return getAppSecSelectableHostnamesPlain(GetAppSecSelectableHostnamesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static Output<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs args) {
        return getAppSecSelectableHostnames(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static CompletableFuture<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnamesPlain(GetAppSecSelectableHostnamesPlainArgs args) {
        return getAppSecSelectableHostnamesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static Output<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSelectableHostnames:getAppSecSelectableHostnames", TypeShape.of(GetAppSecSelectableHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration; contract; group
     * 
     * Returns the list of hostnames that can be (but aren&#39;t yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnames&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesJson&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesOutputText&#34;, selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *         final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()
     *             .contractId(&#34;5-2WA382&#34;)
     *             .groupId(12198)
     *             .build());
     * 
     *         ctx.export(&#34;selectableHostnamesForCreateConfiguration&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationJson&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectableHostnamesForCreateConfigurationOutputText&#34;, selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -&gt; getAppSecSelectableHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selectable hostnames.
     * - `hostnames_json`. JSON-formatted list of selectable hostnames.
     * - `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.
     * 
     */
    public static CompletableFuture<GetAppSecSelectableHostnamesResult> getAppSecSelectableHostnamesPlain(GetAppSecSelectableHostnamesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSelectableHostnames:getAppSecSelectableHostnames", TypeShape.of(GetAppSecSelectableHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the hostnames currently protected by the specified security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectedHostnames&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectedHostnamesJson&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectedHostnamesOutputText&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selected hostnames.
     * - `hostnames_json`. JSON-formatted list of selected hostnames.
     * - `output_text`. Tabular report of the selected hostnames.
     * 
     */
    public static Output<GetAppSecSelectedHostnamesResult> getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs args) {
        return getAppSecSelectedHostnames(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the hostnames currently protected by the specified security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectedHostnames&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectedHostnamesJson&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectedHostnamesOutputText&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selected hostnames.
     * - `hostnames_json`. JSON-formatted list of selected hostnames.
     * - `output_text`. Tabular report of the selected hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecSelectedHostnamesResult> getAppSecSelectedHostnamesPlain(GetAppSecSelectedHostnamesPlainArgs args) {
        return getAppSecSelectedHostnamesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the hostnames currently protected by the specified security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectedHostnames&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectedHostnamesJson&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectedHostnamesOutputText&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selected hostnames.
     * - `hostnames_json`. JSON-formatted list of selected hostnames.
     * - `output_text`. Tabular report of the selected hostnames.
     * 
     */
    public static Output<GetAppSecSelectedHostnamesResult> getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSelectedHostnames:getAppSecSelectedHostnames", TypeShape.of(GetAppSecSelectedHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns a list of the hostnames currently protected by the specified security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;selectedHostnames&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnames()));
     *         ctx.export(&#34;selectedHostnamesJson&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.hostnamesJson()));
     *         ctx.export(&#34;selectedHostnamesOutputText&#34;, selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -&gt; getAppSecSelectedHostnamesResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `hostnames`. List of selected hostnames.
     * - `hostnames_json`. JSON-formatted list of selected hostnames.
     * - `output_text`. Tabular report of the selected hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecSelectedHostnamesResult> getAppSecSelectedHostnamesPlain(GetAppSecSelectedHostnamesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSelectedHostnames:getAppSecSelectedHostnames", TypeShape.of(GetAppSecSelectedHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static Output<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitions() {
        return getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static CompletableFuture<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitionsPlain() {
        return getAppSecSiemDefinitionsPlain(GetAppSecSiemDefinitionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static Output<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs args) {
        return getAppSecSiemDefinitions(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static CompletableFuture<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitionsPlain(GetAppSecSiemDefinitionsPlainArgs args) {
        return getAppSecSiemDefinitionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static Output<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSiemDefinitions:getAppSecSiemDefinitions", TypeShape.of(GetAppSecSiemDefinitionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: SIEM definition
     * 
     * Returns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.
     * 
     * **Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();
     * 
     *         ctx.export(&#34;siemDefinitionsJson&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.json()));
     *         ctx.export(&#34;siemDefinitionsOutput&#34;, siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.outputText()));
     *         final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()
     *             .siemDefinitionName(&#34;SIEM Version 01&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;siemDefinitionId&#34;, siemDefinition.applyValue(getAppSecSiemDefinitionsResult -&gt; getAppSecSiemDefinitionsResult.id()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM version information.
     * - `output_text`. Tabular report showing the ID and name of each SIEM version.
     * 
     */
    public static CompletableFuture<GetAppSecSiemDefinitionsResult> getAppSecSiemDefinitionsPlain(GetAppSecSiemDefinitionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSiemDefinitions:getAppSecSiemDefinitions", TypeShape.of(GetAppSecSiemDefinitionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the SIEM (Security Event and Information Management) settings for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;siemSettingsJson&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.json()));
     *         ctx.export(&#34;siemSettingsOutput&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM setting information.
     * - `output_text`. Tabular report showing the SIEM setting information.
     * 
     */
    public static Output<GetAppSecSiemSettingsResult> getAppSecSiemSettings(GetAppSecSiemSettingsArgs args) {
        return getAppSecSiemSettings(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the SIEM (Security Event and Information Management) settings for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;siemSettingsJson&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.json()));
     *         ctx.export(&#34;siemSettingsOutput&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM setting information.
     * - `output_text`. Tabular report showing the SIEM setting information.
     * 
     */
    public static CompletableFuture<GetAppSecSiemSettingsResult> getAppSecSiemSettingsPlain(GetAppSecSiemSettingsPlainArgs args) {
        return getAppSecSiemSettingsPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the SIEM (Security Event and Information Management) settings for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;siemSettingsJson&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.json()));
     *         ctx.export(&#34;siemSettingsOutput&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM setting information.
     * - `output_text`. Tabular report showing the SIEM setting information.
     * 
     */
    public static Output<GetAppSecSiemSettingsResult> getAppSecSiemSettings(GetAppSecSiemSettingsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSiemSettings:getAppSecSiemSettings", TypeShape.of(GetAppSecSiemSettingsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the SIEM (Security Event and Information Management) settings for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;siemSettingsJson&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.json()));
     *         ctx.export(&#34;siemSettingsOutput&#34;, siemSettings.applyValue(getAppSecSiemSettingsResult -&gt; getAppSecSiemSettingsResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list of the SIEM setting information.
     * - `output_text`. Tabular report showing the SIEM setting information.
     * 
     */
    public static CompletableFuture<GetAppSecSiemSettingsResult> getAppSecSiemSettingsPlain(GetAppSecSiemSettingsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSiemSettings:getAppSecSiemSettings", TypeShape.of(GetAppSecSiemSettingsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;slowPostOutputText&#34;, slowPost.applyValue(getAppSecSlowPostResult -&gt; getAppSecSlowPostResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report including the following:
     *   - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:
     *     - **alert**. Record the event.
     *     - **abort**. Block the request.
     *   - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.
     *   - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.
     *   - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.
     * 
     */
    public static Output<GetAppSecSlowPostResult> getAppSecSlowPost(GetAppSecSlowPostArgs args) {
        return getAppSecSlowPost(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;slowPostOutputText&#34;, slowPost.applyValue(getAppSecSlowPostResult -&gt; getAppSecSlowPostResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report including the following:
     *   - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:
     *     - **alert**. Record the event.
     *     - **abort**. Block the request.
     *   - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.
     *   - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.
     *   - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.
     * 
     */
    public static CompletableFuture<GetAppSecSlowPostResult> getAppSecSlowPostPlain(GetAppSecSlowPostPlainArgs args) {
        return getAppSecSlowPostPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;slowPostOutputText&#34;, slowPost.applyValue(getAppSecSlowPostResult -&gt; getAppSecSlowPostResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report including the following:
     *   - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:
     *     - **alert**. Record the event.
     *     - **abort**. Block the request.
     *   - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.
     *   - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.
     *   - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.
     * 
     */
    public static Output<GetAppSecSlowPostResult> getAppSecSlowPost(GetAppSecSlowPostArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecSlowPost:getAppSecSlowPost", TypeShape.of(GetAppSecSlowPostResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;slowPostOutputText&#34;, slowPost.applyValue(getAppSecSlowPostResult -&gt; getAppSecSlowPostResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `output_text`. Tabular report including the following:
     *   - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:
     *     - **alert**. Record the event.
     *     - **abort**. Block the request.
     *   - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.
     *   - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.
     *   - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.
     * 
     */
    public static CompletableFuture<GetAppSecSlowPostResult> getAppSecSlowPostPlain(GetAppSecSlowPostPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecSlowPost:getAppSecSlowPost", TypeShape.of(GetAppSecSlowPostResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;threatIntel&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.threatIntel()));
     *         ctx.export(&#34;json&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.json()));
     *         ctx.export(&#34;outputText&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.
     * - `json`. JSON-formatted threat intelligence report.
     * - `output_text`. Tabular report of the threat intelligence information.
     * 
     */
    public static Output<GetAppSecThreatIntelResult> getAppSecThreatIntel(GetAppSecThreatIntelArgs args) {
        return getAppSecThreatIntel(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;threatIntel&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.threatIntel()));
     *         ctx.export(&#34;json&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.json()));
     *         ctx.export(&#34;outputText&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.
     * - `json`. JSON-formatted threat intelligence report.
     * - `output_text`. Tabular report of the threat intelligence information.
     * 
     */
    public static CompletableFuture<GetAppSecThreatIntelResult> getAppSecThreatIntelPlain(GetAppSecThreatIntelPlainArgs args) {
        return getAppSecThreatIntelPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;threatIntel&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.threatIntel()));
     *         ctx.export(&#34;json&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.json()));
     *         ctx.export(&#34;outputText&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.
     * - `json`. JSON-formatted threat intelligence report.
     * - `output_text`. Tabular report of the threat intelligence information.
     * 
     */
    public static Output<GetAppSecThreatIntelResult> getAppSecThreatIntel(GetAppSecThreatIntelArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecThreatIntel:getAppSecThreatIntel", TypeShape.of(GetAppSecThreatIntelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;threatIntel&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.threatIntel()));
     *         ctx.export(&#34;json&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.json()));
     *         ctx.export(&#34;outputText&#34;, threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -&gt; getAppSecThreatIntelResult.outputText()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.
     * - `json`. JSON-formatted threat intelligence report.
     * - `output_text`. Tabular report of the threat intelligence information.
     * 
     */
    public static CompletableFuture<GetAppSecThreatIntelResult> getAppSecThreatIntelPlain(GetAppSecThreatIntelPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecThreatIntel:getAppSecThreatIntel", TypeShape.of(GetAppSecThreatIntelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns tuning recommendations for the specified attack group or rule (or, if both the `attack_group` and the `rule_id` arguments are not included, returns tuning recommendations for all the attack groups and rules in the specified security policy).
     * Tuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.
     * Tuning recommendations are returned as attack group or rule exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to an attack group or the `akamai.AppSecRule` resource to add the recommended exception to a rule.\
     * If the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.
     * If you need, you can manually merge a recommended exception for an attack group or a rule with the exception previously configured.
     * You can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).
     * 
     * **Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;policyRecommendationsJson&#34;, policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *         final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .rulesetType(var_.ruleset_type())
     *             .attackGroup(var_.attack_group())
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupRecommendationsJson&#34;, attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAppSecTuningRecommendationsResult> getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs args) {
        return getAppSecTuningRecommendations(args, InvokeOptions.Empty);
    }
    /**
     * Returns tuning recommendations for the specified attack group or rule (or, if both the `attack_group` and the `rule_id` arguments are not included, returns tuning recommendations for all the attack groups and rules in the specified security policy).
     * Tuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.
     * Tuning recommendations are returned as attack group or rule exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to an attack group or the `akamai.AppSecRule` resource to add the recommended exception to a rule.\
     * If the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.
     * If you need, you can manually merge a recommended exception for an attack group or a rule with the exception previously configured.
     * You can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).
     * 
     * **Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;policyRecommendationsJson&#34;, policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *         final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .rulesetType(var_.ruleset_type())
     *             .attackGroup(var_.attack_group())
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupRecommendationsJson&#34;, attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAppSecTuningRecommendationsResult> getAppSecTuningRecommendationsPlain(GetAppSecTuningRecommendationsPlainArgs args) {
        return getAppSecTuningRecommendationsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns tuning recommendations for the specified attack group or rule (or, if both the `attack_group` and the `rule_id` arguments are not included, returns tuning recommendations for all the attack groups and rules in the specified security policy).
     * Tuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.
     * Tuning recommendations are returned as attack group or rule exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to an attack group or the `akamai.AppSecRule` resource to add the recommended exception to a rule.\
     * If the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.
     * If you need, you can manually merge a recommended exception for an attack group or a rule with the exception previously configured.
     * You can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).
     * 
     * **Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;policyRecommendationsJson&#34;, policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *         final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .rulesetType(var_.ruleset_type())
     *             .attackGroup(var_.attack_group())
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupRecommendationsJson&#34;, attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetAppSecTuningRecommendationsResult> getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecTuningRecommendations:getAppSecTuningRecommendations", TypeShape.of(GetAppSecTuningRecommendationsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns tuning recommendations for the specified attack group or rule (or, if both the `attack_group` and the `rule_id` arguments are not included, returns tuning recommendations for all the attack groups and rules in the specified security policy).
     * Tuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.
     * Tuning recommendations are returned as attack group or rule exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to an attack group or the `akamai.AppSecRule` resource to add the recommended exception to a rule.\
     * If the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.
     * If you need, you can manually merge a recommended exception for an attack group or a rule with the exception previously configured.
     * You can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).
     * 
     * **Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(var_.security_configuration())
     *             .build());
     * 
     *         final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .build());
     * 
     *         ctx.export(&#34;policyRecommendationsJson&#34;, policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *         final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(var_.security_policy_id())
     *             .rulesetType(var_.ruleset_type())
     *             .attackGroup(var_.attack_group())
     *             .build());
     * 
     *         ctx.export(&#34;attackGroupRecommendationsJson&#34;, attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -&gt; getAppSecTuningRecommendationsResult.json()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetAppSecTuningRecommendationsResult> getAppSecTuningRecommendationsPlain(GetAppSecTuningRecommendationsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecTuningRecommendations:getAppSecTuningRecommendations", TypeShape.of(GetAppSecTuningRecommendationsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the most recent version notes for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;versionNotesText&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.outputText()));
     *         ctx.export(&#34;versionNotesJson&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list showing the version notes.
     * - `output_text`. Tabular report showing the version notes.
     * 
     */
    public static Output<GetAppSecVersionNotesResult> getAppSecVersionNotes(GetAppSecVersionNotesArgs args) {
        return getAppSecVersionNotes(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the most recent version notes for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;versionNotesText&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.outputText()));
     *         ctx.export(&#34;versionNotesJson&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list showing the version notes.
     * - `output_text`. Tabular report showing the version notes.
     * 
     */
    public static CompletableFuture<GetAppSecVersionNotesResult> getAppSecVersionNotesPlain(GetAppSecVersionNotesPlainArgs args) {
        return getAppSecVersionNotesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the most recent version notes for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;versionNotesText&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.outputText()));
     *         ctx.export(&#34;versionNotesJson&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list showing the version notes.
     * - `output_text`. Tabular report showing the version notes.
     * 
     */
    public static Output<GetAppSecVersionNotesResult> getAppSecVersionNotes(GetAppSecVersionNotesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecVersionNotes:getAppSecVersionNotes", TypeShape.of(GetAppSecVersionNotesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security configuration
     * 
     * Returns the most recent version notes for a security configuration.
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .build());
     * 
     *         ctx.export(&#34;versionNotesText&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.outputText()));
     *         ctx.export(&#34;versionNotesJson&#34;, versionNotes.applyValue(getAppSecVersionNotesResult -&gt; getAppSecVersionNotesResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `json`. JSON-formatted list showing the version notes.
     * - `output_text`. Tabular report showing the version notes.
     * 
     */
    public static CompletableFuture<GetAppSecVersionNotesResult> getAppSecVersionNotesPlain(GetAppSecVersionNotesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecVersionNotes:getAppSecVersionNotes", TypeShape.of(GetAppSecVersionNotesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWafModeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;wafModeMode&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.mode()));
     *         ctx.export(&#34;wafModeCurrentRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.currentRuleset()));
     *         ctx.export(&#34;wafModeEvalStatus&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalStatus()));
     *         ctx.export(&#34;wafModeEvalRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalRuleset()));
     *         ctx.export(&#34;wafModeEvalExpirationDate&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalExpirationDate()));
     *         ctx.export(&#34;wafModeText&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.outputText()));
     *         ctx.export(&#34;wafModeJson&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you&#39;ll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.
     * - `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.
     * - `eval_status`. Specifies whether evaluation mode is enabled or disabled.
     * - `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.
     * - `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.
     * - `output_text`. Tabular report of the mode information.
     * - `json`. JSON-formatted list of the mode information.
     * 
     */
    public static Output<GetAppSecWafModeResult> getAppSecWafMode(GetAppSecWafModeArgs args) {
        return getAppSecWafMode(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWafModeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;wafModeMode&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.mode()));
     *         ctx.export(&#34;wafModeCurrentRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.currentRuleset()));
     *         ctx.export(&#34;wafModeEvalStatus&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalStatus()));
     *         ctx.export(&#34;wafModeEvalRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalRuleset()));
     *         ctx.export(&#34;wafModeEvalExpirationDate&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalExpirationDate()));
     *         ctx.export(&#34;wafModeText&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.outputText()));
     *         ctx.export(&#34;wafModeJson&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you&#39;ll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.
     * - `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.
     * - `eval_status`. Specifies whether evaluation mode is enabled or disabled.
     * - `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.
     * - `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.
     * - `output_text`. Tabular report of the mode information.
     * - `json`. JSON-formatted list of the mode information.
     * 
     */
    public static CompletableFuture<GetAppSecWafModeResult> getAppSecWafModePlain(GetAppSecWafModePlainArgs args) {
        return getAppSecWafModePlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWafModeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;wafModeMode&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.mode()));
     *         ctx.export(&#34;wafModeCurrentRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.currentRuleset()));
     *         ctx.export(&#34;wafModeEvalStatus&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalStatus()));
     *         ctx.export(&#34;wafModeEvalRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalRuleset()));
     *         ctx.export(&#34;wafModeEvalExpirationDate&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalExpirationDate()));
     *         ctx.export(&#34;wafModeText&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.outputText()));
     *         ctx.export(&#34;wafModeJson&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you&#39;ll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.
     * - `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.
     * - `eval_status`. Specifies whether evaluation mode is enabled or disabled.
     * - `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.
     * - `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.
     * - `output_text`. Tabular report of the mode information.
     * - `json`. JSON-formatted list of the mode information.
     * 
     */
    public static Output<GetAppSecWafModeResult> getAppSecWafMode(GetAppSecWafModeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecWafMode:getAppSecWafMode", TypeShape.of(GetAppSecWafModeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).
     * 
     * **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWafModeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;wafModeMode&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.mode()));
     *         ctx.export(&#34;wafModeCurrentRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.currentRuleset()));
     *         ctx.export(&#34;wafModeEvalStatus&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalStatus()));
     *         ctx.export(&#34;wafModeEvalRuleset&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalRuleset()));
     *         ctx.export(&#34;wafModeEvalExpirationDate&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.evalExpirationDate()));
     *         ctx.export(&#34;wafModeText&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.outputText()));
     *         ctx.export(&#34;wafModeJson&#34;, wafMode.applyValue(getAppSecWafModeResult -&gt; getAppSecWafModeResult.json()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned, and how that returned information is formatted:
     * 
     * - `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you&#39;ll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.
     * - `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.
     * - `eval_status`. Specifies whether evaluation mode is enabled or disabled.
     * - `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.
     * - `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.
     * - `output_text`. Tabular report of the mode information.
     * - `json`. JSON-formatted list of the mode information.
     * 
     */
    public static CompletableFuture<GetAppSecWafModeResult> getAppSecWafModePlain(GetAppSecWafModePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecWafMode:getAppSecWafMode", TypeShape.of(GetAppSecWafModeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns hostnames currently protected or being evaluated by a configuration and security policy.
     * This resource is available only to organizations running Web Application Protector (WAP).
     * Note that the WAP selected hostnames feature is currently in beta.
     * Please contact your Akamai representative for more information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.protectedHosts()));
     *         ctx.export(&#34;evaluatedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.evaluatedHosts()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
     * - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
     * - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
     * - `output_text`. Tabular reports of the protected and evaluated hostnames.
     * 
     */
    public static Output<GetAppSecWapSelectedHostnamesResult> getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs args) {
        return getAppSecWapSelectedHostnames(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns hostnames currently protected or being evaluated by a configuration and security policy.
     * This resource is available only to organizations running Web Application Protector (WAP).
     * Note that the WAP selected hostnames feature is currently in beta.
     * Please contact your Akamai representative for more information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.protectedHosts()));
     *         ctx.export(&#34;evaluatedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.evaluatedHosts()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
     * - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
     * - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
     * - `output_text`. Tabular reports of the protected and evaluated hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecWapSelectedHostnamesResult> getAppSecWapSelectedHostnamesPlain(GetAppSecWapSelectedHostnamesPlainArgs args) {
        return getAppSecWapSelectedHostnamesPlain(args, InvokeOptions.Empty);
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns hostnames currently protected or being evaluated by a configuration and security policy.
     * This resource is available only to organizations running Web Application Protector (WAP).
     * Note that the WAP selected hostnames feature is currently in beta.
     * Please contact your Akamai representative for more information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.protectedHosts()));
     *         ctx.export(&#34;evaluatedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.evaluatedHosts()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
     * - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
     * - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
     * - `output_text`. Tabular reports of the protected and evaluated hostnames.
     * 
     */
    public static Output<GetAppSecWapSelectedHostnamesResult> getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAppSecWapSelectedHostnames:getAppSecWapSelectedHostnames", TypeShape.of(GetAppSecWapSelectedHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * **Scopes**: Security policy
     * 
     * Returns hostnames currently protected or being evaluated by a configuration and security policy.
     * This resource is available only to organizations running Web Application Protector (WAP).
     * Note that the WAP selected hostnames feature is currently in beta.
     * Please contact your Akamai representative for more information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;
     * import com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()
     *             .name(&#34;Documentation&#34;)
     *             .build());
     * 
     *         final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()
     *             .configId(configuration.applyValue(getAppSecConfigurationResult -&gt; getAppSecConfigurationResult.configId()))
     *             .securityPolicyId(&#34;gms1_134637&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;protectedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.protectedHosts()));
     *         ctx.export(&#34;evaluatedHostnames&#34;, wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -&gt; getAppSecWapSelectedHostnamesResult.evaluatedHosts()));
     *     }
     * }
     * ```
     * ## Output Options
     * 
     * The following options can be used to determine the information returned and how that returned information is formatted:
     * 
     * - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
     * - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
     * - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
     * - `output_text`. Tabular reports of the protected and evaluated hostnames.
     * 
     */
    public static CompletableFuture<GetAppSecWapSelectedHostnamesResult> getAppSecWapSelectedHostnamesPlain(GetAppSecWapSelectedHostnamesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAppSecWapSelectedHostnames:getAppSecWapSelectedHostnames", TypeShape.of(GetAppSecWapSelectedHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getAuthoritiesSet` data source to retrieve a contract&#39;s authorities set. You use the authorities set when creating new zones.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()
     *             .contract(&#34;ctr_1-AB123&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source supports this attribute:
     * 
     * * `authorities` - A list of authorities.
     * 
     */
    public static Output<GetAuthoritiesSetResult> getAuthoritiesSet(GetAuthoritiesSetArgs args) {
        return getAuthoritiesSet(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getAuthoritiesSet` data source to retrieve a contract&#39;s authorities set. You use the authorities set when creating new zones.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()
     *             .contract(&#34;ctr_1-AB123&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source supports this attribute:
     * 
     * * `authorities` - A list of authorities.
     * 
     */
    public static CompletableFuture<GetAuthoritiesSetResult> getAuthoritiesSetPlain(GetAuthoritiesSetPlainArgs args) {
        return getAuthoritiesSetPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getAuthoritiesSet` data source to retrieve a contract&#39;s authorities set. You use the authorities set when creating new zones.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()
     *             .contract(&#34;ctr_1-AB123&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source supports this attribute:
     * 
     * * `authorities` - A list of authorities.
     * 
     */
    public static Output<GetAuthoritiesSetResult> getAuthoritiesSet(GetAuthoritiesSetArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getAuthoritiesSet:getAuthoritiesSet", TypeShape.of(GetAuthoritiesSetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getAuthoritiesSet` data source to retrieve a contract&#39;s authorities set. You use the authorities set when creating new zones.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()
     *             .contract(&#34;ctr_1-AB123&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source supports this attribute:
     * 
     * * `authorities` - A list of authorities.
     * 
     */
    public static CompletableFuture<GetAuthoritiesSetResult> getAuthoritiesSetPlain(GetAuthoritiesSetPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getAuthoritiesSet:getAuthoritiesSet", TypeShape.of(GetAuthoritiesSetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCPSEnrollment` data source to return data for specific enrollment.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollment = AkamaiFunctions.getCPSEnrollment(GetCPSEnrollmentArgs.builder()
     *             .enrollmentId(var_.enrollment_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollment.applyValue(getCPSEnrollmentResult -&gt; getCPSEnrollmentResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `contract_id` - A contract&#39;s ID, optionally with the `ctr_` prefix.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
     *     * `domain` - The domain to validate.
     *     * `full_path` - The URL where Akamai publishes `response_body` for Let&#39;s Encrypt to validate.
     *     * `response_body` - The data Let&#39;s Encrypt expects to find served at `full_path` URL.
     * 
     */
    public static Output<GetCPSEnrollmentResult> getCPSEnrollment(GetCPSEnrollmentArgs args) {
        return getCPSEnrollment(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCPSEnrollment` data source to return data for specific enrollment.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollment = AkamaiFunctions.getCPSEnrollment(GetCPSEnrollmentArgs.builder()
     *             .enrollmentId(var_.enrollment_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollment.applyValue(getCPSEnrollmentResult -&gt; getCPSEnrollmentResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `contract_id` - A contract&#39;s ID, optionally with the `ctr_` prefix.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
     *     * `domain` - The domain to validate.
     *     * `full_path` - The URL where Akamai publishes `response_body` for Let&#39;s Encrypt to validate.
     *     * `response_body` - The data Let&#39;s Encrypt expects to find served at `full_path` URL.
     * 
     */
    public static CompletableFuture<GetCPSEnrollmentResult> getCPSEnrollmentPlain(GetCPSEnrollmentPlainArgs args) {
        return getCPSEnrollmentPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCPSEnrollment` data source to return data for specific enrollment.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollment = AkamaiFunctions.getCPSEnrollment(GetCPSEnrollmentArgs.builder()
     *             .enrollmentId(var_.enrollment_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollment.applyValue(getCPSEnrollmentResult -&gt; getCPSEnrollmentResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `contract_id` - A contract&#39;s ID, optionally with the `ctr_` prefix.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
     *     * `domain` - The domain to validate.
     *     * `full_path` - The URL where Akamai publishes `response_body` for Let&#39;s Encrypt to validate.
     *     * `response_body` - The data Let&#39;s Encrypt expects to find served at `full_path` URL.
     * 
     */
    public static Output<GetCPSEnrollmentResult> getCPSEnrollment(GetCPSEnrollmentArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCPSEnrollment:getCPSEnrollment", TypeShape.of(GetCPSEnrollmentResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCPSEnrollment` data source to return data for specific enrollment.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollment = AkamaiFunctions.getCPSEnrollment(GetCPSEnrollmentArgs.builder()
     *             .enrollmentId(var_.enrollment_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollment.applyValue(getCPSEnrollmentResult -&gt; getCPSEnrollmentResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `contract_id` - A contract&#39;s ID, optionally with the `ctr_` prefix.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.
     *     * `domain` - The domain to validate.
     *     * `full_path` - The URL where Akamai publishes `response_body` for Let&#39;s Encrypt to validate.
     *     * `response_body` - The data Let&#39;s Encrypt expects to find served at `full_path` URL.
     * 
     */
    public static CompletableFuture<GetCPSEnrollmentResult> getCPSEnrollmentPlain(GetCPSEnrollmentPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCPSEnrollment:getCPSEnrollment", TypeShape.of(GetCPSEnrollmentResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCPSEnrollments` data source to return data for all of a specific contract&#39;s enrollments.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollmentsList = AkamaiFunctions.getCPSEnrollments(GetCPSEnrollmentsArgs.builder()
     *             .contractId(var_.contract_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollmentsList.applyValue(getCPSEnrollmentsResult -&gt; getCPSEnrollmentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `enrollments`
     *   * `enrollment_id`
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, the enrollment is using OCSP stapling. OCSP stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. Possible values are `on`, `off`, or `not-set`.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `pending_changes` - If `true`, there are changes currently pending in CPS. To view pending changes, use the `data_akamai_cps_enrollment` data source.
     * 
     */
    public static Output<GetCPSEnrollmentsResult> getCPSEnrollments(GetCPSEnrollmentsArgs args) {
        return getCPSEnrollments(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCPSEnrollments` data source to return data for all of a specific contract&#39;s enrollments.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollmentsList = AkamaiFunctions.getCPSEnrollments(GetCPSEnrollmentsArgs.builder()
     *             .contractId(var_.contract_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollmentsList.applyValue(getCPSEnrollmentsResult -&gt; getCPSEnrollmentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `enrollments`
     *   * `enrollment_id`
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, the enrollment is using OCSP stapling. OCSP stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. Possible values are `on`, `off`, or `not-set`.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `pending_changes` - If `true`, there are changes currently pending in CPS. To view pending changes, use the `data_akamai_cps_enrollment` data source.
     * 
     */
    public static CompletableFuture<GetCPSEnrollmentsResult> getCPSEnrollmentsPlain(GetCPSEnrollmentsPlainArgs args) {
        return getCPSEnrollmentsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCPSEnrollments` data source to return data for all of a specific contract&#39;s enrollments.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollmentsList = AkamaiFunctions.getCPSEnrollments(GetCPSEnrollmentsArgs.builder()
     *             .contractId(var_.contract_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollmentsList.applyValue(getCPSEnrollmentsResult -&gt; getCPSEnrollmentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `enrollments`
     *   * `enrollment_id`
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, the enrollment is using OCSP stapling. OCSP stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. Possible values are `on`, `off`, or `not-set`.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `pending_changes` - If `true`, there are changes currently pending in CPS. To view pending changes, use the `data_akamai_cps_enrollment` data source.
     * 
     */
    public static Output<GetCPSEnrollmentsResult> getCPSEnrollments(GetCPSEnrollmentsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCPSEnrollments:getCPSEnrollments", TypeShape.of(GetCPSEnrollmentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCPSEnrollments` data source to return data for all of a specific contract&#39;s enrollments.
     * 
     * ## Basic usage
     * 
     * This example shows how to set up a user:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var testEnrollmentsList = AkamaiFunctions.getCPSEnrollments(GetCPSEnrollmentsArgs.builder()
     *             .contractId(var_.contract_id())
     *             .build());
     * 
     *         ctx.export(&#34;dvOutput&#34;, testEnrollmentsList.applyValue(getCPSEnrollmentsResult -&gt; getCPSEnrollmentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `enrollments`
     *   * `enrollment_id`
     *   * `common_name` - The fully qualified domain name (FQDN) used for the certificate.
     *   * `sans` - Additional common names in a Subject Alternative Names (SAN) list.
     *   * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai&#39;s standard secure network, but it isn&#39;t PCI compliant. `enhanced-tls` deploys your certificate to Akamai&#39;s more secure network with PCI compliance capability.
     *   * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.
     *   * `admin_contact` - Contact information for the certificate administrator at your company.
     *   * `certificate_chain_type` - Certificate trust chain type.
     *   * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.
     *     * `country_code` - The country code for the country where your organization is located.
     *     * `city` - The city where your organization resides.
     *     * `organization` - The name of your company or organization.
     *     * `organizational_unit` - Your organizational unit.
     *     * `state` - Your state or province.
     *   * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.
     *   * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.
     *     * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.
     *       * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.
     *       * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.
     *       * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).
     *     * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.
     *     * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.
     *     * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.
     *     * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `ocsp_stapling` - If present, the enrollment is using OCSP stapling. OCSP stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. Possible values are `on`, `off`, or `not-set`.
     *     * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).
     *     * `quic_enabled` - If present, uses the QUIC transport layer network protocol.
     *   * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.
     *   * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can&#39;t reach the `admin_contact`.
     *   * `organization` - The name of the organization in Akamai where your technical contact works.
     *     * `name` - The name of the technical contact at Akamai.
     *     * `phone` - The phone number of the technical contact at Akamai.
     *     * `address_line_one` - The address for the technical contact at Akamai.
     *     * `address_line_two` - The address for the technical contact at Akamai.
     *     * `city` - The address for the technical contact at Akamai.
     *     * `region` - The region for the technical contact at Akamai.
     *     * `postal_code` - The postal code for the technical contact at Akamai.
     *     * `country_code` - The country code for the technical contact at Akamai.
     *   * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.
     *   * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.
     *   * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.
     *   * `pending_changes` - If `true`, there are changes currently pending in CPS. To view pending changes, use the `data_akamai_cps_enrollment` data source.
     * 
     */
    public static CompletableFuture<GetCPSEnrollmentsResult> getCPSEnrollmentsPlain(GetCPSEnrollmentsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCPSEnrollments:getCPSEnrollments", TypeShape.of(GetCPSEnrollmentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRule() {
        return getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRulePlain() {
        return getCloudletsApiPrioritizationMatchRulePlain(GetCloudletsApiPrioritizationMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs args) {
        return getCloudletsApiPrioritizationMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRulePlain(GetCloudletsApiPrioritizationMatchRulePlainArgs args) {
        return getCloudletsApiPrioritizationMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsApiPrioritizationMatchRule:getCloudletsApiPrioritizationMatchRule", TypeShape.of(GetCloudletsApiPrioritizationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the API Prioritization Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()
     *                 .disabled(false)
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(true)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .passThroughPercent(10)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApiPrioritizationMatchRuleResult> getCloudletsApiPrioritizationMatchRulePlain(GetCloudletsApiPrioritizationMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsApiPrioritizationMatchRule:getCloudletsApiPrioritizationMatchRule", TypeShape.of(GetCloudletsApiPrioritizationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the load balancing configuration details based on the origin ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()
     *             .originId(&#34;alb_test_1&#34;)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `description` - The description of the load balancing configuration.
     * * `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.
     * * `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.
     * * `created_by` - The name of the user who created this load balancing configuration.
     * * `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.
     * * `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.
     * * `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.
     * * `last_modified_by` - The user who last modified the load balancing configuration.
     * * `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.
     * * `warnings` - A list of warnings that occurred during the activation of the load balancing configuration.
     * * `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.
     *   * `city` - The city in which the data center is located.
     *   * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.
     *   * `cloud_service` - Whether this datacenter is a cloud service.
     *   * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
     *   * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
     *   * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
     *   * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.
     *   * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
     *   * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.
     *   * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
     *   * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     *   * `state_or_province` - The state, province, or region where the data center is located.
     * * `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.
     *   * `host_header` - The Host header for the liveness HTTP request.
     *   * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.
     *   * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
     *   * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     *   * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.
     *   * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     *   * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.
     *   * `request_string` - The request used for TCP and TCPS tests.
     *   * `response_string` - The response used for TCP and TCPS tests.
     *   * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
     *   * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
     *   * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
     *   * `timeout` - The number of seconds the system waits before failing the liveness test.
     * 
     */
    public static Output<GetCloudletsApplicationLoadBalancerResult> getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs args) {
        return getCloudletsApplicationLoadBalancer(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the load balancing configuration details based on the origin ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()
     *             .originId(&#34;alb_test_1&#34;)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `description` - The description of the load balancing configuration.
     * * `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.
     * * `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.
     * * `created_by` - The name of the user who created this load balancing configuration.
     * * `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.
     * * `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.
     * * `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.
     * * `last_modified_by` - The user who last modified the load balancing configuration.
     * * `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.
     * * `warnings` - A list of warnings that occurred during the activation of the load balancing configuration.
     * * `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.
     *   * `city` - The city in which the data center is located.
     *   * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.
     *   * `cloud_service` - Whether this datacenter is a cloud service.
     *   * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
     *   * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
     *   * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
     *   * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.
     *   * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
     *   * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.
     *   * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
     *   * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     *   * `state_or_province` - The state, province, or region where the data center is located.
     * * `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.
     *   * `host_header` - The Host header for the liveness HTTP request.
     *   * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.
     *   * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
     *   * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     *   * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.
     *   * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     *   * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.
     *   * `request_string` - The request used for TCP and TCPS tests.
     *   * `response_string` - The response used for TCP and TCPS tests.
     *   * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
     *   * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
     *   * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
     *   * `timeout` - The number of seconds the system waits before failing the liveness test.
     * 
     */
    public static CompletableFuture<GetCloudletsApplicationLoadBalancerResult> getCloudletsApplicationLoadBalancerPlain(GetCloudletsApplicationLoadBalancerPlainArgs args) {
        return getCloudletsApplicationLoadBalancerPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the load balancing configuration details based on the origin ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()
     *             .originId(&#34;alb_test_1&#34;)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `description` - The description of the load balancing configuration.
     * * `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.
     * * `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.
     * * `created_by` - The name of the user who created this load balancing configuration.
     * * `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.
     * * `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.
     * * `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.
     * * `last_modified_by` - The user who last modified the load balancing configuration.
     * * `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.
     * * `warnings` - A list of warnings that occurred during the activation of the load balancing configuration.
     * * `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.
     *   * `city` - The city in which the data center is located.
     *   * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.
     *   * `cloud_service` - Whether this datacenter is a cloud service.
     *   * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
     *   * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
     *   * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
     *   * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.
     *   * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
     *   * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.
     *   * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
     *   * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     *   * `state_or_province` - The state, province, or region where the data center is located.
     * * `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.
     *   * `host_header` - The Host header for the liveness HTTP request.
     *   * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.
     *   * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
     *   * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     *   * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.
     *   * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     *   * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.
     *   * `request_string` - The request used for TCP and TCPS tests.
     *   * `response_string` - The response used for TCP and TCPS tests.
     *   * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
     *   * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
     *   * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
     *   * `timeout` - The number of seconds the system waits before failing the liveness test.
     * 
     */
    public static Output<GetCloudletsApplicationLoadBalancerResult> getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsApplicationLoadBalancer:getCloudletsApplicationLoadBalancer", TypeShape.of(GetCloudletsApplicationLoadBalancerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the load balancing configuration details based on the origin ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()
     *             .originId(&#34;alb_test_1&#34;)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `description` - The description of the load balancing configuration.
     * * `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.
     * * `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.
     * * `created_by` - The name of the user who created this load balancing configuration.
     * * `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.
     * * `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.
     * * `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.
     * * `last_modified_by` - The user who last modified the load balancing configuration.
     * * `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.
     * * `warnings` - A list of warnings that occurred during the activation of the load balancing configuration.
     * * `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.
     *   * `city` - The city in which the data center is located.
     *   * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.
     *   * `cloud_service` - Whether this datacenter is a cloud service.
     *   * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.
     *   * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.
     *   * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.
     *   * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.
     *   * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.
     *   * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.
     *   * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
     *   * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
     *   * `state_or_province` - The state, province, or region where the data center is located.
     * * `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.
     *   * `host_header` - The Host header for the liveness HTTP request.
     *   * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.
     *   * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.
     *   * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
     *   * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.
     *   * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
     *   * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.
     *   * `request_string` - The request used for TCP and TCPS tests.
     *   * `response_string` - The response used for TCP and TCPS tests.
     *   * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.
     *   * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.
     *   * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.
     *   * `timeout` - The number of seconds the system waits before failing the liveness test.
     * 
     */
    public static CompletableFuture<GetCloudletsApplicationLoadBalancerResult> getCloudletsApplicationLoadBalancerPlain(GetCloudletsApplicationLoadBalancerPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsApplicationLoadBalancer:getCloudletsApplicationLoadBalancer", TypeShape.of(GetCloudletsApplicationLoadBalancerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRule() {
        return getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRulePlain() {
        return getCloudletsApplicationLoadBalancerMatchRulePlain(GetCloudletsApplicationLoadBalancerMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs args) {
        return getCloudletsApplicationLoadBalancerMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRulePlain(GetCloudletsApplicationLoadBalancerMatchRulePlainArgs args) {
        return getCloudletsApplicationLoadBalancerMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsApplicationLoadBalancerMatchRule:getCloudletsApplicationLoadBalancerMatchRule", TypeShape.of(GetCloudletsApplicationLoadBalancerMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()
     *                     .originId(&#34;alb_test_1&#34;)
     *                     .build())
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsApplicationLoadBalancerMatchRuleResult> getCloudletsApplicationLoadBalancerMatchRulePlain(GetCloudletsApplicationLoadBalancerMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsApplicationLoadBalancerMatchRule:getCloudletsApplicationLoadBalancerMatchRule", TypeShape.of(GetCloudletsApplicationLoadBalancerMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRule() {
        return getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRulePlain() {
        return getCloudletsAudienceSegmentationMatchRulePlain(GetCloudletsAudienceSegmentationMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs args) {
        return getCloudletsAudienceSegmentationMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRulePlain(GetCloudletsAudienceSegmentationMatchRulePlainArgs args) {
        return getCloudletsAudienceSegmentationMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsAudienceSegmentationMatchRule:getCloudletsAudienceSegmentationMatchRule", TypeShape.of(GetCloudletsAudienceSegmentationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;123&#34;)
     *                     .pathAndQs(&#34;/test&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()
     *                     .matchOperator(&#34;contains&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsAudienceSegmentationMatchRuleResult> getCloudletsAudienceSegmentationMatchRulePlain(GetCloudletsAudienceSegmentationMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsAudienceSegmentationMatchRule:getCloudletsAudienceSegmentationMatchRule", TypeShape.of(GetCloudletsAudienceSegmentationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRule() {
        return getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRulePlain() {
        return getCloudletsEdgeRedirectorMatchRulePlain(GetCloudletsEdgeRedirectorMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs args) {
        return getCloudletsEdgeRedirectorMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRulePlain(GetCloudletsEdgeRedirectorMatchRulePlainArgs args) {
        return getCloudletsEdgeRedirectorMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsEdgeRedirectorMatchRule:getCloudletsEdgeRedirectorMatchRule", TypeShape.of(GetCloudletsEdgeRedirectorMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Edge Redirector Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .matchUrl(&#34;example.com&#34;)
     *                 .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;method&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .redirectUrl(&#34;https://www.example.com&#34;)
     *                 .start(1644865045)
     *                 .statusCode(301)
     *                 .useIncomingQueryString(false)
     *                 .useRelativeUrl(&#34;none&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsEdgeRedirectorMatchRuleResult> getCloudletsEdgeRedirectorMatchRulePlain(GetCloudletsEdgeRedirectorMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsEdgeRedirectorMatchRule:getCloudletsEdgeRedirectorMatchRule", TypeShape.of(GetCloudletsEdgeRedirectorMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRule() {
        return getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRulePlain() {
        return getCloudletsForwardRewriteMatchRulePlain(GetCloudletsForwardRewriteMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs args) {
        return getCloudletsForwardRewriteMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRulePlain(GetCloudletsForwardRewriteMatchRulePlainArgs args) {
        return getCloudletsForwardRewriteMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsForwardRewriteMatchRule:getCloudletsForwardRewriteMatchRule", TypeShape.of(GetCloudletsForwardRewriteMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()
     *                 .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .pathAndQs(&#34;/path&#34;)
     *                     .useIncomingQueryString(true)
     *                     .build())
     *                 .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;clientip&#34;)
     *                     .matchValue(&#34;192.0.2.0&#34;)
     *                     .negate(false)
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsForwardRewriteMatchRuleResult> getCloudletsForwardRewriteMatchRulePlain(GetCloudletsForwardRewriteMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsForwardRewriteMatchRule:getCloudletsForwardRewriteMatchRule", TypeShape.of(GetCloudletsForwardRewriteMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRule() {
        return getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRulePlain() {
        return getCloudletsPhasedReleaseMatchRulePlain(GetCloudletsPhasedReleaseMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs args) {
        return getCloudletsPhasedReleaseMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRulePlain(GetCloudletsPhasedReleaseMatchRulePlainArgs args) {
        return getCloudletsPhasedReleaseMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsPhasedReleaseMatchRule:getCloudletsPhasedReleaseMatchRule", TypeShape.of(GetCloudletsPhasedReleaseMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Phased Release Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()
     *             .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()
     *                 .end(1645037845)
     *                 .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()
     *                     .originId(&#34;1234&#34;)
     *                     .percent(100)
     *                     .build())
     *                 .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()
     *                     .caseSensitive(false)
     *                     .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                     .matchOperator(&#34;equals&#34;)
     *                     .matchType(&#34;header&#34;)
     *                     .negate(false)
     *                     .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                     .build())
     *                 .name(&#34;rule&#34;)
     *                 .start(1644865045)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsPhasedReleaseMatchRuleResult> getCloudletsPhasedReleaseMatchRulePlain(GetCloudletsPhasedReleaseMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsPhasedReleaseMatchRule:getCloudletsPhasedReleaseMatchRule", TypeShape.of(GetCloudletsPhasedReleaseMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the policy details based on the policy ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()
     *             .policyId(1234)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `group_id` - Defines the group association for the policy. You must have edit privileges for the group.
     * * `name` - The unique name of the policy.
     * * `api_version` - The specific version of the Cloudlets API.
     * * `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.
     * * `cloudlet_code` - The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.
     * * `revision_id` - A unique identifier given to every policy version update.
     * * `description` - The description of this specific policy.
     * * `version_description` - The description of this specific policy version.
     * * `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.
     * * `match_rules`- A JSON structure that defines the rules for this policy.
     * * `match_rule_format` - The format of the Cloudlet-specific `match_rules`.
     * * `warnings` - A JSON encoded list of warnings.
     * * `activations` - A list of of current policy activation information, including:
     *   * `api_version` - The specific version of the Cloudlets API.
     *   * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.
     *   * `policy_info` - A list of Cloudlet policy information, including:
     *       * `policy_id` - An integer identifier that is associated with all versions of a policy.
     *       * `name` - The name of the policy.
     *       * `version` - The version number of the policy.
     *       * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.
     *       * `activated_by` - The name of the user who activated the policy.
     *       * `activation_date` - The date on which the policy was activated in milliseconds since epoch.
     *   * `property_info` A list of Cloudlet property information, including:
     *       * `name` - The name of the property.
     *       * `version` - The version number of the activated property.
     *       * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.
     *       * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `activated_by` - The name of the user who activated the property.
     *       * `activation_date` - The date on which the property was activated in milliseconds since epoch.
     * 
     */
    public static Output<GetCloudletsPolicyResult> getCloudletsPolicy(GetCloudletsPolicyArgs args) {
        return getCloudletsPolicy(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the policy details based on the policy ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()
     *             .policyId(1234)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `group_id` - Defines the group association for the policy. You must have edit privileges for the group.
     * * `name` - The unique name of the policy.
     * * `api_version` - The specific version of the Cloudlets API.
     * * `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.
     * * `cloudlet_code` - The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.
     * * `revision_id` - A unique identifier given to every policy version update.
     * * `description` - The description of this specific policy.
     * * `version_description` - The description of this specific policy version.
     * * `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.
     * * `match_rules`- A JSON structure that defines the rules for this policy.
     * * `match_rule_format` - The format of the Cloudlet-specific `match_rules`.
     * * `warnings` - A JSON encoded list of warnings.
     * * `activations` - A list of of current policy activation information, including:
     *   * `api_version` - The specific version of the Cloudlets API.
     *   * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.
     *   * `policy_info` - A list of Cloudlet policy information, including:
     *       * `policy_id` - An integer identifier that is associated with all versions of a policy.
     *       * `name` - The name of the policy.
     *       * `version` - The version number of the policy.
     *       * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.
     *       * `activated_by` - The name of the user who activated the policy.
     *       * `activation_date` - The date on which the policy was activated in milliseconds since epoch.
     *   * `property_info` A list of Cloudlet property information, including:
     *       * `name` - The name of the property.
     *       * `version` - The version number of the activated property.
     *       * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.
     *       * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `activated_by` - The name of the user who activated the property.
     *       * `activation_date` - The date on which the property was activated in milliseconds since epoch.
     * 
     */
    public static CompletableFuture<GetCloudletsPolicyResult> getCloudletsPolicyPlain(GetCloudletsPolicyPlainArgs args) {
        return getCloudletsPolicyPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the policy details based on the policy ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()
     *             .policyId(1234)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `group_id` - Defines the group association for the policy. You must have edit privileges for the group.
     * * `name` - The unique name of the policy.
     * * `api_version` - The specific version of the Cloudlets API.
     * * `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.
     * * `cloudlet_code` - The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.
     * * `revision_id` - A unique identifier given to every policy version update.
     * * `description` - The description of this specific policy.
     * * `version_description` - The description of this specific policy version.
     * * `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.
     * * `match_rules`- A JSON structure that defines the rules for this policy.
     * * `match_rule_format` - The format of the Cloudlet-specific `match_rules`.
     * * `warnings` - A JSON encoded list of warnings.
     * * `activations` - A list of of current policy activation information, including:
     *   * `api_version` - The specific version of the Cloudlets API.
     *   * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.
     *   * `policy_info` - A list of Cloudlet policy information, including:
     *       * `policy_id` - An integer identifier that is associated with all versions of a policy.
     *       * `name` - The name of the policy.
     *       * `version` - The version number of the policy.
     *       * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.
     *       * `activated_by` - The name of the user who activated the policy.
     *       * `activation_date` - The date on which the policy was activated in milliseconds since epoch.
     *   * `property_info` A list of Cloudlet property information, including:
     *       * `name` - The name of the property.
     *       * `version` - The version number of the activated property.
     *       * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.
     *       * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `activated_by` - The name of the user who activated the property.
     *       * `activation_date` - The date on which the property was activated in milliseconds since epoch.
     * 
     */
    public static Output<GetCloudletsPolicyResult> getCloudletsPolicy(GetCloudletsPolicyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsPolicy:getCloudletsPolicy", TypeShape.of(GetCloudletsPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.
     * 
     * ## Basic usage
     * 
     * This example returns the policy details based on the policy ID and optionally, a version:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()
     *             .policyId(1234)
     *             .version(1)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `group_id` - Defines the group association for the policy. You must have edit privileges for the group.
     * * `name` - The unique name of the policy.
     * * `api_version` - The specific version of the Cloudlets API.
     * * `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.
     * * `cloudlet_code` - The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.
     * * `revision_id` - A unique identifier given to every policy version update.
     * * `description` - The description of this specific policy.
     * * `version_description` - The description of this specific policy version.
     * * `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.
     * * `match_rules`- A JSON structure that defines the rules for this policy.
     * * `match_rule_format` - The format of the Cloudlet-specific `match_rules`.
     * * `warnings` - A JSON encoded list of warnings.
     * * `activations` - A list of of current policy activation information, including:
     *   * `api_version` - The specific version of the Cloudlets API.
     *   * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.
     *   * `policy_info` - A list of Cloudlet policy information, including:
     *       * `policy_id` - An integer identifier that is associated with all versions of a policy.
     *       * `name` - The name of the policy.
     *       * `version` - The version number of the policy.
     *       * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.
     *       * `activated_by` - The name of the user who activated the policy.
     *       * `activation_date` - The date on which the policy was activated in milliseconds since epoch.
     *   * `property_info` A list of Cloudlet property information, including:
     *       * `name` - The name of the property.
     *       * `version` - The version number of the activated property.
     *       * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.
     *       * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.
     *       * `activated_by` - The name of the user who activated the property.
     *       * `activation_date` - The date on which the property was activated in milliseconds since epoch.
     * 
     */
    public static CompletableFuture<GetCloudletsPolicyResult> getCloudletsPolicyPlain(GetCloudletsPolicyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsPolicy:getCloudletsPolicy", TypeShape.of(GetCloudletsPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRule() {
        return getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRulePlain() {
        return getCloudletsRequestControlMatchRulePlain(GetCloudletsRequestControlMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs args) {
        return getCloudletsRequestControlMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRulePlain(GetCloudletsRequestControlMatchRulePlainArgs args) {
        return getCloudletsRequestControlMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsRequestControlMatchRule:getCloudletsRequestControlMatchRule", TypeShape.of(GetCloudletsRequestControlMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Request Control Cloudlet:
     * 
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()
     *             .matchRules(            
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;allow&#34;)
     *                     .disabled(false)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;CONNECTING_IP XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;method&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 1&#34;)
     *                     .start(1)
     *                     .build(),
     *                 GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()
     *                     .allowDeny(&#34;deny&#34;)
     *                     .disabled(true)
     *                     .end(2)
     *                     .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()
     *                         .caseSensitive(false)
     *                         .checkIps(&#34;XFF_HEADERS&#34;)
     *                         .matchOperator(&#34;contains&#34;)
     *                         .matchType(&#34;header&#34;)
     *                         .negate(false)
     *                         .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
     *                         .build())
     *                     .name(&#34;rule 2&#34;)
     *                     .start(1)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsRequestControlMatchRuleResult> getCloudletsRequestControlMatchRulePlain(GetCloudletsRequestControlMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsRequestControlMatchRule:getCloudletsRequestControlMatchRule", TypeShape.of(GetCloudletsRequestControlMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRule() {
        return getCloudletsVisitorPrioritizationMatchRule(GetCloudletsVisitorPrioritizationMatchRuleArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRulePlain() {
        return getCloudletsVisitorPrioritizationMatchRulePlain(GetCloudletsVisitorPrioritizationMatchRulePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRule(GetCloudletsVisitorPrioritizationMatchRuleArgs args) {
        return getCloudletsVisitorPrioritizationMatchRule(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRulePlain(GetCloudletsVisitorPrioritizationMatchRulePlainArgs args) {
        return getCloudletsVisitorPrioritizationMatchRulePlain(args, InvokeOptions.Empty);
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static Output<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRule(GetCloudletsVisitorPrioritizationMatchRuleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCloudletsVisitorPrioritizationMatchRule:getCloudletsVisitorPrioritizationMatchRule", TypeShape.of(GetCloudletsVisitorPrioritizationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
     * 
     * Use the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.
     * 
     * ## Basic usage
     * 
     * This example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `type` - The type of Cloudlet the rule is for.
     * * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
     * 
     */
    public static CompletableFuture<GetCloudletsVisitorPrioritizationMatchRuleResult> getCloudletsVisitorPrioritizationMatchRulePlain(GetCloudletsVisitorPrioritizationMatchRulePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCloudletsVisitorPrioritizationMatchRule:getCloudletsVisitorPrioritizationMatchRule", TypeShape.of(GetCloudletsVisitorPrioritizationMatchRuleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static Output<GetContractResult> getContract() {
        return getContract(GetContractArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static CompletableFuture<GetContractResult> getContractPlain() {
        return getContractPlain(GetContractPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static Output<GetContractResult> getContract(GetContractArgs args) {
        return getContract(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static CompletableFuture<GetContractResult> getContractPlain(GetContractPlainArgs args) {
        return getContractPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static Output<GetContractResult> getContract(GetContractArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getContract:getContract", TypeShape.of(GetContractResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getContract` data source to find a contract ID.
     * 
     * ## Attributes reference
     * 
     * * `id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     * 
     */
    public static CompletableFuture<GetContractResult> getContractPlain(GetContractPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getContract:getContract", TypeShape.of(GetContractResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static Output<GetContractsResult> getContracts() {
        return getContracts(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static CompletableFuture<GetContractsResult> getContractsPlain() {
        return getContractsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static Output<GetContractsResult> getContracts(InvokeArgs args) {
        return getContracts(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static CompletableFuture<GetContractsResult> getContractsPlain(InvokeArgs args) {
        return getContractsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static Output<GetContractsResult> getContracts(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getContracts:getContracts", TypeShape.of(GetContractsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return contracts associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getContracts();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `contracts` - A list of supported contracts, with the following properties:
     *   * `contract_id` - The contract&#39;s unique ID, including the `ctr_` prefix.
     *   * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
     * 
     */
    public static CompletableFuture<GetContractsResult> getContractsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getContracts:getContracts", TypeShape.of(GetContractsResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetCpCodeResult> getCpCode(GetCpCodeArgs args) {
        return getCpCode(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetCpCodeResult> getCpCodePlain(GetCpCodePlainArgs args) {
        return getCpCodePlain(args, InvokeOptions.Empty);
    }
    public static Output<GetCpCodeResult> getCpCode(GetCpCodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCpCode:getCpCode", TypeShape.of(GetCpCodeResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetCpCodeResult> getCpCodePlain(GetCpCodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCpCode:getCpCode", TypeShape.of(GetCpCodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * When setting up a third-party enrollment, use the `akamai.getCpsCsr` data source to retrieve the Certificate Signing Request (CSR) for that enrollment. When you create an enrollment in CPS, you also generate a PEM-formatted CSR. CPS encodes the CSR with a private key using either the RSA or the ECDSA algorithm. The CSR contains all the information the certificate authority (CA) needs to issue your certificate.
     * 
     * If you&#39;re using dual-stacked certificates, you&#39;ll see data for both ECDSA and RSA keys.
     * 
     * ## Basic usage
     * 
     * This example shows how to return CSR information for enrollment ID 12345:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsCsrArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsCsr(GetCpsCsrArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `csr_rsa` - Returns CSR information for a certificate that uses the RSA algorithm.
     *   * `csr_ecdsa` - Returns CSR information for a certificate that uses the ECDSA algorithm.
     * 
     */
    public static Output<GetCpsCsrResult> getCpsCsr(GetCpsCsrArgs args) {
        return getCpsCsr(args, InvokeOptions.Empty);
    }
    /**
     * When setting up a third-party enrollment, use the `akamai.getCpsCsr` data source to retrieve the Certificate Signing Request (CSR) for that enrollment. When you create an enrollment in CPS, you also generate a PEM-formatted CSR. CPS encodes the CSR with a private key using either the RSA or the ECDSA algorithm. The CSR contains all the information the certificate authority (CA) needs to issue your certificate.
     * 
     * If you&#39;re using dual-stacked certificates, you&#39;ll see data for both ECDSA and RSA keys.
     * 
     * ## Basic usage
     * 
     * This example shows how to return CSR information for enrollment ID 12345:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsCsrArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsCsr(GetCpsCsrArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `csr_rsa` - Returns CSR information for a certificate that uses the RSA algorithm.
     *   * `csr_ecdsa` - Returns CSR information for a certificate that uses the ECDSA algorithm.
     * 
     */
    public static CompletableFuture<GetCpsCsrResult> getCpsCsrPlain(GetCpsCsrPlainArgs args) {
        return getCpsCsrPlain(args, InvokeOptions.Empty);
    }
    /**
     * When setting up a third-party enrollment, use the `akamai.getCpsCsr` data source to retrieve the Certificate Signing Request (CSR) for that enrollment. When you create an enrollment in CPS, you also generate a PEM-formatted CSR. CPS encodes the CSR with a private key using either the RSA or the ECDSA algorithm. The CSR contains all the information the certificate authority (CA) needs to issue your certificate.
     * 
     * If you&#39;re using dual-stacked certificates, you&#39;ll see data for both ECDSA and RSA keys.
     * 
     * ## Basic usage
     * 
     * This example shows how to return CSR information for enrollment ID 12345:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsCsrArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsCsr(GetCpsCsrArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `csr_rsa` - Returns CSR information for a certificate that uses the RSA algorithm.
     *   * `csr_ecdsa` - Returns CSR information for a certificate that uses the ECDSA algorithm.
     * 
     */
    public static Output<GetCpsCsrResult> getCpsCsr(GetCpsCsrArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCpsCsr:getCpsCsr", TypeShape.of(GetCpsCsrResult.class), args, Utilities.withVersion(options));
    }
    /**
     * When setting up a third-party enrollment, use the `akamai.getCpsCsr` data source to retrieve the Certificate Signing Request (CSR) for that enrollment. When you create an enrollment in CPS, you also generate a PEM-formatted CSR. CPS encodes the CSR with a private key using either the RSA or the ECDSA algorithm. The CSR contains all the information the certificate authority (CA) needs to issue your certificate.
     * 
     * If you&#39;re using dual-stacked certificates, you&#39;ll see data for both ECDSA and RSA keys.
     * 
     * ## Basic usage
     * 
     * This example shows how to return CSR information for enrollment ID 12345:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsCsrArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsCsr(GetCpsCsrArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     *   * `csr_rsa` - Returns CSR information for a certificate that uses the RSA algorithm.
     *   * `csr_ecdsa` - Returns CSR information for a certificate that uses the ECDSA algorithm.
     * 
     */
    public static CompletableFuture<GetCpsCsrResult> getCpsCsrPlain(GetCpsCsrPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCpsCsr:getCpsCsr", TypeShape.of(GetCpsCsrResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCpsDeployments` data source to retrieve deployed certificates for a specific enrollment.
     * 
     * You&#39;ll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
     * 
     * ## Basic usage
     * 
     * This example shows how to return information about deployed certificates for enrollment ID 12345.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsDeployments(GetCpsDeploymentsArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `production_certificate_rsa` - The RSA certificate deployed on the production network.
     * * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
     * * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
     * * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
     * * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
     * * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. &lt;br&gt; For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. &lt;br&gt; For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the `akamai.getCPSEnrollments` data source to view pending changes.
     * 
     */
    public static Output<GetCpsDeploymentsResult> getCpsDeployments(GetCpsDeploymentsArgs args) {
        return getCpsDeployments(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsDeployments` data source to retrieve deployed certificates for a specific enrollment.
     * 
     * You&#39;ll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
     * 
     * ## Basic usage
     * 
     * This example shows how to return information about deployed certificates for enrollment ID 12345.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsDeployments(GetCpsDeploymentsArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `production_certificate_rsa` - The RSA certificate deployed on the production network.
     * * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
     * * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
     * * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
     * * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
     * * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. &lt;br&gt; For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. &lt;br&gt; For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the `akamai.getCPSEnrollments` data source to view pending changes.
     * 
     */
    public static CompletableFuture<GetCpsDeploymentsResult> getCpsDeploymentsPlain(GetCpsDeploymentsPlainArgs args) {
        return getCpsDeploymentsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsDeployments` data source to retrieve deployed certificates for a specific enrollment.
     * 
     * You&#39;ll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
     * 
     * ## Basic usage
     * 
     * This example shows how to return information about deployed certificates for enrollment ID 12345.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsDeployments(GetCpsDeploymentsArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `production_certificate_rsa` - The RSA certificate deployed on the production network.
     * * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
     * * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
     * * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
     * * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
     * * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. &lt;br&gt; For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. &lt;br&gt; For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the `akamai.getCPSEnrollments` data source to view pending changes.
     * 
     */
    public static Output<GetCpsDeploymentsResult> getCpsDeployments(GetCpsDeploymentsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCpsDeployments:getCpsDeployments", TypeShape.of(GetCpsDeploymentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCpsDeployments` data source to retrieve deployed certificates for a specific enrollment.
     * 
     * You&#39;ll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
     * 
     * ## Basic usage
     * 
     * This example shows how to return information about deployed certificates for enrollment ID 12345.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsDeployments(GetCpsDeploymentsArgs.builder()
     *             .enrollmentId(12345)
     *             .build());
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `production_certificate_rsa` - The RSA certificate deployed on the production network.
     * * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
     * * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
     * * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
     * * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
     * * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. &lt;br&gt; For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. &lt;br&gt; For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the `akamai.getCPSEnrollments` data source to view pending changes.
     * 
     */
    public static CompletableFuture<GetCpsDeploymentsResult> getCpsDeploymentsPlain(GetCpsDeploymentsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCpsDeployments:getCpsDeployments", TypeShape.of(GetCpsDeploymentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static Output<GetCpsWarningsResult> getCpsWarnings() {
        return getCpsWarnings(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static CompletableFuture<GetCpsWarningsResult> getCpsWarningsPlain() {
        return getCpsWarningsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static Output<GetCpsWarningsResult> getCpsWarnings(InvokeArgs args) {
        return getCpsWarnings(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static CompletableFuture<GetCpsWarningsResult> getCpsWarningsPlain(InvokeArgs args) {
        return getCpsWarningsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static Output<GetCpsWarningsResult> getCpsWarnings(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getCpsWarnings:getCpsWarnings", TypeShape.of(GetCpsWarningsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue.
     * 
     * CPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won&#39;t process a change until you acknowledge all warnings.
     * 
     * You can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.
     * 
     * ## Basic usage
     * 
     * This example shows how to return a map of verification warnings:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getCpsWarnings();
     * 
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     *   * `warnings` - Validation warnings for the current change you&#39;re making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won&#39;t process the change until you acknowledge these warnings.
     * 
     */
    public static CompletableFuture<GetCpsWarningsResult> getCpsWarningsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getCpsWarnings:getCpsWarnings", TypeShape.of(GetCpsWarningsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.
     * 
     * ## Example Usage
     * 
     * This example returns the activation history for a provided stream ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()
     *             .streamId(12345)
     *             .build());
     * 
     *         ctx.export(&#34;dsHistoryStreamId&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.streamId()));
     *         ctx.export(&#34;dsHistoryActivations&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.activations()));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activations` - Detailed information about an activation status change for a version of a stream, including:
     *   * `created_by` - The user who activated or deactivated the stream.
     *   * `created_date` - The date and time of an activation status change.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     *   * `is_active` -	Whether the version of the stream is active.
     * 
     */
    public static Output<GetDatastreamActivationHistoryResult> getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs args) {
        return getDatastreamActivationHistory(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.
     * 
     * ## Example Usage
     * 
     * This example returns the activation history for a provided stream ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()
     *             .streamId(12345)
     *             .build());
     * 
     *         ctx.export(&#34;dsHistoryStreamId&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.streamId()));
     *         ctx.export(&#34;dsHistoryActivations&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.activations()));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activations` - Detailed information about an activation status change for a version of a stream, including:
     *   * `created_by` - The user who activated or deactivated the stream.
     *   * `created_date` - The date and time of an activation status change.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     *   * `is_active` -	Whether the version of the stream is active.
     * 
     */
    public static CompletableFuture<GetDatastreamActivationHistoryResult> getDatastreamActivationHistoryPlain(GetDatastreamActivationHistoryPlainArgs args) {
        return getDatastreamActivationHistoryPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.
     * 
     * ## Example Usage
     * 
     * This example returns the activation history for a provided stream ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()
     *             .streamId(12345)
     *             .build());
     * 
     *         ctx.export(&#34;dsHistoryStreamId&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.streamId()));
     *         ctx.export(&#34;dsHistoryActivations&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.activations()));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activations` - Detailed information about an activation status change for a version of a stream, including:
     *   * `created_by` - The user who activated or deactivated the stream.
     *   * `created_date` - The date and time of an activation status change.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     *   * `is_active` -	Whether the version of the stream is active.
     * 
     */
    public static Output<GetDatastreamActivationHistoryResult> getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getDatastreamActivationHistory:getDatastreamActivationHistory", TypeShape.of(GetDatastreamActivationHistoryResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.
     * 
     * ## Example Usage
     * 
     * This example returns the activation history for a provided stream ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()
     *             .streamId(12345)
     *             .build());
     * 
     *         ctx.export(&#34;dsHistoryStreamId&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.streamId()));
     *         ctx.export(&#34;dsHistoryActivations&#34;, ds.applyValue(getDatastreamActivationHistoryResult -&gt; getDatastreamActivationHistoryResult.activations()));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activations` - Detailed information about an activation status change for a version of a stream, including:
     *   * `created_by` - The user who activated or deactivated the stream.
     *   * `created_date` - The date and time of an activation status change.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     *   * `is_active` -	Whether the version of the stream is active.
     * 
     */
    public static CompletableFuture<GetDatastreamActivationHistoryResult> getDatastreamActivationHistoryPlain(GetDatastreamActivationHistoryPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getDatastreamActivationHistory:getDatastreamActivationHistory", TypeShape.of(GetDatastreamActivationHistoryResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static Output<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFields() {
        return getDatastreamDatasetFields(GetDatastreamDatasetFieldsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static CompletableFuture<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFieldsPlain() {
        return getDatastreamDatasetFieldsPlain(GetDatastreamDatasetFieldsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static Output<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFields(GetDatastreamDatasetFieldsArgs args) {
        return getDatastreamDatasetFields(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static CompletableFuture<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFieldsPlain(GetDatastreamDatasetFieldsPlainArgs args) {
        return getDatastreamDatasetFieldsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static Output<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFields(GetDatastreamDatasetFieldsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getDatastreamDatasetFields:getDatastreamDatasetFields", TypeShape.of(GetDatastreamDatasetFieldsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.
     * 
     * ## Example Usage
     * 
     * This example returns data set fields for a default template:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fields = AkamaiFunctions.getDatastreamDatasetFields();
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `fields` - A group of data set fields available in a template, including:
     *   * `dataset_group_name` - The name of the data set group.
     *   * `dataset_group_description` - Additional information about the data set group.
     *   * `dataset_fields` - A list of data set fields available within the data set group, including:
     *       * `dataset_field_description` - Additional information about the data set field.
     *       * `dataset_field_id` - Unique identifier for the field.
     *       * `dataset_field_json_key` - The JSON key for the field in a log line.
     *       * `dataset_field_name` - The name of the data set field.
     * 
     */
    public static CompletableFuture<GetDatastreamDatasetFieldsResult> getDatastreamDatasetFieldsPlain(GetDatastreamDatasetFieldsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getDatastreamDatasetFields:getDatastreamDatasetFields", TypeShape.of(GetDatastreamDatasetFieldsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static Output<GetDatastreamsResult> getDatastreams() {
        return getDatastreams(GetDatastreamsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static CompletableFuture<GetDatastreamsResult> getDatastreamsPlain() {
        return getDatastreamsPlain(GetDatastreamsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static Output<GetDatastreamsResult> getDatastreams(GetDatastreamsArgs args) {
        return getDatastreams(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static CompletableFuture<GetDatastreamsResult> getDatastreamsPlain(GetDatastreamsPlainArgs args) {
        return getDatastreamsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static Output<GetDatastreamsResult> getDatastreams(GetDatastreamsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getDatastreams:getDatastreams", TypeShape.of(GetDatastreamsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group.
     *   * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.
     *   * `archived` - Whether the stream is archived.
     *   * `connectors` - The connector where the stream sends logs.
     *   * `contract_id` - Identifies the contract that the stream is associated with.
     *   * `created_by` - The user who created the stream.
     *   * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.
     *   * `current_version_id` - Identifies the current version of the stream.
     *   * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).
     *     * `detail` - A message informing about the status of the failed stream.
     *     * `title` - A descriptive label for the type of error.
     *     * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing.
     *   * `group_id` - Identifies the group where the stream is created.
     *   * `group_name` - The group name where the stream is created.
     *   * `properties` - List of properties associated with the stream.
     *     * `property_id` - The identifier of the property.
     *     * `property_name` - The descriptive label for the property.
     *   * `stream_id` - A stream&#39;s unique identifier.
     *   * `stream_name` - The name of the stream.
     *   * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available.
     *   * `stream_version_id` - A stream version&#39;s unique identifier.
     * 
     */
    public static CompletableFuture<GetDatastreamsResult> getDatastreamsPlain(GetDatastreamsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getDatastreams:getDatastreams", TypeShape.of(GetDatastreamsResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetDnsRecordSetResult> getDnsRecordSet(GetDnsRecordSetArgs args) {
        return getDnsRecordSet(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetDnsRecordSetResult> getDnsRecordSetPlain(GetDnsRecordSetPlainArgs args) {
        return getDnsRecordSetPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetDnsRecordSetResult> getDnsRecordSet(GetDnsRecordSetArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getDnsRecordSet:getDnsRecordSet", TypeShape.of(GetDnsRecordSetResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetDnsRecordSetResult> getDnsRecordSetPlain(GetDnsRecordSetPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getDnsRecordSet:getDnsRecordSet", TypeShape.of(GetDnsRecordSetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.EdgeWorker` data source to get an EdgeWorker for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for the selected EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorker(GetEdgeWorkerArgs.builder()
     *             .edgeworkerId(3)
     *             .localBundle(&#34;test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The EdgeWorker name.
     * * `group_id` - Defines the group association for the EdgeWorker.
     * * `resource_tier_id` - The unique identifier of a resource tier.
     * * `local_bundle_hash` - The local bundle hash for the EdgeWorker. It&#39;s used to identify content changes for the bundle.
     * * `version` - The bundle version.
     * * `warnings` - The list of warnings returned by EdgeWorker validation.
     * 
     */
    public static Output<GetEdgeWorkerResult> getEdgeWorker(GetEdgeWorkerArgs args) {
        return getEdgeWorker(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.EdgeWorker` data source to get an EdgeWorker for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for the selected EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorker(GetEdgeWorkerArgs.builder()
     *             .edgeworkerId(3)
     *             .localBundle(&#34;test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The EdgeWorker name.
     * * `group_id` - Defines the group association for the EdgeWorker.
     * * `resource_tier_id` - The unique identifier of a resource tier.
     * * `local_bundle_hash` - The local bundle hash for the EdgeWorker. It&#39;s used to identify content changes for the bundle.
     * * `version` - The bundle version.
     * * `warnings` - The list of warnings returned by EdgeWorker validation.
     * 
     */
    public static CompletableFuture<GetEdgeWorkerResult> getEdgeWorkerPlain(GetEdgeWorkerPlainArgs args) {
        return getEdgeWorkerPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.EdgeWorker` data source to get an EdgeWorker for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for the selected EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorker(GetEdgeWorkerArgs.builder()
     *             .edgeworkerId(3)
     *             .localBundle(&#34;test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The EdgeWorker name.
     * * `group_id` - Defines the group association for the EdgeWorker.
     * * `resource_tier_id` - The unique identifier of a resource tier.
     * * `local_bundle_hash` - The local bundle hash for the EdgeWorker. It&#39;s used to identify content changes for the bundle.
     * * `version` - The bundle version.
     * * `warnings` - The list of warnings returned by EdgeWorker validation.
     * 
     */
    public static Output<GetEdgeWorkerResult> getEdgeWorker(GetEdgeWorkerArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getEdgeWorker:getEdgeWorker", TypeShape.of(GetEdgeWorkerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.EdgeWorker` data source to get an EdgeWorker for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for the selected EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorker(GetEdgeWorkerArgs.builder()
     *             .edgeworkerId(3)
     *             .localBundle(&#34;test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The EdgeWorker name.
     * * `group_id` - Defines the group association for the EdgeWorker.
     * * `resource_tier_id` - The unique identifier of a resource tier.
     * * `local_bundle_hash` - The local bundle hash for the EdgeWorker. It&#39;s used to identify content changes for the bundle.
     * * `version` - The bundle version.
     * * `warnings` - The list of warnings returned by EdgeWorker validation.
     * 
     */
    public static CompletableFuture<GetEdgeWorkerResult> getEdgeWorkerPlain(GetEdgeWorkerPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getEdgeWorker:getEdgeWorker", TypeShape.of(GetEdgeWorkerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getEdgeWorkerActivation` data source to fetch the latest activation for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the latest activation on the staging network:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorkerActivation(GetEdgeWorkerActivationArgs.builder()
     *             .edgeworkerId(1)
     *             .network(&#34;STAGING&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activation_id` - The unique identifier of the activation.
     * * `version` - The EdgeWorker version of the latest activation.
     * 
     */
    public static Output<GetEdgeWorkerActivationResult> getEdgeWorkerActivation(GetEdgeWorkerActivationArgs args) {
        return getEdgeWorkerActivation(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getEdgeWorkerActivation` data source to fetch the latest activation for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the latest activation on the staging network:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorkerActivation(GetEdgeWorkerActivationArgs.builder()
     *             .edgeworkerId(1)
     *             .network(&#34;STAGING&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activation_id` - The unique identifier of the activation.
     * * `version` - The EdgeWorker version of the latest activation.
     * 
     */
    public static CompletableFuture<GetEdgeWorkerActivationResult> getEdgeWorkerActivationPlain(GetEdgeWorkerActivationPlainArgs args) {
        return getEdgeWorkerActivationPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getEdgeWorkerActivation` data source to fetch the latest activation for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the latest activation on the staging network:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorkerActivation(GetEdgeWorkerActivationArgs.builder()
     *             .edgeworkerId(1)
     *             .network(&#34;STAGING&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activation_id` - The unique identifier of the activation.
     * * `version` - The EdgeWorker version of the latest activation.
     * 
     */
    public static Output<GetEdgeWorkerActivationResult> getEdgeWorkerActivation(GetEdgeWorkerActivationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getEdgeWorkerActivation:getEdgeWorkerActivation", TypeShape.of(GetEdgeWorkerActivationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getEdgeWorkerActivation` data source to fetch the latest activation for a given EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the latest activation on the staging network:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = AkamaiFunctions.getEdgeWorkerActivation(GetEdgeWorkerActivationArgs.builder()
     *             .edgeworkerId(1)
     *             .network(&#34;STAGING&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `activation_id` - The unique identifier of the activation.
     * * `version` - The EdgeWorker version of the latest activation.
     * 
     */
    public static CompletableFuture<GetEdgeWorkerActivationResult> getEdgeWorkerActivationPlain(GetEdgeWorkerActivationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getEdgeWorkerActivation:getEdgeWorkerActivation", TypeShape.of(GetEdgeWorkerActivationResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetEdgeWorkersPropertyRulesResult> getEdgeWorkersPropertyRules(GetEdgeWorkersPropertyRulesArgs args) {
        return getEdgeWorkersPropertyRules(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetEdgeWorkersPropertyRulesResult> getEdgeWorkersPropertyRulesPlain(GetEdgeWorkersPropertyRulesPlainArgs args) {
        return getEdgeWorkersPropertyRulesPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetEdgeWorkersPropertyRulesResult> getEdgeWorkersPropertyRules(GetEdgeWorkersPropertyRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getEdgeWorkersPropertyRules:getEdgeWorkersPropertyRules", TypeShape.of(GetEdgeWorkersPropertyRulesResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetEdgeWorkersPropertyRulesResult> getEdgeWorkersPropertyRulesPlain(GetEdgeWorkersPropertyRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getEdgeWorkersPropertyRules:getEdgeWorkersPropertyRules", TypeShape.of(GetEdgeWorkersPropertyRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for an EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()
     *             .contractId(&#34;1-ABC&#34;)
     *             .resourceTierName(&#34;Basic Compute&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `resource_tier_id` - Unique identifier of the resource tier.
     * 
     */
    public static Output<GetEdgeWorkersResourceTierResult> getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs args) {
        return getEdgeWorkersResourceTier(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for an EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()
     *             .contractId(&#34;1-ABC&#34;)
     *             .resourceTierName(&#34;Basic Compute&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `resource_tier_id` - Unique identifier of the resource tier.
     * 
     */
    public static CompletableFuture<GetEdgeWorkersResourceTierResult> getEdgeWorkersResourceTierPlain(GetEdgeWorkersResourceTierPlainArgs args) {
        return getEdgeWorkersResourceTierPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for an EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()
     *             .contractId(&#34;1-ABC&#34;)
     *             .resourceTierName(&#34;Basic Compute&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `resource_tier_id` - Unique identifier of the resource tier.
     * 
     */
    public static Output<GetEdgeWorkersResourceTierResult> getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getEdgeWorkersResourceTier:getEdgeWorkersResourceTier", TypeShape.of(GetEdgeWorkersResourceTierResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.
     * 
     * ## Example Usage
     * 
     * This example returns the resource tier fields for an EdgeWorker ID:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()
     *             .contractId(&#34;1-ABC&#34;)
     *             .resourceTierName(&#34;Basic Compute&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `resource_tier_id` - Unique identifier of the resource tier.
     * 
     */
    public static CompletableFuture<GetEdgeWorkersResourceTierResult> getEdgeWorkersResourceTierPlain(GetEdgeWorkersResourceTierPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getEdgeWorkersResourceTier:getEdgeWorkersResourceTier", TypeShape.of(GetEdgeWorkersResourceTierResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static Output<GetGroupResult> getGroup() {
        return getGroup(GetGroupArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain() {
        return getGroupPlain(GetGroupPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args) {
        return getGroup(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args) {
        return getGroupPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGroup` data source to get a group by name.
     * 
     * Each account features a hierarchy of groups, which control access to your
     * Akamai configurations and help consolidate reporting functions, typically
     * mapping to an organizational hierarchy. Using either Control Center or the
     * [Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),
     * account administrators can assign properties to specific groups, each with
     * its own set of users and accompanying roles.
     * 
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `id` - The group&#39;s unique ID, including the `grp_` prefix.
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static Output<GetGroupsResult> getGroups() {
        return getGroups(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static CompletableFuture<GetGroupsResult> getGroupsPlain() {
        return getGroupsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static Output<GetGroupsResult> getGroups(InvokeArgs args) {
        return getGroups(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static CompletableFuture<GetGroupsResult> getGroupsPlain(InvokeArgs args) {
        return getGroupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static Output<GetGroupsResult> getGroups(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getGroups:getGroups", TypeShape.of(GetGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Basic usage
     * 
     * Return groups associated with the EdgeGrid API client token you&#39;re using:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getGroups();
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `groups` - A list of supported groups, with the following attributes:
     *   * `group_id` - A group&#39;s unique ID, including the `grp_` prefix.
     *   * `group_name` - The name of the group.
     *   * `parent_group_id` - The ID of the parent group, if applicable.
     *   * `contract_ids` - An array of strings listing the contract IDs for each group.
     * 
     */
    public static CompletableFuture<GetGroupsResult> getGroupsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getGroups:getGroups", TypeShape.of(GetGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.
     * 
     * ## Attributes reference
     * 
     * This data source supports these attributes:
     * 
     * * `id` - The data resource ID. Enter in this format: `&lt;domain&gt;:default_datacenter:&lt;datacenter_id&gt;`.
     * * `datacenter_id` - The default data center ID.
     * * `nickname` - The default data center nickname.
     * 
     */
    public static Output<GetGtmDefaultDatacenterResult> getGtmDefaultDatacenter(GetGtmDefaultDatacenterArgs args) {
        return getGtmDefaultDatacenter(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.
     * 
     * ## Attributes reference
     * 
     * This data source supports these attributes:
     * 
     * * `id` - The data resource ID. Enter in this format: `&lt;domain&gt;:default_datacenter:&lt;datacenter_id&gt;`.
     * * `datacenter_id` - The default data center ID.
     * * `nickname` - The default data center nickname.
     * 
     */
    public static CompletableFuture<GetGtmDefaultDatacenterResult> getGtmDefaultDatacenterPlain(GetGtmDefaultDatacenterPlainArgs args) {
        return getGtmDefaultDatacenterPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.
     * 
     * ## Attributes reference
     * 
     * This data source supports these attributes:
     * 
     * * `id` - The data resource ID. Enter in this format: `&lt;domain&gt;:default_datacenter:&lt;datacenter_id&gt;`.
     * * `datacenter_id` - The default data center ID.
     * * `nickname` - The default data center nickname.
     * 
     */
    public static Output<GetGtmDefaultDatacenterResult> getGtmDefaultDatacenter(GetGtmDefaultDatacenterArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter", TypeShape.of(GetGtmDefaultDatacenterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.
     * 
     * ## Attributes reference
     * 
     * This data source supports these attributes:
     * 
     * * `id` - The data resource ID. Enter in this format: `&lt;domain&gt;:default_datacenter:&lt;datacenter_id&gt;`.
     * * `datacenter_id` - The default data center ID.
     * * `nickname` - The default data center nickname.
     * 
     */
    public static CompletableFuture<GetGtmDefaultDatacenterResult> getGtmDefaultDatacenterPlain(GetGtmDefaultDatacenterPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter", TypeShape.of(GetGtmDefaultDatacenterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static Output<GetIamContactTypesResult> getIamContactTypes() {
        return getIamContactTypes(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static CompletableFuture<GetIamContactTypesResult> getIamContactTypesPlain() {
        return getIamContactTypesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static Output<GetIamContactTypesResult> getIamContactTypes(InvokeArgs args) {
        return getIamContactTypes(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static CompletableFuture<GetIamContactTypesResult> getIamContactTypesPlain(InvokeArgs args) {
        return getIamContactTypesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static Output<GetIamContactTypesResult> getIamContactTypes(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamContactTypes:getIamContactTypes", TypeShape.of(GetIamContactTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user&#39;s contact type.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var contactTypes = AkamaiFunctions.getIamContactTypes();
     * 
     *         ctx.export(&#34;supportedContactTypes&#34;, contactTypes.applyValue(getIamContactTypesResult -&gt; getIamContactTypesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `contact_types` — A list of contact types.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
     * 
     */
    public static CompletableFuture<GetIamContactTypesResult> getIamContactTypesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamContactTypes:getIamContactTypes", TypeShape.of(GetIamContactTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static Output<GetIamCountriesResult> getIamCountries() {
        return getIamCountries(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static CompletableFuture<GetIamCountriesResult> getIamCountriesPlain() {
        return getIamCountriesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static Output<GetIamCountriesResult> getIamCountries(InvokeArgs args) {
        return getIamCountries(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static CompletableFuture<GetIamCountriesResult> getIamCountriesPlain(InvokeArgs args) {
        return getIamCountriesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static Output<GetIamCountriesResult> getIamCountries(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamCountries:getIamCountries", TypeShape.of(GetIamCountriesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user&#39;s country information.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var countries = AkamaiFunctions.getIamCountries();
     * 
     *         ctx.export(&#34;supportedCountries&#34;, countries.applyValue(getIamCountriesResult -&gt; getIamCountriesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `countries` — A list of countries.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
     * 
     */
    public static CompletableFuture<GetIamCountriesResult> getIamCountriesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamCountries:getIamCountries", TypeShape.of(GetIamCountriesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static Output<GetIamGrantableRolesResult> getIamGrantableRoles() {
        return getIamGrantableRoles(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static CompletableFuture<GetIamGrantableRolesResult> getIamGrantableRolesPlain() {
        return getIamGrantableRolesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static Output<GetIamGrantableRolesResult> getIamGrantableRoles(InvokeArgs args) {
        return getIamGrantableRoles(args, InvokeOptions.Empty);
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static CompletableFuture<GetIamGrantableRolesResult> getIamGrantableRolesPlain(InvokeArgs args) {
        return getIamGrantableRolesPlain(args, InvokeOptions.Empty);
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static Output<GetIamGrantableRolesResult> getIamGrantableRoles(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamGrantableRoles:getIamGrantableRoles", TypeShape.of(GetIamGrantableRolesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * List which grantable roles you can include in a new custom role or add to an existing custom role.
     * 
     * ## Basic usage
     * 
     * This example returns the available roles to grant to users:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getIamGrantableRoles();
     * 
     *         ctx.export(&#34;akaGrantableRolesCount&#34;, data.akamai_iam_grantable_roles().test().grantable_roles().length());
     *         ctx.export(&#34;akaGrantableRoles&#34;, data.akamai_iam_grantable_roles().test());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This resource returns this attribute:
     * 
     * * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
     *   * `granted_role_id` - Granted role ID.
     *   * `name` - Granted role name.
     *   * `description` - Granted role description.
     * 
     */
    public static CompletableFuture<GetIamGrantableRolesResult> getIamGrantableRolesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamGrantableRoles:getIamGrantableRoles", TypeShape.of(GetIamGrantableRolesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static Output<GetIamRolesResult> getIamRoles() {
        return getIamRoles(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static CompletableFuture<GetIamRolesResult> getIamRolesPlain() {
        return getIamRolesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static Output<GetIamRolesResult> getIamRoles(InvokeArgs args) {
        return getIamRoles(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static CompletableFuture<GetIamRolesResult> getIamRolesPlain(InvokeArgs args) {
        return getIamRolesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static Output<GetIamRolesResult> getIamRoles(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamRoles:getIamRoles", TypeShape.of(GetIamRolesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user&#39;s auth grants.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-roles = AkamaiFunctions.getIamRoles();
     * 
     *         ctx.export(&#34;roles&#34;, my_roles);
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `roles` — A list of roles.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
     * 
     */
    public static CompletableFuture<GetIamRolesResult> getIamRolesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamRoles:getIamRoles", TypeShape.of(GetIamRolesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don&#39;t know a user&#39;s state. Administrators use this data source to set a user&#39;s state.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetIamStatesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()
     *             .country(&#34;canada&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;supportedStates&#34;, states.applyValue(getIamStatesResult -&gt; getIamStatesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `states` — A list of states.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
     * 
     */
    public static Output<GetIamStatesResult> getIamStates(GetIamStatesArgs args) {
        return getIamStates(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don&#39;t know a user&#39;s state. Administrators use this data source to set a user&#39;s state.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetIamStatesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()
     *             .country(&#34;canada&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;supportedStates&#34;, states.applyValue(getIamStatesResult -&gt; getIamStatesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `states` — A list of states.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
     * 
     */
    public static CompletableFuture<GetIamStatesResult> getIamStatesPlain(GetIamStatesPlainArgs args) {
        return getIamStatesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don&#39;t know a user&#39;s state. Administrators use this data source to set a user&#39;s state.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetIamStatesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()
     *             .country(&#34;canada&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;supportedStates&#34;, states.applyValue(getIamStatesResult -&gt; getIamStatesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `states` — A list of states.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
     * 
     */
    public static Output<GetIamStatesResult> getIamStates(GetIamStatesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamStates:getIamStates", TypeShape.of(GetIamStatesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don&#39;t know a user&#39;s state. Administrators use this data source to set a user&#39;s state.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetIamStatesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()
     *             .country(&#34;canada&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;supportedStates&#34;, states.applyValue(getIamStatesResult -&gt; getIamStatesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `states` — A list of states.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
     * 
     */
    public static CompletableFuture<GetIamStatesResult> getIamStatesPlain(GetIamStatesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamStates:getIamStates", TypeShape.of(GetIamStatesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static Output<GetIamSupportedLangsResult> getIamSupportedLangs() {
        return getIamSupportedLangs(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static CompletableFuture<GetIamSupportedLangsResult> getIamSupportedLangsPlain() {
        return getIamSupportedLangsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static Output<GetIamSupportedLangsResult> getIamSupportedLangs(InvokeArgs args) {
        return getIamSupportedLangs(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static CompletableFuture<GetIamSupportedLangsResult> getIamSupportedLangsPlain(InvokeArgs args) {
        return getIamSupportedLangsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static Output<GetIamSupportedLangsResult> getIamSupportedLangs(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamSupportedLangs:getIamSupportedLangs", TypeShape.of(GetIamSupportedLangsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();
     * 
     *         ctx.export(&#34;supportedSupportedLangs&#34;, supportedLangs.applyValue(getIamSupportedLangsResult -&gt; getIamSupportedLangsResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `languages` — Languages supported by Akamai
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
     * 
     */
    public static CompletableFuture<GetIamSupportedLangsResult> getIamSupportedLangsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamSupportedLangs:getIamSupportedLangs", TypeShape.of(GetIamSupportedLangsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static Output<GetIamTimeoutPoliciesResult> getIamTimeoutPolicies() {
        return getIamTimeoutPolicies(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static CompletableFuture<GetIamTimeoutPoliciesResult> getIamTimeoutPoliciesPlain() {
        return getIamTimeoutPoliciesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static Output<GetIamTimeoutPoliciesResult> getIamTimeoutPolicies(InvokeArgs args) {
        return getIamTimeoutPolicies(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static CompletableFuture<GetIamTimeoutPoliciesResult> getIamTimeoutPoliciesPlain(InvokeArgs args) {
        return getIamTimeoutPoliciesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static Output<GetIamTimeoutPoliciesResult> getIamTimeoutPolicies(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamTimeoutPolicies:getIamTimeoutPolicies", TypeShape.of(GetIamTimeoutPoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();
     * 
     *         ctx.export(&#34;supportedTimeoutPolicies&#34;, timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -&gt; getIamTimeoutPoliciesResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `policies` — A map of session timeout policy names to their value in seconds.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)
     * 
     */
    public static CompletableFuture<GetIamTimeoutPoliciesResult> getIamTimeoutPoliciesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamTimeoutPolicies:getIamTimeoutPolicies", TypeShape.of(GetIamTimeoutPoliciesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static Output<GetIamTimezonesResult> getIamTimezones() {
        return getIamTimezones(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static CompletableFuture<GetIamTimezonesResult> getIamTimezonesPlain() {
        return getIamTimezonesPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static Output<GetIamTimezonesResult> getIamTimezones(InvokeArgs args) {
        return getIamTimezones(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static CompletableFuture<GetIamTimezonesResult> getIamTimezonesPlain(InvokeArgs args) {
        return getIamTimezonesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static Output<GetIamTimezonesResult> getIamTimezones(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getIamTimezones:getIamTimezones", TypeShape.of(GetIamTimezonesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user&#39;s time zone. The default time zone is GMT.
     * 
     * ## Attributes reference
     * 
     * These attributes are returned:
     * 
     * * `timezones` — Supported timezones.
     *   * `timezone` - The time zone ID.
     *   * `description` - The description of a time zone, including the GMT +/-.
     *   * `offset` - The time zone offset from GMT.
     *   * `posix` - The time zone posix.
     * 
     * [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
     * 
     */
    public static CompletableFuture<GetIamTimezonesResult> getIamTimezonesPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getIamTimezones:getIamTimezones", TypeShape.of(GetIamTimezonesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetNetworkListsResult> getNetworkLists() {
        return getNetworkLists(GetNetworkListsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetNetworkListsResult> getNetworkListsPlain() {
        return getNetworkListsPlain(GetNetworkListsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetNetworkListsResult> getNetworkLists(GetNetworkListsArgs args) {
        return getNetworkLists(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetNetworkListsResult> getNetworkListsPlain(GetNetworkListsPlainArgs args) {
        return getNetworkListsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetNetworkListsResult> getNetworkLists(GetNetworkListsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getNetworkLists:getNetworkLists", TypeShape.of(GetNetworkListsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,
     * optionally filtered by list type or based on a search string. The information available is described in
     * [List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).
     * 
     * ## Example Usage
     * 
     * Basic usage:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetNetworkListsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var networkLists = AkamaiFunctions.getNetworkLists();
     * 
     *         ctx.export(&#34;networkListsText&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsJson&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsList&#34;, networkLists.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *         final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()
     *             .name(&#34;Test Whitelist&#34;)
     *             .type(&#34;IP&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;networkListsFilterText&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.outputText()));
     *         ctx.export(&#34;networkListsFilterJson&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.json()));
     *         ctx.export(&#34;networkListsFilterList&#34;, networkListsFilter.applyValue(getNetworkListsResult -&gt; getNetworkListsResult.lists()));
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetNetworkListsResult> getNetworkListsPlain(GetNetworkListsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getNetworkLists:getNetworkLists", TypeShape.of(GetNetworkListsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract
     * based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of properties available for the contract and group IDs provided.
     * 
     */
    public static Output<GetPropertiesResult> getProperties(GetPropertiesArgs args) {
        return getProperties(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract
     * based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of properties available for the contract and group IDs provided.
     * 
     */
    public static CompletableFuture<GetPropertiesResult> getPropertiesPlain(GetPropertiesPlainArgs args) {
        return getPropertiesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract
     * based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of properties available for the contract and group IDs provided.
     * 
     */
    public static Output<GetPropertiesResult> getProperties(GetPropertiesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getProperties:getProperties", TypeShape.of(GetPropertiesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract
     * based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of properties available for the contract and group IDs provided.
     * 
     */
    public static CompletableFuture<GetPropertiesResult> getPropertiesPlain(GetPropertiesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getProperties:getProperties", TypeShape.of(GetPropertiesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties_search().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of property version matching the given criteria.
     * 
     */
    public static Output<GetPropertiesSearchResult> getPropertiesSearch(GetPropertiesSearchArgs args) {
        return getPropertiesSearch(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties_search().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of property version matching the given criteria.
     * 
     */
    public static CompletableFuture<GetPropertiesSearchResult> getPropertiesSearchPlain(GetPropertiesSearchPlainArgs args) {
        return getPropertiesSearchPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties_search().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of property version matching the given criteria.
     * 
     */
    public static Output<GetPropertiesSearchResult> getPropertiesSearch(GetPropertiesSearchArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertiesSearch:getPropertiesSearch", TypeShape.of(GetPropertiesSearchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you&#39;re using.
     * 
     * ## Example Usage
     * 
     * Return properties associated with the EdgeGrid API client token currently used for authentication:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;myPropertyList&#34;, data.akamai_properties_search().example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `properties` - A list of property version matching the given criteria.
     * 
     */
    public static CompletableFuture<GetPropertiesSearchResult> getPropertiesSearchPlain(GetPropertiesSearchPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertiesSearch:getPropertiesSearch", TypeShape.of(GetPropertiesSearchResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.
     * 
     * ## Example Usage
     * 
     * This example returns the property ID and rule tree based on the property name and optional version argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()
     *             .name(&#34;terraform-demo&#34;)
     *             .version(&#34;1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myPropertyID&#34;, example.applyValue(getPropertyResult -&gt; getPropertyResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `property_ID` - A property&#39;s unique identifier, including the `prp_` prefix.
     * * `rules` - A JSON-encoded rule tree for a given property.
     * 
     */
    public static Output<GetPropertyResult> getProperty(GetPropertyArgs args) {
        return getProperty(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.
     * 
     * ## Example Usage
     * 
     * This example returns the property ID and rule tree based on the property name and optional version argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()
     *             .name(&#34;terraform-demo&#34;)
     *             .version(&#34;1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myPropertyID&#34;, example.applyValue(getPropertyResult -&gt; getPropertyResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `property_ID` - A property&#39;s unique identifier, including the `prp_` prefix.
     * * `rules` - A JSON-encoded rule tree for a given property.
     * 
     */
    public static CompletableFuture<GetPropertyResult> getPropertyPlain(GetPropertyPlainArgs args) {
        return getPropertyPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.
     * 
     * ## Example Usage
     * 
     * This example returns the property ID and rule tree based on the property name and optional version argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()
     *             .name(&#34;terraform-demo&#34;)
     *             .version(&#34;1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myPropertyID&#34;, example.applyValue(getPropertyResult -&gt; getPropertyResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `property_ID` - A property&#39;s unique identifier, including the `prp_` prefix.
     * * `rules` - A JSON-encoded rule tree for a given property.
     * 
     */
    public static Output<GetPropertyResult> getProperty(GetPropertyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getProperty:getProperty", TypeShape.of(GetPropertyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.
     * 
     * ## Example Usage
     * 
     * This example returns the property ID and rule tree based on the property name and optional version argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()
     *             .name(&#34;terraform-demo&#34;)
     *             .version(&#34;1&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myPropertyID&#34;, example.applyValue(getPropertyResult -&gt; getPropertyResult));
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `property_ID` - A property&#39;s unique identifier, including the `prp_` prefix.
     * * `rules` - A JSON-encoded rule tree for a given property.
     * 
     */
    public static CompletableFuture<GetPropertyResult> getPropertyPlain(GetPropertyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getProperty:getProperty", TypeShape.of(GetPropertyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyHostnames` data source to query and retrieve hostnames and their certificate statuses for an existing property. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the property&#39;s hostnames based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyHostnames&#34;, data.akamai_property_hostnames().my-example().hostnames());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `hostnames` - A list of hostnames for the property, including:
     *   * `cname_type` - A string containing the hostname&#39;s cname type value.
     *   * `edge_hostname_id` - The edge hostname&#39;s unique ID, including the `ehn_` prefix.
     *   * `cname_from` - A string containing the original origin&#39;s hostname.
     *   * `cname_to` - A string containing the hostname for edge content.
     *   * `cert_provisioning_type` - The certificate&#39;s provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the Certificate Provisioning System (CPS), or `DEFAULT` for certificates provisioned automatically.
     *   * `cert_status` - If applicable, this shows a list of certificate statuses, including:
     *     * `target` - The destination part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `hostname` - The hostname part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `production_status` - A string containing the status of the certificate deployment on the production network.
     *     * `staging_status` - A string containing the status of the certificate deployment on the staging network.
     * 
     * ## Domain validation for DEFAULT certificates
     * 
     * If your `cert_provisioning_type = &#34;DEFAULT&#34;` and the value for `cert_status.production_status` or `cert_status.staging_status` is either `PENDING`, `EXPIRING_SOON_NEEDS_VALIDATION`, or `EXPIRED_NEEDS_VALIDATION`, you need to perform domain validation. This proves to the certificate authority that you control the domain and are authorized to create certificates for it.
     * 
     * In your DNS configuration, create a CNAME record and map the `cert_status.hostname` value to the `cert_status.target` value.
     * 
     */
    public static Output<GetPropertyHostnamesResult> getPropertyHostnames(GetPropertyHostnamesArgs args) {
        return getPropertyHostnames(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyHostnames` data source to query and retrieve hostnames and their certificate statuses for an existing property. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the property&#39;s hostnames based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyHostnames&#34;, data.akamai_property_hostnames().my-example().hostnames());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `hostnames` - A list of hostnames for the property, including:
     *   * `cname_type` - A string containing the hostname&#39;s cname type value.
     *   * `edge_hostname_id` - The edge hostname&#39;s unique ID, including the `ehn_` prefix.
     *   * `cname_from` - A string containing the original origin&#39;s hostname.
     *   * `cname_to` - A string containing the hostname for edge content.
     *   * `cert_provisioning_type` - The certificate&#39;s provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the Certificate Provisioning System (CPS), or `DEFAULT` for certificates provisioned automatically.
     *   * `cert_status` - If applicable, this shows a list of certificate statuses, including:
     *     * `target` - The destination part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `hostname` - The hostname part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `production_status` - A string containing the status of the certificate deployment on the production network.
     *     * `staging_status` - A string containing the status of the certificate deployment on the staging network.
     * 
     * ## Domain validation for DEFAULT certificates
     * 
     * If your `cert_provisioning_type = &#34;DEFAULT&#34;` and the value for `cert_status.production_status` or `cert_status.staging_status` is either `PENDING`, `EXPIRING_SOON_NEEDS_VALIDATION`, or `EXPIRED_NEEDS_VALIDATION`, you need to perform domain validation. This proves to the certificate authority that you control the domain and are authorized to create certificates for it.
     * 
     * In your DNS configuration, create a CNAME record and map the `cert_status.hostname` value to the `cert_status.target` value.
     * 
     */
    public static CompletableFuture<GetPropertyHostnamesResult> getPropertyHostnamesPlain(GetPropertyHostnamesPlainArgs args) {
        return getPropertyHostnamesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyHostnames` data source to query and retrieve hostnames and their certificate statuses for an existing property. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the property&#39;s hostnames based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyHostnames&#34;, data.akamai_property_hostnames().my-example().hostnames());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `hostnames` - A list of hostnames for the property, including:
     *   * `cname_type` - A string containing the hostname&#39;s cname type value.
     *   * `edge_hostname_id` - The edge hostname&#39;s unique ID, including the `ehn_` prefix.
     *   * `cname_from` - A string containing the original origin&#39;s hostname.
     *   * `cname_to` - A string containing the hostname for edge content.
     *   * `cert_provisioning_type` - The certificate&#39;s provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the Certificate Provisioning System (CPS), or `DEFAULT` for certificates provisioned automatically.
     *   * `cert_status` - If applicable, this shows a list of certificate statuses, including:
     *     * `target` - The destination part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `hostname` - The hostname part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `production_status` - A string containing the status of the certificate deployment on the production network.
     *     * `staging_status` - A string containing the status of the certificate deployment on the staging network.
     * 
     * ## Domain validation for DEFAULT certificates
     * 
     * If your `cert_provisioning_type = &#34;DEFAULT&#34;` and the value for `cert_status.production_status` or `cert_status.staging_status` is either `PENDING`, `EXPIRING_SOON_NEEDS_VALIDATION`, or `EXPIRED_NEEDS_VALIDATION`, you need to perform domain validation. This proves to the certificate authority that you control the domain and are authorized to create certificates for it.
     * 
     * In your DNS configuration, create a CNAME record and map the `cert_status.hostname` value to the `cert_status.target` value.
     * 
     */
    public static Output<GetPropertyHostnamesResult> getPropertyHostnames(GetPropertyHostnamesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyHostnames:getPropertyHostnames", TypeShape.of(GetPropertyHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyHostnames` data source to query and retrieve hostnames and their certificate statuses for an existing property. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the property&#39;s hostnames based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyHostnames&#34;, data.akamai_property_hostnames().my-example().hostnames());
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `hostnames` - A list of hostnames for the property, including:
     *   * `cname_type` - A string containing the hostname&#39;s cname type value.
     *   * `edge_hostname_id` - The edge hostname&#39;s unique ID, including the `ehn_` prefix.
     *   * `cname_from` - A string containing the original origin&#39;s hostname.
     *   * `cname_to` - A string containing the hostname for edge content.
     *   * `cert_provisioning_type` - The certificate&#39;s provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the Certificate Provisioning System (CPS), or `DEFAULT` for certificates provisioned automatically.
     *   * `cert_status` - If applicable, this shows a list of certificate statuses, including:
     *     * `target` - The destination part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `hostname` - The hostname part of the CNAME record used to validate the certificate&#39;s domain.
     *     * `production_status` - A string containing the status of the certificate deployment on the production network.
     *     * `staging_status` - A string containing the status of the certificate deployment on the staging network.
     * 
     * ## Domain validation for DEFAULT certificates
     * 
     * If your `cert_provisioning_type = &#34;DEFAULT&#34;` and the value for `cert_status.production_status` or `cert_status.staging_status` is either `PENDING`, `EXPIRING_SOON_NEEDS_VALIDATION`, or `EXPIRED_NEEDS_VALIDATION`, you need to perform domain validation. This proves to the certificate authority that you control the domain and are authorized to create certificates for it.
     * 
     * In your DNS configuration, create a CNAME record and map the `cert_status.hostname` value to the `cert_status.target` value.
     * 
     */
    public static CompletableFuture<GetPropertyHostnamesResult> getPropertyHostnamesPlain(GetPropertyHostnamesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyHostnames:getPropertyHostnames", TypeShape.of(GetPropertyHostnamesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.PropertyInclude` data source to get details about a specific include.
     * 
     * ## Basic usage
     * 
     * This example returns details for an include based on contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyInclude = AkamaiFunctions.getPropertyInclude(GetPropertyIncludeArgs.builder()
     *             .contractId(&#34;ctr_1234&#34;)
     *             .groupId(&#34;grp_5678&#34;)
     *             .includeId(&#34;inc_9012&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyInclude.applyValue(getPropertyIncludeResult -&gt; getPropertyIncludeResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The descriptive name for the include.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * * `latest_version` - Returns the most recent version of the include.
     * * `staging_version` - The include version currently activated on the staging network.
     * * `production_version` - The include version currently activated on the production network.
     * 
     */
    public static Output<GetPropertyIncludeResult> getPropertyInclude(GetPropertyIncludeArgs args) {
        return getPropertyInclude(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.PropertyInclude` data source to get details about a specific include.
     * 
     * ## Basic usage
     * 
     * This example returns details for an include based on contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyInclude = AkamaiFunctions.getPropertyInclude(GetPropertyIncludeArgs.builder()
     *             .contractId(&#34;ctr_1234&#34;)
     *             .groupId(&#34;grp_5678&#34;)
     *             .includeId(&#34;inc_9012&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyInclude.applyValue(getPropertyIncludeResult -&gt; getPropertyIncludeResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The descriptive name for the include.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * * `latest_version` - Returns the most recent version of the include.
     * * `staging_version` - The include version currently activated on the staging network.
     * * `production_version` - The include version currently activated on the production network.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeResult> getPropertyIncludePlain(GetPropertyIncludePlainArgs args) {
        return getPropertyIncludePlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.PropertyInclude` data source to get details about a specific include.
     * 
     * ## Basic usage
     * 
     * This example returns details for an include based on contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyInclude = AkamaiFunctions.getPropertyInclude(GetPropertyIncludeArgs.builder()
     *             .contractId(&#34;ctr_1234&#34;)
     *             .groupId(&#34;grp_5678&#34;)
     *             .includeId(&#34;inc_9012&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyInclude.applyValue(getPropertyIncludeResult -&gt; getPropertyIncludeResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The descriptive name for the include.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * * `latest_version` - Returns the most recent version of the include.
     * * `staging_version` - The include version currently activated on the staging network.
     * * `production_version` - The include version currently activated on the production network.
     * 
     */
    public static Output<GetPropertyIncludeResult> getPropertyInclude(GetPropertyIncludeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyInclude:getPropertyInclude", TypeShape.of(GetPropertyIncludeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.PropertyInclude` data source to get details about a specific include.
     * 
     * ## Basic usage
     * 
     * This example returns details for an include based on contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyInclude = AkamaiFunctions.getPropertyInclude(GetPropertyIncludeArgs.builder()
     *             .contractId(&#34;ctr_1234&#34;)
     *             .groupId(&#34;grp_5678&#34;)
     *             .includeId(&#34;inc_9012&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyInclude.applyValue(getPropertyIncludeResult -&gt; getPropertyIncludeResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `name` - The descriptive name for the include.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * * `latest_version` - Returns the most recent version of the include.
     * * `staging_version` - The include version currently activated on the staging network.
     * * `production_version` - The include version currently activated on the production network.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeResult> getPropertyIncludePlain(GetPropertyIncludePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyInclude:getPropertyInclude", TypeShape.of(GetPropertyIncludeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.PropertyIncludeActivation` data source to get activation details for an include on the provided network.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `version` - The version of the activated include.
     * * `name` - The descriptive name for the property.
     * * `note` - A log message assigned to the activation request.
     * * `notify_emails` - The list of email addresses notified when the activation status changes.
     * 
     */
    public static Output<GetPropertyIncludeActivationResult> getPropertyIncludeActivation(GetPropertyIncludeActivationArgs args) {
        return getPropertyIncludeActivation(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.PropertyIncludeActivation` data source to get activation details for an include on the provided network.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `version` - The version of the activated include.
     * * `name` - The descriptive name for the property.
     * * `note` - A log message assigned to the activation request.
     * * `notify_emails` - The list of email addresses notified when the activation status changes.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeActivationResult> getPropertyIncludeActivationPlain(GetPropertyIncludeActivationPlainArgs args) {
        return getPropertyIncludeActivationPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.PropertyIncludeActivation` data source to get activation details for an include on the provided network.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `version` - The version of the activated include.
     * * `name` - The descriptive name for the property.
     * * `note` - A log message assigned to the activation request.
     * * `notify_emails` - The list of email addresses notified when the activation status changes.
     * 
     */
    public static Output<GetPropertyIncludeActivationResult> getPropertyIncludeActivation(GetPropertyIncludeActivationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyIncludeActivation:getPropertyIncludeActivation", TypeShape.of(GetPropertyIncludeActivationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.PropertyIncludeActivation` data source to get activation details for an include on the provided network.
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `version` - The version of the activated include.
     * * `name` - The descriptive name for the property.
     * * `note` - A log message assigned to the activation request.
     * * `notify_emails` - The list of email addresses notified when the activation status changes.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeActivationResult> getPropertyIncludeActivationPlain(GetPropertyIncludeActivationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyIncludeActivation:getPropertyIncludeActivation", TypeShape.of(GetPropertyIncludeActivationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludeParents` data source to return a list of parent properties that use the given include. In your property&#39;s rule tree, you can reference an include by adding the `include` behavior and specifying the `include_id`.
     * 
     * ## Basic usage
     * 
     * This example returns all active properties a specific include is referenced in, based on the contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeParents = AkamaiFunctions.getPropertyIncludeParents(GetPropertyIncludeParentsArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeParents.applyValue(getPropertyIncludeParentsResult -&gt; getPropertyIncludeParentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `parents` - The list of include&#39;s parent properties.
     *  * `id` - The property&#39;s unique identifier.
     *  * `name` - The descriptive name for the property.
     *  * `staging_version` - The property version currently activated on the staging network.
     *  * `production_version` - The property version currently activated on the production network.
     *  * `is_include_used_in_staging_version` - Whether the specified include is active on the staging network and is referenced in parent&#39;s `staging_version`.
     *  * `is_include_used_in_production_version` - Whether the specified include is active on the production network and is referenced in parent&#39;s `production_version`.
     * 
     */
    public static Output<GetPropertyIncludeParentsResult> getPropertyIncludeParents(GetPropertyIncludeParentsArgs args) {
        return getPropertyIncludeParents(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludeParents` data source to return a list of parent properties that use the given include. In your property&#39;s rule tree, you can reference an include by adding the `include` behavior and specifying the `include_id`.
     * 
     * ## Basic usage
     * 
     * This example returns all active properties a specific include is referenced in, based on the contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeParents = AkamaiFunctions.getPropertyIncludeParents(GetPropertyIncludeParentsArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeParents.applyValue(getPropertyIncludeParentsResult -&gt; getPropertyIncludeParentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `parents` - The list of include&#39;s parent properties.
     *  * `id` - The property&#39;s unique identifier.
     *  * `name` - The descriptive name for the property.
     *  * `staging_version` - The property version currently activated on the staging network.
     *  * `production_version` - The property version currently activated on the production network.
     *  * `is_include_used_in_staging_version` - Whether the specified include is active on the staging network and is referenced in parent&#39;s `staging_version`.
     *  * `is_include_used_in_production_version` - Whether the specified include is active on the production network and is referenced in parent&#39;s `production_version`.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeParentsResult> getPropertyIncludeParentsPlain(GetPropertyIncludeParentsPlainArgs args) {
        return getPropertyIncludeParentsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludeParents` data source to return a list of parent properties that use the given include. In your property&#39;s rule tree, you can reference an include by adding the `include` behavior and specifying the `include_id`.
     * 
     * ## Basic usage
     * 
     * This example returns all active properties a specific include is referenced in, based on the contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeParents = AkamaiFunctions.getPropertyIncludeParents(GetPropertyIncludeParentsArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeParents.applyValue(getPropertyIncludeParentsResult -&gt; getPropertyIncludeParentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `parents` - The list of include&#39;s parent properties.
     *  * `id` - The property&#39;s unique identifier.
     *  * `name` - The descriptive name for the property.
     *  * `staging_version` - The property version currently activated on the staging network.
     *  * `production_version` - The property version currently activated on the production network.
     *  * `is_include_used_in_staging_version` - Whether the specified include is active on the staging network and is referenced in parent&#39;s `staging_version`.
     *  * `is_include_used_in_production_version` - Whether the specified include is active on the production network and is referenced in parent&#39;s `production_version`.
     * 
     */
    public static Output<GetPropertyIncludeParentsResult> getPropertyIncludeParents(GetPropertyIncludeParentsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyIncludeParents:getPropertyIncludeParents", TypeShape.of(GetPropertyIncludeParentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludeParents` data source to return a list of parent properties that use the given include. In your property&#39;s rule tree, you can reference an include by adding the `include` behavior and specifying the `include_id`.
     * 
     * ## Basic usage
     * 
     * This example returns all active properties a specific include is referenced in, based on the contract, group, and include IDs.
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeParents = AkamaiFunctions.getPropertyIncludeParents(GetPropertyIncludeParentsArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeParents.applyValue(getPropertyIncludeParentsResult -&gt; getPropertyIncludeParentsResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `parents` - The list of include&#39;s parent properties.
     *  * `id` - The property&#39;s unique identifier.
     *  * `name` - The descriptive name for the property.
     *  * `staging_version` - The property version currently activated on the staging network.
     *  * `production_version` - The property version currently activated on the production network.
     *  * `is_include_used_in_staging_version` - Whether the specified include is active on the staging network and is referenced in parent&#39;s `staging_version`.
     *  * `is_include_used_in_production_version` - Whether the specified include is active on the production network and is referenced in parent&#39;s `production_version`.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeParentsResult> getPropertyIncludeParentsPlain(GetPropertyIncludeParentsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyIncludeParents:getPropertyIncludeParents", TypeShape.of(GetPropertyIncludeParentsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludeRules` data source to query and get an include&#39;s rules. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the include&#39;s rule tree based on the specified contract, group, and include IDs:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeRules = AkamaiFunctions.getPropertyIncludeRules(GetPropertyIncludeRulesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeRules.applyValue(getPropertyIncludeRulesResult -&gt; getPropertyIncludeRulesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rules` - Include&#39;s rules as JSON.
     * * `name` - The descriptive name for the include.
     * * `rule_errors` - Rule&#39;s validation errors. You need to resolve returned errors, as they block an activation.
     * * `rule_warnings` - Rule&#39;s validation warnings. You can activate a version that yields non-blocking warnings.
     * * `rule_format` - Indicates the versioned set of features and criteria that are currently applied to a rule tree. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * 
     */
    public static Output<GetPropertyIncludeRulesResult> getPropertyIncludeRules(GetPropertyIncludeRulesArgs args) {
        return getPropertyIncludeRules(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludeRules` data source to query and get an include&#39;s rules. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the include&#39;s rule tree based on the specified contract, group, and include IDs:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeRules = AkamaiFunctions.getPropertyIncludeRules(GetPropertyIncludeRulesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeRules.applyValue(getPropertyIncludeRulesResult -&gt; getPropertyIncludeRulesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rules` - Include&#39;s rules as JSON.
     * * `name` - The descriptive name for the include.
     * * `rule_errors` - Rule&#39;s validation errors. You need to resolve returned errors, as they block an activation.
     * * `rule_warnings` - Rule&#39;s validation warnings. You can activate a version that yields non-blocking warnings.
     * * `rule_format` - Indicates the versioned set of features and criteria that are currently applied to a rule tree. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeRulesResult> getPropertyIncludeRulesPlain(GetPropertyIncludeRulesPlainArgs args) {
        return getPropertyIncludeRulesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludeRules` data source to query and get an include&#39;s rules. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the include&#39;s rule tree based on the specified contract, group, and include IDs:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeRules = AkamaiFunctions.getPropertyIncludeRules(GetPropertyIncludeRulesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeRules.applyValue(getPropertyIncludeRulesResult -&gt; getPropertyIncludeRulesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rules` - Include&#39;s rules as JSON.
     * * `name` - The descriptive name for the include.
     * * `rule_errors` - Rule&#39;s validation errors. You need to resolve returned errors, as they block an activation.
     * * `rule_warnings` - Rule&#39;s validation warnings. You can activate a version that yields non-blocking warnings.
     * * `rule_format` - Indicates the versioned set of features and criteria that are currently applied to a rule tree. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * 
     */
    public static Output<GetPropertyIncludeRulesResult> getPropertyIncludeRules(GetPropertyIncludeRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyIncludeRules:getPropertyIncludeRules", TypeShape.of(GetPropertyIncludeRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludeRules` data source to query and get an include&#39;s rules. This data source lets you search across the contracts and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the include&#39;s rule tree based on the specified contract, group, and include IDs:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludeRules = AkamaiFunctions.getPropertyIncludeRules(GetPropertyIncludeRulesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .includeId(&#34;inc_123456&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludeRules.applyValue(getPropertyIncludeRulesResult -&gt; getPropertyIncludeRulesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rules` - Include&#39;s rules as JSON.
     * * `name` - The descriptive name for the include.
     * * `rule_errors` - Rule&#39;s validation errors. You need to resolve returned errors, as they block an activation.
     * * `rule_warnings` - Rule&#39;s validation warnings. You can activate a version that yields non-blocking warnings.
     * * `rule_format` - Indicates the versioned set of features and criteria that are currently applied to a rule tree. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
     * 
     */
    public static CompletableFuture<GetPropertyIncludeRulesResult> getPropertyIncludeRulesPlain(GetPropertyIncludeRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyIncludeRules:getPropertyIncludeRules", TypeShape.of(GetPropertyIncludeRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludes` data source to get all includes available for the current contract and group. Includes are small, reusable, and configurable components for your properties.
     * 
     * ## Basic usage
     * 
     * This example returns all includes for the specified contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludes = AkamaiFunctions.getPropertyIncludes(GetPropertyIncludesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludes.applyValue(getPropertyIncludesResult -&gt; getPropertyIncludesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `includes` -  The small, reusable, configurable components for your properties.
     *  * `latest_version` - Returns the most recent version of the include.
     *  * `staging_version` - The include version currently activated on the staging network.
     *  * `production_version` - The include version currently activated on the production network.
     *  * `id` - The include&#39;s unique identifier.
     *  * `name` - The descriptive name for the include.
     *  * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`.
     * 
     */
    public static Output<GetPropertyIncludesResult> getPropertyIncludes(GetPropertyIncludesArgs args) {
        return getPropertyIncludes(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludes` data source to get all includes available for the current contract and group. Includes are small, reusable, and configurable components for your properties.
     * 
     * ## Basic usage
     * 
     * This example returns all includes for the specified contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludes = AkamaiFunctions.getPropertyIncludes(GetPropertyIncludesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludes.applyValue(getPropertyIncludesResult -&gt; getPropertyIncludesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `includes` -  The small, reusable, configurable components for your properties.
     *  * `latest_version` - Returns the most recent version of the include.
     *  * `staging_version` - The include version currently activated on the staging network.
     *  * `production_version` - The include version currently activated on the production network.
     *  * `id` - The include&#39;s unique identifier.
     *  * `name` - The descriptive name for the include.
     *  * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`.
     * 
     */
    public static CompletableFuture<GetPropertyIncludesResult> getPropertyIncludesPlain(GetPropertyIncludesPlainArgs args) {
        return getPropertyIncludesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyIncludes` data source to get all includes available for the current contract and group. Includes are small, reusable, and configurable components for your properties.
     * 
     * ## Basic usage
     * 
     * This example returns all includes for the specified contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludes = AkamaiFunctions.getPropertyIncludes(GetPropertyIncludesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludes.applyValue(getPropertyIncludesResult -&gt; getPropertyIncludesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `includes` -  The small, reusable, configurable components for your properties.
     *  * `latest_version` - Returns the most recent version of the include.
     *  * `staging_version` - The include version currently activated on the staging network.
     *  * `production_version` - The include version currently activated on the production network.
     *  * `id` - The include&#39;s unique identifier.
     *  * `name` - The descriptive name for the include.
     *  * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`.
     * 
     */
    public static Output<GetPropertyIncludesResult> getPropertyIncludes(GetPropertyIncludesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyIncludes:getPropertyIncludes", TypeShape.of(GetPropertyIncludesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyIncludes` data source to get all includes available for the current contract and group. Includes are small, reusable, and configurable components for your properties.
     * 
     * ## Basic usage
     * 
     * This example returns all includes for the specified contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyIncludesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myExamplePropertyIncludes = AkamaiFunctions.getPropertyIncludes(GetPropertyIncludesArgs.builder()
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;myExample&#34;, myExamplePropertyIncludes.applyValue(getPropertyIncludesResult -&gt; getPropertyIncludesResult));
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `includes` -  The small, reusable, configurable components for your properties.
     *  * `latest_version` - Returns the most recent version of the include.
     *  * `staging_version` - The include version currently activated on the staging network.
     *  * `production_version` - The include version currently activated on the production network.
     *  * `id` - The include&#39;s unique identifier.
     *  * `name` - The descriptive name for the include.
     *  * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`.
     * 
     */
    public static CompletableFuture<GetPropertyIncludesResult> getPropertyIncludesPlain(GetPropertyIncludesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyIncludes:getPropertyIncludes", TypeShape.of(GetPropertyIncludesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyProducts` data source to list the products included on a contract.
     * 
     * ## Example Usage
     * 
     * This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_products().my-example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `products` - A list of supported products for the contract, including:
     *   * `product_id` - The product&#39;s unique ID, including the `prd_` prefix.
     *   * `product_name` - A string containing the product name.
     * 
     */
    public static Output<GetPropertyProductsResult> getPropertyProducts(GetPropertyProductsArgs args) {
        return getPropertyProducts(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyProducts` data source to list the products included on a contract.
     * 
     * ## Example Usage
     * 
     * This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_products().my-example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `products` - A list of supported products for the contract, including:
     *   * `product_id` - The product&#39;s unique ID, including the `prd_` prefix.
     *   * `product_name` - A string containing the product name.
     * 
     */
    public static CompletableFuture<GetPropertyProductsResult> getPropertyProductsPlain(GetPropertyProductsPlainArgs args) {
        return getPropertyProductsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyProducts` data source to list the products included on a contract.
     * 
     * ## Example Usage
     * 
     * This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_products().my-example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `products` - A list of supported products for the contract, including:
     *   * `product_id` - The product&#39;s unique ID, including the `prd_` prefix.
     *   * `product_name` - A string containing the product name.
     * 
     */
    public static Output<GetPropertyProductsResult> getPropertyProducts(GetPropertyProductsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyProducts:getPropertyProducts", TypeShape.of(GetPropertyProductsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyProducts` data source to list the products included on a contract.
     * 
     * ## Example Usage
     * 
     * This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_products().my-example());
     *     }
     * }
     * ```
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `products` - A list of supported products for the contract, including:
     *   * `product_id` - The product&#39;s unique ID, including the `prd_` prefix.
     *   * `product_name` - A string containing the product name.
     * 
     */
    public static CompletableFuture<GetPropertyProductsResult> getPropertyProductsPlain(GetPropertyProductsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyProducts:getPropertyProducts", TypeShape.of(GetPropertyProductsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetPropertyRuleFormatsResult> getPropertyRuleFormats() {
        return getPropertyRuleFormats(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetPropertyRuleFormatsResult> getPropertyRuleFormatsPlain() {
        return getPropertyRuleFormatsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetPropertyRuleFormatsResult> getPropertyRuleFormats(InvokeArgs args) {
        return getPropertyRuleFormats(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetPropertyRuleFormatsResult> getPropertyRuleFormatsPlain(InvokeArgs args) {
        return getPropertyRuleFormatsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static Output<GetPropertyRuleFormatsResult> getPropertyRuleFormats(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyRuleFormats:getPropertyRuleFormats", TypeShape.of(GetPropertyRuleFormatsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyRuleFormats` data source to query the list of
     * known rule formats.
     * You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
     * [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
     * and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
     * would update automatically and generate unexpected errors.
     * 
     * ## Example Usage
     * 
     * Use this example to list available property rule formats:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         ctx.export(&#34;propertyMatch&#34;, data.akamai_property_rule_formats().my-example());
     *     }
     * }
     * ```
     * 
     */
    public static CompletableFuture<GetPropertyRuleFormatsResult> getPropertyRuleFormatsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyRuleFormats:getPropertyRuleFormats", TypeShape.of(GetPropertyRuleFormatsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of
     * an existing property version. This data source lets you search across the contracts
     * and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the rule tree for version 3 of a property based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()
     *             .propertyId(&#34;prp_123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `rules` - A JSON-encoded rule tree for the property.
     * * `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.
     * 
     */
    public static Output<GetPropertyRulesResult> getPropertyRules(GetPropertyRulesArgs args) {
        return getPropertyRules(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of
     * an existing property version. This data source lets you search across the contracts
     * and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the rule tree for version 3 of a property based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()
     *             .propertyId(&#34;prp_123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `rules` - A JSON-encoded rule tree for the property.
     * * `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.
     * 
     */
    public static CompletableFuture<GetPropertyRulesResult> getPropertyRulesPlain(GetPropertyRulesPlainArgs args) {
        return getPropertyRulesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of
     * an existing property version. This data source lets you search across the contracts
     * and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the rule tree for version 3 of a property based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()
     *             .propertyId(&#34;prp_123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `rules` - A JSON-encoded rule tree for the property.
     * * `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.
     * 
     */
    public static Output<GetPropertyRulesResult> getPropertyRules(GetPropertyRulesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyRules:getPropertyRules", TypeShape.of(GetPropertyRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of
     * an existing property version. This data source lets you search across the contracts
     * and groups you have access to.
     * 
     * ## Basic usage
     * 
     * This example returns the rule tree for version 3 of a property based on the selected contract and group:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()
     *             .propertyId(&#34;prp_123&#34;)
     *             .groupId(&#34;grp_12345&#34;)
     *             .contractId(&#34;ctr_1-AB123&#34;)
     *             .version(3)
     *             .build());
     * 
     *         ctx.export(&#34;propertyMatch&#34;, my_example);
     *     }
     * }
     * ```
     * 
     * ## Attributes reference
     * 
     * This data source returns these attributes:
     * 
     * * `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.
     * * `rules` - A JSON-encoded rule tree for the property.
     * * `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.
     * 
     */
    public static CompletableFuture<GetPropertyRulesResult> getPropertyRulesPlain(GetPropertyRulesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyRules:getPropertyRules", TypeShape.of(GetPropertyRulesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static Output<GetPropertyRulesTemplateResult> getPropertyRulesTemplate() {
        return getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static CompletableFuture<GetPropertyRulesTemplateResult> getPropertyRulesTemplatePlain() {
        return getPropertyRulesTemplatePlain(GetPropertyRulesTemplatePlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static Output<GetPropertyRulesTemplateResult> getPropertyRulesTemplate(GetPropertyRulesTemplateArgs args) {
        return getPropertyRulesTemplate(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static CompletableFuture<GetPropertyRulesTemplateResult> getPropertyRulesTemplatePlain(GetPropertyRulesTemplatePlainArgs args) {
        return getPropertyRulesTemplatePlain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static Output<GetPropertyRulesTemplateResult> getPropertyRulesTemplate(GetPropertyRulesTemplateArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("akamai:index/getPropertyRulesTemplate:getPropertyRulesTemplate", TypeShape.of(GetPropertyRulesTemplateResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * ### JSON Template Files
     * 
     * Here are some examples of how you can set up your JSON template files for use with this data source.
     * ### Single JSON template that calls other templates
     * 
     * Here&#39;s an example of a JSON template file with nested templates:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Individual JSON rule template file
     * 
     * Here’s a simple default rule example that you can include inside the `template_data` argument:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *     }
     * }
     * ```
     * ### Add Templates To The Data Source
     * 
     * Here are some examples of how you can call your JSON template files with this data source.
     * ### Call individual template files with this data source
     * 
     * This second example shows how to call a specific JSON template using the `template_data` field:
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.akamai.AkamaiFunctions;
     * import com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;
     * import com.pulumi.akamai.Property;
     * import com.pulumi.akamai.PropertyArgs;
     * import static com.pulumi.codegen.internal.Serialization.*;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()
     *             .templates(GetPropertyRulesTemplateTemplateArgs.builder()
     *                 .templateData(serializeJson(
     *                     jsonObject(
     *                         jsonProperty(&#34;rules&#34;, jsonObject(
     *                             jsonProperty(&#34;name&#34;, &#34;default&#34;),
     *                             jsonProperty(&#34;children&#34;, jsonArray(&#34;#include:rules.json&#34;))
     *                         ))
     *                     )))
     *                 .templateDir(&#34;property-snippets/&#34;)
     *                 .build())
     *             .build());
     * 
     *         var exampleProperty = new Property(&#34;exampleProperty&#34;, PropertyArgs.builder()        
     *             .contractId(var_.contractid())
     *             .groupId(var_.groupid())
     *             .ruleFormat(&#34;v2020-03-04&#34;)
     *             .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -&gt; getPropertyRulesTemplateResult.json()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * ### Variables
     * 
     * You can add variables individually or reference variable definition files.
     * ## Attributes reference
     * 
     * This data source returns this attribute:
     * 
     * * `json` - The fully expanded template with variables and all nested templates resolved.
     * 
     */
    public static CompletableFuture<GetPropertyRulesTemplateResult> getPropertyRulesTemplatePlain(GetPropertyRulesTemplatePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("akamai:index/getPropertyRulesTemplate:getPropertyRulesTemplate", TypeShape.of(GetPropertyRulesTemplateResult.class), args, Utilities.withVersion(options));
    }
}
