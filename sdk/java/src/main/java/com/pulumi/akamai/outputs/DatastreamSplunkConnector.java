// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class DatastreamSplunkConnector {
    /**
     * @return The certification authority (CA) certificate used to verify the origin server&#39;s certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    private @Nullable String caCert;
    /**
     * @return The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     * 
     */
    private @Nullable String clientCert;
    /**
     * @return The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    private @Nullable String clientKey;
    /**
     * @return Indicates whether the logs should be compressed
     * 
     */
    private @Nullable Boolean compressLogs;
    /**
     * @return The name of custom header passed with the request to the destination
     * 
     */
    private @Nullable String customHeaderName;
    /**
     * @return The custom header&#39;s contents passed with the request to the destination
     * 
     */
    private @Nullable String customHeaderValue;
    /**
     * @return The name of the connector
     * 
     */
    private String displayName;
    /**
     * @return The raw event Splunk URL where logs will be stored
     * 
     */
    private String endpoint;
    /**
     * @return The Event Collector token associated with Splunk account
     * 
     */
    private String eventCollectorToken;
    /**
     * @return Indicates whether mTLS is enabled or not.
     * 
     */
    private @Nullable Boolean mTls;
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    private @Nullable String tlsHostname;

    private DatastreamSplunkConnector() {}
    /**
     * @return The certification authority (CA) certificate used to verify the origin server&#39;s certificate. If the certificate is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.
     * 
     */
    public Optional<String> caCert() {
        return Optional.ofNullable(this.caCert);
    }
    /**
     * @return The digital certificate in the PEM format you want to use to authenticate requests to your destination. If you want to use mutual authentication, you need to provide both the client certificate and the client key (in the PEM format).
     * 
     */
    public Optional<String> clientCert() {
        return Optional.ofNullable(this.clientCert);
    }
    /**
     * @return The private key in the non-encrypted PKCS8 format you want to use to authenticate with the back-end server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.
     * 
     */
    public Optional<String> clientKey() {
        return Optional.ofNullable(this.clientKey);
    }
    /**
     * @return Indicates whether the logs should be compressed
     * 
     */
    public Optional<Boolean> compressLogs() {
        return Optional.ofNullable(this.compressLogs);
    }
    /**
     * @return The name of custom header passed with the request to the destination
     * 
     */
    public Optional<String> customHeaderName() {
        return Optional.ofNullable(this.customHeaderName);
    }
    /**
     * @return The custom header&#39;s contents passed with the request to the destination
     * 
     */
    public Optional<String> customHeaderValue() {
        return Optional.ofNullable(this.customHeaderValue);
    }
    /**
     * @return The name of the connector
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return The raw event Splunk URL where logs will be stored
     * 
     */
    public String endpoint() {
        return this.endpoint;
    }
    /**
     * @return The Event Collector token associated with Splunk account
     * 
     */
    public String eventCollectorToken() {
        return this.eventCollectorToken;
    }
    /**
     * @return Indicates whether mTLS is enabled or not.
     * 
     */
    public Optional<Boolean> mTls() {
        return Optional.ofNullable(this.mTls);
    }
    /**
     * @return The hostname that verifies the server&#39;s certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.
     * 
     */
    public Optional<String> tlsHostname() {
        return Optional.ofNullable(this.tlsHostname);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(DatastreamSplunkConnector defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String caCert;
        private @Nullable String clientCert;
        private @Nullable String clientKey;
        private @Nullable Boolean compressLogs;
        private @Nullable String customHeaderName;
        private @Nullable String customHeaderValue;
        private String displayName;
        private String endpoint;
        private String eventCollectorToken;
        private @Nullable Boolean mTls;
        private @Nullable String tlsHostname;
        public Builder() {}
        public Builder(DatastreamSplunkConnector defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.caCert = defaults.caCert;
    	      this.clientCert = defaults.clientCert;
    	      this.clientKey = defaults.clientKey;
    	      this.compressLogs = defaults.compressLogs;
    	      this.customHeaderName = defaults.customHeaderName;
    	      this.customHeaderValue = defaults.customHeaderValue;
    	      this.displayName = defaults.displayName;
    	      this.endpoint = defaults.endpoint;
    	      this.eventCollectorToken = defaults.eventCollectorToken;
    	      this.mTls = defaults.mTls;
    	      this.tlsHostname = defaults.tlsHostname;
        }

        @CustomType.Setter
        public Builder caCert(@Nullable String caCert) {

            this.caCert = caCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientCert(@Nullable String clientCert) {

            this.clientCert = clientCert;
            return this;
        }
        @CustomType.Setter
        public Builder clientKey(@Nullable String clientKey) {

            this.clientKey = clientKey;
            return this;
        }
        @CustomType.Setter
        public Builder compressLogs(@Nullable Boolean compressLogs) {

            this.compressLogs = compressLogs;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderName(@Nullable String customHeaderName) {

            this.customHeaderName = customHeaderName;
            return this;
        }
        @CustomType.Setter
        public Builder customHeaderValue(@Nullable String customHeaderValue) {

            this.customHeaderValue = customHeaderValue;
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            if (displayName == null) {
              throw new MissingRequiredPropertyException("DatastreamSplunkConnector", "displayName");
            }
            this.displayName = displayName;
            return this;
        }
        @CustomType.Setter
        public Builder endpoint(String endpoint) {
            if (endpoint == null) {
              throw new MissingRequiredPropertyException("DatastreamSplunkConnector", "endpoint");
            }
            this.endpoint = endpoint;
            return this;
        }
        @CustomType.Setter
        public Builder eventCollectorToken(String eventCollectorToken) {
            if (eventCollectorToken == null) {
              throw new MissingRequiredPropertyException("DatastreamSplunkConnector", "eventCollectorToken");
            }
            this.eventCollectorToken = eventCollectorToken;
            return this;
        }
        @CustomType.Setter
        public Builder mTls(@Nullable Boolean mTls) {

            this.mTls = mTls;
            return this;
        }
        @CustomType.Setter
        public Builder tlsHostname(@Nullable String tlsHostname) {

            this.tlsHostname = tlsHostname;
            return this;
        }
        public DatastreamSplunkConnector build() {
            final var _resultValue = new DatastreamSplunkConnector();
            _resultValue.caCert = caCert;
            _resultValue.clientCert = clientCert;
            _resultValue.clientKey = clientKey;
            _resultValue.compressLogs = compressLogs;
            _resultValue.customHeaderName = customHeaderName;
            _resultValue.customHeaderValue = customHeaderValue;
            _resultValue.displayName = displayName;
            _resultValue.endpoint = endpoint;
            _resultValue.eventCollectorToken = eventCollectorToken;
            _resultValue.mTls = mTls;
            _resultValue.tlsHostname = tlsHostname;
            return _resultValue;
        }
    }
}
