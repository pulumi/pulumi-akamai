// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.akamai.outputs;

import com.pulumi.akamai.outputs.GetGtmDomainPropertyLink;
import com.pulumi.akamai.outputs.GetGtmDomainPropertyLivenessTest;
import com.pulumi.akamai.outputs.GetGtmDomainPropertyStaticRrSet;
import com.pulumi.akamai.outputs.GetGtmDomainPropertyTrafficTarget;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;

@CustomType
public final class GetGtmDomainProperty {
    /**
     * @return Specifies a backup CNAME.
     * 
     */
    private String backupCname;
    /**
     * @return Specifies a backup IP.
     * 
     */
    private String backupIp;
    /**
     * @return Indicates whether download score based load balancing is enabled.
     * 
     */
    private Boolean balanceByDownloadScore;
    /**
     * @return Indicates the fully qualified name aliased to a particular property.
     * 
     */
    private String cname;
    /**
     * @return Descriptive comments for the property.
     * 
     */
    private String comments;
    /**
     * @return Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    private Integer dynamicTtl;
    /**
     * @return Specifies the failback delay in seconds.
     * 
     */
    private Integer failbackDelay;
    /**
     * @return Specifies the failover delay in seconds.
     * 
     */
    private Integer failoverDelay;
    /**
     * @return Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    private Boolean ghostDemandReporting;
    /**
     * @return Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    private Integer handoutLimit;
    /**
     * @return Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    private String handoutMode;
    /**
     * @return Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    private Double healthMax;
    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    private Double healthMultiplier;
    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    private Double healthThreshold;
    /**
     * @return Indicates the type of IP address handed out by a property.
     * 
     */
    private Boolean ipv6;
    /**
     * @return An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    private String lastModified;
    /**
     * @return Provides a URL path that allows direct navigation to the property.
     * 
     */
    private @Nullable List<GetGtmDomainPropertyLink> links;
    /**
     * @return Contains information about liveness tests.
     * 
     */
    private @Nullable List<GetGtmDomainPropertyLivenessTest> livenessTests;
    /**
     * @return Indicates the percent of load imbalance factor for the domain.
     * 
     */
    private Double loadImbalancePercentage;
    /**
     * @return A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    private String mapName;
    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    private Integer maxUnreachablePenalty;
    /**
     * @return Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    private Double minLiveFraction;
    /**
     * @return A descriptive label for the property.
     * 
     */
    private String name;
    /**
     * @return Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    private String scoreAggregationType;
    /**
     * @return Contains static recordsets.
     * 
     */
    private @Nullable List<GetGtmDomainPropertyStaticRrSet> staticRrSets;
    /**
     * @return Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    private Integer staticTtl;
    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    private Integer sticknessBonusConstant;
    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    private Integer sticknessBonusPercentage;
    /**
     * @return Traffic targets for the property.
     * 
     */
    private @Nullable List<GetGtmDomainPropertyTrafficTarget> trafficTargets;
    /**
     * @return Specifies the load balancing behvior for the property.
     * 
     */
    private String type;
    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    private Double unreachableThreshold;
    /**
     * @return For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    private Boolean useComputedTargets;
    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    private Integer weightedHashBitsForIpv4;
    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    private Integer weightedHashBitsForIpv6;

    private GetGtmDomainProperty() {}
    /**
     * @return Specifies a backup CNAME.
     * 
     */
    public String backupCname() {
        return this.backupCname;
    }
    /**
     * @return Specifies a backup IP.
     * 
     */
    public String backupIp() {
        return this.backupIp;
    }
    /**
     * @return Indicates whether download score based load balancing is enabled.
     * 
     */
    public Boolean balanceByDownloadScore() {
        return this.balanceByDownloadScore;
    }
    /**
     * @return Indicates the fully qualified name aliased to a particular property.
     * 
     */
    public String cname() {
        return this.cname;
    }
    /**
     * @return Descriptive comments for the property.
     * 
     */
    public String comments() {
        return this.comments;
    }
    /**
     * @return Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing.
     * 
     */
    public Integer dynamicTtl() {
        return this.dynamicTtl;
    }
    /**
     * @return Specifies the failback delay in seconds.
     * 
     */
    public Integer failbackDelay() {
        return this.failbackDelay;
    }
    /**
     * @return Specifies the failover delay in seconds.
     * 
     */
    public Integer failoverDelay() {
        return this.failoverDelay;
    }
    /**
     * @return Whether an alternate way to collect load feedback from a GTM Performance domain is enabled.
     * 
     */
    public Boolean ghostDemandReporting() {
        return this.ghostDemandReporting;
    }
    /**
     * @return Indicates the limit for the number of live IPs handed out to a DNS request.
     * 
     */
    public Integer handoutLimit() {
        return this.handoutLimit;
    }
    /**
     * @return Specifies how IPs are returned when more than one IP is alive and available.
     * 
     */
    public String handoutMode() {
        return this.handoutMode;
    }
    /**
     * @return Defines the absolute limit beyond which IPs are declared unhealthy.
     * 
     */
    public Double healthMax() {
        return this.healthMax;
    }
    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Double healthMultiplier() {
        return this.healthMultiplier;
    }
    /**
     * @return Configures a cutoff value that is computed from the median scores.
     * 
     */
    public Double healthThreshold() {
        return this.healthThreshold;
    }
    /**
     * @return Indicates the type of IP address handed out by a property.
     * 
     */
    public Boolean ipv6() {
        return this.ipv6;
    }
    /**
     * @return An ISO 8601 timestamp that indicates when the property was last changed.
     * 
     */
    public String lastModified() {
        return this.lastModified;
    }
    /**
     * @return Provides a URL path that allows direct navigation to the property.
     * 
     */
    public List<GetGtmDomainPropertyLink> links() {
        return this.links == null ? List.of() : this.links;
    }
    /**
     * @return Contains information about liveness tests.
     * 
     */
    public List<GetGtmDomainPropertyLivenessTest> livenessTests() {
        return this.livenessTests == null ? List.of() : this.livenessTests;
    }
    /**
     * @return Indicates the percent of load imbalance factor for the domain.
     * 
     */
    public Double loadImbalancePercentage() {
        return this.loadImbalancePercentage;
    }
    /**
     * @return A descriptive label for a geographic or a CIDR map that&#39;s required if the property is either geographic or cidrmapping.
     * 
     */
    public String mapName() {
        return this.mapName;
    }
    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.
     * 
     */
    public Integer maxUnreachablePenalty() {
        return this.maxUnreachablePenalty;
    }
    /**
     * @return Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.
     * 
     */
    public Double minLiveFraction() {
        return this.minLiveFraction;
    }
    /**
     * @return A descriptive label for the property.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.
     * 
     */
    public String scoreAggregationType() {
        return this.scoreAggregationType;
    }
    /**
     * @return Contains static recordsets.
     * 
     */
    public List<GetGtmDomainPropertyStaticRrSet> staticRrSets() {
        return this.staticRrSets == null ? List.of() : this.staticRrSets;
    }
    /**
     * @return Specifies the TTL in seconds for static resource records that don&#39;t change based on the requesting name server IP.
     * 
     */
    public Integer staticTtl() {
        return this.staticTtl;
    }
    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Integer sticknessBonusConstant() {
        return this.sticknessBonusConstant;
    }
    /**
     * @return Specifies a percentage used to configure data center affinity.
     * 
     */
    public Integer sticknessBonusPercentage() {
        return this.sticknessBonusPercentage;
    }
    /**
     * @return Traffic targets for the property.
     * 
     */
    public List<GetGtmDomainPropertyTrafficTarget> trafficTargets() {
        return this.trafficTargets == null ? List.of() : this.trafficTargets;
    }
    /**
     * @return Specifies the load balancing behvior for the property.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return For performance domains, this specifies a penalty value that&#39;s added to liveness test scores when data centers have an aggregated loss fraction higher than this value.
     * 
     */
    public Double unreachableThreshold() {
        return this.unreachableThreshold;
    }
    /**
     * @return For load-feedback domains only, this specifies that you want GTM to automatically compute target load.
     * 
     */
    public Boolean useComputedTargets() {
        return this.useComputedTargets;
    }
    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv4; the default value is 32 (the entire address).
     * 
     */
    public Integer weightedHashBitsForIpv4() {
        return this.weightedHashBitsForIpv4;
    }
    /**
     * @return For weighted hashed properties, how many leading bits of the client nameserver IP address to include when computing a hash for picking a datacenter for a client nameserver using IPv6; the default value is 128 (the entire address).
     * 
     */
    public Integer weightedHashBitsForIpv6() {
        return this.weightedHashBitsForIpv6;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetGtmDomainProperty defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String backupCname;
        private String backupIp;
        private Boolean balanceByDownloadScore;
        private String cname;
        private String comments;
        private Integer dynamicTtl;
        private Integer failbackDelay;
        private Integer failoverDelay;
        private Boolean ghostDemandReporting;
        private Integer handoutLimit;
        private String handoutMode;
        private Double healthMax;
        private Double healthMultiplier;
        private Double healthThreshold;
        private Boolean ipv6;
        private String lastModified;
        private @Nullable List<GetGtmDomainPropertyLink> links;
        private @Nullable List<GetGtmDomainPropertyLivenessTest> livenessTests;
        private Double loadImbalancePercentage;
        private String mapName;
        private Integer maxUnreachablePenalty;
        private Double minLiveFraction;
        private String name;
        private String scoreAggregationType;
        private @Nullable List<GetGtmDomainPropertyStaticRrSet> staticRrSets;
        private Integer staticTtl;
        private Integer sticknessBonusConstant;
        private Integer sticknessBonusPercentage;
        private @Nullable List<GetGtmDomainPropertyTrafficTarget> trafficTargets;
        private String type;
        private Double unreachableThreshold;
        private Boolean useComputedTargets;
        private Integer weightedHashBitsForIpv4;
        private Integer weightedHashBitsForIpv6;
        public Builder() {}
        public Builder(GetGtmDomainProperty defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.backupCname = defaults.backupCname;
    	      this.backupIp = defaults.backupIp;
    	      this.balanceByDownloadScore = defaults.balanceByDownloadScore;
    	      this.cname = defaults.cname;
    	      this.comments = defaults.comments;
    	      this.dynamicTtl = defaults.dynamicTtl;
    	      this.failbackDelay = defaults.failbackDelay;
    	      this.failoverDelay = defaults.failoverDelay;
    	      this.ghostDemandReporting = defaults.ghostDemandReporting;
    	      this.handoutLimit = defaults.handoutLimit;
    	      this.handoutMode = defaults.handoutMode;
    	      this.healthMax = defaults.healthMax;
    	      this.healthMultiplier = defaults.healthMultiplier;
    	      this.healthThreshold = defaults.healthThreshold;
    	      this.ipv6 = defaults.ipv6;
    	      this.lastModified = defaults.lastModified;
    	      this.links = defaults.links;
    	      this.livenessTests = defaults.livenessTests;
    	      this.loadImbalancePercentage = defaults.loadImbalancePercentage;
    	      this.mapName = defaults.mapName;
    	      this.maxUnreachablePenalty = defaults.maxUnreachablePenalty;
    	      this.minLiveFraction = defaults.minLiveFraction;
    	      this.name = defaults.name;
    	      this.scoreAggregationType = defaults.scoreAggregationType;
    	      this.staticRrSets = defaults.staticRrSets;
    	      this.staticTtl = defaults.staticTtl;
    	      this.sticknessBonusConstant = defaults.sticknessBonusConstant;
    	      this.sticknessBonusPercentage = defaults.sticknessBonusPercentage;
    	      this.trafficTargets = defaults.trafficTargets;
    	      this.type = defaults.type;
    	      this.unreachableThreshold = defaults.unreachableThreshold;
    	      this.useComputedTargets = defaults.useComputedTargets;
    	      this.weightedHashBitsForIpv4 = defaults.weightedHashBitsForIpv4;
    	      this.weightedHashBitsForIpv6 = defaults.weightedHashBitsForIpv6;
        }

        @CustomType.Setter
        public Builder backupCname(String backupCname) {
            if (backupCname == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "backupCname");
            }
            this.backupCname = backupCname;
            return this;
        }
        @CustomType.Setter
        public Builder backupIp(String backupIp) {
            if (backupIp == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "backupIp");
            }
            this.backupIp = backupIp;
            return this;
        }
        @CustomType.Setter
        public Builder balanceByDownloadScore(Boolean balanceByDownloadScore) {
            if (balanceByDownloadScore == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "balanceByDownloadScore");
            }
            this.balanceByDownloadScore = balanceByDownloadScore;
            return this;
        }
        @CustomType.Setter
        public Builder cname(String cname) {
            if (cname == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "cname");
            }
            this.cname = cname;
            return this;
        }
        @CustomType.Setter
        public Builder comments(String comments) {
            if (comments == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "comments");
            }
            this.comments = comments;
            return this;
        }
        @CustomType.Setter
        public Builder dynamicTtl(Integer dynamicTtl) {
            if (dynamicTtl == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "dynamicTtl");
            }
            this.dynamicTtl = dynamicTtl;
            return this;
        }
        @CustomType.Setter
        public Builder failbackDelay(Integer failbackDelay) {
            if (failbackDelay == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "failbackDelay");
            }
            this.failbackDelay = failbackDelay;
            return this;
        }
        @CustomType.Setter
        public Builder failoverDelay(Integer failoverDelay) {
            if (failoverDelay == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "failoverDelay");
            }
            this.failoverDelay = failoverDelay;
            return this;
        }
        @CustomType.Setter
        public Builder ghostDemandReporting(Boolean ghostDemandReporting) {
            if (ghostDemandReporting == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "ghostDemandReporting");
            }
            this.ghostDemandReporting = ghostDemandReporting;
            return this;
        }
        @CustomType.Setter
        public Builder handoutLimit(Integer handoutLimit) {
            if (handoutLimit == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "handoutLimit");
            }
            this.handoutLimit = handoutLimit;
            return this;
        }
        @CustomType.Setter
        public Builder handoutMode(String handoutMode) {
            if (handoutMode == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "handoutMode");
            }
            this.handoutMode = handoutMode;
            return this;
        }
        @CustomType.Setter
        public Builder healthMax(Double healthMax) {
            if (healthMax == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthMax");
            }
            this.healthMax = healthMax;
            return this;
        }
        @CustomType.Setter
        public Builder healthMultiplier(Double healthMultiplier) {
            if (healthMultiplier == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthMultiplier");
            }
            this.healthMultiplier = healthMultiplier;
            return this;
        }
        @CustomType.Setter
        public Builder healthThreshold(Double healthThreshold) {
            if (healthThreshold == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "healthThreshold");
            }
            this.healthThreshold = healthThreshold;
            return this;
        }
        @CustomType.Setter
        public Builder ipv6(Boolean ipv6) {
            if (ipv6 == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "ipv6");
            }
            this.ipv6 = ipv6;
            return this;
        }
        @CustomType.Setter
        public Builder lastModified(String lastModified) {
            if (lastModified == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "lastModified");
            }
            this.lastModified = lastModified;
            return this;
        }
        @CustomType.Setter
        public Builder links(@Nullable List<GetGtmDomainPropertyLink> links) {

            this.links = links;
            return this;
        }
        public Builder links(GetGtmDomainPropertyLink... links) {
            return links(List.of(links));
        }
        @CustomType.Setter
        public Builder livenessTests(@Nullable List<GetGtmDomainPropertyLivenessTest> livenessTests) {

            this.livenessTests = livenessTests;
            return this;
        }
        public Builder livenessTests(GetGtmDomainPropertyLivenessTest... livenessTests) {
            return livenessTests(List.of(livenessTests));
        }
        @CustomType.Setter
        public Builder loadImbalancePercentage(Double loadImbalancePercentage) {
            if (loadImbalancePercentage == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "loadImbalancePercentage");
            }
            this.loadImbalancePercentage = loadImbalancePercentage;
            return this;
        }
        @CustomType.Setter
        public Builder mapName(String mapName) {
            if (mapName == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "mapName");
            }
            this.mapName = mapName;
            return this;
        }
        @CustomType.Setter
        public Builder maxUnreachablePenalty(Integer maxUnreachablePenalty) {
            if (maxUnreachablePenalty == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "maxUnreachablePenalty");
            }
            this.maxUnreachablePenalty = maxUnreachablePenalty;
            return this;
        }
        @CustomType.Setter
        public Builder minLiveFraction(Double minLiveFraction) {
            if (minLiveFraction == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "minLiveFraction");
            }
            this.minLiveFraction = minLiveFraction;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder scoreAggregationType(String scoreAggregationType) {
            if (scoreAggregationType == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "scoreAggregationType");
            }
            this.scoreAggregationType = scoreAggregationType;
            return this;
        }
        @CustomType.Setter
        public Builder staticRrSets(@Nullable List<GetGtmDomainPropertyStaticRrSet> staticRrSets) {

            this.staticRrSets = staticRrSets;
            return this;
        }
        public Builder staticRrSets(GetGtmDomainPropertyStaticRrSet... staticRrSets) {
            return staticRrSets(List.of(staticRrSets));
        }
        @CustomType.Setter
        public Builder staticTtl(Integer staticTtl) {
            if (staticTtl == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "staticTtl");
            }
            this.staticTtl = staticTtl;
            return this;
        }
        @CustomType.Setter
        public Builder sticknessBonusConstant(Integer sticknessBonusConstant) {
            if (sticknessBonusConstant == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "sticknessBonusConstant");
            }
            this.sticknessBonusConstant = sticknessBonusConstant;
            return this;
        }
        @CustomType.Setter
        public Builder sticknessBonusPercentage(Integer sticknessBonusPercentage) {
            if (sticknessBonusPercentage == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "sticknessBonusPercentage");
            }
            this.sticknessBonusPercentage = sticknessBonusPercentage;
            return this;
        }
        @CustomType.Setter
        public Builder trafficTargets(@Nullable List<GetGtmDomainPropertyTrafficTarget> trafficTargets) {

            this.trafficTargets = trafficTargets;
            return this;
        }
        public Builder trafficTargets(GetGtmDomainPropertyTrafficTarget... trafficTargets) {
            return trafficTargets(List.of(trafficTargets));
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "type");
            }
            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder unreachableThreshold(Double unreachableThreshold) {
            if (unreachableThreshold == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "unreachableThreshold");
            }
            this.unreachableThreshold = unreachableThreshold;
            return this;
        }
        @CustomType.Setter
        public Builder useComputedTargets(Boolean useComputedTargets) {
            if (useComputedTargets == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "useComputedTargets");
            }
            this.useComputedTargets = useComputedTargets;
            return this;
        }
        @CustomType.Setter
        public Builder weightedHashBitsForIpv4(Integer weightedHashBitsForIpv4) {
            if (weightedHashBitsForIpv4 == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "weightedHashBitsForIpv4");
            }
            this.weightedHashBitsForIpv4 = weightedHashBitsForIpv4;
            return this;
        }
        @CustomType.Setter
        public Builder weightedHashBitsForIpv6(Integer weightedHashBitsForIpv6) {
            if (weightedHashBitsForIpv6 == null) {
              throw new MissingRequiredPropertyException("GetGtmDomainProperty", "weightedHashBitsForIpv6");
            }
            this.weightedHashBitsForIpv6 = weightedHashBitsForIpv6;
            return this;
        }
        public GetGtmDomainProperty build() {
            final var _resultValue = new GetGtmDomainProperty();
            _resultValue.backupCname = backupCname;
            _resultValue.backupIp = backupIp;
            _resultValue.balanceByDownloadScore = balanceByDownloadScore;
            _resultValue.cname = cname;
            _resultValue.comments = comments;
            _resultValue.dynamicTtl = dynamicTtl;
            _resultValue.failbackDelay = failbackDelay;
            _resultValue.failoverDelay = failoverDelay;
            _resultValue.ghostDemandReporting = ghostDemandReporting;
            _resultValue.handoutLimit = handoutLimit;
            _resultValue.handoutMode = handoutMode;
            _resultValue.healthMax = healthMax;
            _resultValue.healthMultiplier = healthMultiplier;
            _resultValue.healthThreshold = healthThreshold;
            _resultValue.ipv6 = ipv6;
            _resultValue.lastModified = lastModified;
            _resultValue.links = links;
            _resultValue.livenessTests = livenessTests;
            _resultValue.loadImbalancePercentage = loadImbalancePercentage;
            _resultValue.mapName = mapName;
            _resultValue.maxUnreachablePenalty = maxUnreachablePenalty;
            _resultValue.minLiveFraction = minLiveFraction;
            _resultValue.name = name;
            _resultValue.scoreAggregationType = scoreAggregationType;
            _resultValue.staticRrSets = staticRrSets;
            _resultValue.staticTtl = staticTtl;
            _resultValue.sticknessBonusConstant = sticknessBonusConstant;
            _resultValue.sticknessBonusPercentage = sticknessBonusPercentage;
            _resultValue.trafficTargets = trafficTargets;
            _resultValue.type = type;
            _resultValue.unreachableThreshold = unreachableThreshold;
            _resultValue.useComputedTargets = useComputedTargets;
            _resultValue.weightedHashBitsForIpv4 = weightedHashBitsForIpv4;
            _resultValue.weightedHashBitsForIpv6 = weightedHashBitsForIpv6;
            return _resultValue;
        }
    }
}
