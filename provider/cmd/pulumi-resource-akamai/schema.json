{
    "name": "akamai",
    "description": "A Pulumi package for creating and managing akamai cloud resources.",
    "keywords": [
        "pulumi",
        "akamai"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`akamai` Terraform Provider](https://github.com/akamai/terraform-provider-akamai).",
    "repository": "https://github.com/pulumi/pulumi-akamai",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "akamai": "Akamai"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing akamai cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/akamai/terraform-provider-akamai)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-akamai` repo](https://github.com/pulumi/pulumi-akamai/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-akamai` repo](https://github.com/akamai/terraform-provider-akamai/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/akamai/terraform-provider-akamai)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-akamai` repo](https://github.com/pulumi/pulumi-akamai/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-akamai` repo](https://github.com/akamai/terraform-provider-akamai/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:config/appsecs:appsecs"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:config/config:config",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:config/dns:dns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:config/gtm:gtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:config/networks:networks"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:config/property:property",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        }
    },
    "types": {
        "akamai:config/appsecs:appsecs": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/config:config": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/dns:dns": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/gtm:gtm": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/networks:networks": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/property:property": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "The hashing algorithm.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The key name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "String known between transfer endpoints.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "name",
                "secret"
            ]
        },
        "akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter": {
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city in which the data center is located.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "Whether to override the cloud server host header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudService": {
                    "type": "boolean",
                    "description": "Whether this datacenter is a cloud service.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "continent": {
                    "type": "string",
                    "description": "The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "description": "The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "description": "The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude value for the data center. This member supports six decimal places of precision.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "livenessHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude value for the data center. This member supports six decimal places of precision.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "number",
                    "description": "The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "The state, province, or region where the data center is located.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "continent",
                "country",
                "latitude",
                "longitude",
                "originId",
                "percent"
            ]
        },
        "akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings": {
            "properties": {
                "additionalHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Maps additional case-insensitive HTTP header names included to the liveness testing requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeader": {
                    "type": "string",
                    "description": "The Host header for the liveness HTTP request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "interval": {
                    "type": "integer",
                    "description": "The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "Whether to validate the origin certificate for an HTTPS request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol or scheme for the database, either `HTTP` or `HTTPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "The request used for TCP and TCPS tests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "The response used for TCP and TCPS tests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status3xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status4xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status5xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "number",
                    "description": "The number of seconds the system waits before failing the liveness test.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path",
                "port",
                "protocol"
            ]
        },
        "akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr": {
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "description": "Your organizational unit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "description": "Your state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "countryCode",
                "organization",
                "organizationalUnit",
                "state"
            ]
        },
        "akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domain",
                        "fullPath",
                        "responseBody"
                    ]
                }
            }
        },
        "akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domain",
                        "fullPath",
                        "responseBody"
                    ]
                }
            }
        },
        "akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration": {
            "properties": {
                "clientMutualAuthentication": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication:CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication",
                    "description": "The configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloneDnsNames": {
                    "type": "boolean",
                    "description": "Whether CPS should direct traffic using all the SANs you listed in the SANs parameter when you created your enrollment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disallowedTlsVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The TLS protocol version to disallow. CPS uses the TLS protocols that Akamai currently supports as a best practice.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geography": {
                    "type": "string",
                    "description": "Lists where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia. You can only use the setting to include China and Russia if your Akamai contract specifies your ability to do so and you have approval from the Chinese and Russian government.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mustHaveCiphers": {
                    "type": "string",
                    "description": "The ciphers to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ocspStapling": {
                    "type": "string",
                    "description": "Whether to use OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response must be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want visitors to your site to contact the CA directly for an OSCP response. OCSP allows you to obtain the revocation status of a certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferredCiphers": {
                    "type": "string",
                    "description": "Ciphers that you preferably want to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quicEnabled": {
                    "type": "boolean",
                    "description": "Whether to use the QUIC transport layer network protocol.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "geography"
            ]
        },
        "akamai:index/CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication:CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication": {
            "properties": {
                "ocspEnabled": {
                    "type": "boolean",
                    "description": "Whether you want to enable the Online Certificate Status Protocol (OCSP) stapling for client certificates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sendCaListToClient": {
                    "type": "boolean",
                    "description": "Whether you want to enable the server to send the certificate authority (CA) list to the client.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setId": {
                    "type": "string",
                    "description": "The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "name",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/DatastreamAzureConnector:DatastreamAzureConnector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountName": {
                    "type": "string",
                    "description": "- (Required) Specifies the Azure Storage account name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containerName": {
                    "type": "string",
                    "description": "- (Required) Specifies the Azure Storage container name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "accountName",
                "connectorName",
                "containerName",
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "accountName",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "containerName",
                        "path"
                    ]
                }
            }
        },
        "akamai:index/DatastreamConfig:DatastreamConfig": {
            "properties": {
                "delimiter": {
                    "type": "string",
                    "description": "A delimiter that you want to use to separate data set fields in the log lines. Currently, `SPACE` is the only available delimiter. This field is required for the `STRUCTURED` log file `format`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "format": {
                    "type": "string",
                    "description": "- (Required) The format in which you want to receive log files, either `STRUCTURED` or `JSON`. When `delimiter` is present in the request, `STRUCTURED` is the mandatory format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequency": {
                    "$ref": "#/types/akamai:index/DatastreamConfigFrequency:DatastreamConfigFrequency",
                    "description": "- (Required) How often you want to collect logs from each uploader and send them to a destination.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uploadFilePrefix": {
                    "type": "string",
                    "description": "- (Optional) The prefix of the log file that you want to send to a destination. It’s a string of at most 200 characters. If unspecified, defaults to `ak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uploadFileSuffix": {
                    "type": "string",
                    "description": "The suffix of the log file that you want to send to a destination. It’s a static string of at most 10 characters. If unspecified, defaults to `ds`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "format",
                "frequency"
            ]
        },
        "akamai:index/DatastreamConfigFrequency:DatastreamConfigFrequency": {
            "properties": {
                "timeInSec": {
                    "type": "integer",
                    "description": "- (Required) The time in seconds after which the system bundles log lines into a file and sends it to a destination. `30` or `60` are the possible values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "timeInSec"
            ]
        },
        "akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector": {
            "properties": {
                "authToken": {
                    "type": "string",
                    "description": "- (Required) **Secret**. The API key associated with your Datadog account. See [View API keys in Datadog](https://docs.datadoghq.com/account_management/api-app-keys/#api-keys).\n* `compress logs` - (Optional) Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "description": "The service of the Datadog connector. A service groups together endpoints, queries, or jobs for the purposes of scaling instances. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "source": {
                    "type": "string",
                    "description": "The source of the Datadog connector. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_collection/?tab=http#reserved-attributes).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tags": {
                    "type": "string",
                    "description": "The tags of the Datadog connector. See [View Datadog tags](https://docs.datadoghq.com/getting_started/tagging/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authToken",
                "connectorName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authToken",
                        "connectorId",
                        "connectorName",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamGcsConnector:DatastreamGcsConnector": {
            "properties": {
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "description": "- (Required) **Secret**. The contents of the JSON private key you generated and downloaded in your Google Cloud Storage account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "- (Required) The unique ID of your Google Cloud project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "- (Required)\tThe name of the service account with the storage.object.create permission or Storage Object Creator role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucket",
                "connectorName",
                "privateKey",
                "projectId",
                "serviceAccountName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "privateKey",
                        "projectId",
                        "serviceAccountName"
                    ]
                }
            }
        },
        "akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector": {
            "properties": {
                "authenticationType": {
                    "type": "string",
                    "description": "Either `NONE` for no authentication, or `BASIC`. For basic authentication, provide the `user_name` and `password` you set in your custom HTTPS endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "**Secret**. Enter the password you set in your custom HTTPS endpoint for authentication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "**Secret**. Enter the valid username you set in your custom HTTPS endpoint for authentication.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authenticationType",
                "connectorName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authenticationType",
                        "connectorId",
                        "connectorName",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamOracleConnector:DatastreamOracleConnector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace of your Oracle Cloud Storage account. See [Understanding Object Storage namespaces](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/understandingnamespaces.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "**Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "bucket",
                "connectorName",
                "namespace",
                "path",
                "region",
                "secretAccessKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "namespace",
                        "path",
                        "region",
                        "secretAccessKey"
                    ]
                }
            }
        },
        "akamai:index/DatastreamS3Connector:DatastreamS3Connector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "**Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "bucket",
                "connectorName",
                "path",
                "region",
                "secretAccessKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "path",
                        "region",
                        "secretAccessKey"
                    ]
                }
            }
        },
        "akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector": {
            "properties": {
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventCollectorToken": {
                    "type": "string",
                    "description": "- (Required) **Secret**. The Event Collector token associated with your Splunk account. See [View usage of Event Collector token in Splunk](https://docs.splunk.com/Documentation/Splunk/8.0.3/Data/UsetheHTTPEventCollector).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectorName",
                "eventCollectorToken",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectorId",
                        "connectorName",
                        "eventCollectorToken",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector": {
            "properties": {
                "collectorCode": {
                    "type": "string",
                    "description": "**Secret**. The unique HTTP collector code of your Sumo Logic `endpoint`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "The Sumo Logic collection endpoint where you want to send your logs. You should follow the `https://\u003cSumoEndpoint\u003e/receiver/v1/http` format and pass the collector code in the `collectorCode` argument.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collectorCode",
                "connectorName",
                "endpoint"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collectorCode",
                        "connectorId",
                        "connectorName",
                        "endpoint"
                    ]
                }
            }
        },
        "akamai:index/DnsZoneTsigKey:DnsZoneTsigKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "The hashing algorithm.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The key name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "String known between transfer endpoints.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "name",
                "secret"
            ]
        },
        "akamai:index/EdgeKvInitialData:EdgeKvInitialData": {
            "properties": {
                "group": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "akamai:index/GtmAsmapAssignment:GtmAsmapAssignment": {
            "properties": {
                "asNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies an array of AS numbers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "asNumbers",
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment": {
            "properties": {
                "blocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of CIDR blocks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject": {
            "properties": {
                "loadObject": {
                    "type": "string",
                    "description": "A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port to connect to when requesting the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of servers to request the load object from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmGeomapAssignment:GtmGeomapAssignment": {
            "properties": {
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest": {
            "properties": {
                "answersRequired": {
                    "type": "boolean",
                    "description": "If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableNonstandardPortWarning": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, disables warnings when non-standard ports are used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorPenalty": {
                    "type": "number",
                    "description": "Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError3xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError4xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError5xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader"
                    },
                    "description": "Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "recursionRequested": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "Specifies a request string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceType": {
                    "type": "string",
                    "description": "Specifies the query type, if `test_object_protocol` is DNS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "Specifies a response string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientCertificate": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientPrivateKey": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testInterval": {
                    "type": "integer",
                    "description": "Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObject": {
                    "type": "string",
                    "description": "Specifies the static text that acts as a stand-in for the data that you're sending on the network.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPassword": {
                    "type": "string",
                    "description": "Specifies the test object's password. It is required if testObjectProtocol is ftp.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPort": {
                    "type": "integer",
                    "description": "Specifies the port number for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectProtocol": {
                    "type": "string",
                    "description": "Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectUsername": {
                    "type": "string",
                    "description": "A descriptive name for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testTimeout": {
                    "type": "number",
                    "description": "Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeoutPenalty": {
                    "type": "number",
                    "description": "Specifies the score to be reported if the liveness test times out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "testInterval",
                "testObject",
                "testObjectProtocol",
                "testTimeout"
            ]
        },
        "akamai:index/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet": {
            "properties": {
                "rdatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) An array of data strings, representing multiple records within a set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "The number of seconds that this record should live in a resolver's cache before being refetched.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "handoutCname": {
                    "type": "string",
                    "description": "Specifies an optional data center for the property. Used when there are no servers configured for the property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Identifies the IP address or the hostnames of the servers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "Specifies the traffic weight for the target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObject": {
                    "type": "string",
                    "description": "Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port of the `load_object`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Specifies a list of servers from which to request the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useDefaultLoadObject": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether a default `load_object` is used for the resources.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/PropertyActivationRuleError:PropertyActivationRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyHostname:PropertyHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "description": "The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://learn.akamai.com/en-us/products/core_features/certificate_provisioning_system.html), or `DEFAULT` for certificates provisioned automatically.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostnameCertStatus:PropertyHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "description": "A string containing the original origin's hostname. For example, `\"example.org\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "description": "A string containing the hostname for edge content. For example,  `\"example.org.edgesuite.net\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "cnameFrom",
                "cnameTo"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certProvisioningType",
                        "certStatuses",
                        "cnameFrom",
                        "cnameTo",
                        "cnameType",
                        "edgeHostnameId"
                    ]
                }
            }
        },
        "akamai:index/PropertyHostnameCertStatus:PropertyHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "hostname",
                        "productionStatus",
                        "stagingStatus",
                        "target"
                    ]
                }
            }
        },
        "akamai:index/PropertyOrigin:PropertyOrigin": {
            "properties": {
                "cacheKeyHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableTrueClientIp": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyRuleError:PropertyRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyRuleWarning:PropertyRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderAppsec:ProviderAppsec": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderConfig:ProviderConfig": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderDns:ProviderDns": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderGtm:ProviderGtm": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderNetwork:ProviderNetwork": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderProperty:ProviderProperty": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n* `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatch:getCloudletsApiPrioritizationMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passThroughPercent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "passThroughPercent",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "passThroughPercent"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatch:getCloudletsApiPrioritizationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApplicationLoadBalancerDataCenter:getCloudletsApplicationLoadBalancerDataCenter": {
            "properties": {
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudService": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "continent": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "livenessHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originId": {
                    "type": "string",
                    "description": "- (Required) A unique identifier for the Conditional Origin that supports the load balancing configuration. The Conditional Origin type must be set to `APPLICATION_LOAD_BALANCER` in the `origin` behavior. See property rules for more information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateOrProvince": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "cloudServerHostHeaderOverride",
                "cloudService",
                "continent",
                "country",
                "hostname",
                "latitude",
                "livenessHosts",
                "longitude",
                "originId",
                "percent",
                "stateOrProvince"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerLivenessSetting:getCloudletsApplicationLoadBalancerLivenessSetting": {
            "properties": {
                "additionalHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "interval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status3xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status4xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status5xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalHeaders",
                "hostHeader",
                "interval",
                "path",
                "peerCertificateVerification",
                "port",
                "protocol",
                "requestString",
                "responseString",
                "status3xxFailure",
                "status4xxFailure",
                "status5xxFailure",
                "timeout"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting"
                    },
                    "description": "- (Required) Defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, the Edge Server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "integer",
                    "description": "- (Optional) An identifier for Akamai internal use only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) The URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match supports default rules that apply to all requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "- (Required) The ID of the Conditional Origin the requests are forwarded to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "originId"
            ]
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `clientip`, `continent`, `cookie`, `countrycode`, `deviceCharacteristics`, `extension`, `header`, `hostname`, `method`, `path`, `protocol`, `proxy`, `query`, `regioncode`, or `range`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings:getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings:getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "- (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pathAndQs": {
                    "type": "string",
                    "description": "- (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "- (Required) The URL Edge Redirector redirects the request to. If you're using `use_relative_url`, you can enter a path for the value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "description": "- (Required) The HTTP response status code, which is either `301` (permanent redirect) or `302` (temporary redirect).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useRelativeUrl": {
                    "type": "string",
                    "description": "- (Optional) If set to `relative_url`, takes the path you specify in the `redirect_url` argument and sets it in the response’s Location header. The client or browser receiving the request decides which protocol and hostname to use. If set to `copy_scheme_hostname`, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information you specify in the `redirect_url` argument. This absolute path is set in the response’s Location header. If you do not specify use_relative_url or set to `none`, then specify the `redirect_url` argument as a fully-qualified URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "redirectUrl",
                "statusCode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "redirectUrl",
                        "statusCode"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings:getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatch:getCloudletsForwardRewriteMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings:getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "- (Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pathAndQs": {
                    "type": "string",
                    "description": "- (Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatch:getCloudletsForwardRewriteMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings:getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatch:getCloudletsPhasedReleaseMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match supports default rules that apply to all requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings:getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "- (Required) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "integer",
                    "description": "- (Required)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "originId",
                "percent"
            ]
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatch:getCloudletsPhasedReleaseMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPolicyActivation:getCloudletsPolicyActivation": {
            "properties": {
                "apiVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "network": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPolicyActivationPolicyInfo:getCloudletsPolicyActivationPolicyInfo"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPolicyActivationPropertyInfo:getCloudletsPolicyActivationPropertyInfo"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiVersion",
                "network",
                "policyInfos",
                "propertyInfos"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsPolicyActivationPolicyInfo:getCloudletsPolicyActivationPolicyInfo": {
            "properties": {
                "activatedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "activationDate": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyId": {
                    "type": "integer",
                    "description": "- (Required) An integer identifier that is associated with all versions of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusDetail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "description": "- (Optional) The version number of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "activatedBy",
                "activationDate",
                "name",
                "policyId",
                "status",
                "statusDetail",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsPolicyActivationPropertyInfo:getCloudletsPolicyActivationPropertyInfo": {
            "properties": {
                "activatedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "activationDate": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "description": "- (Optional) The version number of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "activatedBy",
                "activationDate",
                "groupId",
                "name",
                "status",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule": {
            "properties": {
                "allowDeny": {
                    "type": "string",
                    "description": "- (Required) If set to `allow`, the request is sent to origin when all conditions are true. If set to `deny`, the request is denied when all conditions are true. If set to `denybranded`, the request is denied and rerouted according to the Request Control behavior settings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule. When a rule is disabled it's not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatch:getCloudletsRequestControlMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "- (Optional) Match on all incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowDeny",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "allowDeny"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatch:getCloudletsRequestControlMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "- (Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "- (Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n* `pass_through_percent`- (Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin. Enter `-1` to send everyone to the waiting room.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch"
                    },
                    "description": "- (Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passThroughPercent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "- (Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "passThroughPercent",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "passThroughPercent"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "- (Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "- (Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "- (Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "- (Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "- (Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "- (Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "- (Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "- (Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "- (Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "- (Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getContractsContract:getContractsContract": {
            "properties": {
                "contractId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contractTypeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractId",
                "contractTypeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamActivationHistoryActivation:getDatastreamActivationHistoryActivation": {
            "properties": {
                "createdBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isActive": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamId": {
                    "type": "integer",
                    "description": "- (Required) A stream's unique identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamVersionId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdBy",
                "createdDate",
                "isActive",
                "streamId",
                "streamVersionId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamDatasetFieldsField:getDatastreamDatasetFieldsField": {
            "properties": {
                "datasetFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getDatastreamDatasetFieldsFieldDatasetField:getDatastreamDatasetFieldsFieldDatasetField"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetGroupDescription": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetGroupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datasetFields",
                "datasetGroupDescription",
                "datasetGroupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamDatasetFieldsFieldDatasetField:getDatastreamDatasetFieldsFieldDatasetField": {
            "properties": {
                "datasetFieldDescription": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldJsonKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datasetFieldDescription",
                "datasetFieldId",
                "datasetFieldJsonKey",
                "datasetFieldName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getGroupsGroup:getGroupsGroup": {
            "properties": {
                "contractIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parentGroupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractIds",
                "groupId",
                "groupName",
                "parentGroupId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamGrantableRolesGrantableRole:getIamGrantableRolesGrantableRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "grantedRoleId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "description",
                "grantedRoleId",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamRolesRole:getIamRolesRole": {
            "properties": {
                "createdBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeCreated": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeModified": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdBy",
                "description",
                "modifiedBy",
                "name",
                "roleId",
                "timeCreated",
                "timeModified",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamTimezonesTimezone:getIamTimezonesTimezone": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "offset": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "posix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timezone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "description",
                "offset",
                "posix",
                "timezone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertiesProperty:getPropertiesProperty": {
            "properties": {
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latestVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "note": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ruleFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractId",
                "groupId",
                "latestVersion",
                "note",
                "productId",
                "productionVersion",
                "propertyId",
                "propertyName",
                "ruleFormat",
                "stagingVersion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertiesSearchProperty:getPropertiesSearchProperty": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "assetId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contractId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updatedByUser": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updatedDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "assetId",
                "contractId",
                "edgeHostname",
                "groupId",
                "hostname",
                "productionStatus",
                "propertyId",
                "propertyName",
                "propertyVersion",
                "stagingStatus",
                "updatedByUser",
                "updatedDate"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyHostnamesHostname:getPropertyHostnamesHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getPropertyHostnamesHostnameCertStatus:getPropertyHostnamesHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "certStatuses",
                "cnameFrom",
                "cnameTo",
                "cnameType",
                "edgeHostnameId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyHostnamesHostnameCertStatus:getPropertyHostnamesHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "hostname",
                "productionStatus",
                "stagingStatus",
                "target"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyProductsProduct:getPropertyProductsProduct": {
            "properties": {
                "productId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "productId",
                "productName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate": {
            "properties": {
                "templateData": {
                    "type": "string",
                    "description": "The content of the JSON template as a string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "templateDir": {
                    "type": "string",
                    "description": "The absolute or relative path to the directory containing the template files. The path must end with `property-snippets`, the required directory name. For example: `template_dir = abspath(\"${path.root}/property-snippets/\")`, or `template_dir = \"property-snippets/\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "templateData",
                "templateDir"
            ]
        },
        "akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the variable used in the template.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of variable: `string`, `number`, `bool`, or `jsonBlock`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable passed as a string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyHostname:PropertyHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "description": "The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://learn.akamai.com/en-us/products/core_features/certificate_provisioning_system.html), or `DEFAULT` for certificates provisioned automatically.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostnameCertStatus:PropertyHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "description": "A string containing the original origin's hostname. For example, `\"example.org\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "description": "A string containing the hostname for edge content. For example,  `\"example.org.edgesuite.net\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "cnameFrom",
                "cnameTo"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certProvisioningType",
                        "certStatuses",
                        "cnameFrom",
                        "cnameTo",
                        "cnameType",
                        "edgeHostnameId"
                    ]
                }
            }
        },
        "akamai:properties/PropertyHostnameCertStatus:PropertyHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "hostname",
                        "productionStatus",
                        "stagingStatus",
                        "target"
                    ]
                }
            }
        },
        "akamai:properties/PropertyOrigin:PropertyOrigin": {
            "properties": {
                "cacheKeyHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableTrueClientIp": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyRuleError:PropertyRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyRuleWarning:PropertyRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment": {
            "properties": {
                "asNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies an array of AS numbers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "asNumbers",
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment": {
            "properties": {
                "blocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of CIDR blocks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject": {
            "properties": {
                "loadObject": {
                    "type": "string",
                    "description": "A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port to connect to when requesting the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of servers to request the load object from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment": {
            "properties": {
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest": {
            "properties": {
                "answersRequired": {
                    "type": "boolean",
                    "description": "If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableNonstandardPortWarning": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, disables warnings when non-standard ports are used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorPenalty": {
                    "type": "number",
                    "description": "Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError3xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError4xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError5xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader"
                    },
                    "description": "Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "recursionRequested": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "Specifies a request string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceType": {
                    "type": "string",
                    "description": "Specifies the query type, if `test_object_protocol` is DNS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "Specifies a response string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientCertificate": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientPrivateKey": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testInterval": {
                    "type": "integer",
                    "description": "Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObject": {
                    "type": "string",
                    "description": "Specifies the static text that acts as a stand-in for the data that you're sending on the network.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPassword": {
                    "type": "string",
                    "description": "Specifies the test object's password. It is required if testObjectProtocol is ftp.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPort": {
                    "type": "integer",
                    "description": "Specifies the port number for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectProtocol": {
                    "type": "string",
                    "description": "Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectUsername": {
                    "type": "string",
                    "description": "A descriptive name for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testTimeout": {
                    "type": "number",
                    "description": "Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeoutPenalty": {
                    "type": "number",
                    "description": "Specifies the score to be reported if the liveness test times out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "testInterval",
                "testObject",
                "testObjectProtocol",
                "testTimeout"
            ]
        },
        "akamai:trafficmanagement/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet": {
            "properties": {
                "rdatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) An array of data strings, representing multiple records within a set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "The number of seconds that this record should live in a resolver's cache before being refetched.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "handoutCname": {
                    "type": "string",
                    "description": "Specifies an optional data center for the property. Used when there are no servers configured for the property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Identifies the IP address or the hostnames of the servers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "Specifies the traffic weight for the target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObject": {
                    "type": "string",
                    "description": "Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port of the `load_object`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Specifies a list of servers from which to request the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useDefaultLoadObject": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether a default `load_object` is used for the resources.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the akamai package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderAppsec:ProviderAppsec"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:index/ProviderConfig:ProviderConfig",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:index/ProviderDns:ProviderDns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:index/ProviderGtm:ProviderGtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderNetwork:ProviderNetwork"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:index/ProviderProperty:ProviderProperty",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        },
        "inputProperties": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderAppsec:ProviderAppsec"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:index/ProviderConfig:ProviderConfig",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:index/ProviderDns:ProviderDns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:index/ProviderGtm:ProviderGtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderNetwork:ProviderNetwork"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:index/ProviderProperty:ProviderProperty",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        }
    },
    "resources": {
        "akamai:edgedns/dnsRecord:DnsRecord": {
            "description": "Use the `akamai.DnsRecord` resource to configure a DNS record that can integrate with your existing DNS infrastructure.\n\n{{% examples %}}\n## Example Usage\n\nHere are examples of an A record and a CNAME record.\n{{% example %}}\n### An A record example\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst origin = new akamai.DnsRecord(\"origin\", {\n    active: true,\n    recordtype: \"A\",\n    targets: [\"192.0.2.42\"],\n    ttl: 30,\n    zone: \"origin.org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\norigin = akamai.DnsRecord(\"origin\",\n    active=True,\n    recordtype=\"A\",\n    targets=[\"192.0.2.42\"],\n    ttl=30,\n    zone=\"origin.org\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var origin = new Akamai.DnsRecord(\"origin\", new Akamai.DnsRecordArgs\n        {\n            Active = true,\n            Recordtype = \"A\",\n            Targets = \n            {\n                \"192.0.2.42\",\n            },\n            Ttl = 30,\n            Zone = \"origin.org\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewDnsRecord(ctx, \"origin\", \u0026akamai.DnsRecordArgs{\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tRecordtype: pulumi.String(\"A\"),\n\t\t\tTargets: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.2.42\"),\n\t\t\t},\n\t\t\tTtl:  pulumi.Int(30),\n\t\t\tZone: pulumi.String(\"origin.org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.DnsRecord;\nimport com.pulumi.akamai.DnsRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var origin = new DnsRecord(\"origin\", DnsRecordArgs.builder()        \n            .active(true)\n            .recordtype(\"A\")\n            .targets(\"192.0.2.42\")\n            .ttl(30)\n            .zone(\"origin.org\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  origin:\n    type: akamai:DnsRecord\n    properties:\n      active: true\n      recordtype: A\n      targets:\n        - 192.0.2.42\n      ttl: 30\n      zone: origin.org\n```\n{{% /example %}}\n{{% example %}}\n### CNAME Record Example\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst www = new akamai.DnsRecord(\"www\", {\n    active: true,\n    recordtype: \"CNAME\",\n    targets: \"origin.example.org.edgesuite.net\",\n    ttl: 600,\n    zone: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nwww = akamai.DnsRecord(\"www\",\n    active=True,\n    recordtype=\"CNAME\",\n    targets=\"origin.example.org.edgesuite.net\",\n    ttl=600,\n    zone=\"example.com\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var www = new Akamai.DnsRecord(\"www\", new Akamai.DnsRecordArgs\n        {\n            Active = true,\n            Recordtype = \"CNAME\",\n            Targets = \"origin.example.org.edgesuite.net\",\n            Ttl = 600,\n            Zone = \"example.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewDnsRecord(ctx, \"www\", \u0026akamai.DnsRecordArgs{\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tRecordtype: pulumi.String(\"CNAME\"),\n\t\t\tTargets:    pulumi.StringArray(\"origin.example.org.edgesuite.net\"),\n\t\t\tTtl:        pulumi.Int(600),\n\t\t\tZone:       pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.DnsRecord;\nimport com.pulumi.akamai.DnsRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var www = new DnsRecord(\"www\", DnsRecordArgs.builder()        \n            .active(true)\n            .recordtype(\"CNAME\")\n            .targets(\"origin.example.org.edgesuite.net\")\n            .ttl(600)\n            .zone(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  www:\n    type: akamai:DnsRecord\n    properties:\n      active: true\n      recordtype: CNAME\n      targets: origin.example.org.edgesuite.net\n      ttl: 600\n      zone: example.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Argument reference [argument-reference]\n\nThis resource supports these arguments for all record types:\n\n* `name` - (Required) The DNS record name. This is the node this DNS record is associated with. Also known as an owner name. \n* `zone` - (Required) The domain zone, including any nested subdomains.  \n* `recordType` - (Required) The DNS record type.  \n* `ttl` - (Required) The time to live (TTL) is a 32-bit signed integer for the time the resource record is cached. \u003cbr /\u003e A value of `0` means that the resource record is not cached. It's only used for the transaction in progress and may be useful for extremely volatile data.  \n\n## Additional arguments by record type\n\nThis section lists additional required and optional arguments for specific record types.\n\n\n### A record\n\nAn A record requires this argument:\n\n* `target` - One or more IPv4 addresses, for example, 192.0.2.0.\n\n### AAAA record\n\nAn AAAA record requires this argument:\n\n* `target` - One or more IPv6 addresses, for example, 2001:0db8::ff00:0042:8329.\n\n### AFSDB record\n\nAn AFSDB record requires these arguments:\n\n* `target` - The domain name of the host having a server for the cell named by the owner name of the resource record.\n* `subtype` - An integer between `0` and `65535` that indicates the type of service provided by the host.\n\n### AKAMAICDN record\n\nAn AKAMAICDN record requires this argument:\n\n* `target` - A DNS name representing the selected edge hostname and domain.\n\n### AKAMAITLC record\n\nNo additional arguments are needed for AKAMAITLC records. This resource returns these computed attributes for this record type:\n\n* `dns_name` - A valid DNS name.\n* `answer_type` - The answer type.\n\n### CAA record\n\nA certificate authority authorization (CAA) record requires this argument:\n\n* `target` - One or more certificate authority authorizations. Each authorization contains three attributes: flags, property tag, and property value.\n\nExample:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\n### CERT record\n\nA CERT record requires these arguments:\n\n* `type_value` - A numeric certificate type value.\n* `type_mnemonic` - A mnemonic certificate type value.\n* `keytag` - A value computed for the key embedded in the certificate.\n* `algorithm` - The cryptographic algorithm used to create the signature.\n* `certificate` - Certificate data.\n\n\u003e **Note:** When entering the certificate type, you can enter `type_value`, `type_mnemonic`, or  both arguments. If you use both, `type_mnemonic` takes precedence.\n\n### CNAME record\n\nA CNAME record requires this argument:\n\n* `target `- A domain name that specifies the canonical or primary name for the owner. The owner name is an alias.\n\n### DNSKEY record\n\nA DNSKEY record requires these arguments:\n\n* `flags`\n* `protocol` - Set to `3`. If the value isn't `3`, the DNSKEY resource record is treated as invalid during signature verification.\n* `algorithm` - The public key's cryptographic algorithm. This algorithm determines the format of the public key field.\n* `key` - A Base64 encoded value representing the public key. The format used depends on the `algorithm`.\n\n### DS record\n\nA DS record requires these arguments:\n\n* `keytag` - The key tag of the DNSKEY record that the DS record refers to, in network byte order.\n* `algorithm` - The algorithm number of the DNSKEY resource record referred to by the DS record.\n* `digest_type` - Identifies the algorithm used to construct the digest.\n* `digest` - A base 16 encoded DS record includes a digest of the DNSKEY record it refers to. The digest is conifgured the canonical form of the DNSKEY record's fully qualified owner name with the DNSKEY RDATA, and then applying the digest algorithm.\n\n### HINFO record\n\nA HINFO record requires these arguments:\n\n* `hardware` - The type of hardware the host uses. A machine name or CPU type may be up to 40 characters long and include uppercase letters, digits, hyphens, and slashes. The entry needs to start and to end with an uppercase letter.\n* `software` - The type of software the host uses. A system name may be up to 40 characters long and include uppercase letters, digits, hyphens, and slashes. The entry needs to start with an uppercase letter and end with an uppercase letter or a digit.\n\n### HTTPS Record\n\nThe following fields are required:\n\n* `svc_priority` - Service priority associated with endpoint. Value mist be between 0 and 65535. A piority of 0 enables alias mode. \n* `svc_params` - Space separated list of endpoint parameters. Not allowed if service priority is 0.\n* `target_name` - Domain name of the service endpoint.\n\n### LOC record\n\nA LOC record requires this argument:\n\n* `target` - A geographical location associated with a domain name.\n\n### MX record\n\nAn MX record supports these arguments:\n\n* `target` - (Required) One or more domain names that specify a host willing to act as a mail exchange for the owner name.\n* `priority` - (Optional) The preference value given to this MX record in relation to all other MX records. When a mailer needs to send mail to a certain DNS domain, it first contacts a DNS server for that domain and retrieves all the MX records. It then contacts the mailer with the lowest preference value. This value is ignored if an embedded priority exists in the target.\n* `priority_increment` - (Optional) An auto priority increment when multiple targets are provided with no embedded priority.\n\nSee Working with MX records in the DNS Getting Started Guide for more information.\n\n### NAPTR record\n\nAn NAPTR record requires these arguments:\n\n* `order` - A 16-bit unsigned integer specifying the order in which the NAPTR records need to be processed to ensure the correct ordering of rules. Low numbers are processed before high numbers. Once a NAPTR is found whose rule matches the target, the client shouldn't consider any NAPTRs with a higher value for order (except as noted below for the flagsnapter field).\n* `preference` - A 16-bit unsigned integer that specifies the order in which NAPTR records with equal order values are processed. Low numbers are processed before high numbers.\n* `flagsnaptr` - A character string containing flags that control how fields in the record are rewritten and interpreted. Flags are single alphanumeric characters. \n* `service` - Specifies the services available down this rewrite path.\n* `regexp` - A regular expression string containing a substitution expression. This substitution expression is applied to the original client string in order to construct the next domain name to lookup.\n* `replacement` - Depending on the value of the `flags` attribute, the next NAME to query for NAPTR, SRV, or address records. Enter a fully qualified domain name as the value.\n\n### NS record\n\nAn NS record requires these arguments:\n\n* `target` - One or more domain names that specify authoritative hosts for the specified class and domain.\n\n### NSEC3 record\n\nAn NSEC3 record requires these arguments:\n\n* `algorithm` - The cryptographic hash algorithm used to construct the hash-value.\n* `flags` - Eight one-bit flags you can use to indicate different processing. All undefined flags must be zero.\n* `iterations` - The number of additional times the hash function has been performed.\n* `salt` - The base 16 encoded salt value, which is appended to the original owner name before hashing. Used to defend against pre-calculated dictionary attacks.\n* `next_hashed_owner_name` - Base 32 encoded. The next hashed owner name in hash order. This value is in binary format. Given the ordered set of all hashed owner names, the Next Hashed Owner Name field contains the hash of an owner name that immediately follows the owner name of the given NSEC3 RR.\n* `type_bitmaps` - The resource record set types that exist at the original owner name of the NSEC3 RR.\n\n### NSEC3PARAM record\n\nAn NSEC3PARAM record requires these arguments:\n\n* `algorithm` - The cryptographic hash algorithm used to construct the hash-value.\n* `flags` - Eight one-bit flags that can be used to indicate different processing. All undefined flags must be zero.\n* `iterations` - The number of additional times the hash function has been performed.\n* `salt` - The base 16 encoded salt value, which is appended to the original owner name before hashing in order to defend against pre-calculated dictionary attacks.\n\n### PTR record\n\nA PTR record requires this argument:\n\n* `target` - A domain name that points to some location in the domain name space.\n\n### RP record\n\nAn RP record requires these arguments:\n\n* `mailbox` - A domain name that specifies the mailbox for the responsible person.\n* `txt` - A domain name for which TXT resource records exist.\n\n### RRSIG record\n\nAn RRSIG record requires these arguments:\n\n* `type_covered` - The resource record set type covered by this signature.\n* `algorithm` - Identifies the cryptographic algorithm used to create the signature.\n* `original_ttl` - The TTL of the covered record set as it appears in the authoritative zone.\n* `expiration` - The end point of this signature's validity. The signature can`t be used for authentication past this point in time.\n* `inception` - The start point of this signature's validity. The signature can`t be used for authentication prior to this point in time.\n* `keytag` - The Key Tag field contains the key tag value of the DNSKEY RR that validates this signature, in network byte order.\n* `signer` - The owner of the DNSKEY resource record who validates this signature.\n* `signature` - The base 64 encoded cryptographic signature that covers the RRSIG RDATA and covered record set. Format depends on the TSIG algorithm in use.\n* `labels` - The Labels field specifies the number of labels in the original RRSIG RR owner name. The significance of this field is that a validator uses it to determine whether the answer was synthesized from a wildcard. If so, it can be used to determine what owner name was used in generating the signature.\n\n### SPF record\n\nAn SPF record requires this argument:\n\n* `target` - Indicates which hosts are, and are not, authorized to use a domain name for the “HELO” and “MAIL FROM” identities.\n\n### SRV record\n\nAn SRV record requires these arguments:\n\n* `target` - The domain name of the target host.\n* `priority` - A 16-bit integer that specifies the preference given to this resource record among others at the same owner. Lower values are preferred.\n* `weight` - A server selection mechanism that specifies a relative weight for entries with the same priority. Larger weights are given a proportionately higher probability of being selected. The range of this number is 0–65535, a 16-bit unsigned integer in network byte order. Domain administrators should use Weight 0 when there isn't any server selection to do, to make the RR easier to read for humans. In the presence of records containing weights greater than 0, records with weight 0 should have a very small chance of being selected.\n* `port` - The port on this target of this service. The range of this number is 0–65535, a 16-bit unsigned integer in network byte order.\n\n### SSHFP record\n\nAn SSHFP record requires these arguments:\n\n* `algorithm` - Describes the algorithm of the public key. The following values are assigned: `0` is reserved, `1` is for RSA, `2` is for DSS, and `3` is for ECDSA.\n* `fingerprint_type` - Describes the message-digest algorithm used to calculate the fingerprint of the public key. The following values are assigned: 0 = reserved, 1 = SHA-1, 2 = SHA-256.\n* `fingerprint` - The base 16 encoded fingerprint as calculated over the public key blob. The message-digest algorithm is presumed to produce an opaque octet string output, which is placed as-is in the RDATA fingerprint field.\n\n### SOA record\n\nAn SOA record requires these arguments:\n\n* `name_server` - The domain name of the name server that was the original or primary source of data for this zone.\n* `email_address` - A domain name that specifies the mailbox of this person responsible for this zone.\n* `serial` - The unsigned version number between 0 and 214748364 of the original copy of the zone.\n* `refresh` - A time interval between 0 and 214748364 before the zone should be refreshed.\n* `retry` - A time interval between 0 and 214748364 that should elapse before a failed refresh should be retried.\n* `expiry` - A time value between 0 and 214748364 that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.\n* `nxdomain_ttl` - The unsigned minimum TTL between 0 and 214748364 that should be exported with any resource record from this zone.\n\n### SVCB record\n\nAn SVCB record requires these arguments:\n\n* `svc_priority` - Service priority associated with endpoint. Value mist be between 0 and 65535. A piority of 0 enables alias mode.\n* `svc_params` - Space separated list of endpoint parameters. Not allowed if service priority is 0.\n* `target_name` - Domain name of the service endpoint.\n\n### TLSA record\n\nA TLSA record requires these arguments:\n\n* `usage` - Specifies the association used to match the certificate presented in the TLS handshake.\n* `selector` - Specifies the part of the TLS certificate presented by the server that is matched against the association data. \n* `match_type` - Specifies how the certificate association is presented.\n* `certificate` - Specifies the certificate association data to be matched.\n\n### TXT record\n\nA TXT record requires this argument:\n\n* `target` - One or more character strings. TXT resource records hold descriptive text. The semantics of the text depends on the domain where it is found.\n",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "answerType": {
                    "type": "string"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "dnsName": {
                    "type": "string"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordSha": {
                    "type": "string"
                },
                "recordtype": {
                    "type": "string"
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "serial": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string"
                }
            },
            "required": [
                "answerType",
                "dnsName",
                "name",
                "recordSha",
                "recordtype",
                "serial",
                "ttl",
                "zone"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordtype": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "recordtype",
                "ttl",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsRecord resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "algorithm": {
                        "type": "integer"
                    },
                    "answerType": {
                        "type": "string"
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "digest": {
                        "type": "string"
                    },
                    "digestType": {
                        "type": "integer"
                    },
                    "dnsName": {
                        "type": "string"
                    },
                    "emailAddress": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string"
                    },
                    "expiry": {
                        "type": "integer"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "fingerprintType": {
                        "type": "integer"
                    },
                    "flags": {
                        "type": "integer"
                    },
                    "flagsnaptr": {
                        "type": "string"
                    },
                    "hardware": {
                        "type": "string"
                    },
                    "inception": {
                        "type": "string"
                    },
                    "iterations": {
                        "type": "integer"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keytag": {
                        "type": "integer"
                    },
                    "labels": {
                        "type": "integer"
                    },
                    "mailbox": {
                        "type": "string"
                    },
                    "matchType": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "nameServer": {
                        "type": "string"
                    },
                    "nextHashedOwnerName": {
                        "type": "string"
                    },
                    "nxdomainTtl": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "integer"
                    },
                    "originalTtl": {
                        "type": "integer"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "preference": {
                        "type": "integer"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "priorityIncrement": {
                        "type": "integer"
                    },
                    "protocol": {
                        "type": "integer"
                    },
                    "recordSha": {
                        "type": "string"
                    },
                    "recordtype": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "refresh": {
                        "type": "integer"
                    },
                    "regexp": {
                        "type": "string"
                    },
                    "replacement": {
                        "type": "string"
                    },
                    "retry": {
                        "type": "integer"
                    },
                    "salt": {
                        "type": "string"
                    },
                    "selector": {
                        "type": "integer"
                    },
                    "serial": {
                        "type": "integer"
                    },
                    "service": {
                        "type": "string"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "signer": {
                        "type": "string"
                    },
                    "software": {
                        "type": "string"
                    },
                    "subtype": {
                        "type": "integer"
                    },
                    "svcParams": {
                        "type": "string"
                    },
                    "svcPriority": {
                        "type": "integer"
                    },
                    "targetName": {
                        "type": "string"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ttl": {
                        "type": "integer"
                    },
                    "txt": {
                        "type": "string"
                    },
                    "typeBitmaps": {
                        "type": "string"
                    },
                    "typeCovered": {
                        "type": "string"
                    },
                    "typeMnemonic": {
                        "type": "string"
                    },
                    "typeValue": {
                        "type": "integer"
                    },
                    "usage": {
                        "type": "integer"
                    },
                    "weight": {
                        "type": "integer"
                    },
                    "zone": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.edgedns.DnsRecord has been deprecated in favor of akamai.DnsRecord"
        },
        "akamai:edgedns/dnsZone:DnsZone": {
            "properties": {
                "activationState": {
                    "type": "string"
                },
                "aliasCount": {
                    "type": "integer"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n"
                },
                "versionId": {
                    "type": "string"
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "required": [
                "activationState",
                "aliasCount",
                "contract",
                "type",
                "versionId",
                "zone"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                    "willReplaceOnChanges": true
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "requiredInputs": [
                "contract",
                "type",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsZone resources.\n",
                "properties": {
                    "activationState": {
                        "type": "string"
                    },
                    "aliasCount": {
                        "type": "integer"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive comment.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    },
                    "endCustomerId": {
                        "type": "string",
                        "description": "A free form identifier for the zone.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The currently selected group ID.\n"
                    },
                    "masters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                    },
                    "signAndServe": {
                        "type": "boolean",
                        "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                    },
                    "signAndServeAlgorithm": {
                        "type": "string",
                        "description": "The algorithm used by Sign and Serve.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The name of the zone whose configuration this zone will copy.\n"
                    },
                    "tsigKey": {
                        "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                        "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                        "willReplaceOnChanges": true
                    },
                    "versionId": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The domain zone, encapsulating any nested subdomains.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone"
        },
        "akamai:index/appSecActivations:AppSecActivations": {
            "properties": {
                "activate": {
                    "type": "boolean",
                    "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                },
                "network": {
                    "type": "string",
                    "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                },
                "note": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                },
                "notes": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The results of the activation\n"
                },
                "version": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                }
            },
            "required": [
                "configId",
                "notificationEmails",
                "status",
                "version"
            ],
            "inputProperties": {
                "activate": {
                    "type": "boolean",
                    "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                },
                "network": {
                    "type": "string",
                    "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                },
                "note": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                },
                "notes": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                },
                "version": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "notificationEmails",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecActivations resources.\n",
                "properties": {
                    "activate": {
                        "type": "boolean",
                        "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                        "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                    },
                    "note": {
                        "type": "string",
                        "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                        "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                    },
                    "notificationEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The results of the activation\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsEvasivePathMatch:AppSecAdvancedSettingsEvasivePathMatch": {
            "description": "**Scopes**: Security configuration; security policy\n\nThe `resource_akamai_appsec_advanced_settings_evasive_path_match` resource allows you to enable, disable, or update the evasive path match setting for a configuration.\nThis setting determines whether fuzzy matching is used to make URL matching more inclusive.\nThis operation applies at the configuration level, and therefore applies to all policies within a configuration.\nYou may override this setting for a particular policy by specifying the policy using the security_policy_id parameter.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/put-evasive-path-match)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst configEvasivePathMatch = new akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enablePathMatch: true,\n});\n// USE CASE: user wants to override the evasive path match setting for a security policy\nconst policyOverride = new akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: _var.security_policy_id,\n    enablePathMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\nconfig_evasive_path_match = akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\",\n    config_id=configuration.config_id,\n    enable_path_match=True)\n# USE CASE: user wants to override the evasive path match setting for a security policy\npolicy_override = akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\",\n    config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"],\n    enable_path_match=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = @var.Security_configuration,\n        }));\n        var configEvasivePathMatch = new Akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", new Akamai.AppSecAdvancedSettingsEvasivePathMatchArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            EnablePathMatch = true,\n        });\n        // USE CASE: user wants to override the evasive path match setting for a security policy\n        var policyOverride = new Akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", new Akamai.AppSecAdvancedSettingsEvasivePathMatchArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = @var.Security_policy_id,\n            EnablePathMatch = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsEvasivePathMatch(ctx, \"configEvasivePathMatch\", \u0026akamai.AppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:        pulumi.Int(configuration.ConfigId),\n\t\t\tEnablePathMatch: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsEvasivePathMatch(ctx, \"policyOverride\", \u0026akamai.AppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.Any(_var.Security_policy_id),\n\t\t\tEnablePathMatch:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsEvasivePathMatch;\nimport com.pulumi.akamai.AppSecAdvancedSettingsEvasivePathMatchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        var configEvasivePathMatch = new AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", AppSecAdvancedSettingsEvasivePathMatchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enablePathMatch(true)\n            .build());\n\n        var policyOverride = new AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", AppSecAdvancedSettingsEvasivePathMatchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .enablePathMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  configEvasivePathMatch:\n    type: akamai:AppSecAdvancedSettingsEvasivePathMatch\n    properties:\n      configId: ${configuration.configId}\n      enablePathMatch: true\n  # USE CASE: user wants to override the evasive path match setting for a security policy\n  policyOverride:\n    type: akamai:AppSecAdvancedSettingsEvasivePathMatch\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: ${var.security_policy_id}\n      enablePathMatch: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": "The ID of the security configuration to use.\n"
                },
                "enablePathMatch": {
                    "type": "boolean",
                    "description": "Whether to enable path match.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                }
            },
            "required": [
                "configId",
                "enablePathMatch"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": "The ID of the security configuration to use.\n"
                },
                "enablePathMatch": {
                    "type": "boolean",
                    "description": "Whether to enable path match.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enablePathMatch"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsEvasivePathMatch resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "The ID of the security configuration to use.\n"
                    },
                    "enablePathMatch": {
                        "type": "boolean",
                        "description": "Whether to enable path match.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsLogging:AppSecAdvancedSettingsLogging": {
            "description": "**Scopes**: Security configuration; security policy\n\nEnables, disables, or updates HTTP header logging settings.\nBy default, this operation applies at the configuration level, which means that it applies to all the security policies within that configuration.\nHowever, by using the `security_policy_id` parameter you can specify custom settings for an individual security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/put-policies-logging)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst logging = new akamai.AppSecAdvancedSettingsLogging(\"logging\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    logging: fs.readFileSync(`${path.module}/logging.json`),\n});\n// USE CASE: User wants to configure logging settings for a security policy.\nconst policyLogging = new akamai.AppSecAdvancedSettingsLogging(\"policyLogging\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    logging: fs.readFileSync(`${path.module}/logging.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nlogging = akamai.AppSecAdvancedSettingsLogging(\"logging\",\n    config_id=configuration.config_id,\n    logging=(lambda path: open(path).read())(f\"{path['module']}/logging.json\"))\n# USE CASE: User wants to configure logging settings for a security policy.\npolicy_logging = akamai.AppSecAdvancedSettingsLogging(\"policyLogging\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    logging=(lambda path: open(path).read())(f\"{path['module']}/logging.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var logging = new Akamai.AppSecAdvancedSettingsLogging(\"logging\", new Akamai.AppSecAdvancedSettingsLoggingArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            Logging = File.ReadAllText($\"{path.Module}/logging.json\"),\n        });\n        // USE CASE: User wants to configure logging settings for a security policy.\n        var policyLogging = new Akamai.AppSecAdvancedSettingsLogging(\"policyLogging\", new Akamai.AppSecAdvancedSettingsLoggingArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Logging = File.ReadAllText($\"{path.Module}/logging.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsLogging(ctx, \"logging\", \u0026akamai.AppSecAdvancedSettingsLoggingArgs{\n\t\t\tConfigId: pulumi.Int(configuration.ConfigId),\n\t\t\tLogging:  readFileOrPanic(fmt.Sprintf(\"%v/logging.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsLogging(ctx, \"policyLogging\", \u0026akamai.AppSecAdvancedSettingsLoggingArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tLogging:          readFileOrPanic(fmt.Sprintf(\"%v/logging.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsLogging;\nimport com.pulumi.akamai.AppSecAdvancedSettingsLoggingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var logging = new AppSecAdvancedSettingsLogging(\"logging\", AppSecAdvancedSettingsLoggingArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .logging(Files.readString(Paths.get(String.format(\"%s/logging.json\", path.module()))))\n            .build());\n\n        var policyLogging = new AppSecAdvancedSettingsLogging(\"policyLogging\", AppSecAdvancedSettingsLoggingArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .logging(Files.readString(Paths.get(String.format(\"%s/logging.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                },
                "logging": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the logging settings to be configured. A sample JSON file can be found in the [Modify HTTP header log settings for a configuration](https://developer.akamai.com/api/cloud_security/application_security/v1.html#puthttpheaderloggingforaconfiguration) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "required": [
                "configId",
                "logging"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                },
                "logging": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the logging settings to be configured. A sample JSON file can be found in the [Modify HTTP header log settings for a configuration](https://developer.akamai.com/api/cloud_security/application_security/v1.html#puthttpheaderloggingforaconfiguration) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "logging"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsLogging resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                    },
                    "logging": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the logging settings to be configured. A sample JSON file can be found in the [Modify HTTP header log settings for a configuration](https://developer.akamai.com/api/cloud_security/application_security/v1.html#puthttpheaderloggingforaconfiguration) section of the Application Security API documentation.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsPragmaHeader:AppSecAdvancedSettingsPragmaHeader": {
            "description": "**Scopes**: Security configuration; security policy\n\nSpecifies the headers you can exclude from inspection when you are working with a Pragma debug header, a header that provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; whether a request was cached or not; etc. By default, pragma headers are removed from all responses.\n\nThis operation can be applied at the security configuration level (in which case it applies to all the security policies in the configuration), or can be customized for an individual security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/put-policies-pragma-header)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst pragmaHeader = new akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    pragmaHeader: fs.readFileSync(`${path.module}/pragma_header.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npragma_header = akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    pragma_header=(lambda path: open(path).read())(f\"{path['module']}/pragma_header.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var pragmaHeader = new Akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", new Akamai.AppSecAdvancedSettingsPragmaHeaderArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            PragmaHeader = File.ReadAllText($\"{path.Module}/pragma_header.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsPragmaHeader(ctx, \"pragmaHeader\", \u0026akamai.AppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tPragmaHeader:     readFileOrPanic(fmt.Sprintf(\"%v/pragma_header.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPragmaHeader;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPragmaHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var pragmaHeader = new AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", AppSecAdvancedSettingsPragmaHeaderArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .pragmaHeader(Files.readString(Paths.get(String.format(\"%s/pragma_header.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                },
                "pragmaHeader": {
                    "type": "string",
                    "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`. You can view a sample JSON file in the [Modify pragma settings for a security setting](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putpragmaheaderconfiguration) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "required": [
                "configId",
                "pragmaHeader"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                },
                "pragmaHeader": {
                    "type": "string",
                    "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`. You can view a sample JSON file in the [Modify pragma settings for a security setting](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putpragmaheaderconfiguration) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "pragmaHeader"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsPragmaHeader resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                    },
                    "pragmaHeader": {
                        "type": "string",
                        "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`. You can view a sample JSON file in the [Modify pragma settings for a security setting](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putpragmaheaderconfiguration) section of the Application Security API documentation.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsPrefetch:AppSecAdvancedSettingsPrefetch": {
            "description": "**Scopes**: Security configuration\n\nEnables inspection of internal requests (that is, requests between your origin servers and Akamai's edge servers). You can also use this resource to apply rate controls to prefetch requests.\n\nWhen prefetch is enabled, internal requests are inspected by your firewall the same way that external requests (requests that originate outside the firewall and outside Akamai's edge servers) are inspected.\n\nThis operation applies at the security configuration level, meaning that the settings affect all the security policies in that configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/put-advanced-settings-prefetch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst prefetch = new akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enableAppLayer: false,\n    allExtensions: true,\n    enableRateControls: false,\n    extensions: [\n        \".tiff\",\n        \".bmp\",\n        \".jpg\",\n        \".gif\",\n        \".png\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprefetch = akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\",\n    config_id=configuration.config_id,\n    enable_app_layer=False,\n    all_extensions=True,\n    enable_rate_controls=False,\n    extensions=[\n        \".tiff\",\n        \".bmp\",\n        \".jpg\",\n        \".gif\",\n        \".png\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var prefetch = new Akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\", new Akamai.AppSecAdvancedSettingsPrefetchArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            EnableAppLayer = false,\n            AllExtensions = true,\n            EnableRateControls = false,\n            Extensions = \n            {\n                \".tiff\",\n                \".bmp\",\n                \".jpg\",\n                \".gif\",\n                \".png\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsPrefetch(ctx, \"prefetch\", \u0026akamai.AppSecAdvancedSettingsPrefetchArgs{\n\t\t\tConfigId:           pulumi.Int(configuration.ConfigId),\n\t\t\tEnableAppLayer:     pulumi.Bool(false),\n\t\t\tAllExtensions:      pulumi.Bool(true),\n\t\t\tEnableRateControls: pulumi.Bool(false),\n\t\t\tExtensions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\".tiff\"),\n\t\t\t\tpulumi.String(\".bmp\"),\n\t\t\t\tpulumi.String(\".jpg\"),\n\t\t\t\tpulumi.String(\".gif\"),\n\t\t\t\tpulumi.String(\".png\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPrefetch;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPrefetchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var prefetch = new AppSecAdvancedSettingsPrefetch(\"prefetch\", AppSecAdvancedSettingsPrefetchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enableAppLayer(false)\n            .allExtensions(true)\n            .enableRateControls(false)\n            .extensions(            \n                \".tiff\",\n                \".bmp\",\n                \".jpg\",\n                \".gif\",\n                \".png\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prefetch:\n    type: akamai:AppSecAdvancedSettingsPrefetch\n    properties:\n      configId: ${configuration.configId}\n      enableAppLayer: false\n      allExtensions: true\n      enableRateControls: false\n      extensions:\n        - .tiff\n        - .bmp\n        - .jpg\n        - .gif\n        - .png\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allExtensions": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                },
                "enableAppLayer": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                },
                "enableRateControls": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                },
                "extensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                }
            },
            "required": [
                "allExtensions",
                "configId",
                "enableAppLayer",
                "enableRateControls",
                "extensions"
            ],
            "inputProperties": {
                "allExtensions": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                },
                "enableAppLayer": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                },
                "enableRateControls": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                },
                "extensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                }
            },
            "requiredInputs": [
                "allExtensions",
                "configId",
                "enableAppLayer",
                "enableRateControls",
                "extensions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsPrefetch resources.\n",
                "properties": {
                    "allExtensions": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                    },
                    "enableAppLayer": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                    },
                    "enableRateControls": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                    },
                    "extensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecApiConstraintsProtection:AppSecApiConstraintsProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables API constraints protection. These constraints specify the action to be taken when designated API endpoints are invoked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecApiConstraintsProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecApiConstraintsProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecApiConstraintsProtection(\"protection\", new Akamai.AppSecApiConstraintsProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecApiConstraintsProtection(ctx, \"protection\", \u0026akamai.AppSecApiConstraintsProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecApiConstraintsProtection;\nimport com.pulumi.akamai.AppSecApiConstraintsProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecApiConstraintsProtection(\"protection\", AppSecApiConstraintsProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecApiConstraintsProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer"
                },
                "enabled": {
                    "type": "boolean"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer"
                },
                "enabled": {
                    "type": "boolean"
                },
                "securityPolicyId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecApiConstraintsProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecApiRequestConstraints:AppSecApiRequestConstraints": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst apiEndpoint = configuration.then(configuration =\u003e akamai.getAppSecApiEndpoints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    apiName: \"Contracts\",\n}));\nconst apiRequestConstraints = new akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    apiEndpointId: apiEndpoint.then(apiEndpoint =\u003e apiEndpoint.id),\n    action: \"alert\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\napi_endpoint = akamai.get_app_sec_api_endpoints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_name=\"Contracts\")\napi_request_constraints = akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_endpoint_id=api_endpoint.id,\n    action=\"alert\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var apiEndpoint = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecApiEndpoints.InvokeAsync(new Akamai.GetAppSecApiEndpointsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n            ApiName = \"Contracts\",\n        })));\n        var apiRequestConstraints = new Akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\", new Akamai.AppSecApiRequestConstraintsArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            ApiEndpointId = apiEndpoint.Apply(apiEndpoint =\u003e apiEndpoint.Id),\n            Action = \"alert\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tapiEndpoint, err := akamai.GetAppSecApiEndpoints(ctx, \u0026GetAppSecApiEndpointsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(\"gms1_134637\"),\n\t\t\tApiName:          pulumi.StringRef(\"Contracts\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecApiRequestConstraints(ctx, \"apiRequestConstraints\", \u0026akamai.AppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tApiEndpointId:    pulumi.String(apiEndpoint.Id),\n\t\t\tAction:           pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;\nimport com.pulumi.akamai.AppSecApiRequestConstraints;\nimport com.pulumi.akamai.AppSecApiRequestConstraintsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var apiEndpoint = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiName(\"Contracts\")\n            .build());\n\n        var apiRequestConstraints = new AppSecApiRequestConstraints(\"apiRequestConstraints\", AppSecApiRequestConstraintsArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiEndpointId(apiEndpoint.applyValue(getAppSecApiEndpointsResult -\u003e getAppSecApiEndpointsResult.id()))\n            .action(\"alert\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  apiRequestConstraints:\n    type: akamai:AppSecApiRequestConstraints\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      apiEndpointId: ${apiEndpoint.id}\n      action: alert\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  apiEndpoint:\n    Fn::Invoke:\n      Function: akamai:getAppSecApiEndpoints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        apiName: Contracts\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "apiEndpointId": {
                    "type": "integer",
                    "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                }
            },
            "required": [
                "action",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "apiEndpointId": {
                    "type": "integer",
                    "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                }
            },
            "requiredInputs": [
                "action",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecApiRequestConstraints resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "apiEndpointId": {
                        "type": "integer",
                        "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAttackGroup:AppSecAttackGroup": {
            "description": "**Scopes**: Attack group\n\nModify an attack group's action, conditions, and exceptions. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst attackGroup = new akamai.AppSecAttackGroup(\"attackGroup\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    attackGroup: \"SQL\",\n    attackGroupAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nattack_group = akamai.AppSecAttackGroup(\"attackGroup\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    attack_group=\"SQL\",\n    attack_group_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var attackGroup = new Akamai.AppSecAttackGroup(\"attackGroup\", new Akamai.AppSecAttackGroupArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            AttackGroup = \"SQL\",\n            AttackGroupAction = \"deny\",\n            ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAttackGroup(ctx, \"attackGroup\", \u0026akamai.AppSecAttackGroupArgs{\n\t\t\tConfigId:           pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tAttackGroup:        pulumi.String(\"SQL\"),\n\t\t\tAttackGroupAction:  pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAttackGroup;\nimport com.pulumi.akamai.AppSecAttackGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var attackGroup = new AppSecAttackGroup(\"attackGroup\", AppSecAttackGroupArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .attackGroup(\"SQL\")\n            .attackGroupAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique name of the attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group. You can view a sample JSON file in the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                }
            },
            "required": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique name of the attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group. You can view a sample JSON file in the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                }
            },
            "requiredInputs": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAttackGroup resources.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group being modified.\n"
                    },
                    "attackGroupAction": {
                        "type": "string",
                        "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group. You can view a sample JSON file in the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecByPassNetworkList:AppSecByPassNetworkList": {
            "description": "**Scopes**: Security configuration\n\nSpecifies the networks that appear on the bypass network list. Networks on this list are allowed to bypass the Web Application Firewall.\n\nNote that this resource is only applicable to WAP (Web Application Protector) configurations.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/put-bypass-network-lists)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst bypassNetworkLists = new akamai.AppSecByPassNetworkList(\"bypassNetworkLists\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    bypassNetworkLists: [\n        \"DocumentationNetworkList\",\n        \"TrainingNetworkList\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nbypass_network_lists = akamai.AppSecByPassNetworkList(\"bypassNetworkLists\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    bypass_network_lists=[\n        \"DocumentationNetworkList\",\n        \"TrainingNetworkList\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var bypassNetworkLists = new Akamai.AppSecByPassNetworkList(\"bypassNetworkLists\", new Akamai.AppSecByPassNetworkListArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            BypassNetworkLists = \n            {\n                \"DocumentationNetworkList\",\n                \"TrainingNetworkList\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecByPassNetworkList(ctx, \"bypassNetworkLists\", \u0026akamai.AppSecByPassNetworkListArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tBypassNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DocumentationNetworkList\"),\n\t\t\t\tpulumi.String(\"TrainingNetworkList\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecByPassNetworkList;\nimport com.pulumi.akamai.AppSecByPassNetworkListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var bypassNetworkLists = new AppSecByPassNetworkList(\"bypassNetworkLists\", AppSecByPassNetworkListArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .bypassNetworkLists(            \n                \"DocumentationNetworkList\",\n                \"TrainingNetworkList\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bypassNetworkLists:\n    type: akamai:AppSecByPassNetworkList\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      bypassNetworkLists:\n        - DocumentationNetworkList\n        - TrainingNetworkList\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated list of bypass network IDs.\n",
            "properties": {
                "bypassNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network IDs that comprise the bypass list.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                }
            },
            "required": [
                "bypassNetworkLists",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "bypassNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network IDs that comprise the bypass list.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                }
            },
            "requiredInputs": [
                "bypassNetworkLists",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecByPassNetworkList resources.\n",
                "properties": {
                    "bypassNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of network IDs that comprise the bypass list.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecConfiguration:AppSecConfiguration": {
            "description": "**Scopes**: Contract and group\n\nCreates a new WAP (Web Application Protector) or KSD (Kona Site Defender) security configuration. KSD security configurations start out empty (i.e., unconfigured), while WAP configurations are created using preset values. The contract referenced in the request body determines the type of configuration you can create.\n\nIn addition to manually creating a new configuration, you can use the `create_from_config_id` argument to clone an existing configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs](https://techdocs.akamai.com/application-security/reference/post-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst selectableHostnames = akamai.getAppSecSelectableHostnames({\n    configId: \"Documentation\",\n});\nconst createConfig = new akamai.AppSecConfiguration(\"createConfig\", {\n    description: \"This configuration is used as a testing environment for the documentation team.\",\n    contractId: \"5-2WA382\",\n    groupId: 12198,\n    hostNames: [\n        \"documentation.akamai.com\",\n        \"training.akamai.com\",\n    ],\n});\nexport const createConfigId = createConfig.configId;\nconst cloneConfig = new akamai.AppSecConfiguration(\"cloneConfig\", {\n    description: \"This configuration is used as a testing environment for the documentation team.\",\n    createFromConfigId: data.akamai_appsec_configuration.configuration.config_id,\n    createFromVersion: data.akamai_appsec_configuration.configuration.latest_version,\n    contractId: \"5-2WA382\",\n    groupId: 12198,\n    hostNames: selectableHostnames.then(selectableHostnames =\u003e selectableHostnames.hostnames),\n});\nexport const cloneConfigId = cloneConfig.configId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nselectable_hostnames = akamai.get_app_sec_selectable_hostnames(config_id=\"Documentation\")\ncreate_config = akamai.AppSecConfiguration(\"createConfig\",\n    description=\"This configuration is used as a testing environment for the documentation team.\",\n    contract_id=\"5-2WA382\",\n    group_id=12198,\n    host_names=[\n        \"documentation.akamai.com\",\n        \"training.akamai.com\",\n    ])\npulumi.export(\"createConfigId\", create_config.config_id)\nclone_config = akamai.AppSecConfiguration(\"cloneConfig\",\n    description=\"This configuration is used as a testing environment for the documentation team.\",\n    create_from_config_id=data[\"akamai_appsec_configuration\"][\"configuration\"][\"config_id\"],\n    create_from_version=data[\"akamai_appsec_configuration\"][\"configuration\"][\"latest_version\"],\n    contract_id=\"5-2WA382\",\n    group_id=12198,\n    host_names=selectable_hostnames.hostnames)\npulumi.export(\"cloneConfigId\", clone_config.config_id)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var selectableHostnames = Output.Create(Akamai.GetAppSecSelectableHostnames.InvokeAsync(new Akamai.GetAppSecSelectableHostnamesArgs\n        {\n            ConfigId = \"Documentation\",\n        }));\n        var createConfig = new Akamai.AppSecConfiguration(\"createConfig\", new Akamai.AppSecConfigurationArgs\n        {\n            Description = \"This configuration is used as a testing environment for the documentation team.\",\n            ContractId = \"5-2WA382\",\n            GroupId = 12198,\n            HostNames = \n            {\n                \"documentation.akamai.com\",\n                \"training.akamai.com\",\n            },\n        });\n        this.CreateConfigId = createConfig.ConfigId;\n        var cloneConfig = new Akamai.AppSecConfiguration(\"cloneConfig\", new Akamai.AppSecConfigurationArgs\n        {\n            Description = \"This configuration is used as a testing environment for the documentation team.\",\n            CreateFromConfigId = data.Akamai_appsec_configuration.Configuration.Config_id,\n            CreateFromVersion = data.Akamai_appsec_configuration.Configuration.Latest_version,\n            ContractId = \"5-2WA382\",\n            GroupId = 12198,\n            HostNames = selectableHostnames.Apply(selectableHostnames =\u003e selectableHostnames.Hostnames),\n        });\n        this.CloneConfigId = cloneConfig.ConfigId;\n    }\n\n    [Output(\"createConfigId\")]\n    public Output\u003cstring\u003e CreateConfigId { get; set; }\n    [Output(\"cloneConfigId\")]\n    public Output\u003cstring\u003e CloneConfigId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tselectableHostnames, err := akamai.GetAppSecSelectableHostnames(ctx, \u0026GetAppSecSelectableHostnamesArgs{\n\t\t\tConfigId: pulumi.IntRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateConfig, err := akamai.NewAppSecConfiguration(ctx, \"createConfig\", \u0026akamai.AppSecConfigurationArgs{\n\t\t\tDescription: pulumi.String(\"This configuration is used as a testing environment for the documentation team.\"),\n\t\t\tContractId:  pulumi.String(\"5-2WA382\"),\n\t\t\tGroupId:     pulumi.Int(12198),\n\t\t\tHostNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"documentation.akamai.com\"),\n\t\t\t\tpulumi.String(\"training.akamai.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"createConfigId\", createConfig.ConfigId)\n\t\tcloneConfig, err := akamai.NewAppSecConfiguration(ctx, \"cloneConfig\", \u0026akamai.AppSecConfigurationArgs{\n\t\t\tDescription:        pulumi.String(\"This configuration is used as a testing environment for the documentation team.\"),\n\t\t\tCreateFromConfigId: pulumi.Any(data.Akamai_appsec_configuration.Configuration.Config_id),\n\t\t\tCreateFromVersion:  pulumi.Any(data.Akamai_appsec_configuration.Configuration.Latest_version),\n\t\t\tContractId:         pulumi.String(\"5-2WA382\"),\n\t\t\tGroupId:            pulumi.Int(12198),\n\t\t\tHostNames:          interface{}(selectableHostnames.Hostnames),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"cloneConfigId\", cloneConfig.ConfigId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;\nimport com.pulumi.akamai.AppSecConfiguration;\nimport com.pulumi.akamai.AppSecConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var selectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .configId(\"Documentation\")\n            .build());\n\n        var createConfig = new AppSecConfiguration(\"createConfig\", AppSecConfigurationArgs.builder()        \n            .description(\"This configuration is used as a testing environment for the documentation team.\")\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .hostNames(            \n                \"documentation.akamai.com\",\n                \"training.akamai.com\")\n            .build());\n\n        ctx.export(\"createConfigId\", createConfig.configId());\n        var cloneConfig = new AppSecConfiguration(\"cloneConfig\", AppSecConfigurationArgs.builder()        \n            .description(\"This configuration is used as a testing environment for the documentation team.\")\n            .createFromConfigId(data.akamai_appsec_configuration().configuration().config_id())\n            .createFromVersion(data.akamai_appsec_configuration().configuration().latest_version())\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .hostNames(selectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()))\n            .build());\n\n        ctx.export(\"cloneConfigId\", cloneConfig.configId());\n    }\n}\n```\n```yaml\nresources:\n  createConfig:\n    type: akamai:AppSecConfiguration\n    properties:\n      description: This configuration is used as a testing environment for the documentation team.\n      contractId: 5-2WA382\n      groupId: 12198\n      hostNames:\n        - documentation.akamai.com\n        - training.akamai.com\n  cloneConfig:\n    type: akamai:AppSecConfiguration\n    properties:\n      description: This configuration is used as a testing environment for the documentation team.\n      createFromConfigId: ${data.akamai_appsec_configuration.configuration.config_id}\n      createFromVersion: ${data.akamai_appsec_configuration.configuration.latest_version}\n      contractId: 5-2WA382\n      groupId: 12198\n      hostNames: ${selectableHostnames.hostnames}\nvariables:\n  selectableHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        configId: Documentation\noutputs:\n  createConfigId: ${createConfig.configId} # USE CASE: User wants to clone a new security configuration from an existing configuration and version.\n  cloneConfigId: ${cloneConfig.configId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `config_id`. ID of the new security configuration.\n",
            "properties": {
                "configId": {
                    "type": "integer"
                },
                "contractId": {
                    "type": "string",
                    "description": ". Unique identifier of the Akamai contract t associated with the new configuration.\n"
                },
                "createFromConfigId": {
                    "type": "integer",
                    "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                },
                "createFromVersion": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being cloned.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the new configuration.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                },
                "hostNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". Name of the new configuration.\n"
                }
            },
            "required": [
                "configId",
                "contractId",
                "description",
                "groupId",
                "hostNames",
                "name"
            ],
            "inputProperties": {
                "contractId": {
                    "type": "string",
                    "description": ". Unique identifier of the Akamai contract t associated with the new configuration.\n"
                },
                "createFromConfigId": {
                    "type": "integer",
                    "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                },
                "createFromVersion": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being cloned.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the new configuration.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                },
                "hostNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". Name of the new configuration.\n"
                }
            },
            "requiredInputs": [
                "contractId",
                "description",
                "groupId",
                "hostNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecConfiguration resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "contractId": {
                        "type": "string",
                        "description": ". Unique identifier of the Akamai contract t associated with the new configuration.\n"
                    },
                    "createFromConfigId": {
                        "type": "integer",
                        "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                    },
                    "createFromVersion": {
                        "type": "integer",
                        "description": ". Version number of the security configuration being cloned.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": ". Brief description of the new configuration.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                    },
                    "hostNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": ". Name of the new configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecConfigurationRename:AppSecConfigurationRename": {
            "description": "**Scopes**: Security configuration\n\nRenames an existing security configuration.\nNote that you can change only the configuration name. You can't modify the ID assigned to a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}](https://techdocs.akamai.com/application-security/reference/put-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configurationAppSecConfiguration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst configurationAppSecConfigurationRename = new akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", {\n    configId: configurationAppSecConfiguration.then(configurationAppSecConfiguration =\u003e configurationAppSecConfiguration.configId),\n    description: \"This configuration is by both the documentation team and the training team.\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration_app_sec_configuration = akamai.get_app_sec_configuration(name=\"Documentation\")\nconfiguration_app_sec_configuration_rename = akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\",\n    config_id=configuration_app_sec_configuration.config_id,\n    description=\"This configuration is by both the documentation team and the training team.\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configurationAppSecConfiguration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var configurationAppSecConfigurationRename = new Akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", new Akamai.AppSecConfigurationRenameArgs\n        {\n            ConfigId = configurationAppSecConfiguration.Apply(configurationAppSecConfiguration =\u003e configurationAppSecConfiguration.ConfigId),\n            Description = \"This configuration is by both the documentation team and the training team.\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfigurationAppSecConfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecConfigurationRename(ctx, \"configurationAppSecConfigurationRename\", \u0026akamai.AppSecConfigurationRenameArgs{\n\t\t\tConfigId:    pulumi.Int(configurationAppSecConfiguration.ConfigId),\n\t\t\tDescription: pulumi.String(\"This configuration is by both the documentation team and the training team.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecConfigurationRename;\nimport com.pulumi.akamai.AppSecConfigurationRenameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configurationAppSecConfiguration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var configurationAppSecConfigurationRename = new AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", AppSecConfigurationRenameArgs.builder()        \n            .configId(configurationAppSecConfiguration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .description(\"This configuration is by both the documentation team and the training team.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  configurationAppSecConfigurationRename:\n    type: akamai:AppSecConfigurationRename\n    properties:\n      configId: ${configurationAppSecConfiguration.configId}\n      description: This configuration is by both the documentation team and the training team.\nvariables:\n  configurationAppSecConfiguration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configurating being renamed.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the security configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". New name for the security configuration.\n"
                }
            },
            "required": [
                "configId",
                "description",
                "name"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configurating being renamed.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the security configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". New name for the security configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "description"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecConfigurationRename resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configurating being renamed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": ". Brief description of the security configuration.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": ". New name for the security configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomDeny:AppSecCustomDeny": {
            "description": "**Scopes**: Custom deny\n\nModifies a custom deny action. Custom denies enable you to craft your own error message or redirect pages for use when HTTP requests are denied.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customDeny = new akamai.AppSecCustomDeny(\"customDeny\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    customDeny: fs.readFileSync(`${path.module}/custom_deny.json`),\n});\nexport const customDenyId = customDeny.customDenyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_deny = akamai.AppSecCustomDeny(\"customDeny\",\n    config_id=configuration.config_id,\n    custom_deny=(lambda path: open(path).read())(f\"{path['module']}/custom_deny.json\"))\npulumi.export(\"customDenyId\", custom_deny.custom_deny_id)\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var customDeny = new Akamai.AppSecCustomDeny(\"customDeny\", new Akamai.AppSecCustomDenyArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            CustomDeny = File.ReadAllText($\"{path.Module}/custom_deny.json\"),\n        });\n        this.CustomDenyId = customDeny.CustomDenyId;\n    }\n\n    [Output(\"customDenyId\")]\n    public Output\u003cstring\u003e CustomDenyId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomDeny, err := akamai.NewAppSecCustomDeny(ctx, \"customDeny\", \u0026akamai.AppSecCustomDenyArgs{\n\t\t\tConfigId:   pulumi.Int(configuration.ConfigId),\n\t\t\tCustomDeny: readFileOrPanic(fmt.Sprintf(\"%v/custom_deny.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyId\", customDeny.CustomDenyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecCustomDeny;\nimport com.pulumi.akamai.AppSecCustomDenyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var customDeny = new AppSecCustomDeny(\"customDeny\", AppSecCustomDenyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customDeny(Files.readString(Paths.get(String.format(\"%s/custom_deny.json\", path.module()))))\n            .build());\n\n        ctx.export(\"customDenyId\", customDeny.customDenyId());\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `custom_deny_id`. ID of the new custom deny action.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                },
                "customDeny": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the custom deny. For more information, see the [CustomDeny members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#63df3de3) section of the Application Security API documentation.\n"
                },
                "customDenyId": {
                    "type": "string",
                    "description": "custom_deny_id\n"
                }
            },
            "required": [
                "configId",
                "customDeny",
                "customDenyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                },
                "customDeny": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the custom deny. For more information, see the [CustomDeny members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#63df3de3) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customDeny"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomDeny resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                    },
                    "customDeny": {
                        "type": "string",
                        "description": ". Path to a JSON file containing properties and property values for the custom deny. For more information, see the [CustomDeny members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#63df3de3) section of the Application Security API documentation.\n"
                    },
                    "customDenyId": {
                        "type": "string",
                        "description": "custom_deny_id\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomRule:AppSecCustomRule": {
            "description": "**Scopes**: Security configuration\n\nCreates a custom rule associated with a security configuration. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules]https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                },
                "customRule": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postcustomrules) section of the Application Security API documentation.\n"
                },
                "customRuleId": {
                    "type": "integer"
                }
            },
            "required": [
                "configId",
                "customRule",
                "customRuleId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                },
                "customRule": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postcustomrules) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customRule"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomRule resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                    },
                    "customRule": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postcustomrules) section of the Application Security API documentation.\n"
                    },
                    "customRuleId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomRuleAction:AppSecCustomRuleAction": {
            "description": "**Scopes**: Custom rule\n\nAssociates an action with a custom rule. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst createCustomRuleAction = new akamai.AppSecCustomRuleAction(\"createCustomRuleAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    customRuleId: 12345,\n    customRuleAction: \"alert\",\n});\nexport const customRuleId = createCustomRuleAction.customRuleId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncreate_custom_rule_action = akamai.AppSecCustomRuleAction(\"createCustomRuleAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    custom_rule_id=12345,\n    custom_rule_action=\"alert\")\npulumi.export(\"customRuleId\", create_custom_rule_action.custom_rule_id)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var createCustomRuleAction = new Akamai.AppSecCustomRuleAction(\"createCustomRuleAction\", new Akamai.AppSecCustomRuleActionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            CustomRuleId = 12345,\n            CustomRuleAction = \"alert\",\n        });\n        this.CustomRuleId = createCustomRuleAction.CustomRuleId;\n    }\n\n    [Output(\"customRuleId\")]\n    public Output\u003cstring\u003e CustomRuleId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateCustomRuleAction, err := akamai.NewAppSecCustomRuleAction(ctx, \"createCustomRuleAction\", \u0026akamai.AppSecCustomRuleActionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tCustomRuleId:     pulumi.Int(12345),\n\t\t\tCustomRuleAction: pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRuleId\", createCustomRuleAction.CustomRuleId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecCustomRuleAction;\nimport com.pulumi.akamai.AppSecCustomRuleActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var createCustomRuleAction = new AppSecCustomRuleAction(\"createCustomRuleAction\", AppSecCustomRuleActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .customRuleId(12345)\n            .customRuleAction(\"alert\")\n            .build());\n\n        ctx.export(\"customRuleId\", createCustomRuleAction.customRuleId());\n    }\n}\n```\n```yaml\nresources:\n  createCustomRuleAction:\n    type: akamai:AppSecCustomRuleAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      customRuleId: 12345\n      customRuleAction: alert\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  customRuleId: ${createCustomRuleAction.customRuleId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                },
                "customRuleAction": {
                    "type": "string",
                    "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "customRuleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                }
            },
            "required": [
                "configId",
                "customRuleAction",
                "customRuleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                },
                "customRuleAction": {
                    "type": "string",
                    "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "customRuleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customRuleAction",
                "customRuleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomRuleAction resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                    },
                    "customRuleAction": {
                        "type": "string",
                        "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEval:AppSecEval": {
            "description": "**Scopes**: Security policy\n\nIssues an evaluation mode command (`Start`, `Stop`, `Restart`, `Update`, or `Complete`) to a security configuration.\nEvaluation mode is used for testing and fine-tuning your Kona Rule Set rules and configuration settings.\nIn evaluation mode rules are triggered by events, but the only thing those rules do is record the actions they *would* have taken had the event occurred on the production network.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval](https://techdocs.akamai.com/application-security/reference/post-policy-eval)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalOperation = new akamai.AppSecEval(\"evalOperation\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    evalOperation: \"START\",\n});\nexport const evalModeEvaluatingRuleset = evalOperation.evaluatingRuleset;\nexport const evalModeExpirationDate = evalOperation.expirationDate;\nexport const evalModeCurrentRuleset = evalOperation.currentRuleset;\nexport const evalModeStatus = evalOperation.evalStatus;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_operation = akamai.AppSecEval(\"evalOperation\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    eval_operation=\"START\")\npulumi.export(\"evalModeEvaluatingRuleset\", eval_operation.evaluating_ruleset)\npulumi.export(\"evalModeExpirationDate\", eval_operation.expiration_date)\npulumi.export(\"evalModeCurrentRuleset\", eval_operation.current_ruleset)\npulumi.export(\"evalModeStatus\", eval_operation.eval_status)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalOperation = new Akamai.AppSecEval(\"evalOperation\", new Akamai.AppSecEvalArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            EvalOperation = \"START\",\n        });\n        this.EvalModeEvaluatingRuleset = evalOperation.EvaluatingRuleset;\n        this.EvalModeExpirationDate = evalOperation.ExpirationDate;\n        this.EvalModeCurrentRuleset = evalOperation.CurrentRuleset;\n        this.EvalModeStatus = evalOperation.EvalStatus;\n    }\n\n    [Output(\"evalModeEvaluatingRuleset\")]\n    public Output\u003cstring\u003e EvalModeEvaluatingRuleset { get; set; }\n    [Output(\"evalModeExpirationDate\")]\n    public Output\u003cstring\u003e EvalModeExpirationDate { get; set; }\n    [Output(\"evalModeCurrentRuleset\")]\n    public Output\u003cstring\u003e EvalModeCurrentRuleset { get; set; }\n    [Output(\"evalModeStatus\")]\n    public Output\u003cstring\u003e EvalModeStatus { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalOperation, err := akamai.NewAppSecEval(ctx, \"evalOperation\", \u0026akamai.AppSecEvalArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEvalOperation:    pulumi.String(\"START\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalModeEvaluatingRuleset\", evalOperation.EvaluatingRuleset)\n\t\tctx.Export(\"evalModeExpirationDate\", evalOperation.ExpirationDate)\n\t\tctx.Export(\"evalModeCurrentRuleset\", evalOperation.CurrentRuleset)\n\t\tctx.Export(\"evalModeStatus\", evalOperation.EvalStatus)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEval;\nimport com.pulumi.akamai.AppSecEvalArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalOperation = new AppSecEval(\"evalOperation\", AppSecEvalArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .evalOperation(\"START\")\n            .build());\n\n        ctx.export(\"evalModeEvaluatingRuleset\", evalOperation.evaluatingRuleset());\n        ctx.export(\"evalModeExpirationDate\", evalOperation.expirationDate());\n        ctx.export(\"evalModeCurrentRuleset\", evalOperation.currentRuleset());\n        ctx.export(\"evalModeStatus\", evalOperation.evalStatus());\n    }\n}\n```\n```yaml\nresources:\n  evalOperation:\n    type: akamai:AppSecEval\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      evalOperation: START\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  evalModeEvaluatingRuleset: ${evalOperation.evaluatingRuleset}\n  evalModeExpirationDate: ${evalOperation.expirationDate}\n  evalModeCurrentRuleset: ${evalOperation.currentRuleset}\n  evalModeStatus: ${evalOperation.evalStatus}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `evaluation_ruleset`. Versioning information for the Kona Rule Set being evaluated.\n- `expiration_date`. Date when the evaluation period ends.\n- `current_ruleset`. Versioning information for the Kona Rule Set currently in use on the production network.\n- `eval_status`. If **true**, an evaluation is currently in progress; if **false**, evaluation is either paused or is not running.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                },
                "currentRuleset": {
                    "type": "string"
                },
                "evalMode": {
                    "type": "string",
                    "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                },
                "evalOperation": {
                    "type": "string",
                    "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                },
                "evalStatus": {
                    "type": "string"
                },
                "evaluatingRuleset": {
                    "type": "string"
                },
                "expirationDate": {
                    "type": "string"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalOperation",
                "evalStatus",
                "evaluatingRuleset",
                "expirationDate",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                },
                "evalMode": {
                    "type": "string",
                    "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                },
                "evalOperation": {
                    "type": "string",
                    "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "evalOperation",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEval resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                    },
                    "currentRuleset": {
                        "type": "string"
                    },
                    "evalMode": {
                        "type": "string",
                        "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                    },
                    "evalOperation": {
                        "type": "string",
                        "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                    },
                    "evalStatus": {
                        "type": "string"
                    },
                    "evaluatingRuleset": {
                        "type": "string"
                    },
                    "expirationDate": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalGroup:AppSecEvalGroup": {
            "description": "**Scopes**: Evaluation attack group\n\nModifies the action and the conditions and exceptions for an evaluation mode attack group.\n\nNote that this resource is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalAttackGroup = new akamai.AppSecEvalGroup(\"evalAttackGroup\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    attackGroup: \"SQL\",\n    attackGroupAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_attack_group = akamai.AppSecEvalGroup(\"evalAttackGroup\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    attack_group=\"SQL\",\n    attack_group_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalAttackGroup = new Akamai.AppSecEvalGroup(\"evalAttackGroup\", new Akamai.AppSecEvalGroupArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            AttackGroup = \"SQL\",\n            AttackGroupAction = \"deny\",\n            ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalGroup(ctx, \"evalAttackGroup\", \u0026akamai.AppSecEvalGroupArgs{\n\t\t\tConfigId:           pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tAttackGroup:        pulumi.String(\"SQL\"),\n\t\t\tAttackGroupAction:  pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalGroup;\nimport com.pulumi.akamai.AppSecEvalGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalAttackGroup = new AppSecEvalGroup(\"evalAttackGroup\", AppSecEvalGroupArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .attackGroup(\"SQL\")\n            .attackGroupAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique identifier of the evaluation attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the attack group. For more information, the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique identifier of the evaluation attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the attack group. For more information, the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalGroup resources.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique identifier of the evaluation attack group being modified.\n"
                    },
                    "attackGroupAction": {
                        "type": "string",
                        "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing properties and property values for the attack group. For more information, the [Modify the exceptions of an attack group](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putattackgroupconditionexception) section of the Application Security API documentation.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalPenaltyBox:AppSecEvalPenaltyBox": {
            "description": "**Scopes**: Security policy\n\n __ASE_Beta__.:\nModifies the penalty box settings for a security policy in evaluation mode - evaluation penalty box. \nWhen the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**:  [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/put-policy-eval_penalty-box)\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalPenaltyBox = new akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    penaltyBoxProtection: true,\n    penaltyBoxAction: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_penalty_box = akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    penalty_box_protection=True,\n    penalty_box_action=\"deny\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalPenaltyBox = new Akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\", new Akamai.AppSecEvalPenaltyBoxArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            PenaltyBoxProtection = true,\n            PenaltyBoxAction = \"deny\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalPenaltyBox(ctx, \"evalPenaltyBox\", \u0026akamai.AppSecEvalPenaltyBoxArgs{\n\t\t\tConfigId:             pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:     pulumi.String(\"gms1_134637\"),\n\t\t\tPenaltyBoxProtection: pulumi.Bool(true),\n\t\t\tPenaltyBoxAction:     pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalPenaltyBox;\nimport com.pulumi.akamai.AppSecEvalPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalPenaltyBox = new AppSecEvalPenaltyBox(\"evalPenaltyBox\", AppSecEvalPenaltyBoxArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .penaltyBoxProtection(true)\n            .penaltyBoxAction(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  evalPenaltyBox:\n    type: akamai:AppSecEvalPenaltyBox\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      penaltyBoxProtection: true\n      penaltyBoxAction: deny\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalPenaltyBox resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                    },
                    "penaltyBoxAction": {
                        "type": "string",
                        "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "penaltyBoxProtection": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalRule:AppSecEvalRule": {
            "description": "**Scopes**: Evaluation rule\n\nCreates or modifies an evaluation rule's action, conditions, and exceptions.\nEvaluation rules are Kona Rule Set rules used when running a security configuration in evaluation mode.\nChanges to these rules do not affect the rules used on your production network.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-policy-eval-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalRule = new akamai.AppSecEvalRule(\"evalRule\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n    ruleAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_rule = akamai.AppSecEvalRule(\"evalRule\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316,\n    rule_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalRule = new Akamai.AppSecEvalRule(\"evalRule\", new Akamai.AppSecEvalRuleArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            RuleId = 60029316,\n            RuleAction = \"deny\",\n            ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalRule(ctx, \"evalRule\", \u0026akamai.AppSecEvalRuleArgs{\n\t\t\tConfigId:           pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tRuleId:             pulumi.Int(60029316),\n\t\t\tRuleAction:         pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalRule;\nimport com.pulumi.akamai.AppSecEvalRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalRule = new AppSecEvalRule(\"evalRule\", AppSecEvalRuleArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(60029316)\n            .ruleAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule. To view a sample JSON file, see the [Modify the conditions and exceptions for an evaluation rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putevalconditionsexceptions) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the evaluation rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule. To view a sample JSON file, see the [Modify the conditions and exceptions for an evaluation rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putevalconditionsexceptions) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the evaluation rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalRule resources.\n",
                "properties": {
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule. To view a sample JSON file, see the [Modify the conditions and exceptions for an evaluation rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putevalconditionsexceptions) section of the Application Security API documentation.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                    },
                    "ruleAction": {
                        "type": "string",
                        "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the evaluation rule being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecIPGeo:AppSecIPGeo": {
            "description": "**Scopes**: Security policy\n\nModifies the method used for firewall blocking, and manages the network lists used for IP/Geo firewall blocking.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-ip-geo-firewall)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ipGeoBlock = new akamai.AppSecIPGeo(\"ipGeoBlock\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    mode: \"block\",\n    geoNetworkLists: [\"06038_GEO_TEST\"],\n    ipNetworkLists: [\"56921_TEST\"],\n    exceptionIpNetworkLists: [\"07126_EXCEPTION_TEST\"],\n});\n// USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\nconst ipGeoAllow = new akamai.AppSecIPGeo(\"ipGeoAllow\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1-090334\",\n    mode: \"allow\",\n    exceptionIpNetworkLists: [\"07126_EXCEPTION_TEST\"],\n});\nexport const ipGeoModeBlock = ipGeoBlock.mode;\nexport const blockGeoNetworkLists = ipGeoBlock.geoNetworkLists;\nexport const blockIpNetworkLists = ipGeoBlock.ipNetworkLists;\nexport const blockExceptionIpNetworkLists = ipGeoBlock.exceptionIpNetworkLists;\nexport const ipGeoModeAllow = ipGeoAllow.mode;\nexport const allowExceptionIpNetworkLists = ipGeoAllow.exceptionIpNetworkLists;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nip_geo_block = akamai.AppSecIPGeo(\"ipGeoBlock\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    mode=\"block\",\n    geo_network_lists=[\"06038_GEO_TEST\"],\n    ip_network_lists=[\"56921_TEST\"],\n    exception_ip_network_lists=[\"07126_EXCEPTION_TEST\"])\n# USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\nip_geo_allow = akamai.AppSecIPGeo(\"ipGeoAllow\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1-090334\",\n    mode=\"allow\",\n    exception_ip_network_lists=[\"07126_EXCEPTION_TEST\"])\npulumi.export(\"ipGeoModeBlock\", ip_geo_block.mode)\npulumi.export(\"blockGeoNetworkLists\", ip_geo_block.geo_network_lists)\npulumi.export(\"blockIpNetworkLists\", ip_geo_block.ip_network_lists)\npulumi.export(\"blockExceptionIpNetworkLists\", ip_geo_block.exception_ip_network_lists)\npulumi.export(\"ipGeoModeAllow\", ip_geo_allow.mode)\npulumi.export(\"allowExceptionIpNetworkLists\", ip_geo_allow.exception_ip_network_lists)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ipGeoBlock = new Akamai.AppSecIPGeo(\"ipGeoBlock\", new Akamai.AppSecIPGeoArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Mode = \"block\",\n            GeoNetworkLists = \n            {\n                \"06038_GEO_TEST\",\n            },\n            IpNetworkLists = \n            {\n                \"56921_TEST\",\n            },\n            ExceptionIpNetworkLists = \n            {\n                \"07126_EXCEPTION_TEST\",\n            },\n        });\n        // USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\n        var ipGeoAllow = new Akamai.AppSecIPGeo(\"ipGeoAllow\", new Akamai.AppSecIPGeoArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1-090334\",\n            Mode = \"allow\",\n            ExceptionIpNetworkLists = \n            {\n                \"07126_EXCEPTION_TEST\",\n            },\n        });\n        this.IpGeoModeBlock = ipGeoBlock.Mode;\n        this.BlockGeoNetworkLists = ipGeoBlock.GeoNetworkLists;\n        this.BlockIpNetworkLists = ipGeoBlock.IpNetworkLists;\n        this.BlockExceptionIpNetworkLists = ipGeoBlock.ExceptionIpNetworkLists;\n        this.IpGeoModeAllow = ipGeoAllow.Mode;\n        this.AllowExceptionIpNetworkLists = ipGeoAllow.ExceptionIpNetworkLists;\n    }\n\n    [Output(\"ipGeoModeBlock\")]\n    public Output\u003cstring\u003e IpGeoModeBlock { get; set; }\n    [Output(\"blockGeoNetworkLists\")]\n    public Output\u003cstring\u003e BlockGeoNetworkLists { get; set; }\n    [Output(\"blockIpNetworkLists\")]\n    public Output\u003cstring\u003e BlockIpNetworkLists { get; set; }\n    [Output(\"blockExceptionIpNetworkLists\")]\n    public Output\u003cstring\u003e BlockExceptionIpNetworkLists { get; set; }\n    [Output(\"ipGeoModeAllow\")]\n    public Output\u003cstring\u003e IpGeoModeAllow { get; set; }\n    [Output(\"allowExceptionIpNetworkLists\")]\n    public Output\u003cstring\u003e AllowExceptionIpNetworkLists { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeoBlock, err := akamai.NewAppSecIPGeo(ctx, \"ipGeoBlock\", \u0026akamai.AppSecIPGeoArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tMode:             pulumi.String(\"block\"),\n\t\t\tGeoNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"06038_GEO_TEST\"),\n\t\t\t},\n\t\t\tIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"56921_TEST\"),\n\t\t\t},\n\t\t\tExceptionIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"07126_EXCEPTION_TEST\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeoAllow, err := akamai.NewAppSecIPGeo(ctx, \"ipGeoAllow\", \u0026akamai.AppSecIPGeoArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1-090334\"),\n\t\t\tMode:             pulumi.String(\"allow\"),\n\t\t\tExceptionIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"07126_EXCEPTION_TEST\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ipGeoModeBlock\", ipGeoBlock.Mode)\n\t\tctx.Export(\"blockGeoNetworkLists\", ipGeoBlock.GeoNetworkLists)\n\t\tctx.Export(\"blockIpNetworkLists\", ipGeoBlock.IpNetworkLists)\n\t\tctx.Export(\"blockExceptionIpNetworkLists\", ipGeoBlock.ExceptionIpNetworkLists)\n\t\tctx.Export(\"ipGeoModeAllow\", ipGeoAllow.Mode)\n\t\tctx.Export(\"allowExceptionIpNetworkLists\", ipGeoAllow.ExceptionIpNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecIPGeo;\nimport com.pulumi.akamai.AppSecIPGeoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ipGeoBlock = new AppSecIPGeo(\"ipGeoBlock\", AppSecIPGeoArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .mode(\"block\")\n            .geoNetworkLists(\"06038_GEO_TEST\")\n            .ipNetworkLists(\"56921_TEST\")\n            .exceptionIpNetworkLists(\"07126_EXCEPTION_TEST\")\n            .build());\n\n        var ipGeoAllow = new AppSecIPGeo(\"ipGeoAllow\", AppSecIPGeoArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1-090334\")\n            .mode(\"allow\")\n            .exceptionIpNetworkLists(\"07126_EXCEPTION_TEST\")\n            .build());\n\n        ctx.export(\"ipGeoModeBlock\", ipGeoBlock.mode());\n        ctx.export(\"blockGeoNetworkLists\", ipGeoBlock.geoNetworkLists());\n        ctx.export(\"blockIpNetworkLists\", ipGeoBlock.ipNetworkLists());\n        ctx.export(\"blockExceptionIpNetworkLists\", ipGeoBlock.exceptionIpNetworkLists());\n        ctx.export(\"ipGeoModeAllow\", ipGeoAllow.mode());\n        ctx.export(\"allowExceptionIpNetworkLists\", ipGeoAllow.exceptionIpNetworkLists());\n    }\n}\n```\n```yaml\nresources:\n  ipGeoBlock: # USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\n    type: akamai:AppSecIPGeo\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      mode: block\n      geoNetworkLists:\n        - 06038_GEO_TEST\n      ipNetworkLists:\n        - 56921_TEST\n      exceptionIpNetworkLists:\n        - 07126_EXCEPTION_TEST\n  ipGeoAllow:\n    type: akamai:AppSecIPGeo\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1-090334\n      mode: allow\n      exceptionIpNetworkLists:\n        - 07126_EXCEPTION_TEST\nvariables:\n  configuration: # USE CASE: User wants to update the IP/Geo firewall mode, and update the IP, geographic, and exception lists.\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  ipGeoModeBlock: ${ipGeoBlock.mode}\n  blockGeoNetworkLists: ${ipGeoBlock.geoNetworkLists}\n  blockIpNetworkLists: ${ipGeoBlock.ipNetworkLists}\n  blockExceptionIpNetworkLists: ${ipGeoBlock.exceptionIpNetworkLists}\n  ipGeoModeAllow: ${ipGeoAllow.mode}\n  allowExceptionIpNetworkLists: ${ipGeoAllow.exceptionIpNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                },
                "exceptionIpNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                },
                "geoNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "ipNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                }
            },
            "required": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                },
                "exceptionIpNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                },
                "geoNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "ipNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecIPGeo resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                    },
                    "exceptionIpNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                    },
                    "geoNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                    },
                    "ipNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecIPGeoProtection:AppSecIPGeoProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables IP/Geo protection for the specified configuration and security policy. When enabled, this allows your firewall to allow (or to block) clients based on their IP address or their geographic location.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecIPGeoProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecIPGeoProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecIPGeoProtection(\"protection\", new Akamai.AppSecIPGeoProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecIPGeoProtection(ctx, \"protection\", \u0026akamai.AppSecIPGeoProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecIPGeoProtection;\nimport com.pulumi.akamai.AppSecIPGeoProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecIPGeoProtection(\"protection\", AppSecIPGeoProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecIPGeoProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecIPGeoProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMatchTarget:AppSecMatchTarget": {
            "description": "**Scopes**: Security configuration\n\nCreates a match target associated with a security configuration. Match targets determine which security policy should apply to an API, hostname or path.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets](https://techdocs.akamai.com/application-security/reference/post-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTarget = new akamai.AppSecMatchTarget(\"matchTarget\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    matchTarget: fs.readFileSync(`${path.module}/match_targets.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_target = akamai.AppSecMatchTarget(\"matchTarget\",\n    config_id=configuration.config_id,\n    match_target=(lambda path: open(path).read())(f\"{path['module']}/match_targets.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var matchTarget = new Akamai.AppSecMatchTarget(\"matchTarget\", new Akamai.AppSecMatchTargetArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            MatchTarget = File.ReadAllText($\"{path.Module}/match_targets.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMatchTarget(ctx, \"matchTarget\", \u0026akamai.AppSecMatchTargetArgs{\n\t\t\tConfigId:    pulumi.Int(configuration.ConfigId),\n\t\t\tMatchTarget: readFileOrPanic(fmt.Sprintf(\"%v/match_targets.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMatchTarget;\nimport com.pulumi.akamai.AppSecMatchTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var matchTarget = new AppSecMatchTarget(\"matchTarget\", AppSecMatchTargetArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTarget(Files.readString(Paths.get(String.format(\"%s/match_targets.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nIn addition to the arguments above, the following attribute is exported:\n\n- `match_target_id`. ID of the match target.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                },
                "matchTarget": {
                    "type": "string",
                    "description": ". Path to a JSON file containing one or more match target definitions. You can find a sample match target JSON file in the [Create a match target section](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postmatchtargets) of the Application Security API documentation.\n"
                },
                "matchTargetId": {
                    "type": "integer"
                }
            },
            "required": [
                "configId",
                "matchTarget",
                "matchTargetId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                },
                "matchTarget": {
                    "type": "string",
                    "description": ". Path to a JSON file containing one or more match target definitions. You can find a sample match target JSON file in the [Create a match target section](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postmatchtargets) of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "matchTarget"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMatchTarget resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                    },
                    "matchTarget": {
                        "type": "string",
                        "description": ". Path to a JSON file containing one or more match target definitions. You can find a sample match target JSON file in the [Create a match target section](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postmatchtargets) of the Application Security API documentation.\n"
                    },
                    "matchTargetId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMatchTargetSequence:AppSecMatchTargetSequence": {
            "description": "**Scopes**: Security configuration\n\nSpecifies the order in which match targets are applied within a security configuration. As a general rule, you should process broader and more-general match targets first, gradually working your way down to more granular and highly-specific targets.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-match-targets-sequence)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargetSequence = new akamai.AppSecMatchTargetSequence(\"matchTargetSequence\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    matchTargetSequence: fs.readFileSync(`${path.module}/match_targets_sequence.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_target_sequence = akamai.AppSecMatchTargetSequence(\"matchTargetSequence\",\n    config_id=configuration.config_id,\n    match_target_sequence=(lambda path: open(path).read())(f\"{path['module']}/match_targets_sequence.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var matchTargetSequence = new Akamai.AppSecMatchTargetSequence(\"matchTargetSequence\", new Akamai.AppSecMatchTargetSequenceArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            MatchTargetSequence = File.ReadAllText($\"{path.Module}/match_targets_sequence.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMatchTargetSequence(ctx, \"matchTargetSequence\", \u0026akamai.AppSecMatchTargetSequenceArgs{\n\t\t\tConfigId:            pulumi.Int(configuration.ConfigId),\n\t\t\tMatchTargetSequence: readFileOrPanic(fmt.Sprintf(\"%v/match_targets_sequence.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMatchTargetSequence;\nimport com.pulumi.akamai.AppSecMatchTargetSequenceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var matchTargetSequence = new AppSecMatchTargetSequence(\"matchTargetSequence\", AppSecMatchTargetSequenceArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTargetSequence(Files.readString(Paths.get(String.format(\"%s/match_targets_sequence.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                },
                "matchTargetSequence": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://developer.akamai.com/api/cloud_security/application_security/v1.html#matchtargetorder) section of the Application Security API documentation.\n"
                }
            },
            "required": [
                "configId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                },
                "matchTargetSequence": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://developer.akamai.com/api/cloud_security/application_security/v1.html#matchtargetorder) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMatchTargetSequence resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                    },
                    "matchTargetSequence": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://developer.akamai.com/api/cloud_security/application_security/v1.html#matchtargetorder) section of the Application Security API documentation.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecPenaltyBox:AppSecPenaltyBox": {
            "description": "**Scopes**: Security policy\n\nModifies the penalty box settings for a security policy.\nWhen the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-policy-penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst penaltyBox = new akamai.AppSecPenaltyBox(\"penaltyBox\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    penaltyBoxProtection: true,\n    penaltyBoxAction: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npenalty_box = akamai.AppSecPenaltyBox(\"penaltyBox\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    penalty_box_protection=True,\n    penalty_box_action=\"deny\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var penaltyBox = new Akamai.AppSecPenaltyBox(\"penaltyBox\", new Akamai.AppSecPenaltyBoxArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            PenaltyBoxProtection = true,\n            PenaltyBoxAction = \"deny\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecPenaltyBox(ctx, \"penaltyBox\", \u0026akamai.AppSecPenaltyBoxArgs{\n\t\t\tConfigId:             pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:     pulumi.String(\"gms1_134637\"),\n\t\t\tPenaltyBoxProtection: pulumi.Bool(true),\n\t\t\tPenaltyBoxAction:     pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecPenaltyBox;\nimport com.pulumi.akamai.AppSecPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var penaltyBox = new AppSecPenaltyBox(\"penaltyBox\", AppSecPenaltyBoxArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .penaltyBoxProtection(true)\n            .penaltyBoxAction(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  penaltyBox:\n    type: akamai:AppSecPenaltyBox\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      penaltyBoxProtection: true\n      penaltyBoxAction: deny\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecPenaltyBox resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                    },
                    "penaltyBoxAction": {
                        "type": "string",
                        "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "penaltyBoxProtection": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRatePolicy:AppSecRatePolicy": {
            "description": "**Scopes**: Security configuration; rate policy\n\nCreates, modifies, or deletes rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive.\nIn turn, this helps you prevent your website from being overwhelmed by a dramatic and unexpected surge in traffic.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/post-rate-policies)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicy = new akamai.AppSecRatePolicy(\"ratePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    ratePolicy: fs.readFileSync(`${path.module}/rate_policy.json`),\n});\nexport const ratePolicyId = ratePolicy.ratePolicyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policy = akamai.AppSecRatePolicy(\"ratePolicy\",\n    config_id=configuration.config_id,\n    rate_policy=(lambda path: open(path).read())(f\"{path['module']}/rate_policy.json\"))\npulumi.export(\"ratePolicyId\", rate_policy.rate_policy_id)\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ratePolicy = new Akamai.AppSecRatePolicy(\"ratePolicy\", new Akamai.AppSecRatePolicyArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            RatePolicy = File.ReadAllText($\"{path.Module}/rate_policy.json\"),\n        });\n        this.RatePolicyId = ratePolicy.RatePolicyId;\n    }\n\n    [Output(\"ratePolicyId\")]\n    public Output\u003cstring\u003e RatePolicyId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicy, err := akamai.NewAppSecRatePolicy(ctx, \"ratePolicy\", \u0026akamai.AppSecRatePolicyArgs{\n\t\t\tConfigId:   pulumi.Int(configuration.ConfigId),\n\t\t\tRatePolicy: readFileOrPanic(fmt.Sprintf(\"%v/rate_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyId\", ratePolicy.RatePolicyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRatePolicy;\nimport com.pulumi.akamai.AppSecRatePolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ratePolicy = new AppSecRatePolicy(\"ratePolicy\", AppSecRatePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicy(Files.readString(Paths.get(String.format(\"%s/rate_policy.json\", path.module()))))\n            .build());\n\n        ctx.export(\"ratePolicyId\", ratePolicy.ratePolicyId());\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `rate_policy_id`. ID of the modified or newly-created rate policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                },
                "ratePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a rate policy definition. You can view a sample rate policy JSON file in the [RatePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#ratepolicy) section of the Application Security API documentation.\n"
                },
                "ratePolicyId": {
                    "type": "integer"
                }
            },
            "required": [
                "configId",
                "ratePolicy",
                "ratePolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                },
                "ratePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a rate policy definition. You can view a sample rate policy JSON file in the [RatePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#ratepolicy) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ratePolicy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRatePolicy resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                    },
                    "ratePolicy": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a rate policy definition. You can view a sample rate policy JSON file in the [RatePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#ratepolicy) section of the Application Security API documentation.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRatePolicyAction:AppSecRatePolicyAction": {
            "description": "**Scopes**: Rate policy\n\nCreates, modifies, or deletes the actions associated with a rate policy.\nBy default, rate policies take no action when triggered.\nNote that you must set separate actions for requests originating from an IPv4 IP address and for requests originating from an IPv6 address.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies/{ratePolicyId}](https://techdocs.akamai.com/application-security/reference/put-rate-policy-action)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecRatePolicy = new akamai.AppSecRatePolicy(\"appsecRatePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    ratePolicy: fs.readFileSync(`${path.module}/rate_policy.json`),\n});\nconst appsecRatePolicyAction = new akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ratePolicyId: appsecRatePolicy.ratePolicyId,\n    ipv4Action: \"deny\",\n    ipv6Action: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_rate_policy = akamai.AppSecRatePolicy(\"appsecRatePolicy\",\n    config_id=configuration.config_id,\n    rate_policy=(lambda path: open(path).read())(f\"{path['module']}/rate_policy.json\"))\nappsec_rate_policy_action = akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rate_policy_id=appsec_rate_policy.rate_policy_id,\n    ipv4_action=\"deny\",\n    ipv6_action=\"deny\")\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var appsecRatePolicy = new Akamai.AppSecRatePolicy(\"appsecRatePolicy\", new Akamai.AppSecRatePolicyArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            RatePolicy = File.ReadAllText($\"{path.Module}/rate_policy.json\"),\n        });\n        var appsecRatePolicyAction = new Akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\", new Akamai.AppSecRatePolicyActionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            RatePolicyId = appsecRatePolicy.RatePolicyId,\n            Ipv4Action = \"deny\",\n            Ipv6Action = \"deny\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappsecRatePolicy, err := akamai.NewAppSecRatePolicy(ctx, \"appsecRatePolicy\", \u0026akamai.AppSecRatePolicyArgs{\n\t\t\tConfigId:   pulumi.Int(configuration.ConfigId),\n\t\t\tRatePolicy: readFileOrPanic(fmt.Sprintf(\"%v/rate_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRatePolicyAction(ctx, \"appsecRatePolicyAction\", \u0026akamai.AppSecRatePolicyActionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tRatePolicyId:     appsecRatePolicy.RatePolicyId,\n\t\t\tIpv4Action:       pulumi.String(\"deny\"),\n\t\t\tIpv6Action:       pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRatePolicy;\nimport com.pulumi.akamai.AppSecRatePolicyArgs;\nimport com.pulumi.akamai.AppSecRatePolicyAction;\nimport com.pulumi.akamai.AppSecRatePolicyActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecRatePolicy = new AppSecRatePolicy(\"appsecRatePolicy\", AppSecRatePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicy(Files.readString(Paths.get(String.format(\"%s/rate_policy.json\", path.module()))))\n            .build());\n\n        var appsecRatePolicyAction = new AppSecRatePolicyAction(\"appsecRatePolicyAction\", AppSecRatePolicyActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ratePolicyId(appsecRatePolicy.ratePolicyId())\n            .ipv4Action(\"deny\")\n            .ipv6Action(\"deny\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                },
                "ipv4Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ipv6Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                },
                "ratePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                }
            },
            "required": [
                "configId",
                "ipv4Action",
                "ipv6Action",
                "ratePolicyId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                },
                "ipv4Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ipv6Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                },
                "ratePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ipv4Action",
                "ipv6Action",
                "ratePolicyId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRatePolicyAction resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                    },
                    "ipv4Action": {
                        "type": "string",
                        "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "ipv6Action": {
                        "type": "string",
                        "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRateProtection:AppSecRateProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables rate protection for a security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecRateProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecRateProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecRateProtection(\"protection\", new Akamai.AppSecRateProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRateProtection(ctx, \"protection\", \u0026akamai.AppSecRateProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRateProtection;\nimport com.pulumi.akamai.AppSecRateProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecRateProtection(\"protection\", AppSecRateProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecRateProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRateProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfile:AppSecReputationProfile": {
            "description": "**Scopes**: Security policy\n\nCreates or modifies a reputation profile.\nReputation profiles grade the security risk of an IP address based on previous activities associated with that address.\nDepending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/put-reputation-profile)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfile = new akamai.AppSecReputationProfile(\"reputationProfile\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    reputationProfile: fs.readFileSync(`${path.module}/reputation_profile.json`),\n});\nexport const reputationProfileId = reputationProfile.reputationProfileId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profile = akamai.AppSecReputationProfile(\"reputationProfile\",\n    config_id=configuration.config_id,\n    reputation_profile=(lambda path: open(path).read())(f\"{path['module']}/reputation_profile.json\"))\npulumi.export(\"reputationProfileId\", reputation_profile.reputation_profile_id)\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var reputationProfile = new Akamai.AppSecReputationProfile(\"reputationProfile\", new Akamai.AppSecReputationProfileArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            ReputationProfile = File.ReadAllText($\"{path.Module}/reputation_profile.json\"),\n        });\n        this.ReputationProfileId = reputationProfile.ReputationProfileId;\n    }\n\n    [Output(\"reputationProfileId\")]\n    public Output\u003cstring\u003e ReputationProfileId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfile, err := akamai.NewAppSecReputationProfile(ctx, \"reputationProfile\", \u0026akamai.AppSecReputationProfileArgs{\n\t\t\tConfigId:          pulumi.Int(configuration.ConfigId),\n\t\t\tReputationProfile: readFileOrPanic(fmt.Sprintf(\"%v/reputation_profile.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileId\", reputationProfile.ReputationProfileId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProfile;\nimport com.pulumi.akamai.AppSecReputationProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var reputationProfile = new AppSecReputationProfile(\"reputationProfile\", AppSecReputationProfileArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .reputationProfile(Files.readString(Paths.get(String.format(\"%s/reputation_profile.json\", path.module()))))\n            .build());\n\n        ctx.export(\"reputationProfileId\", reputationProfile.reputationProfileId());\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `reputation_profile_id`. ID of the newly-created or newly-modified reputation profile.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                },
                "reputationProfile": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a definition of the reputation profile. You can view a sample JSON file in the [Create a reputation profile](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postreputationprofiles) section of the Application Security API documentation.\n"
                },
                "reputationProfileId": {
                    "type": "integer"
                }
            },
            "required": [
                "configId",
                "reputationProfile",
                "reputationProfileId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                },
                "reputationProfile": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a definition of the reputation profile. You can view a sample JSON file in the [Create a reputation profile](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postreputationprofiles) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "reputationProfile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfile resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                    },
                    "reputationProfile": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a definition of the reputation profile. You can view a sample JSON file in the [Create a reputation profile](https://developer.akamai.com/api/cloud_security/application_security/v1.html#postreputationprofiles) section of the Application Security API documentation.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfileAction:AppSecReputationProfileAction": {
            "description": "**Scopes**: Reputation profile\n\nModifies the action taken when a reputation profile is triggered.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles/{reputationProfileId}](https://techdocs.akamai.com/application-security/reference/put-reputation-profile-action)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecReputationProfileAction = new akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    reputationProfileId: 130713,\n    action: \"alert\",\n});\nexport const reputationProfileId = appsecReputationProfileAction.reputationProfileId;\nexport const reputationProfileAction = appsecReputationProfileAction.action;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_reputation_profile_action = akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    reputation_profile_id=130713,\n    action=\"alert\")\npulumi.export(\"reputationProfileId\", appsec_reputation_profile_action.reputation_profile_id)\npulumi.export(\"reputationProfileAction\", appsec_reputation_profile_action.action)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var appsecReputationProfileAction = new Akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\", new Akamai.AppSecReputationProfileActionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            ReputationProfileId = 130713,\n            Action = \"alert\",\n        });\n        this.ReputationProfileId = appsecReputationProfileAction.ReputationProfileId;\n        this.ReputationProfileAction = appsecReputationProfileAction.Action;\n    }\n\n    [Output(\"reputationProfileId\")]\n    public Output\u003cstring\u003e ReputationProfileId { get; set; }\n    [Output(\"reputationProfileAction\")]\n    public Output\u003cstring\u003e ReputationProfileAction { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappsecReputationProfileAction, err := akamai.NewAppSecReputationProfileAction(ctx, \"appsecReputationProfileAction\", \u0026akamai.AppSecReputationProfileActionArgs{\n\t\t\tConfigId:            pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:    pulumi.String(\"gms1_134637\"),\n\t\t\tReputationProfileId: pulumi.Int(130713),\n\t\t\tAction:              pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileId\", appsecReputationProfileAction.ReputationProfileId)\n\t\tctx.Export(\"reputationProfileAction\", appsecReputationProfileAction.Action)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProfileAction;\nimport com.pulumi.akamai.AppSecReputationProfileActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecReputationProfileAction = new AppSecReputationProfileAction(\"appsecReputationProfileAction\", AppSecReputationProfileActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .reputationProfileId(130713)\n            .action(\"alert\")\n            .build());\n\n        ctx.export(\"reputationProfileId\", appsecReputationProfileAction.reputationProfileId());\n        ctx.export(\"reputationProfileAction\", appsecReputationProfileAction.action());\n    }\n}\n```\n```yaml\nresources:\n  appsecReputationProfileAction:\n    type: akamai:AppSecReputationProfileAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      reputationProfileId: 130713\n      action: alert\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  reputationProfileId: ${appsecReputationProfileAction.reputationProfileId}\n  reputationProfileAction: ${appsecReputationProfileAction.action}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                },
                "reputationProfileId": {
                    "type": "integer",
                    "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                }
            },
            "required": [
                "action",
                "configId",
                "reputationProfileId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                },
                "reputationProfileId": {
                    "type": "integer",
                    "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                }
            },
            "requiredInputs": [
                "action",
                "configId",
                "reputationProfileId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfileAction resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfileAnalysis:AppSecReputationProfileAnalysis": {
            "description": "**Scopes**: Security policy\n\nModifies the reputation analysis settings for a security policy. These settings include the following:\n\n- The `forward_to_http_header` parameter, which indicates whether client reputation details are added to requests forwarded to origin in an HTTP header.\n- The `forward_shared_ip_to_http_header_siem` parameter, which specifies whether a value is added indicating that shared IPs addresses are included in HTTP headers and in SIEM integration events.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/put-reputation-analysis)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .forwardToHttpHeader(true)\n            .build());\n\n        ctx.export(\"reputationAnalysisText\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.outputText()));\n        ctx.export(\"reputationAnalysisJson\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationAnalysis:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfileAnalysis\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        forwardToHttpHeader: true\noutputs:\n  reputationAnalysisText: ${reputationAnalysis.outputText}\n  reputationAnalysisJson: ${reputationAnalysis.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                },
                "forwardSharedIpToHttpHeaderSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                },
                "forwardToHttpHeader": {
                    "type": "boolean",
                    "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "forwardSharedIpToHttpHeaderSiem",
                "forwardToHttpHeader",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                },
                "forwardSharedIpToHttpHeaderSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                },
                "forwardToHttpHeader": {
                    "type": "boolean",
                    "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "forwardSharedIpToHttpHeaderSiem",
                "forwardToHttpHeader",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfileAnalysis resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                    },
                    "forwardSharedIpToHttpHeaderSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                    },
                    "forwardToHttpHeader": {
                        "type": "boolean",
                        "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProtection:AppSecReputationProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables reputation protection for a security configuration and security policy.\nReputation profiles grade the security risk of an IP address based on previous activities associated with that address.\nDepending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecReputationProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecReputationProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecReputationProtection(\"protection\", new Akamai.AppSecReputationProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecReputationProtection(ctx, \"protection\", \u0026akamai.AppSecReputationProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProtection;\nimport com.pulumi.akamai.AppSecReputationProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecReputationProtection(\"protection\", AppSecReputationProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecReputationProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRule:AppSecRule": {
            "description": "**Scopes**: Rule\n\nModifies a Kona Rule Set rule's action, conditions, and exceptions.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-rule-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst rule = new akamai.AppSecRule(\"rule\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n    ruleAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrule = akamai.AppSecRule(\"rule\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316,\n    rule_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var rule = new Akamai.AppSecRule(\"rule\", new Akamai.AppSecRuleArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            RuleId = 60029316,\n            RuleAction = \"deny\",\n            ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRule(ctx, \"rule\", \u0026akamai.AppSecRuleArgs{\n\t\t\tConfigId:           pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tRuleId:             pulumi.Int(60029316),\n\t\t\tRuleAction:         pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRule;\nimport com.pulumi.akamai.AppSecRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var rule = new AppSecRule(\"rule\", AppSecRuleArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(60029316)\n            .ruleAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule. You can view a sample JSON file in the [Modify the conditions and exceptions of a rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putruleconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                }
            },
            "required": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule. You can view a sample JSON file in the [Modify the conditions and exceptions of a rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putruleconditionexception) section of the Application Security API documentation.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ruleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRule resources.\n",
                "properties": {
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule. You can view a sample JSON file in the [Modify the conditions and exceptions of a rule](https://developer.akamai.com/api/cloud_security/application_security/v1.html#putruleconditionexception) section of the Application Security API documentation.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                    },
                    "ruleAction": {
                        "type": "string",
                        "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rule being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRuleUpgrade:AppSecRuleUpgrade": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ruleUpgrade = new akamai.AppSecRuleUpgrade(\"ruleUpgrade\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n});\nexport const ruleUpgradeCurrentRuleset = ruleUpgrade.currentRuleset;\nexport const ruleUpgradeMode = ruleUpgrade.mode;\nexport const ruleUpgradeEvalStatus = ruleUpgrade.evalStatus;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrule_upgrade = akamai.AppSecRuleUpgrade(\"ruleUpgrade\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ruleUpgradeCurrentRuleset\", rule_upgrade.current_ruleset)\npulumi.export(\"ruleUpgradeMode\", rule_upgrade.mode)\npulumi.export(\"ruleUpgradeEvalStatus\", rule_upgrade.eval_status)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ruleUpgrade = new Akamai.AppSecRuleUpgrade(\"ruleUpgrade\", new Akamai.AppSecRuleUpgradeArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n        });\n        this.RuleUpgradeCurrentRuleset = ruleUpgrade.CurrentRuleset;\n        this.RuleUpgradeMode = ruleUpgrade.Mode;\n        this.RuleUpgradeEvalStatus = ruleUpgrade.EvalStatus;\n    }\n\n    [Output(\"ruleUpgradeCurrentRuleset\")]\n    public Output\u003cstring\u003e RuleUpgradeCurrentRuleset { get; set; }\n    [Output(\"ruleUpgradeMode\")]\n    public Output\u003cstring\u003e RuleUpgradeMode { get; set; }\n    [Output(\"ruleUpgradeEvalStatus\")]\n    public Output\u003cstring\u003e RuleUpgradeEvalStatus { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\truleUpgrade, err := akamai.NewAppSecRuleUpgrade(ctx, \"ruleUpgrade\", \u0026akamai.AppSecRuleUpgradeArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ruleUpgradeCurrentRuleset\", ruleUpgrade.CurrentRuleset)\n\t\tctx.Export(\"ruleUpgradeMode\", ruleUpgrade.Mode)\n\t\tctx.Export(\"ruleUpgradeEvalStatus\", ruleUpgrade.EvalStatus)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRuleUpgrade;\nimport com.pulumi.akamai.AppSecRuleUpgradeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ruleUpgrade = new AppSecRuleUpgrade(\"ruleUpgrade\", AppSecRuleUpgradeArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ruleUpgradeCurrentRuleset\", ruleUpgrade.currentRuleset());\n        ctx.export(\"ruleUpgradeMode\", ruleUpgrade.mode());\n        ctx.export(\"ruleUpgradeEvalStatus\", ruleUpgrade.evalStatus());\n    }\n}\n```\n```yaml\nresources:\n  ruleUpgrade:\n    type: akamai:AppSecRuleUpgrade\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  ruleUpgradeCurrentRuleset: ${ruleUpgrade.currentRuleset}\n  ruleUpgradeMode: ${ruleUpgrade.mode}\n  ruleUpgradeEvalStatus: ${ruleUpgrade.evalStatus}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `current_ruleset`. Versioning information for your current KRS rule set.\n- `mode`. Specifies the current upgrade mode type. Valid values are:\n  - **KRS**. Rulesets must be manually upgraded.\n\n  - **AAG**. Rulesets are automatically upgraded by Akamai.\n\n  - **ASE_MANUAL**. Adaptive Security Engine rulesets must be manually upgraded.\n\n  - **ASE_AUTO**. Adaptive Security Engine rulesets are automatically updated by Akamai.\n\n- `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                },
                "currentRuleset": {
                    "type": "string"
                },
                "evalStatus": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n- `upgrade_mode`. (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                },
                "upgradeMode": {
                    "type": "string"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalStatus",
                "mode",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n- `upgrade_mode`. (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                },
                "upgradeMode": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRuleUpgrade resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                    },
                    "currentRuleset": {
                        "type": "string"
                    },
                    "evalStatus": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n- `upgrade_mode`. (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                    },
                    "upgradeMode": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSecurityPolicy:AppSecSecurityPolicy": {
            "description": "**Scopes**: Security configuration\n\nCreates a new security policy. The resource enables you to:\n\n- Create a new, “blank” security policy.\n- Create a new policy preconfigured with the default security policy settings.\n- Clone an existing security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies](https://techdocs.akamai.com/application-security/reference/post-policy)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst securityPolicyCreateAppSecSecurityPolicy = new akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    defaultSettings: true,\n    securityPolicyName: \"Documentation Policy\",\n    securityPolicyPrefix: \"gms1\",\n});\nexport const securityPolicyCreate = securityPolicyCreateAppSecSecurityPolicy.securityPolicyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsecurity_policy_create_app_sec_security_policy = akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\",\n    config_id=configuration.config_id,\n    default_settings=True,\n    security_policy_name=\"Documentation Policy\",\n    security_policy_prefix=\"gms1\")\npulumi.export(\"securityPolicyCreate\", security_policy_create_app_sec_security_policy.security_policy_id)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var securityPolicyCreateAppSecSecurityPolicy = new Akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", new Akamai.AppSecSecurityPolicyArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            DefaultSettings = true,\n            SecurityPolicyName = \"Documentation Policy\",\n            SecurityPolicyPrefix = \"gms1\",\n        });\n        this.SecurityPolicyCreate = securityPolicyCreateAppSecSecurityPolicy.SecurityPolicyId;\n    }\n\n    [Output(\"securityPolicyCreate\")]\n    public Output\u003cstring\u003e SecurityPolicyCreate { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecurityPolicyCreateAppSecSecurityPolicy, err := akamai.NewAppSecSecurityPolicy(ctx, \"securityPolicyCreateAppSecSecurityPolicy\", \u0026akamai.AppSecSecurityPolicyArgs{\n\t\t\tConfigId:             pulumi.Int(configuration.ConfigId),\n\t\t\tDefaultSettings:      pulumi.Bool(true),\n\t\t\tSecurityPolicyName:   pulumi.String(\"Documentation Policy\"),\n\t\t\tSecurityPolicyPrefix: pulumi.String(\"gms1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"securityPolicyCreate\", securityPolicyCreateAppSecSecurityPolicy.SecurityPolicyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSecurityPolicy;\nimport com.pulumi.akamai.AppSecSecurityPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var securityPolicyCreateAppSecSecurityPolicy = new AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", AppSecSecurityPolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .defaultSettings(true)\n            .securityPolicyName(\"Documentation Policy\")\n            .securityPolicyPrefix(\"gms1\")\n            .build());\n\n        ctx.export(\"securityPolicyCreate\", securityPolicyCreateAppSecSecurityPolicy.securityPolicyId());\n    }\n}\n```\n```yaml\nresources:\n  securityPolicyCreateAppSecSecurityPolicy:\n    type: akamai:AppSecSecurityPolicy\n    properties:\n      configId: ${configuration.configId}\n      defaultSettings: true\n      securityPolicyName: Documentation Policy\n      securityPolicyPrefix: gms1\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  securityPolicyCreate: ${securityPolicyCreateAppSecSecurityPolicy.securityPolicyId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `security_policy_id`. ID of the newly-created security policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                },
                "createFromSecurityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                },
                "defaultSettings": {
                    "type": "boolean",
                    "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "Policy ID for new policy\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". Name of the new security policy.\n"
                },
                "securityPolicyPrefix": {
                    "type": "string",
                    "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "securityPolicyName",
                "securityPolicyPrefix"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                },
                "createFromSecurityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                },
                "defaultSettings": {
                    "type": "boolean",
                    "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". Name of the new security policy.\n"
                },
                "securityPolicyPrefix": {
                    "type": "string",
                    "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyName",
                "securityPolicyPrefix"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSecurityPolicy resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                    },
                    "createFromSecurityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                    },
                    "defaultSettings": {
                        "type": "boolean",
                        "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "Policy ID for new policy\n"
                    },
                    "securityPolicyName": {
                        "type": "string",
                        "description": ". Name of the new security policy.\n"
                    },
                    "securityPolicyPrefix": {
                        "type": "string",
                        "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSecurityPolicyRename:AppSecSecurityPolicyRename": {
            "description": "**Scopes**: Security policy\n\nRenames an existing security policy. Note that you can only change the name of the policy: once issued, the security policy ID can't be modified.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}](https://techdocs.akamai.com/application-security/reference/put-policy)\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy being renamed.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". New name to be given to the security policy.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "securityPolicyName"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy being renamed.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". New name to be given to the security policy.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "securityPolicyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSecurityPolicyRename resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy being renamed.\n"
                    },
                    "securityPolicyName": {
                        "type": "string",
                        "description": ". New name to be given to the security policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSelectedHostnames:AppSecSelectedHostnames": {
            "description": "**Scopes**: Security configuration\n\nModifies the list of hostnames protected under by a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/put-selected-hostnames-per-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecselectedhostnames = new akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    hostnames: [\"example.com\"],\n    mode: \"APPEND\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsecselectedhostnames = akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\",\n    config_id=configuration.config_id,\n    hostnames=[\"example.com\"],\n    mode=\"APPEND\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var appsecselectedhostnames = new Akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\", new Akamai.AppSecSelectedHostnamesArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            Hostnames = \n            {\n                \"example.com\",\n            },\n            Mode = \"APPEND\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSelectedHostnames(ctx, \"appsecselectedhostnames\", \u0026akamai.AppSecSelectedHostnamesArgs{\n\t\t\tConfigId: pulumi.Int(configuration.ConfigId),\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tMode: pulumi.String(\"APPEND\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSelectedHostnames;\nimport com.pulumi.akamai.AppSecSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecselectedhostnames = new AppSecSelectedHostnames(\"appsecselectedhostnames\", AppSecSelectedHostnamesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostnames(\"example.com\")\n            .mode(\"APPEND\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecselectedhostnames:\n    type: akamai:AppSecSelectedHostnames\n    properties:\n      configId: ${configuration.configId}\n      hostnames:\n        - example.com\n      mode: APPEND\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                }
            },
            "required": [
                "configId",
                "hostnames",
                "mode"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "hostnames",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSelectedHostnames resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSiemSettings:AppSecSiemSettings": {
            "description": "**Scopes**: Security configuration\n\nModifies SIEM (Security Information and Event Management) integration settings for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/put-siem)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst siemDefinition = akamai.getAppSecSiemDefinitions({\n    siemDefinitionName: \"SIEM Version 01\",\n});\nconst securityPolicies = configuration.then(configuration =\u003e akamai.getAppSecSecurityPolicy({\n    configId: configuration.configId,\n}));\nconst siem = new akamai.AppSecSiemSettings(\"siem\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enableSiem: true,\n    enableForAllPolicies: false,\n    enableBotmanSiem: true,\n    siemId: siemDefinition.then(siemDefinition =\u003e siemDefinition.id),\n    securityPolicyIds: securityPolicies.then(securityPolicies =\u003e securityPolicies.securityPolicyIdLists),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsiem_definition = akamai.get_app_sec_siem_definitions(siem_definition_name=\"SIEM Version 01\")\nsecurity_policies = akamai.get_app_sec_security_policy(config_id=configuration.config_id)\nsiem = akamai.AppSecSiemSettings(\"siem\",\n    config_id=configuration.config_id,\n    enable_siem=True,\n    enable_for_all_policies=False,\n    enable_botman_siem=True,\n    siem_id=siem_definition.id,\n    security_policy_ids=security_policies.security_policy_id_lists)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var siemDefinition = Output.Create(Akamai.GetAppSecSiemDefinitions.InvokeAsync(new Akamai.GetAppSecSiemDefinitionsArgs\n        {\n            SiemDefinitionName = \"SIEM Version 01\",\n        }));\n        var securityPolicies = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecSecurityPolicy.InvokeAsync(new Akamai.GetAppSecSecurityPolicyArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        var siem = new Akamai.AppSecSiemSettings(\"siem\", new Akamai.AppSecSiemSettingsArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            EnableSiem = true,\n            EnableForAllPolicies = false,\n            EnableBotmanSiem = true,\n            SiemId = siemDefinition.Apply(siemDefinition =\u003e siemDefinition.Id),\n            SecurityPolicyIds = securityPolicies.Apply(securityPolicies =\u003e securityPolicies.SecurityPolicyIdLists),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsiemDefinition, err := akamai.GetAppSecSiemDefinitions(ctx, \u0026GetAppSecSiemDefinitionsArgs{\n\t\t\tSiemDefinitionName: pulumi.StringRef(\"SIEM Version 01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecurityPolicies, err := akamai.LookupAppSecSecurityPolicy(ctx, \u0026GetAppSecSecurityPolicyArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSiemSettings(ctx, \"siem\", \u0026akamai.AppSecSiemSettingsArgs{\n\t\t\tConfigId:             pulumi.Int(configuration.ConfigId),\n\t\t\tEnableSiem:           pulumi.Bool(true),\n\t\t\tEnableForAllPolicies: pulumi.Bool(false),\n\t\t\tEnableBotmanSiem:     pulumi.Bool(true),\n\t\t\tSiemId:               pulumi.String(siemDefinition.Id),\n\t\t\tSecurityPolicyIds:    interface{}(securityPolicies.SecurityPolicyIdLists),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSecurityPolicyArgs;\nimport com.pulumi.akamai.AppSecSiemSettings;\nimport com.pulumi.akamai.AppSecSiemSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()\n            .siemDefinitionName(\"SIEM Version 01\")\n            .build());\n\n        final var securityPolicies = AkamaiFunctions.getAppSecSecurityPolicy(GetAppSecSecurityPolicyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        var siem = new AppSecSiemSettings(\"siem\", AppSecSiemSettingsArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enableSiem(true)\n            .enableForAllPolicies(false)\n            .enableBotmanSiem(true)\n            .siemId(siemDefinition.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.id()))\n            .securityPolicyIds(securityPolicies.applyValue(getAppSecSecurityPolicyResult -\u003e getAppSecSecurityPolicyResult.securityPolicyIdLists()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  siem:\n    type: akamai:AppSecSiemSettings\n    properties:\n      configId: ${configuration.configId}\n      enableSiem: true\n      enableForAllPolicies: false\n      enableBotmanSiem: true\n      siemId: ${siemDefinition.id}\n      securityPolicyIds: ${securityPolicies.securityPolicyIdLists}\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  siemDefinition:\n    Fn::Invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments:\n        siemDefinitionName: SIEM Version 01\n  securityPolicies:\n    Fn::Invoke:\n      Function: akamai:getAppSecSecurityPolicy\n      Arguments:\n        configId: ${configuration.configId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated SIEM integration settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                },
                "enableBotmanSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                },
                "enableForAllPolicies": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                },
                "enableSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                },
                "securityPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                },
                "siemId": {
                    "type": "integer",
                    "description": ". Unique identifier of the SIEM settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enableBotmanSiem",
                "enableForAllPolicies",
                "enableSiem",
                "siemId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                },
                "enableBotmanSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                },
                "enableForAllPolicies": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                },
                "enableSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                },
                "securityPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                },
                "siemId": {
                    "type": "integer",
                    "description": ". Unique identifier of the SIEM settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enableBotmanSiem",
                "enableForAllPolicies",
                "enableSiem",
                "siemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSiemSettings resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                    },
                    "enableBotmanSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                    },
                    "enableForAllPolicies": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                    },
                    "enableSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                    },
                    "securityPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                    },
                    "siemId": {
                        "type": "integer",
                        "description": ". Unique identifier of the SIEM settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSlowPost:AppSecSlowPost": {
            "description": "**Scopes**: Security policy\n\nModifies slow POST protection settings for a security configuration and security policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/put-policy-slow-post)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst slowPost = new akamai.AppSecSlowPost(\"slowPost\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    slowRateAction: \"alert\",\n    slowRateThresholdRate: 10,\n    slowRateThresholdPeriod: 30,\n    durationThresholdTimeout: 20,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nslow_post = akamai.AppSecSlowPost(\"slowPost\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    slow_rate_action=\"alert\",\n    slow_rate_threshold_rate=10,\n    slow_rate_threshold_period=30,\n    duration_threshold_timeout=20)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var slowPost = new Akamai.AppSecSlowPost(\"slowPost\", new Akamai.AppSecSlowPostArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            SlowRateAction = \"alert\",\n            SlowRateThresholdRate = 10,\n            SlowRateThresholdPeriod = 30,\n            DurationThresholdTimeout = 20,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSlowPost(ctx, \"slowPost\", \u0026akamai.AppSecSlowPostArgs{\n\t\t\tConfigId:                 pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:         pulumi.String(\"gms1_134637\"),\n\t\t\tSlowRateAction:           pulumi.String(\"alert\"),\n\t\t\tSlowRateThresholdRate:    pulumi.Int(10),\n\t\t\tSlowRateThresholdPeriod:  pulumi.Int(30),\n\t\t\tDurationThresholdTimeout: pulumi.Int(20),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSlowPost;\nimport com.pulumi.akamai.AppSecSlowPostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var slowPost = new AppSecSlowPost(\"slowPost\", AppSecSlowPostArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .slowRateAction(\"alert\")\n            .slowRateThresholdRate(10)\n            .slowRateThresholdPeriod(30)\n            .durationThresholdTimeout(20)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  slowPost:\n    type: akamai:AppSecSlowPost\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      slowRateAction: alert\n      slowRateThresholdRate: 10\n      slowRateThresholdPeriod: 30\n      durationThresholdTimeout: 20\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                },
                "durationThresholdTimeout": {
                    "type": "integer",
                    "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                },
                "slowRateAction": {
                    "type": "string",
                    "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                },
                "slowRateThresholdPeriod": {
                    "type": "integer",
                    "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                },
                "slowRateThresholdRate": {
                    "type": "integer",
                    "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "slowRateAction"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                },
                "durationThresholdTimeout": {
                    "type": "integer",
                    "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                },
                "slowRateAction": {
                    "type": "string",
                    "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                },
                "slowRateThresholdPeriod": {
                    "type": "integer",
                    "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                },
                "slowRateThresholdRate": {
                    "type": "integer",
                    "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "slowRateAction"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSlowPost resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                    },
                    "durationThresholdTimeout": {
                        "type": "integer",
                        "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                    },
                    "slowRateAction": {
                        "type": "string",
                        "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                    },
                    "slowRateThresholdPeriod": {
                        "type": "integer",
                        "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                    },
                    "slowRateThresholdRate": {
                        "type": "integer",
                        "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSlowPostProtection:AppSecSlowPostProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables slow POST protection for a security configuration and security policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecSlowPostProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecSlowPostProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecSlowPostProtection(\"protection\", new Akamai.AppSecSlowPostProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSlowPostProtection(ctx, \"protection\", \u0026akamai.AppSecSlowPostProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSlowPostProtection;\nimport com.pulumi.akamai.AppSecSlowPostProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecSlowPostProtection(\"protection\", AppSecSlowPostProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecSlowPostProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSlowPostProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecThreatIntel:AppSecThreatIntel": {
            "description": "**Scopes**: Security policy\n\nEnables or disables threat intelligence for a security policy. This resource is only available to organizations running the Adaptive Security Engine (ASE) beta Please contact your Akamai representative for more information.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/put-rules-threat-intel)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst threatIntel = new akamai.AppSecThreatIntel(\"threatIntel\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    threatIntel: \"on\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nthreat_intel = akamai.AppSecThreatIntel(\"threatIntel\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    threat_intel=\"on\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var threatIntel = new Akamai.AppSecThreatIntel(\"threatIntel\", new Akamai.AppSecThreatIntelArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            ThreatIntel = \"on\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecThreatIntel(ctx, \"threatIntel\", \u0026akamai.AppSecThreatIntelArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tThreatIntel:      pulumi.String(\"on\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecThreatIntel;\nimport com.pulumi.akamai.AppSecThreatIntelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var threatIntel = new AppSecThreatIntel(\"threatIntel\", AppSecThreatIntelArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .threatIntel(\"on\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  threatIntel:\n    type: akamai:AppSecThreatIntel\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      threatIntel: on\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                },
                "threatIntel": {
                    "type": "string",
                    "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "threatIntel"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                },
                "threatIntel": {
                    "type": "string",
                    "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "threatIntel"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecThreatIntel resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                    },
                    "threatIntel": {
                        "type": "string",
                        "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecVersionNodes:AppSecVersionNodes": {
            "description": "**Scopes**: Security configuration\n\nUpdates the version notes for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/put-version-notes)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst versionNotesAppSecVersionNodes = new akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    versionNotes: \"This version enables reputation profiles.\",\n});\nexport const versionNotes = versionNotesAppSecVersionNodes.outputText;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nversion_notes_app_sec_version_nodes = akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\",\n    config_id=configuration.config_id,\n    version_notes=\"This version enables reputation profiles.\")\npulumi.export(\"versionNotes\", version_notes_app_sec_version_nodes.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var versionNotesAppSecVersionNodes = new Akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", new Akamai.AppSecVersionNodesArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            VersionNotes = \"This version enables reputation profiles.\",\n        });\n        this.VersionNotes = versionNotesAppSecVersionNodes.OutputText;\n    }\n\n    [Output(\"versionNotes\")]\n    public Output\u003cstring\u003e VersionNotes { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversionNotesAppSecVersionNodes, err := akamai.NewAppSecVersionNodes(ctx, \"versionNotesAppSecVersionNodes\", \u0026akamai.AppSecVersionNodesArgs{\n\t\t\tConfigId:     pulumi.Int(configuration.ConfigId),\n\t\t\tVersionNotes: pulumi.String(\"This version enables reputation profiles.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"versionNotes\", versionNotesAppSecVersionNodes.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecVersionNodes;\nimport com.pulumi.akamai.AppSecVersionNodesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var versionNotesAppSecVersionNodes = new AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", AppSecVersionNodesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .versionNotes(\"This version enables reputation profiles.\")\n            .build());\n\n        ctx.export(\"versionNotes\", versionNotesAppSecVersionNodes.outputText());\n    }\n}\n```\n```yaml\nresources:\n  versionNotesAppSecVersionNodes:\n    type: akamai:AppSecVersionNodes\n    properties:\n      configId: ${configuration.configId}\n      versionNotes: This version enables reputation profiles.\nvariables:\n  configuration: # USE CASE: User wants to update the version notes for the latest version of a security configuration.\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  versionNotes: ${versionNotesAppSecVersionNodes.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated version notes.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "versionNotes": {
                    "type": "string",
                    "description": ". Brief description of the security configuration version.\n"
                }
            },
            "required": [
                "configId",
                "outputText",
                "versionNotes"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                },
                "versionNotes": {
                    "type": "string",
                    "description": ". Brief description of the security configuration version.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "versionNotes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecVersionNodes resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "versionNotes": {
                        "type": "string",
                        "description": ". Brief description of the security configuration version.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWafMode:AppSecWafMode": {
            "description": "**Scopes**: Security policy\n\nModifies the way your Kona Rule Set rules are updated.\nUse **KRS** mode to update the rule sets manually or **AAG** to have those rule sets automatically updated.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/put-policy-mode)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wafMode = new akamai.AppSecWafMode(\"wafMode\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    mode: \"KRS\",\n});\nexport const wafModeMode = wafMode.mode;\nexport const wafModeCurrentRuleset = wafMode.currentRuleset;\nexport const wafModeEvalStatus = wafMode.evalStatus;\nexport const wafModeEvalRuleset = wafMode.evalRuleset;\nexport const wafModeEvalExpirationDate = wafMode.evalExpirationDate;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwaf_mode = akamai.AppSecWafMode(\"wafMode\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    mode=\"KRS\")\npulumi.export(\"wafModeMode\", waf_mode.mode)\npulumi.export(\"wafModeCurrentRuleset\", waf_mode.current_ruleset)\npulumi.export(\"wafModeEvalStatus\", waf_mode.eval_status)\npulumi.export(\"wafModeEvalRuleset\", waf_mode.eval_ruleset)\npulumi.export(\"wafModeEvalExpirationDate\", waf_mode.eval_expiration_date)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var wafMode = new Akamai.AppSecWafMode(\"wafMode\", new Akamai.AppSecWafModeArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Mode = \"KRS\",\n        });\n        this.WafModeMode = wafMode.Mode;\n        this.WafModeCurrentRuleset = wafMode.CurrentRuleset;\n        this.WafModeEvalStatus = wafMode.EvalStatus;\n        this.WafModeEvalRuleset = wafMode.EvalRuleset;\n        this.WafModeEvalExpirationDate = wafMode.EvalExpirationDate;\n    }\n\n    [Output(\"wafModeMode\")]\n    public Output\u003cstring\u003e WafModeMode { get; set; }\n    [Output(\"wafModeCurrentRuleset\")]\n    public Output\u003cstring\u003e WafModeCurrentRuleset { get; set; }\n    [Output(\"wafModeEvalStatus\")]\n    public Output\u003cstring\u003e WafModeEvalStatus { get; set; }\n    [Output(\"wafModeEvalRuleset\")]\n    public Output\u003cstring\u003e WafModeEvalRuleset { get; set; }\n    [Output(\"wafModeEvalExpirationDate\")]\n    public Output\u003cstring\u003e WafModeEvalExpirationDate { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twafMode, err := akamai.NewAppSecWafMode(ctx, \"wafMode\", \u0026akamai.AppSecWafModeArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tMode:             pulumi.String(\"KRS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafModeMode\", wafMode.Mode)\n\t\tctx.Export(\"wafModeCurrentRuleset\", wafMode.CurrentRuleset)\n\t\tctx.Export(\"wafModeEvalStatus\", wafMode.EvalStatus)\n\t\tctx.Export(\"wafModeEvalRuleset\", wafMode.EvalRuleset)\n\t\tctx.Export(\"wafModeEvalExpirationDate\", wafMode.EvalExpirationDate)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWafMode;\nimport com.pulumi.akamai.AppSecWafModeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var wafMode = new AppSecWafMode(\"wafMode\", AppSecWafModeArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .mode(\"KRS\")\n            .build());\n\n        ctx.export(\"wafModeMode\", wafMode.mode());\n        ctx.export(\"wafModeCurrentRuleset\", wafMode.currentRuleset());\n        ctx.export(\"wafModeEvalStatus\", wafMode.evalStatus());\n        ctx.export(\"wafModeEvalRuleset\", wafMode.evalRuleset());\n        ctx.export(\"wafModeEvalExpirationDate\", wafMode.evalExpirationDate());\n    }\n}\n```\n```yaml\nresources:\n  wafMode:\n    type: akamai:AppSecWafMode\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      mode: KRS\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  wafModeMode: ${wafMode.mode}\n  wafModeCurrentRuleset: ${wafMode.currentRuleset}\n  wafModeEvalStatus: ${wafMode.evalStatus}\n  wafModeEvalRuleset: ${wafMode.evalRuleset}\n  wafModeEvalExpirationDate: ${wafMode.evalExpirationDate}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `current_ruleset` – Versioning information for the current Kona Rule Set.\n- `eval_ruleset`. Versioning information for the Kona Rule Set being evaluated (if applicable).\n- `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.\n- `eval_expiration_date`. Date on which the evaluation period ends (if applicable).\n- `output_text`. Tabular report showing the current rule set, WAF mode and evaluation status.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                },
                "currentRuleset": {
                    "type": "string"
                },
                "evalExpirationDate": {
                    "type": "string"
                },
                "evalRuleset": {
                    "type": "string"
                },
                "evalStatus": {
                    "type": "string"
                },
                "mode": {
                    "type": "string",
                    "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalExpirationDate",
                "evalRuleset",
                "evalStatus",
                "mode",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWafMode resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                    },
                    "currentRuleset": {
                        "type": "string"
                    },
                    "evalExpirationDate": {
                        "type": "string"
                    },
                    "evalRuleset": {
                        "type": "string"
                    },
                    "evalStatus": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWafProtection:AppSecWafProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables Web Application Firewall (WAF) protection for a security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecWafProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecWafProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protection = new Akamai.AppSecWafProtection(\"protection\", new Akamai.AppSecWafProtectionArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecWafProtection(ctx, \"protection\", \u0026akamai.AppSecWafProtectionArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWafProtection;\nimport com.pulumi.akamai.AppSecWafProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecWafProtection(\"protection\", AppSecWafProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecWafProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text Export representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWafProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text Export representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWapSelectedHostnames:AppSecWapSelectedHostnames": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecwapSelectedhostnames = new akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    protectedHosts: [\"documentation.akamai.com\"],\n    evaluatedHosts: [\"training.akamai.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsecwap_selectedhostnames = akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    protected_hosts=[\"documentation.akamai.com\"],\n    evaluated_hosts=[\"training.akamai.com\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var appsecwapSelectedhostnames = new Akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", new Akamai.AppSecWapSelectedHostnamesArgs\n        {\n            ConfigId = configuration.Apply(configuration =\u003e configuration.ConfigId),\n            SecurityPolicyId = \"gms1_134637\",\n            ProtectedHosts = \n            {\n                \"documentation.akamai.com\",\n            },\n            EvaluatedHosts = \n            {\n                \"training.akamai.com\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecWapSelectedHostnames(ctx, \"appsecwapSelectedhostnames\", \u0026akamai.AppSecWapSelectedHostnamesArgs{\n\t\t\tConfigId:         pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tProtectedHosts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"documentation.akamai.com\"),\n\t\t\t},\n\t\t\tEvaluatedHosts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"training.akamai.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWapSelectedHostnames;\nimport com.pulumi.akamai.AppSecWapSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecwapSelectedhostnames = new AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", AppSecWapSelectedHostnamesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .protectedHosts(\"documentation.akamai.com\")\n            .evaluatedHosts(\"training.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecwapSelectedhostnames:\n    type: akamai:AppSecWapSelectedHostnames\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      protectedHosts:\n        - documentation.akamai.com\n      evaluatedHosts:\n        - training.akamai.com\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                },
                "evaluatedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "protectedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                },
                "evaluatedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "protectedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWapSelectedHostnames resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                    },
                    "evaluatedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "protectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsApplicationLoadBalancer:CloudletsApplicationLoadBalancer": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancer` resource to create the Application Load Balancer Cloudlet configuration. The Application Load Balancer Cloudlet provides intelligent, scalable traffic management across physical, virtual, and cloud-hosted data centers without requiring the origin to send load feedback. This Cloudlet can automatically detect load conditions and route traffic to the optimal data source while maintaining custom routing policies and consistent visitor session behavior for your visitors.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsApplicationLoadBalancer(\"example\", {\n    balancingType: \"WEIGHTED\",\n    dataCenters: [{\n        city: \"Boston\",\n        cloudServerHostHeaderOverride: false,\n        cloudService: true,\n        continent: \"NA\",\n        country: \"US\",\n        hostname: \"example-hostname\",\n        latitude: 102.78108,\n        livenessHosts: [\"example\"],\n        longitude: -116.07064,\n        originId: \"alb_test_1\",\n        percent: 100,\n        stateOrProvince: \"MA\",\n    }],\n    description: \"application_load_balancer description\",\n    livenessSettings: {\n        additionalHeaders: {\n            additional_headers: \"123\",\n        },\n        hostHeader: \"header\",\n        interval: 10,\n        path: \"/status\",\n        port: 1234,\n        protocol: \"HTTP\",\n        requestString: \"test_request_string\",\n        responseString: \"test_response_string\",\n        timeout: 60,\n    },\n    originId: \"alb_test_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsApplicationLoadBalancer(\"example\",\n    balancing_type=\"WEIGHTED\",\n    data_centers=[akamai.CloudletsApplicationLoadBalancerDataCenterArgs(\n        city=\"Boston\",\n        cloud_server_host_header_override=False,\n        cloud_service=True,\n        continent=\"NA\",\n        country=\"US\",\n        hostname=\"example-hostname\",\n        latitude=102.78108,\n        liveness_hosts=[\"example\"],\n        longitude=-116.07064,\n        origin_id=\"alb_test_1\",\n        percent=100,\n        state_or_province=\"MA\",\n    )],\n    description=\"application_load_balancer description\",\n    liveness_settings=akamai.CloudletsApplicationLoadBalancerLivenessSettingsArgs(\n        additional_headers={\n            \"additionalHeaders\": \"123\",\n        },\n        host_header=\"header\",\n        interval=10,\n        path=\"/status\",\n        port=1234,\n        protocol=\"HTTP\",\n        request_string=\"test_request_string\",\n        response_string=\"test_response_string\",\n        timeout=60,\n    ),\n    origin_id=\"alb_test_1\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CloudletsApplicationLoadBalancer(\"example\", new Akamai.CloudletsApplicationLoadBalancerArgs\n        {\n            BalancingType = \"WEIGHTED\",\n            DataCenters = \n            {\n                new Akamai.Inputs.CloudletsApplicationLoadBalancerDataCenterArgs\n                {\n                    City = \"Boston\",\n                    CloudServerHostHeaderOverride = false,\n                    CloudService = true,\n                    Continent = \"NA\",\n                    Country = \"US\",\n                    Hostname = \"example-hostname\",\n                    Latitude = 102.78108,\n                    LivenessHosts = \n                    {\n                        \"example\",\n                    },\n                    Longitude = -116.07064,\n                    OriginId = \"alb_test_1\",\n                    Percent = 100,\n                    StateOrProvince = \"MA\",\n                },\n            },\n            Description = \"application_load_balancer description\",\n            LivenessSettings = new Akamai.Inputs.CloudletsApplicationLoadBalancerLivenessSettingsArgs\n            {\n                AdditionalHeaders = \n                {\n                    { \"additionalHeaders\", \"123\" },\n                },\n                HostHeader = \"header\",\n                Interval = 10,\n                Path = \"/status\",\n                Port = 1234,\n                Protocol = \"HTTP\",\n                RequestString = \"test_request_string\",\n                ResponseString = \"test_response_string\",\n                Timeout = 60,\n            },\n            OriginId = \"alb_test_1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsApplicationLoadBalancer(ctx, \"example\", \u0026akamai.CloudletsApplicationLoadBalancerArgs{\n\t\t\tBalancingType: pulumi.String(\"WEIGHTED\"),\n\t\t\tDataCenters: CloudletsApplicationLoadBalancerDataCenterArray{\n\t\t\t\t\u0026CloudletsApplicationLoadBalancerDataCenterArgs{\n\t\t\t\t\tCity:                          pulumi.String(\"Boston\"),\n\t\t\t\t\tCloudServerHostHeaderOverride: pulumi.Bool(false),\n\t\t\t\t\tCloudService:                  pulumi.Bool(true),\n\t\t\t\t\tContinent:                     pulumi.String(\"NA\"),\n\t\t\t\t\tCountry:                       pulumi.String(\"US\"),\n\t\t\t\t\tHostname:                      pulumi.String(\"example-hostname\"),\n\t\t\t\t\tLatitude:                      pulumi.Float64(102.78108),\n\t\t\t\t\tLivenessHosts: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example\"),\n\t\t\t\t\t},\n\t\t\t\t\tLongitude:       -116.07064,\n\t\t\t\t\tOriginId:        pulumi.String(\"alb_test_1\"),\n\t\t\t\t\tPercent:         pulumi.Float64(100),\n\t\t\t\t\tStateOrProvince: pulumi.String(\"MA\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"application_load_balancer description\"),\n\t\t\tLivenessSettings: \u0026CloudletsApplicationLoadBalancerLivenessSettingsArgs{\n\t\t\t\tAdditionalHeaders: pulumi.StringMap{\n\t\t\t\t\t\"additionalHeaders\": pulumi.String(\"123\"),\n\t\t\t\t},\n\t\t\t\tHostHeader:     pulumi.String(\"header\"),\n\t\t\t\tInterval:       pulumi.Int(10),\n\t\t\t\tPath:           pulumi.String(\"/status\"),\n\t\t\t\tPort:           pulumi.Int(1234),\n\t\t\t\tProtocol:       pulumi.String(\"HTTP\"),\n\t\t\t\tRequestString:  pulumi.String(\"test_request_string\"),\n\t\t\t\tResponseString: pulumi.String(\"test_response_string\"),\n\t\t\t\tTimeout:        pulumi.Float64(60),\n\t\t\t},\n\t\t\tOriginId: pulumi.String(\"alb_test_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic usagehcl resource \"akamai_cloudlets_application_load_balancer\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai Application Load Balancer configuration using an origin ID. For example\n\n```sh\n $ pulumi import akamai:index/cloudletsApplicationLoadBalancer:CloudletsApplicationLoadBalancer example alb_test_1\n```\n\n ",
            "properties": {
                "balancingType": {
                    "type": "string",
                    "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                },
                "dataCenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                    },
                    "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the load balancing configuration.\n"
                },
                "livenessSettings": {
                    "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                    "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version number of the load balancing configuration.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "A list of warnings that occurred during the activation of the load balancing configuration.\n"
                }
            },
            "required": [
                "dataCenters",
                "originId",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "balancingType": {
                    "type": "string",
                    "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                },
                "dataCenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                    },
                    "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the load balancing configuration.\n"
                },
                "livenessSettings": {
                    "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                    "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataCenters",
                "originId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsApplicationLoadBalancer resources.\n",
                "properties": {
                    "balancingType": {
                        "type": "string",
                        "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                    },
                    "dataCenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                        },
                        "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the load balancing configuration.\n"
                    },
                    "livenessSettings": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                        "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                    },
                    "originId": {
                        "type": "string",
                        "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version number of the load balancing configuration.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "A list of warnings that occurred during the activation of the load balancing configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsApplicationLoadBalancerActivation:CloudletsApplicationLoadBalancerActivation": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancerActivation` resource to activate the Application Load Balancer Cloudlet configuration. An activation deploys the configuration version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsApplicationLoadBalancerActivation(\"example\", {\n    originId: \"alb_test_1\",\n    network: \"staging\",\n    version: 1,\n});\nexport const status = example.status;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsApplicationLoadBalancerActivation(\"example\",\n    origin_id=\"alb_test_1\",\n    network=\"staging\",\n    version=1)\npulumi.export(\"status\", example.status)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CloudletsApplicationLoadBalancerActivation(\"example\", new Akamai.CloudletsApplicationLoadBalancerActivationArgs\n        {\n            OriginId = \"alb_test_1\",\n            Network = \"staging\",\n            Version = 1,\n        });\n        this.Status = example.Status;\n    }\n\n    [Output(\"status\")]\n    public Output\u003cstring\u003e Status { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.NewCloudletsApplicationLoadBalancerActivation(ctx, \"example\", \u0026akamai.CloudletsApplicationLoadBalancerActivationArgs{\n\t\t\tOriginId: pulumi.String(\"alb_test_1\"),\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"status\", example.Status)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsApplicationLoadBalancerActivation;\nimport com.pulumi.akamai.CloudletsApplicationLoadBalancerActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsApplicationLoadBalancerActivation(\"example\", CloudletsApplicationLoadBalancerActivationArgs.builder()        \n            .originId(\"alb_test_1\")\n            .network(\"staging\")\n            .version(1)\n            .build());\n\n        ctx.export(\"status\", example.status());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsApplicationLoadBalancerActivation\n    properties:\n      originId: alb_test_1\n      network: staging\n      version: 1\noutputs:\n  status: ${example.status}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The activation status for this load balancing configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                }
            },
            "required": [
                "network",
                "originId",
                "status",
                "version"
            ],
            "inputProperties": {
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "integer",
                    "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "network",
                "originId",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsApplicationLoadBalancerActivation resources.\n",
                "properties": {
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                    },
                    "originId": {
                        "type": "string",
                        "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The activation status for this load balancing configuration.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsPolicy:CloudletsPolicy": {
            "description": "Use the `akamai.CloudletsPolicy` resource to create and version a policy. For each Cloudlet instance on your contract, there can be any number of policies. A single policy is associated with a single property configuration. Within a policy version you define the rules that determine when the Cloudlet executes. You may want to create a new version of a policy to support a different business requirement, or to test new functionality.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsPolicy(\"example\", {\n    cloudletCode: \"ER\",\n    description: \"policy description\",\n    groupId: \"grp_123\",\n    matchRules: `  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"hostname\",\n        \"matchValue\": \"3333.dom\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": true,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsPolicy(\"example\",\n    cloudlet_code=\"ER\",\n    description=\"policy description\",\n    group_id=\"grp_123\",\n    match_rules=\"\"\"  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"hostname\",\n        \"matchValue\": \"3333.dom\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": true,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CloudletsPolicy(\"example\", new Akamai.CloudletsPolicyArgs\n        {\n            CloudletCode = \"ER\",\n            Description = \"policy description\",\n            GroupId = \"grp_123\",\n            MatchRules = @\"  [\n  {\n    \"\"name\"\": \"\"rule1\"\",\n    \"\"type\"\": \"\"erMatchRule\"\",\n    \"\"useRelativeUrl\"\": \"\"none\"\",\n    \"\"statusCode\"\": 301,\n    \"\"redirectURL\"\": \"\"https://www.example.com\"\",\n    \"\"matchURL\"\": \"\"example.com\"\",\n    \"\"useIncomingQueryString\"\": false,\n    \"\"useIncomingSchemeAndHost\"\": true\n  },\n  {\n    \"\"name\"\": \"\"rule2\"\",\n    \"\"type\"\": \"\"erMatchRule\"\",\n    \"\"matches\"\": [\n      {\n        \"\"matchType\"\": \"\"hostname\"\",\n        \"\"matchValue\"\": \"\"3333.dom\"\",\n        \"\"matchOperator\"\": \"\"equals\"\",\n        \"\"caseSensitive\"\": true,\n        \"\"negate\"\": false\n      }\n    ],\n    \"\"useRelativeUrl\"\": \"\"none\"\",\n    \"\"statusCode\"\": 301,\n    \"\"redirectURL\"\": \"\"https://www.example.com\"\",\n    \"\"useIncomingQueryString\"\": false,\n    \"\"useIncomingSchemeAndHost\"\": true\n  }\n]\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsPolicy(ctx, \"example\", \u0026akamai.CloudletsPolicyArgs{\n\t\t\tCloudletCode: pulumi.String(\"ER\"),\n\t\t\tDescription:  pulumi.String(\"policy description\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tMatchRules: pulumi.String(fmt.Sprintf(`  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"hostname\",\n        \"matchValue\": \"3333.dom\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": true,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n`)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicy;\nimport com.pulumi.akamai.CloudletsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsPolicy(\"example\", CloudletsPolicyArgs.builder()        \n            .cloudletCode(\"ER\")\n            .description(\"policy description\")\n            .groupId(\"grp_123\")\n            .matchRules(\"\"\"\n  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"hostname\",\n        \"matchValue\": \"3333.dom\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": true,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsPolicy\n    properties:\n      cloudletCode: ER\n      description: policy description\n      groupId: grp_123\n      matchRules: |2\n          [\n          {\n            \"name\": \"rule1\",\n            \"type\": \"erMatchRule\",\n            \"useRelativeUrl\": \"none\",\n            \"statusCode\": 301,\n            \"redirectURL\": \"https://www.example.com\",\n            \"matchURL\": \"example.com\",\n            \"useIncomingQueryString\": false,\n            \"useIncomingSchemeAndHost\": true\n          },\n          {\n            \"name\": \"rule2\",\n            \"type\": \"erMatchRule\",\n            \"matches\": [\n              {\n                \"matchType\": \"hostname\",\n                \"matchValue\": \"3333.dom\",\n                \"matchOperator\": \"equals\",\n                \"caseSensitive\": true,\n                \"negate\": false\n              }\n            ],\n            \"useRelativeUrl\": \"none\",\n            \"statusCode\": 301,\n            \"redirectURL\": \"https://www.example.com\",\n            \"useIncomingQueryString\": false,\n            \"useIncomingSchemeAndHost\": true\n          }\n        ]\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic usagehcl resource \"akamai_cloudlets_policy\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai Cloudlets policy using a policy name. For example\n\n```sh\n $ pulumi import akamai:index/cloudletsPolicy:CloudletsPolicy example policy1\n```\n\n ",
            "properties": {
                "cloudletCode": {
                    "type": "string",
                    "description": "The two- or three- character code for the type of Cloudlet, either `ALB` for Application Load Balancer or `ER` for Edge Redirector.\n"
                },
                "cloudletId": {
                    "type": "integer",
                    "description": "A unique identifier that corresponds to a Cloudlets policy type, either `0` for Edge Redirector or `9` for Application Load Balancer.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this specific policy.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                },
                "matchRuleFormat": {
                    "type": "string",
                    "description": "The version of the Cloudlet-specific `match_rules`.\n"
                },
                "matchRules": {
                    "type": "string",
                    "description": "A JSON structure that defines the rules for this policy\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the policy.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version number of the policy.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "A JSON-encoded list of warnings.\n"
                }
            },
            "required": [
                "cloudletCode",
                "cloudletId",
                "groupId",
                "name",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "cloudletCode": {
                    "type": "string",
                    "description": "The two- or three- character code for the type of Cloudlet, either `ALB` for Application Load Balancer or `ER` for Edge Redirector.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this specific policy.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                },
                "matchRuleFormat": {
                    "type": "string",
                    "description": "The version of the Cloudlet-specific `match_rules`.\n"
                },
                "matchRules": {
                    "type": "string",
                    "description": "A JSON structure that defines the rules for this policy\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the policy.\n"
                }
            },
            "requiredInputs": [
                "cloudletCode",
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsPolicy resources.\n",
                "properties": {
                    "cloudletCode": {
                        "type": "string",
                        "description": "The two- or three- character code for the type of Cloudlet, either `ALB` for Application Load Balancer or `ER` for Edge Redirector.\n"
                    },
                    "cloudletId": {
                        "type": "integer",
                        "description": "A unique identifier that corresponds to a Cloudlets policy type, either `0` for Edge Redirector or `9` for Application Load Balancer.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this specific policy.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                    },
                    "matchRuleFormat": {
                        "type": "string",
                        "description": "The version of the Cloudlet-specific `match_rules`.\n"
                    },
                    "matchRules": {
                        "type": "string",
                        "description": "A JSON structure that defines the rules for this policy\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The unique name of the policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version number of the policy.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "A JSON-encoded list of warnings.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsPolicyActivation:CloudletsPolicyActivation": {
            "description": "Use the `akamai.CloudletsPolicyActivation` resource to activate a specific version of a Cloudlet policy. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsPolicyActivation(\"example\", {\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n        \"Property_3\",\n    ],\n    network: \"staging\",\n    policyId: 1234,\n    version: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsPolicyActivation(\"example\",\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n        \"Property_3\",\n    ],\n    network=\"staging\",\n    policy_id=1234,\n    version=1)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CloudletsPolicyActivation(\"example\", new Akamai.CloudletsPolicyActivationArgs\n        {\n            AssociatedProperties = \n            {\n                \"Property_1\",\n                \"Property_2\",\n                \"Property_3\",\n            },\n            Network = \"staging\",\n            PolicyId = 1234,\n            Version = 1,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsPolicyActivation(ctx, \"example\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t\tpulumi.String(\"Property_3\"),\n\t\t\t},\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tPolicyId: pulumi.Int(1234),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicyActivation;\nimport com.pulumi.akamai.CloudletsPolicyActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsPolicyActivation(\"example\", CloudletsPolicyActivationArgs.builder()        \n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\",\n                \"Property_3\")\n            .network(\"staging\")\n            .policyId(1234)\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      associatedProperties:\n        - Property_1\n        - Property_2\n        - Property_3\n      network: staging\n      policyId: 1234\n      version: 1\n```\nIf you're handling two `akamai.CloudletsPolicyActivation` resources in the same configuration file with the same `policy_id`, but different `network` arguments (for example, `production` and `staging`), you need to add `depends_on` to the production resource. See the example:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst stag = new akamai.CloudletsPolicyActivation(\"stag\", {\n    policyId: 1234567,\n    network: \"staging\",\n    version: 1,\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n    ],\n});\nconst prod = new akamai.CloudletsPolicyActivation(\"prod\", {\n    policyId: 1234567,\n    network: \"production\",\n    version: 1,\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n    ],\n}, {\n    dependsOn: [stag],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nstag = akamai.CloudletsPolicyActivation(\"stag\",\n    policy_id=1234567,\n    network=\"staging\",\n    version=1,\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n    ])\nprod = akamai.CloudletsPolicyActivation(\"prod\",\n    policy_id=1234567,\n    network=\"production\",\n    version=1,\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n    ],\n    opts=pulumi.ResourceOptions(depends_on=[stag]))\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var stag = new Akamai.CloudletsPolicyActivation(\"stag\", new Akamai.CloudletsPolicyActivationArgs\n        {\n            PolicyId = 1234567,\n            Network = \"staging\",\n            Version = 1,\n            AssociatedProperties = \n            {\n                \"Property_1\",\n                \"Property_2\",\n            },\n        });\n        var prod = new Akamai.CloudletsPolicyActivation(\"prod\", new Akamai.CloudletsPolicyActivationArgs\n        {\n            PolicyId = 1234567,\n            Network = \"production\",\n            Version = 1,\n            AssociatedProperties = \n            {\n                \"Property_1\",\n                \"Property_2\",\n            },\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                stag,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstag, err := akamai.NewCloudletsPolicyActivation(ctx, \"stag\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tPolicyId: pulumi.Int(1234567),\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCloudletsPolicyActivation(ctx, \"prod\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tPolicyId: pulumi.Int(1234567),\n\t\t\tNetwork:  pulumi.String(\"production\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tstag,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicyActivation;\nimport com.pulumi.akamai.CloudletsPolicyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var stag = new CloudletsPolicyActivation(\"stag\", CloudletsPolicyActivationArgs.builder()        \n            .policyId(1234567)\n            .network(\"staging\")\n            .version(1)\n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\")\n            .build());\n\n        var prod = new CloudletsPolicyActivation(\"prod\", CloudletsPolicyActivationArgs.builder()        \n            .policyId(1234567)\n            .network(\"production\")\n            .version(1)\n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(stag)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  stag:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      policyId: 1.234567e+06\n      network: staging\n      version: 1\n      associatedProperties:\n        - Property_1\n        - Property_2\n  prod:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      policyId: 1.234567e+06\n      network: production\n      version: 1\n      associatedProperties:\n        - Property_1\n        - Property_2\n    options:\n      dependson:\n        - ${stag}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "associatedProperties": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                },
                "policyId": {
                    "type": "integer",
                    "description": "An identifier for the Cloudlet policy you want to activate.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The activation status for this Cloudlet policy.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The Cloudlet policy version you want to activate.\n"
                }
            },
            "required": [
                "associatedProperties",
                "network",
                "policyId",
                "status",
                "version"
            ],
            "inputProperties": {
                "associatedProperties": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                },
                "policyId": {
                    "type": "integer",
                    "description": "An identifier for the Cloudlet policy you want to activate.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "integer",
                    "description": "The Cloudlet policy version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "associatedProperties",
                "network",
                "policyId",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsPolicyActivation resources.\n",
                "properties": {
                    "associatedProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                    },
                    "policyId": {
                        "type": "integer",
                        "description": "An identifier for the Cloudlet policy you want to activate.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The activation status for this Cloudlet policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The Cloudlet policy version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpCode:CpCode": {
            "description": "The `akamai.CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.\n\nYou can create additional CP codes to support more detailed billing and reporting functions.\n\nBy default, the Akamai Provider uses your existing CP code instead of creating a new one.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst cpCode = new akamai.CpCode(\"cpCode\", {\n    contractId: akamai_contract.contract.id,\n    groupId: akamai_group.group.id,\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncp_code = akamai.CpCode(\"cpCode\",\n    contract_id=akamai_contract[\"contract\"][\"id\"],\n    group_id=akamai_group[\"group\"][\"id\"],\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var cpCode = new Akamai.CpCode(\"cpCode\", new Akamai.CpCodeArgs\n        {\n            ContractId = akamai_contract.Contract.Id,\n            GroupId = akamai_group.Group.Id,\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpCode(ctx, \"cpCode\", \u0026akamai.CpCodeArgs{\n\t\t\tContractId: pulumi.Any(akamai_contract.Contract.Id),\n\t\t\tGroupId:    pulumi.Any(akamai_group.Group.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cpCode = new CpCode(\"cpCode\", CpCodeArgs.builder()        \n            .contractId(akamai_contract.contract().id())\n            .groupId(akamai_group.group().id())\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cpCode:\n    type: akamai:CpCode\n    properties:\n      contractId: ${akamai_contract.contract.id}\n      groupId: ${akamai_group.group.id}\n      productId: prd_Object_Delivery\n```\n\nHere's a real-life example that includes other data sources as dependencies:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst groupName = \"example group name\";\nconst cpcodeName = \"My CP Code\";\nconst exampleContract = akamai.getContract({\n    groupName: groupName,\n});\nconst exampleGroup = exampleContract.then(exampleContract =\u003e akamai.getGroup({\n    name: groupName,\n    contractId: exampleContract.id,\n}));\nconst exampleCp = new akamai.CpCode(\"exampleCp\", {\n    groupId: exampleGroup.then(exampleGroup =\u003e exampleGroup.id),\n    contractId: exampleContract.then(exampleContract =\u003e exampleContract.id),\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ngroup_name = \"example group name\"\ncpcode_name = \"My CP Code\"\nexample_contract = akamai.get_contract(group_name=group_name)\nexample_group = akamai.get_group(name=group_name,\n    contract_id=example_contract.id)\nexample_cp = akamai.CpCode(\"exampleCp\",\n    group_id=example_group.id,\n    contract_id=example_contract.id,\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var groupName = \"example group name\";\n        var cpcodeName = \"My CP Code\";\n        var exampleContract = Output.Create(Akamai.GetContract.InvokeAsync(new Akamai.GetContractArgs\n        {\n            GroupName = groupName,\n        }));\n        var exampleGroup = exampleContract.Apply(exampleContract =\u003e Output.Create(Akamai.GetGroup.InvokeAsync(new Akamai.GetGroupArgs\n        {\n            Name = groupName,\n            ContractId = exampleContract.Id,\n        })));\n        var exampleCp = new Akamai.CpCode(\"exampleCp\", new Akamai.CpCodeArgs\n        {\n            GroupId = exampleGroup.Apply(exampleGroup =\u003e exampleGroup.Id),\n            ContractId = exampleContract.Apply(exampleContract =\u003e exampleContract.Id),\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroupName := \"example group name\"\n\t\t_ := \"My CP Code\"\n\t\texampleContract, err := akamai.GetContract(ctx, \u0026GetContractArgs{\n\t\t\tGroupName: pulumi.StringRef(groupName),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleGroup, err := akamai.GetGroup(ctx, \u0026GetGroupArgs{\n\t\t\tName:       pulumi.StringRef(groupName),\n\t\t\tContractId: pulumi.StringRef(exampleContract.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCpCode(ctx, \"exampleCp\", \u0026akamai.CpCodeArgs{\n\t\t\tGroupId:    pulumi.String(exampleGroup.Id),\n\t\t\tContractId: pulumi.String(exampleContract.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetContractArgs;\nimport com.pulumi.akamai.inputs.GetGroupArgs;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var groupName = \"example group name\";\n\n        final var cpcodeName = \"My CP Code\";\n\n        final var exampleContract = AkamaiFunctions.getContract(GetContractArgs.builder()\n            .groupName(groupName)\n            .build());\n\n        final var exampleGroup = AkamaiFunctions.getGroup(GetGroupArgs.builder()\n            .name(groupName)\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .build());\n\n        var exampleCp = new CpCode(\"exampleCp\", CpCodeArgs.builder()        \n            .groupId(exampleGroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCp:\n    type: akamai:CpCode\n    properties:\n      groupId: ${exampleGroup.id}\n      contractId: ${exampleContract.id}\n      productId: prd_Object_Delivery\nvariables:\n  groupName: example group name\n  cpcodeName: My CP Code\n  exampleGroup:\n    Fn::Invoke:\n      Function: akamai:getGroup\n      Arguments:\n        name: ${groupName}\n        contractId: ${exampleContract.id}\n  exampleContract:\n    Fn::Invoke:\n      Function: akamai:getContract\n      Arguments:\n        groupName: ${groupName}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `id` - The ID of the CP code.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cp_code\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example\n\n```sh\n $ pulumi import akamai:index/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "name",
                "product",
                "productId"
            ],
            "inputProperties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpCode resources.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/cpCode:CpCode"
                }
            ]
        },
        "akamai:index/cpsDvEnrollment:CpsDvEnrollment": {
            "description": "Use the `akamai.CpsDvEnrollment` resource to create an enrollment with all the information about your certificate life cycle, from the time you request it, through removal or automatic renewal. You can treat an enrollment as a core container for all the operations you perform within CPS.\n\nYou can use this resource with `akamai.DnsRecord` or other third-party DNS provider to create DNS records, and `akamai.CpsDvValidation` to complete the certificate validation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CpsDvEnrollment(\"example\", {\n    contractId: \"ctr_1-AB123\",\n    acknowledgePreVerificationWarnings: true,\n    commonName: \"cps-test.example.net\",\n    sans: [\n        \"san1.cps-test.example.net\",\n        \"san2.cps-test.example.net\",\n    ],\n    secureNetwork: \"enhanced-tls\",\n    sniOnly: true,\n    adminContact: {\n        firstName: \"x1\",\n        lastName: \"x2\",\n        phone: \"123123123\",\n        email: \"x1x2@example.net\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Akamai\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    techContact: {\n        firstName: \"x3\",\n        lastName: \"x4\",\n        phone: \"123123123\",\n        email: \"x3x4@akamai.com\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Akamai\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    certificateChainType: \"default\",\n    csr: {\n        countryCode: \"US\",\n        city: \"cambridge\",\n        organization: \"Akamai\",\n        organizationalUnit: \"Dev\",\n        state: \"MA\",\n    },\n    enableMultiStackedCertificates: false,\n    networkConfiguration: {\n        disallowedTlsVersions: [\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        cloneDnsNames: false,\n        geography: \"core\",\n        ocspStapling: \"on\",\n        preferredCiphers: \"ak-akamai-2020q1\",\n        mustHaveCiphers: \"ak-akamai-2020q1\",\n        quicEnabled: false,\n    },\n    signatureAlgorithm: \"SHA-256\",\n    organization: {\n        name: \"Akamai\",\n        phone: \"123123123\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        postalCode: \"02142\",\n        region: \"MA\",\n    },\n});\nexport const dnsChallenges = example.dnsChallenges;\nexport const httpChallenges = example.httpChallenges;\nexport const enrollmentId = example.id;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CpsDvEnrollment(\"example\",\n    contract_id=\"ctr_1-AB123\",\n    acknowledge_pre_verification_warnings=True,\n    common_name=\"cps-test.example.net\",\n    sans=[\n        \"san1.cps-test.example.net\",\n        \"san2.cps-test.example.net\",\n    ],\n    secure_network=\"enhanced-tls\",\n    sni_only=True,\n    admin_contact=akamai.CpsDvEnrollmentAdminContactArgs(\n        first_name=\"x1\",\n        last_name=\"x2\",\n        phone=\"123123123\",\n        email=\"x1x2@example.net\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Akamai\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    tech_contact=akamai.CpsDvEnrollmentTechContactArgs(\n        first_name=\"x3\",\n        last_name=\"x4\",\n        phone=\"123123123\",\n        email=\"x3x4@akamai.com\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Akamai\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    certificate_chain_type=\"default\",\n    csr=akamai.CpsDvEnrollmentCsrArgs(\n        country_code=\"US\",\n        city=\"cambridge\",\n        organization=\"Akamai\",\n        organizational_unit=\"Dev\",\n        state=\"MA\",\n    ),\n    enable_multi_stacked_certificates=False,\n    network_configuration=akamai.CpsDvEnrollmentNetworkConfigurationArgs(\n        disallowed_tls_versions=[\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        clone_dns_names=False,\n        geography=\"core\",\n        ocsp_stapling=\"on\",\n        preferred_ciphers=\"ak-akamai-2020q1\",\n        must_have_ciphers=\"ak-akamai-2020q1\",\n        quic_enabled=False,\n    ),\n    signature_algorithm=\"SHA-256\",\n    organization=akamai.CpsDvEnrollmentOrganizationArgs(\n        name=\"Akamai\",\n        phone=\"123123123\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        postal_code=\"02142\",\n        region=\"MA\",\n    ))\npulumi.export(\"dnsChallenges\", example.dns_challenges)\npulumi.export(\"httpChallenges\", example.http_challenges)\npulumi.export(\"enrollmentId\", example.id)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CpsDvEnrollment(\"example\", new Akamai.CpsDvEnrollmentArgs\n        {\n            ContractId = \"ctr_1-AB123\",\n            AcknowledgePreVerificationWarnings = true,\n            CommonName = \"cps-test.example.net\",\n            Sans = \n            {\n                \"san1.cps-test.example.net\",\n                \"san2.cps-test.example.net\",\n            },\n            SecureNetwork = \"enhanced-tls\",\n            SniOnly = true,\n            AdminContact = new Akamai.Inputs.CpsDvEnrollmentAdminContactArgs\n            {\n                FirstName = \"x1\",\n                LastName = \"x2\",\n                Phone = \"123123123\",\n                Email = \"x1x2@example.net\",\n                AddressLineOne = \"150 Broadway\",\n                City = \"Cambridge\",\n                CountryCode = \"US\",\n                Organization = \"Akamai\",\n                PostalCode = \"02142\",\n                Region = \"MA\",\n                Title = \"Administrator\",\n            },\n            TechContact = new Akamai.Inputs.CpsDvEnrollmentTechContactArgs\n            {\n                FirstName = \"x3\",\n                LastName = \"x4\",\n                Phone = \"123123123\",\n                Email = \"x3x4@akamai.com\",\n                AddressLineOne = \"150 Broadway\",\n                City = \"Cambridge\",\n                CountryCode = \"US\",\n                Organization = \"Akamai\",\n                PostalCode = \"02142\",\n                Region = \"MA\",\n                Title = \"Administrator\",\n            },\n            CertificateChainType = \"default\",\n            Csr = new Akamai.Inputs.CpsDvEnrollmentCsrArgs\n            {\n                CountryCode = \"US\",\n                City = \"cambridge\",\n                Organization = \"Akamai\",\n                OrganizationalUnit = \"Dev\",\n                State = \"MA\",\n            },\n            EnableMultiStackedCertificates = false,\n            NetworkConfiguration = new Akamai.Inputs.CpsDvEnrollmentNetworkConfigurationArgs\n            {\n                DisallowedTlsVersions = \n                {\n                    \"TLSv1\",\n                    \"TLSv1_1\",\n                },\n                CloneDnsNames = false,\n                Geography = \"core\",\n                OcspStapling = \"on\",\n                PreferredCiphers = \"ak-akamai-2020q1\",\n                MustHaveCiphers = \"ak-akamai-2020q1\",\n                QuicEnabled = false,\n            },\n            SignatureAlgorithm = \"SHA-256\",\n            Organization = new Akamai.Inputs.CpsDvEnrollmentOrganizationArgs\n            {\n                Name = \"Akamai\",\n                Phone = \"123123123\",\n                AddressLineOne = \"150 Broadway\",\n                City = \"Cambridge\",\n                CountryCode = \"US\",\n                PostalCode = \"02142\",\n                Region = \"MA\",\n            },\n        });\n        this.DnsChallenges = example.DnsChallenges;\n        this.HttpChallenges = example.HttpChallenges;\n        this.EnrollmentId = example.Id;\n    }\n\n    [Output(\"dnsChallenges\")]\n    public Output\u003cstring\u003e DnsChallenges { get; set; }\n    [Output(\"httpChallenges\")]\n    public Output\u003cstring\u003e HttpChallenges { get; set; }\n    [Output(\"enrollmentId\")]\n    public Output\u003cstring\u003e EnrollmentId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.NewCpsDvEnrollment(ctx, \"example\", \u0026akamai.CpsDvEnrollmentArgs{\n\t\t\tContractId:                         pulumi.String(\"ctr_1-AB123\"),\n\t\t\tAcknowledgePreVerificationWarnings: pulumi.Bool(true),\n\t\t\tCommonName:                         pulumi.String(\"cps-test.example.net\"),\n\t\t\tSans: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"san1.cps-test.example.net\"),\n\t\t\t\tpulumi.String(\"san2.cps-test.example.net\"),\n\t\t\t},\n\t\t\tSecureNetwork: pulumi.String(\"enhanced-tls\"),\n\t\t\tSniOnly:       pulumi.Bool(true),\n\t\t\tAdminContact: \u0026CpsDvEnrollmentAdminContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"x1\"),\n\t\t\t\tLastName:       pulumi.String(\"x2\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tEmail:          pulumi.String(\"x1x2@example.net\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Akamai\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tTechContact: \u0026CpsDvEnrollmentTechContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"x3\"),\n\t\t\t\tLastName:       pulumi.String(\"x4\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tEmail:          pulumi.String(\"x3x4@akamai.com\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Akamai\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tCertificateChainType: pulumi.String(\"default\"),\n\t\t\tCsr: \u0026CpsDvEnrollmentCsrArgs{\n\t\t\t\tCountryCode:        pulumi.String(\"US\"),\n\t\t\t\tCity:               pulumi.String(\"cambridge\"),\n\t\t\t\tOrganization:       pulumi.String(\"Akamai\"),\n\t\t\t\tOrganizationalUnit: pulumi.String(\"Dev\"),\n\t\t\t\tState:              pulumi.String(\"MA\"),\n\t\t\t},\n\t\t\tEnableMultiStackedCertificates: pulumi.Bool(false),\n\t\t\tNetworkConfiguration: \u0026CpsDvEnrollmentNetworkConfigurationArgs{\n\t\t\t\tDisallowedTlsVersions: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"TLSv1\"),\n\t\t\t\t\tpulumi.String(\"TLSv1_1\"),\n\t\t\t\t},\n\t\t\t\tCloneDnsNames:    pulumi.Bool(false),\n\t\t\t\tGeography:        pulumi.String(\"core\"),\n\t\t\t\tOcspStapling:     pulumi.String(\"on\"),\n\t\t\t\tPreferredCiphers: pulumi.String(\"ak-akamai-2020q1\"),\n\t\t\t\tMustHaveCiphers:  pulumi.String(\"ak-akamai-2020q1\"),\n\t\t\t\tQuicEnabled:      pulumi.Bool(false),\n\t\t\t},\n\t\t\tSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t\tOrganization: \u0026CpsDvEnrollmentOrganizationArgs{\n\t\t\t\tName:           pulumi.String(\"Akamai\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dnsChallenges\", example.DnsChallenges)\n\t\tctx.Export(\"httpChallenges\", example.HttpChallenges)\n\t\tctx.Export(\"enrollmentId\", example.ID())\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsDvEnrollment;\nimport com.pulumi.akamai.CpsDvEnrollmentArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentAdminContactArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentTechContactArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentCsrArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentNetworkConfigurationArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentOrganizationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CpsDvEnrollment(\"example\", CpsDvEnrollmentArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .acknowledgePreVerificationWarnings(true)\n            .commonName(\"cps-test.example.net\")\n            .sans(            \n                \"san1.cps-test.example.net\",\n                \"san2.cps-test.example.net\")\n            .secureNetwork(\"enhanced-tls\")\n            .sniOnly(true)\n            .adminContact(CpsDvEnrollmentAdminContactArgs.builder()\n                .firstName(\"x1\")\n                .lastName(\"x2\")\n                .phone(\"123123123\")\n                .email(\"x1x2@example.net\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Akamai\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .techContact(CpsDvEnrollmentTechContactArgs.builder()\n                .firstName(\"x3\")\n                .lastName(\"x4\")\n                .phone(\"123123123\")\n                .email(\"x3x4@akamai.com\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Akamai\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .certificateChainType(\"default\")\n            .csr(CpsDvEnrollmentCsrArgs.builder()\n                .countryCode(\"US\")\n                .city(\"cambridge\")\n                .organization(\"Akamai\")\n                .organizationalUnit(\"Dev\")\n                .state(\"MA\")\n                .build())\n            .enableMultiStackedCertificates(false)\n            .networkConfiguration(CpsDvEnrollmentNetworkConfigurationArgs.builder()\n                .disallowedTlsVersions(                \n                    \"TLSv1\",\n                    \"TLSv1_1\")\n                .cloneDnsNames(false)\n                .geography(\"core\")\n                .ocspStapling(\"on\")\n                .preferredCiphers(\"ak-akamai-2020q1\")\n                .mustHaveCiphers(\"ak-akamai-2020q1\")\n                .quicEnabled(false)\n                .build())\n            .signatureAlgorithm(\"SHA-256\")\n            .organization(CpsDvEnrollmentOrganizationArgs.builder()\n                .name(\"Akamai\")\n                .phone(\"123123123\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .build())\n            .build());\n\n        ctx.export(\"dnsChallenges\", example.dnsChallenges());\n        ctx.export(\"httpChallenges\", example.httpChallenges());\n        ctx.export(\"enrollmentId\", example.id());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CpsDvEnrollment\n    properties:\n      contractId: ctr_1-AB123\n      acknowledgePreVerificationWarnings: true\n      commonName: cps-test.example.net\n      sans:\n        - san1.cps-test.example.net\n        - san2.cps-test.example.net\n      secureNetwork: enhanced-tls\n      sniOnly: true\n      adminContact:\n        firstName: x1\n        lastName: x2\n        phone: 123123123\n        email: x1x2@example.net\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Akamai\n        postalCode: 02142\n        region: MA\n        title: Administrator\n      techContact:\n        firstName: x3\n        lastName: x4\n        phone: 123123123\n        email: x3x4@akamai.com\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Akamai\n        postalCode: 02142\n        region: MA\n        title: Administrator\n      certificateChainType: default\n      csr:\n        countryCode: US\n        city: cambridge\n        organization: Akamai\n        organizationalUnit: Dev\n        state: MA\n      enableMultiStackedCertificates: false\n      networkConfiguration:\n        disallowedTlsVersions:\n          - TLSv1\n          - TLSv1_1\n        cloneDnsNames: false\n        geography: core\n        ocspStapling: on\n        preferredCiphers: ak-akamai-2020q1\n        mustHaveCiphers: ak-akamai-2020q1\n        quicEnabled: false\n      signatureAlgorithm: SHA-256\n      organization:\n        name: Akamai\n        phone: 123123123\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        postalCode: 02142\n        region: MA\noutputs:\n  dnsChallenges: ${example.dnsChallenges}\n  httpChallenges: ${example.httpChallenges}\n  enrollmentId: ${example.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThe resource returns these attributes:\n\n* `registration_authority` - (Required) This value populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.\n* `certificate_type` - (Required) This value populates automatically with the `san` certificate type and is preserved in the `state` file.\n* `validation_type` - (Required) This value populates automatically with the `dv` validation type and is preserved in the `state` file.\n* `id` - The unique identifier for this enrollment.\n* `dns_challenges` - The validation challenge for the domains listed in the certificate. To successfully perform the validation, only one challenge for each domain must be complete, either `dns_challenges` or `http_challenges`.\n\n    Returns these additional attributes:\n\n      * `domain` - The domain to validate.\n      * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.\n      * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.\n* `http_challenges` - The validation challenge for the domains listed in the certificate. To successfully perform the validation, only one challenge for each domain must be complete, either `dns_challenges` or `http_challenges`.\n\n    Returns these additional attributes:\n\n      * `domain` - The domain to validate.\n      * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.\n      * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cps_dv_enrollment\" \"example\" { # (resource arguments) } You can import your Akamai DV enrollment using a comma-delimited string of the enrollment ID and\n\n contract ID, optionally with the `ctr_` prefix. You have to enter the IDs in this order`enrollment_id,contract_id` For example\n\n```sh\n $ pulumi import akamai:index/cpsDvEnrollment:CpsDvEnrollment example 12345,1-AB123\n```\n\n ",
            "properties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "certificateType": {
                    "type": "string"
                },
                "commonName": {
                    "type": "string",
                    "description": "- (Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's ID, optionally with the `ctr_` prefix.\n"
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "dnsChallenges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge"
                    }
                },
                "enableMultiStackedCertificates": {
                    "type": "boolean",
                    "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n"
                },
                "httpChallenges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge"
                    }
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "registrationAuthority": {
                    "type": "string"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n"
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                },
                "validationType": {
                    "type": "string"
                }
            },
            "required": [
                "adminContact",
                "certificateType",
                "commonName",
                "contractId",
                "csr",
                "dnsChallenges",
                "httpChallenges",
                "networkConfiguration",
                "organization",
                "registrationAuthority",
                "secureNetwork",
                "signatureAlgorithm",
                "sniOnly",
                "techContact",
                "validationType"
            ],
            "inputProperties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "- (Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                    "willReplaceOnChanges": true
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "enableMultiStackedCertificates": {
                    "type": "boolean",
                    "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n"
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                    "willReplaceOnChanges": true
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                    "willReplaceOnChanges": true
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                }
            },
            "requiredInputs": [
                "adminContact",
                "commonName",
                "contractId",
                "csr",
                "networkConfiguration",
                "organization",
                "secureNetwork",
                "signatureAlgorithm",
                "sniOnly",
                "techContact"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsDvEnrollment resources.\n",
                "properties": {
                    "acknowledgePreVerificationWarnings": {
                        "type": "boolean",
                        "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                    },
                    "adminContact": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                        "description": "Contact information for the certificate administrator at your company.\n"
                    },
                    "certificateChainType": {
                        "type": "string",
                        "description": "Certificate trust chain type.\n"
                    },
                    "certificateType": {
                        "type": "string"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "- (Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                        "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                    },
                    "dnsChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge"
                        }
                    },
                    "enableMultiStackedCertificates": {
                        "type": "boolean",
                        "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n"
                    },
                    "httpChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge"
                        }
                    },
                    "networkConfiguration": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                        "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                    },
                    "organization": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                        "description": "Your organization information.\n"
                    },
                    "registrationAuthority": {
                        "type": "string"
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                    },
                    "secureNetwork": {
                        "type": "string",
                        "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                        "willReplaceOnChanges": true
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                    },
                    "sniOnly": {
                        "type": "boolean",
                        "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "techContact": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                        "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                    },
                    "validationType": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpsDvValidation:CpsDvValidation": {
            "description": "Once you complete the Let's Encrypt challenges, optionally use the `akamai.CpsDvValidation` resource to send the acknowledgement to CPS and inform it that tokens are ready for validation. You can also wait for CPS to check for the tokens, which it does on a regular schedule. Next, CPS automatically deploys the certificate on Staging, and eventually on the Production network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CpsDvValidation(\"example\", {\n    enrollmentId: akamai_cps_dv_enrollment.example.id,\n    sans: akamai_cps_dv_enrollment.example.sans,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CpsDvValidation(\"example\",\n    enrollment_id=akamai_cps_dv_enrollment[\"example\"][\"id\"],\n    sans=akamai_cps_dv_enrollment[\"example\"][\"sans\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.CpsDvValidation(\"example\", new Akamai.CpsDvValidationArgs\n        {\n            EnrollmentId = akamai_cps_dv_enrollment.Example.Id,\n            Sans = akamai_cps_dv_enrollment.Example.Sans,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpsDvValidation(ctx, \"example\", \u0026akamai.CpsDvValidationArgs{\n\t\t\tEnrollmentId: pulumi.Any(akamai_cps_dv_enrollment.Example.Id),\n\t\t\tSans:         pulumi.Any(akamai_cps_dv_enrollment.Example.Sans),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsDvValidation;\nimport com.pulumi.akamai.CpsDvValidationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CpsDvValidation(\"example\", CpsDvValidationArgs.builder()        \n            .enrollmentId(akamai_cps_dv_enrollment.example().id())\n            .sans(akamai_cps_dv_enrollment.example().sans())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CpsDvValidation\n    properties:\n      enrollmentId: ${akamai_cps_dv_enrollment.example.id}\n      sans: ${akamai_cps_dv_enrollment.example.sans}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `status` - The status of certificate validation.\n",
            "properties": {
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the DV certificate enrollment.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n"
                },
                "status": {
                    "type": "string"
                }
            },
            "required": [
                "enrollmentId",
                "status"
            ],
            "inputProperties": {
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the DV certificate enrollment.\n",
                    "willReplaceOnChanges": true
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enrollmentId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsDvValidation resources.\n",
                "properties": {
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier for the DV certificate enrollment.\n",
                        "willReplaceOnChanges": true
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/datastream:Datastream": {
            "description": "\n\n\n## Import\n\nBasic usagehcl resource \"akamai_datastream\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai DataStream configuration using a stream version ID. For example\n\n```sh\n $ pulumi import akamai:index/datastream:Datastream example 1234\n```\n\n ~\u003e **IMPORTANT:** For security reasons, this command doesn't import any secrets you specify for your connector. To make sure the state file includes complete data, use this resource to manually add the arguments marked **Secret** above. ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "- (Required) Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                },
                "azureConnector": {
                    "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                    "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                },
                "config": {
                    "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                    "description": "- (Required) Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) Identifies the contract that has access to the product.\n"
                },
                "createdBy": {
                    "type": "string",
                    "description": "The username who created the stream\n"
                },
                "createdDate": {
                    "type": "string",
                    "description": "The date and time when the stream was created\n"
                },
                "datadogConnector": {
                    "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                    "description": "Specify details about the Datadog connector in a stream, including:\n"
                },
                "datasetFieldsIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "- (Required)\tIdentifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                },
                "emailIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                },
                "gcsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                    "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) Identifies the group that has access to the product and this stream configuration.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the user group for which the stream was created\n"
                },
                "httpsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                    "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                },
                "modifiedBy": {
                    "type": "string",
                    "description": "The username who modified the stream\n"
                },
                "modifiedDate": {
                    "type": "string",
                    "description": "The date and time when the stream was modified\n"
                },
                "oracleConnector": {
                    "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                    "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                },
                "papiJson": {
                    "type": "string",
                    "description": "The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior\n"
                },
                "productId": {
                    "type": "string",
                    "description": "The ID of the product for which the stream was created\n"
                },
                "productName": {
                    "type": "string",
                    "description": "The name of the product for which the stream was created\n"
                },
                "propertyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Required) Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                },
                "s3Connector": {
                    "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                    "description": "- (Optional) Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                },
                "splunkConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                    "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "- (Required) The name of the stream.\n"
                },
                "streamType": {
                    "type": "string",
                    "description": "- (Required) The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                },
                "streamVersionId": {
                    "type": "integer",
                    "description": "Identifies the configuration version of the stream\n"
                },
                "sumologicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                    "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "- (Required) The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                }
            },
            "required": [
                "active",
                "config",
                "contractId",
                "createdBy",
                "createdDate",
                "datasetFieldsIds",
                "groupId",
                "groupName",
                "modifiedBy",
                "modifiedDate",
                "papiJson",
                "productId",
                "productName",
                "propertyIds",
                "streamName",
                "streamType",
                "streamVersionId",
                "templateName"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "- (Required) Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                },
                "azureConnector": {
                    "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                    "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                },
                "config": {
                    "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                    "description": "- (Required) Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) Identifies the contract that has access to the product.\n"
                },
                "datadogConnector": {
                    "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                    "description": "Specify details about the Datadog connector in a stream, including:\n"
                },
                "datasetFieldsIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "- (Required)\tIdentifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                },
                "emailIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Optional) A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                },
                "gcsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                    "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) Identifies the group that has access to the product and this stream configuration.\n"
                },
                "httpsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                    "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                },
                "oracleConnector": {
                    "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                    "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                },
                "propertyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "- (Required) Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                },
                "s3Connector": {
                    "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                    "description": "- (Optional) Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                },
                "splunkConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                    "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "- (Required) The name of the stream.\n"
                },
                "streamType": {
                    "type": "string",
                    "description": "- (Required) The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                },
                "sumologicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                    "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "- (Required) The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                }
            },
            "requiredInputs": [
                "active",
                "config",
                "contractId",
                "datasetFieldsIds",
                "groupId",
                "propertyIds",
                "streamName",
                "streamType",
                "templateName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datastream resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "- (Required) Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                    },
                    "azureConnector": {
                        "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                        "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                    },
                    "config": {
                        "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                        "description": "- (Required) Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) Identifies the contract that has access to the product.\n"
                    },
                    "createdBy": {
                        "type": "string",
                        "description": "The username who created the stream\n"
                    },
                    "createdDate": {
                        "type": "string",
                        "description": "The date and time when the stream was created\n"
                    },
                    "datadogConnector": {
                        "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                        "description": "Specify details about the Datadog connector in a stream, including:\n"
                    },
                    "datasetFieldsIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "- (Required)\tIdentifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                    },
                    "emailIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "- (Optional) A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                    },
                    "gcsConnector": {
                        "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                        "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) Identifies the group that has access to the product and this stream configuration.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the user group for which the stream was created\n"
                    },
                    "httpsConnector": {
                        "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                        "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                    },
                    "modifiedBy": {
                        "type": "string",
                        "description": "The username who modified the stream\n"
                    },
                    "modifiedDate": {
                        "type": "string",
                        "description": "The date and time when the stream was modified\n"
                    },
                    "oracleConnector": {
                        "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                        "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                    },
                    "papiJson": {
                        "type": "string",
                        "description": "The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior\n"
                    },
                    "productId": {
                        "type": "string",
                        "description": "The ID of the product for which the stream was created\n"
                    },
                    "productName": {
                        "type": "string",
                        "description": "The name of the product for which the stream was created\n"
                    },
                    "propertyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "- (Required) Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                    },
                    "s3Connector": {
                        "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                        "description": "- (Optional) Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                    },
                    "splunkConnector": {
                        "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                        "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                    },
                    "streamName": {
                        "type": "string",
                        "description": "- (Required) The name of the stream.\n"
                    },
                    "streamType": {
                        "type": "string",
                        "description": "- (Required) The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                    },
                    "streamVersionId": {
                        "type": "integer",
                        "description": "Identifies the configuration version of the stream\n"
                    },
                    "sumologicConnector": {
                        "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                        "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "- (Required) The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/dnsRecord:DnsRecord": {
            "description": "Use the `akamai.DnsRecord` resource to configure a DNS record that can integrate with your existing DNS infrastructure.\n\n{{% examples %}}\n## Example Usage\n\nHere are examples of an A record and a CNAME record.\n{{% example %}}\n### An A record example\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst origin = new akamai.DnsRecord(\"origin\", {\n    active: true,\n    recordtype: \"A\",\n    targets: [\"192.0.2.42\"],\n    ttl: 30,\n    zone: \"origin.org\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\norigin = akamai.DnsRecord(\"origin\",\n    active=True,\n    recordtype=\"A\",\n    targets=[\"192.0.2.42\"],\n    ttl=30,\n    zone=\"origin.org\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var origin = new Akamai.DnsRecord(\"origin\", new Akamai.DnsRecordArgs\n        {\n            Active = true,\n            Recordtype = \"A\",\n            Targets = \n            {\n                \"192.0.2.42\",\n            },\n            Ttl = 30,\n            Zone = \"origin.org\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewDnsRecord(ctx, \"origin\", \u0026akamai.DnsRecordArgs{\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tRecordtype: pulumi.String(\"A\"),\n\t\t\tTargets: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.2.42\"),\n\t\t\t},\n\t\t\tTtl:  pulumi.Int(30),\n\t\t\tZone: pulumi.String(\"origin.org\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.DnsRecord;\nimport com.pulumi.akamai.DnsRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var origin = new DnsRecord(\"origin\", DnsRecordArgs.builder()        \n            .active(true)\n            .recordtype(\"A\")\n            .targets(\"192.0.2.42\")\n            .ttl(30)\n            .zone(\"origin.org\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  origin:\n    type: akamai:DnsRecord\n    properties:\n      active: true\n      recordtype: A\n      targets:\n        - 192.0.2.42\n      ttl: 30\n      zone: origin.org\n```\n{{% /example %}}\n{{% example %}}\n### CNAME Record Example\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst www = new akamai.DnsRecord(\"www\", {\n    active: true,\n    recordtype: \"CNAME\",\n    targets: \"origin.example.org.edgesuite.net\",\n    ttl: 600,\n    zone: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nwww = akamai.DnsRecord(\"www\",\n    active=True,\n    recordtype=\"CNAME\",\n    targets=\"origin.example.org.edgesuite.net\",\n    ttl=600,\n    zone=\"example.com\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var www = new Akamai.DnsRecord(\"www\", new Akamai.DnsRecordArgs\n        {\n            Active = true,\n            Recordtype = \"CNAME\",\n            Targets = \"origin.example.org.edgesuite.net\",\n            Ttl = 600,\n            Zone = \"example.com\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewDnsRecord(ctx, \"www\", \u0026akamai.DnsRecordArgs{\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tRecordtype: pulumi.String(\"CNAME\"),\n\t\t\tTargets:    pulumi.StringArray(\"origin.example.org.edgesuite.net\"),\n\t\t\tTtl:        pulumi.Int(600),\n\t\t\tZone:       pulumi.String(\"example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.DnsRecord;\nimport com.pulumi.akamai.DnsRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var www = new DnsRecord(\"www\", DnsRecordArgs.builder()        \n            .active(true)\n            .recordtype(\"CNAME\")\n            .targets(\"origin.example.org.edgesuite.net\")\n            .ttl(600)\n            .zone(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  www:\n    type: akamai:DnsRecord\n    properties:\n      active: true\n      recordtype: CNAME\n      targets: origin.example.org.edgesuite.net\n      ttl: 600\n      zone: example.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Argument reference [argument-reference]\n\nThis resource supports these arguments for all record types:\n\n* `name` - (Required) The DNS record name. This is the node this DNS record is associated with. Also known as an owner name. \n* `zone` - (Required) The domain zone, including any nested subdomains.  \n* `recordType` - (Required) The DNS record type.  \n* `ttl` - (Required) The time to live (TTL) is a 32-bit signed integer for the time the resource record is cached. \u003cbr /\u003e A value of `0` means that the resource record is not cached. It's only used for the transaction in progress and may be useful for extremely volatile data.  \n\n## Additional arguments by record type\n\nThis section lists additional required and optional arguments for specific record types.\n\n\n### A record\n\nAn A record requires this argument:\n\n* `target` - One or more IPv4 addresses, for example, 192.0.2.0.\n\n### AAAA record\n\nAn AAAA record requires this argument:\n\n* `target` - One or more IPv6 addresses, for example, 2001:0db8::ff00:0042:8329.\n\n### AFSDB record\n\nAn AFSDB record requires these arguments:\n\n* `target` - The domain name of the host having a server for the cell named by the owner name of the resource record.\n* `subtype` - An integer between `0` and `65535` that indicates the type of service provided by the host.\n\n### AKAMAICDN record\n\nAn AKAMAICDN record requires this argument:\n\n* `target` - A DNS name representing the selected edge hostname and domain.\n\n### AKAMAITLC record\n\nNo additional arguments are needed for AKAMAITLC records. This resource returns these computed attributes for this record type:\n\n* `dns_name` - A valid DNS name.\n* `answer_type` - The answer type.\n\n### CAA record\n\nA certificate authority authorization (CAA) record requires this argument:\n\n* `target` - One or more certificate authority authorizations. Each authorization contains three attributes: flags, property tag, and property value.\n\nExample:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\n### CERT record\n\nA CERT record requires these arguments:\n\n* `type_value` - A numeric certificate type value.\n* `type_mnemonic` - A mnemonic certificate type value.\n* `keytag` - A value computed for the key embedded in the certificate.\n* `algorithm` - The cryptographic algorithm used to create the signature.\n* `certificate` - Certificate data.\n\n\u003e **Note:** When entering the certificate type, you can enter `type_value`, `type_mnemonic`, or  both arguments. If you use both, `type_mnemonic` takes precedence.\n\n### CNAME record\n\nA CNAME record requires this argument:\n\n* `target `- A domain name that specifies the canonical or primary name for the owner. The owner name is an alias.\n\n### DNSKEY record\n\nA DNSKEY record requires these arguments:\n\n* `flags`\n* `protocol` - Set to `3`. If the value isn't `3`, the DNSKEY resource record is treated as invalid during signature verification.\n* `algorithm` - The public key's cryptographic algorithm. This algorithm determines the format of the public key field.\n* `key` - A Base64 encoded value representing the public key. The format used depends on the `algorithm`.\n\n### DS record\n\nA DS record requires these arguments:\n\n* `keytag` - The key tag of the DNSKEY record that the DS record refers to, in network byte order.\n* `algorithm` - The algorithm number of the DNSKEY resource record referred to by the DS record.\n* `digest_type` - Identifies the algorithm used to construct the digest.\n* `digest` - A base 16 encoded DS record includes a digest of the DNSKEY record it refers to. The digest is conifgured the canonical form of the DNSKEY record's fully qualified owner name with the DNSKEY RDATA, and then applying the digest algorithm.\n\n### HINFO record\n\nA HINFO record requires these arguments:\n\n* `hardware` - The type of hardware the host uses. A machine name or CPU type may be up to 40 characters long and include uppercase letters, digits, hyphens, and slashes. The entry needs to start and to end with an uppercase letter.\n* `software` - The type of software the host uses. A system name may be up to 40 characters long and include uppercase letters, digits, hyphens, and slashes. The entry needs to start with an uppercase letter and end with an uppercase letter or a digit.\n\n### HTTPS Record\n\nThe following fields are required:\n\n* `svc_priority` - Service priority associated with endpoint. Value mist be between 0 and 65535. A piority of 0 enables alias mode. \n* `svc_params` - Space separated list of endpoint parameters. Not allowed if service priority is 0.\n* `target_name` - Domain name of the service endpoint.\n\n### LOC record\n\nA LOC record requires this argument:\n\n* `target` - A geographical location associated with a domain name.\n\n### MX record\n\nAn MX record supports these arguments:\n\n* `target` - (Required) One or more domain names that specify a host willing to act as a mail exchange for the owner name.\n* `priority` - (Optional) The preference value given to this MX record in relation to all other MX records. When a mailer needs to send mail to a certain DNS domain, it first contacts a DNS server for that domain and retrieves all the MX records. It then contacts the mailer with the lowest preference value. This value is ignored if an embedded priority exists in the target.\n* `priority_increment` - (Optional) An auto priority increment when multiple targets are provided with no embedded priority.\n\nSee Working with MX records in the DNS Getting Started Guide for more information.\n\n### NAPTR record\n\nAn NAPTR record requires these arguments:\n\n* `order` - A 16-bit unsigned integer specifying the order in which the NAPTR records need to be processed to ensure the correct ordering of rules. Low numbers are processed before high numbers. Once a NAPTR is found whose rule matches the target, the client shouldn't consider any NAPTRs with a higher value for order (except as noted below for the flagsnapter field).\n* `preference` - A 16-bit unsigned integer that specifies the order in which NAPTR records with equal order values are processed. Low numbers are processed before high numbers.\n* `flagsnaptr` - A character string containing flags that control how fields in the record are rewritten and interpreted. Flags are single alphanumeric characters. \n* `service` - Specifies the services available down this rewrite path.\n* `regexp` - A regular expression string containing a substitution expression. This substitution expression is applied to the original client string in order to construct the next domain name to lookup.\n* `replacement` - Depending on the value of the `flags` attribute, the next NAME to query for NAPTR, SRV, or address records. Enter a fully qualified domain name as the value.\n\n### NS record\n\nAn NS record requires these arguments:\n\n* `target` - One or more domain names that specify authoritative hosts for the specified class and domain.\n\n### NSEC3 record\n\nAn NSEC3 record requires these arguments:\n\n* `algorithm` - The cryptographic hash algorithm used to construct the hash-value.\n* `flags` - Eight one-bit flags you can use to indicate different processing. All undefined flags must be zero.\n* `iterations` - The number of additional times the hash function has been performed.\n* `salt` - The base 16 encoded salt value, which is appended to the original owner name before hashing. Used to defend against pre-calculated dictionary attacks.\n* `next_hashed_owner_name` - Base 32 encoded. The next hashed owner name in hash order. This value is in binary format. Given the ordered set of all hashed owner names, the Next Hashed Owner Name field contains the hash of an owner name that immediately follows the owner name of the given NSEC3 RR.\n* `type_bitmaps` - The resource record set types that exist at the original owner name of the NSEC3 RR.\n\n### NSEC3PARAM record\n\nAn NSEC3PARAM record requires these arguments:\n\n* `algorithm` - The cryptographic hash algorithm used to construct the hash-value.\n* `flags` - Eight one-bit flags that can be used to indicate different processing. All undefined flags must be zero.\n* `iterations` - The number of additional times the hash function has been performed.\n* `salt` - The base 16 encoded salt value, which is appended to the original owner name before hashing in order to defend against pre-calculated dictionary attacks.\n\n### PTR record\n\nA PTR record requires this argument:\n\n* `target` - A domain name that points to some location in the domain name space.\n\n### RP record\n\nAn RP record requires these arguments:\n\n* `mailbox` - A domain name that specifies the mailbox for the responsible person.\n* `txt` - A domain name for which TXT resource records exist.\n\n### RRSIG record\n\nAn RRSIG record requires these arguments:\n\n* `type_covered` - The resource record set type covered by this signature.\n* `algorithm` - Identifies the cryptographic algorithm used to create the signature.\n* `original_ttl` - The TTL of the covered record set as it appears in the authoritative zone.\n* `expiration` - The end point of this signature's validity. The signature can`t be used for authentication past this point in time.\n* `inception` - The start point of this signature's validity. The signature can`t be used for authentication prior to this point in time.\n* `keytag` - The Key Tag field contains the key tag value of the DNSKEY RR that validates this signature, in network byte order.\n* `signer` - The owner of the DNSKEY resource record who validates this signature.\n* `signature` - The base 64 encoded cryptographic signature that covers the RRSIG RDATA and covered record set. Format depends on the TSIG algorithm in use.\n* `labels` - The Labels field specifies the number of labels in the original RRSIG RR owner name. The significance of this field is that a validator uses it to determine whether the answer was synthesized from a wildcard. If so, it can be used to determine what owner name was used in generating the signature.\n\n### SPF record\n\nAn SPF record requires this argument:\n\n* `target` - Indicates which hosts are, and are not, authorized to use a domain name for the “HELO” and “MAIL FROM” identities.\n\n### SRV record\n\nAn SRV record requires these arguments:\n\n* `target` - The domain name of the target host.\n* `priority` - A 16-bit integer that specifies the preference given to this resource record among others at the same owner. Lower values are preferred.\n* `weight` - A server selection mechanism that specifies a relative weight for entries with the same priority. Larger weights are given a proportionately higher probability of being selected. The range of this number is 0–65535, a 16-bit unsigned integer in network byte order. Domain administrators should use Weight 0 when there isn't any server selection to do, to make the RR easier to read for humans. In the presence of records containing weights greater than 0, records with weight 0 should have a very small chance of being selected.\n* `port` - The port on this target of this service. The range of this number is 0–65535, a 16-bit unsigned integer in network byte order.\n\n### SSHFP record\n\nAn SSHFP record requires these arguments:\n\n* `algorithm` - Describes the algorithm of the public key. The following values are assigned: `0` is reserved, `1` is for RSA, `2` is for DSS, and `3` is for ECDSA.\n* `fingerprint_type` - Describes the message-digest algorithm used to calculate the fingerprint of the public key. The following values are assigned: 0 = reserved, 1 = SHA-1, 2 = SHA-256.\n* `fingerprint` - The base 16 encoded fingerprint as calculated over the public key blob. The message-digest algorithm is presumed to produce an opaque octet string output, which is placed as-is in the RDATA fingerprint field.\n\n### SOA record\n\nAn SOA record requires these arguments:\n\n* `name_server` - The domain name of the name server that was the original or primary source of data for this zone.\n* `email_address` - A domain name that specifies the mailbox of this person responsible for this zone.\n* `serial` - The unsigned version number between 0 and 214748364 of the original copy of the zone.\n* `refresh` - A time interval between 0 and 214748364 before the zone should be refreshed.\n* `retry` - A time interval between 0 and 214748364 that should elapse before a failed refresh should be retried.\n* `expiry` - A time value between 0 and 214748364 that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.\n* `nxdomain_ttl` - The unsigned minimum TTL between 0 and 214748364 that should be exported with any resource record from this zone.\n\n### SVCB record\n\nAn SVCB record requires these arguments:\n\n* `svc_priority` - Service priority associated with endpoint. Value mist be between 0 and 65535. A piority of 0 enables alias mode.\n* `svc_params` - Space separated list of endpoint parameters. Not allowed if service priority is 0.\n* `target_name` - Domain name of the service endpoint.\n\n### TLSA record\n\nA TLSA record requires these arguments:\n\n* `usage` - Specifies the association used to match the certificate presented in the TLS handshake.\n* `selector` - Specifies the part of the TLS certificate presented by the server that is matched against the association data. \n* `match_type` - Specifies how the certificate association is presented.\n* `certificate` - Specifies the certificate association data to be matched.\n\n### TXT record\n\nA TXT record requires this argument:\n\n* `target` - One or more character strings. TXT resource records hold descriptive text. The semantics of the text depends on the domain where it is found.\n",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "answerType": {
                    "type": "string"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "dnsName": {
                    "type": "string"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordSha": {
                    "type": "string"
                },
                "recordtype": {
                    "type": "string"
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "serial": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string"
                }
            },
            "required": [
                "answerType",
                "dnsName",
                "name",
                "recordSha",
                "recordtype",
                "serial",
                "ttl",
                "zone"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordtype": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "recordtype",
                "ttl",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsRecord resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "algorithm": {
                        "type": "integer"
                    },
                    "answerType": {
                        "type": "string"
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "digest": {
                        "type": "string"
                    },
                    "digestType": {
                        "type": "integer"
                    },
                    "dnsName": {
                        "type": "string"
                    },
                    "emailAddress": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string"
                    },
                    "expiry": {
                        "type": "integer"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "fingerprintType": {
                        "type": "integer"
                    },
                    "flags": {
                        "type": "integer"
                    },
                    "flagsnaptr": {
                        "type": "string"
                    },
                    "hardware": {
                        "type": "string"
                    },
                    "inception": {
                        "type": "string"
                    },
                    "iterations": {
                        "type": "integer"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keytag": {
                        "type": "integer"
                    },
                    "labels": {
                        "type": "integer"
                    },
                    "mailbox": {
                        "type": "string"
                    },
                    "matchType": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "nameServer": {
                        "type": "string"
                    },
                    "nextHashedOwnerName": {
                        "type": "string"
                    },
                    "nxdomainTtl": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "integer"
                    },
                    "originalTtl": {
                        "type": "integer"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "preference": {
                        "type": "integer"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "priorityIncrement": {
                        "type": "integer"
                    },
                    "protocol": {
                        "type": "integer"
                    },
                    "recordSha": {
                        "type": "string"
                    },
                    "recordtype": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "refresh": {
                        "type": "integer"
                    },
                    "regexp": {
                        "type": "string"
                    },
                    "replacement": {
                        "type": "string"
                    },
                    "retry": {
                        "type": "integer"
                    },
                    "salt": {
                        "type": "string"
                    },
                    "selector": {
                        "type": "integer"
                    },
                    "serial": {
                        "type": "integer"
                    },
                    "service": {
                        "type": "string"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "signer": {
                        "type": "string"
                    },
                    "software": {
                        "type": "string"
                    },
                    "subtype": {
                        "type": "integer"
                    },
                    "svcParams": {
                        "type": "string"
                    },
                    "svcPriority": {
                        "type": "integer"
                    },
                    "targetName": {
                        "type": "string"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ttl": {
                        "type": "integer"
                    },
                    "txt": {
                        "type": "string"
                    },
                    "typeBitmaps": {
                        "type": "string"
                    },
                    "typeCovered": {
                        "type": "string"
                    },
                    "typeMnemonic": {
                        "type": "string"
                    },
                    "typeValue": {
                        "type": "integer"
                    },
                    "usage": {
                        "type": "integer"
                    },
                    "weight": {
                        "type": "integer"
                    },
                    "zone": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:edgedns/dnsRecord:DnsRecord"
                }
            ]
        },
        "akamai:index/dnsZone:DnsZone": {
            "properties": {
                "activationState": {
                    "type": "string"
                },
                "aliasCount": {
                    "type": "integer"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n"
                },
                "versionId": {
                    "type": "string"
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "required": [
                "activationState",
                "aliasCount",
                "contract",
                "type",
                "versionId",
                "zone"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                    "willReplaceOnChanges": true
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "requiredInputs": [
                "contract",
                "type",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsZone resources.\n",
                "properties": {
                    "activationState": {
                        "type": "string"
                    },
                    "aliasCount": {
                        "type": "integer"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive comment.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    },
                    "endCustomerId": {
                        "type": "string",
                        "description": "A free form identifier for the zone.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The currently selected group ID.\n"
                    },
                    "masters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                    },
                    "signAndServe": {
                        "type": "boolean",
                        "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                    },
                    "signAndServeAlgorithm": {
                        "type": "string",
                        "description": "The algorithm used by Sign and Serve.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The name of the zone whose configuration this zone will copy.\n"
                    },
                    "tsigKey": {
                        "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                        "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                        "willReplaceOnChanges": true
                    },
                    "versionId": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The domain zone, encapsulating any nested subdomains.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:edgedns/dnsZone:DnsZone"
                }
            ]
        },
        "akamai:index/edgeHostName:EdgeHostName": {
            "description": "The `akamai.EdgeHostName` resource lets you configure a secure edge hostname. Your\nedge hostname determines how requests for your site, app, or content are mapped to\nAkamai edge servers.\n\nAn edge hostname is the CNAME target you use when directing your end user traffic to\nAkamai. Each hostname assigned to a property has a corresponding edge hostname.\n\nAkamai supports three types of edge hostnames, depending on the level of security\nyou need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When\nentering the `edge_hostname` attribute, you need to include a specific domain suffix\nfor your edge hostname type:\n\n| Edge hostname type | Domain suffix |\n|------|-------|\n| Enhanced TLS | edgekey.net |\n| Standard TLS | edgesuite.net |\n| Shared Cert | akamaized.net |\n\nFor example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See the [Property Manager API (PAPI)](https://developer.akamai.com/api/core_features/property_manager/v1.html#createedgehostnames) for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst provider_demo = new akamai.EdgeHostName(\"provider-demo\", {\n    contractId: \"ctr_1-AB123\",\n    edgeHostname: \"www.example.org.edgesuite.net\",\n    groupId: \"grp_123\",\n    ipBehavior: \"IPV4\",\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nprovider_demo = akamai.EdgeHostName(\"provider-demo\",\n    contract_id=\"ctr_1-AB123\",\n    edge_hostname=\"www.example.org.edgesuite.net\",\n    group_id=\"grp_123\",\n    ip_behavior=\"IPV4\",\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var provider_demo = new Akamai.EdgeHostName(\"provider-demo\", new Akamai.EdgeHostNameArgs\n        {\n            ContractId = \"ctr_1-AB123\",\n            EdgeHostname = \"www.example.org.edgesuite.net\",\n            GroupId = \"grp_123\",\n            IpBehavior = \"IPV4\",\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeHostName(ctx, \"provider-demo\", \u0026akamai.EdgeHostNameArgs{\n\t\t\tContractId:   pulumi.String(\"ctr_1-AB123\"),\n\t\t\tEdgeHostname: pulumi.String(\"www.example.org.edgesuite.net\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tIpBehavior:   pulumi.String(\"IPV4\"),\n\t\t\tProductId:    pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeHostName;\nimport com.pulumi.akamai.EdgeHostNameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var provider_demo = new EdgeHostName(\"provider-demo\", EdgeHostNameArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .edgeHostname(\"www.example.org.edgesuite.net\")\n            .groupId(\"grp_123\")\n            .ipBehavior(\"IPV4\")\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  provider-demo:\n    type: akamai:EdgeHostName\n    properties:\n      contractId: ctr_1-AB123\n      edgeHostname: www.example.org.edgesuite.net\n      groupId: grp_123\n      ipBehavior: IPV4\n      productId: prd_Object_Delivery\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE` for version 6, or `IPV6_COMPLIANCE` for both.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_edge_hostname\" \"example\" {\n\n # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:\n\n`edge_hostname, contract_id, group_id` For example\n\n```sh\n $ pulumi import akamai:index/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n"
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n"
                }
            },
            "required": [
                "contract",
                "contractId",
                "edgeHostname",
                "group",
                "groupId",
                "ipBehavior",
                "product",
                "productId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                    "willReplaceOnChanges": true
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeHostname",
                "ipBehavior"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeHostName resources.\n",
                "properties": {
                    "certificate": {
                        "type": "integer",
                        "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                        "willReplaceOnChanges": true
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "edgeHostname": {
                        "type": "string",
                        "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "ipBehavior": {
                        "type": "string",
                        "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    },
                    "statusUpdateEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                    },
                    "useCases": {
                        "type": "string",
                        "description": "A JSON encoded list of use cases.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/edgeHostName:EdgeHostName"
                }
            ]
        },
        "akamai:index/edgeKv:EdgeKv": {
            "description": "The `akamai.EdgeKv` resource lets you control EdgeKV database functions outside EdgeWorkers JavaScript code. Refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/welcome-to-edgekv) for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst testStaging = new akamai.EdgeKv(\"test_staging\", {\n    geoLocation: \"US\",\n    groupId: 4284,\n    initialDatas: [{\n        group: \"translations\",\n        key: \"lang\",\n        value: \"English\",\n    }],\n    namespaceName: \"Marketing\",\n    network: \"staging\",\n    retentionInSeconds: 15724800,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest_staging = akamai.EdgeKv(\"testStaging\",\n    geo_location=\"US\",\n    group_id=4284,\n    initial_datas=[akamai.EdgeKvInitialDataArgs(\n        group=\"translations\",\n        key=\"lang\",\n        value=\"English\",\n    )],\n    namespace_name=\"Marketing\",\n    network=\"staging\",\n    retention_in_seconds=15724800)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testStaging = new Akamai.EdgeKv(\"testStaging\", new Akamai.EdgeKvArgs\n        {\n            GeoLocation = \"US\",\n            GroupId = 4284,\n            InitialDatas = \n            {\n                new Akamai.Inputs.EdgeKvInitialDataArgs\n                {\n                    Group = \"translations\",\n                    Key = \"lang\",\n                    Value = \"English\",\n                },\n            },\n            NamespaceName = \"Marketing\",\n            Network = \"staging\",\n            RetentionInSeconds = 15724800,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeKv(ctx, \"testStaging\", \u0026akamai.EdgeKvArgs{\n\t\t\tGeoLocation: pulumi.String(\"US\"),\n\t\t\tGroupId:     pulumi.Int(4284),\n\t\t\tInitialDatas: EdgeKvInitialDataArray{\n\t\t\t\t\u0026EdgeKvInitialDataArgs{\n\t\t\t\t\tGroup: pulumi.String(\"translations\"),\n\t\t\t\t\tKey:   pulumi.String(\"lang\"),\n\t\t\t\t\tValue: pulumi.String(\"English\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tNamespaceName:      pulumi.String(\"Marketing\"),\n\t\t\tNetwork:            pulumi.String(\"staging\"),\n\t\t\tRetentionInSeconds: pulumi.Int(15724800),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeKv;\nimport com.pulumi.akamai.EdgeKvArgs;\nimport com.pulumi.akamai.inputs.EdgeKvInitialDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testStaging = new EdgeKv(\"testStaging\", EdgeKvArgs.builder()        \n            .geoLocation(\"US\")\n            .groupId(4284)\n            .initialDatas(EdgeKvInitialDataArgs.builder()\n                .group(\"translations\")\n                .key(\"lang\")\n                .value(\"English\")\n                .build())\n            .namespaceName(\"Marketing\")\n            .network(\"staging\")\n            .retentionInSeconds(15724800)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testStaging:\n    type: akamai:EdgeKv\n    properties:\n      geoLocation: US\n      groupId: 4284\n      initialDatas:\n        - group: translations\n          key: lang\n          value: English\n      namespaceName: Marketing\n      network: staging\n      retentionInSeconds: 1.57248e+07\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThere are no supported arguments for this resource.\n",
            "properties": {
                "geoLocation": {
                    "type": "string",
                    "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "- (Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n"
                },
                "initialDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                    },
                    "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                },
                "namespaceName": {
                    "type": "string",
                    "description": "- (Required) The name of the namespace.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "retentionInSeconds": {
                    "type": "integer",
                    "description": "- (Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                }
            },
            "required": [
                "groupId",
                "namespaceName",
                "network",
                "retentionInSeconds"
            ],
            "inputProperties": {
                "geoLocation": {
                    "type": "string",
                    "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "integer",
                    "description": "- (Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n",
                    "willReplaceOnChanges": true
                },
                "initialDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                    },
                    "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                },
                "namespaceName": {
                    "type": "string",
                    "description": "- (Required) The name of the namespace.\n",
                    "willReplaceOnChanges": true
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInSeconds": {
                    "type": "integer",
                    "description": "- (Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "namespaceName",
                "network",
                "retentionInSeconds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeKv resources.\n",
                "properties": {
                    "geoLocation": {
                        "type": "string",
                        "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "- (Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n",
                        "willReplaceOnChanges": true
                    },
                    "initialDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                        },
                        "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                    },
                    "namespaceName": {
                        "type": "string",
                        "description": "- (Required) The name of the namespace.\n",
                        "willReplaceOnChanges": true
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n",
                        "willReplaceOnChanges": true
                    },
                    "retentionInSeconds": {
                        "type": "integer",
                        "description": "- (Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/edgeWorker:EdgeWorker": {
            "description": "The `akamai.EdgeWorker` resource lets you deploy custom code on thousands of edge servers and apply logic that creates powerful web experiences.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst ew = new akamai.EdgeWorker(\"ew\", {\n    groupId: 72297,\n    resourceTierId: 100,\n    localBundle: _var.bundle_path,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\new = akamai.EdgeWorker(\"ew\",\n    group_id=72297,\n    resource_tier_id=100,\n    local_bundle=var[\"bundle_path\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ew = new Akamai.EdgeWorker(\"ew\", new Akamai.EdgeWorkerArgs\n        {\n            GroupId = 72297,\n            ResourceTierId = 100,\n            LocalBundle = @var.Bundle_path,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeWorker(ctx, \"ew\", \u0026akamai.EdgeWorkerArgs{\n\t\t\tGroupId:        pulumi.Int(72297),\n\t\t\tResourceTierId: pulumi.Int(100),\n\t\t\tLocalBundle:    pulumi.Any(_var.Bundle_path),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeWorker;\nimport com.pulumi.akamai.EdgeWorkerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ew = new EdgeWorker(\"ew\", EdgeWorkerArgs.builder()        \n            .groupId(72297)\n            .resourceTierId(100)\n            .localBundle(var_.bundle_path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ew:\n    type: akamai:EdgeWorker\n    properties:\n      groupId: 72297\n      resourceTierId: 100\n      localBundle: ${var.bundle_path}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `edgeworker_id` - Unique identifier for an EdgeWorker ID.\n* `local_bundle_hash` - A SHA-256 hash digest of the EdgeWorkers code bundle.\n* `version` - Unique identifier for a specific EdgeWorker version.\n* `warnings` - List of validation warnings.\n",
            "properties": {
                "edgeworkerId": {
                    "type": "integer",
                    "description": "The unique identifier of the EdgeWorker\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "- (Required) Identifies a group to assign to the EdgeWorker ID.\n"
                },
                "localBundle": {
                    "type": "string",
                    "description": "- (Optional) The path to the EdgeWorkers code bundle.\n"
                },
                "localBundleHash": {
                    "type": "string",
                    "description": "The local bundle hash for the EdgeWorker\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) The name of the EdgeWorker ID.\n"
                },
                "resourceTierId": {
                    "type": "integer",
                    "description": "- (Required) Unique identifier of the resource tier.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The bundle version\n"
                },
                "warnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of warnings returned by EdgeWorker validation\n"
                }
            },
            "required": [
                "edgeworkerId",
                "groupId",
                "localBundleHash",
                "name",
                "resourceTierId",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "integer",
                    "description": "- (Required) Identifies a group to assign to the EdgeWorker ID.\n"
                },
                "localBundle": {
                    "type": "string",
                    "description": "- (Optional) The path to the EdgeWorkers code bundle.\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) The name of the EdgeWorker ID.\n"
                },
                "resourceTierId": {
                    "type": "integer",
                    "description": "- (Required) Unique identifier of the resource tier.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId",
                "resourceTierId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeWorker resources.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "The unique identifier of the EdgeWorker\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "- (Required) Identifies a group to assign to the EdgeWorker ID.\n"
                    },
                    "localBundle": {
                        "type": "string",
                        "description": "- (Optional) The path to the EdgeWorkers code bundle.\n"
                    },
                    "localBundleHash": {
                        "type": "string",
                        "description": "The local bundle hash for the EdgeWorker\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "- (Required) The name of the EdgeWorker ID.\n"
                    },
                    "resourceTierId": {
                        "type": "integer",
                        "description": "- (Required) Unique identifier of the resource tier.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The bundle version\n"
                    },
                    "warnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of warnings returned by EdgeWorker validation\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/edgeWorkersActivation:EdgeWorkersActivation": {
            "description": "Use the `akamai.EdgeWorkersActivation` resource to activate a specific EdgeWorker version. An activation deploys the version to either the Akamai staging or production network.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst test = new akamai.EdgeWorkersActivation(\"test\", {\n    edgeworkerId: 1234,\n    network: \"STAGING\",\n    version: \"test1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest = akamai.EdgeWorkersActivation(\"test\",\n    edgeworker_id=1234,\n    network=\"STAGING\",\n    version=\"test1\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Akamai.EdgeWorkersActivation(\"test\", new Akamai.EdgeWorkersActivationArgs\n        {\n            EdgeworkerId = 1234,\n            Network = \"STAGING\",\n            Version = \"test1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeWorkersActivation(ctx, \"test\", \u0026akamai.EdgeWorkersActivationArgs{\n\t\t\tEdgeworkerId: pulumi.Int(1234),\n\t\t\tNetwork:      pulumi.String(\"STAGING\"),\n\t\t\tVersion:      pulumi.String(\"test1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeWorkersActivation;\nimport com.pulumi.akamai.EdgeWorkersActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EdgeWorkersActivation(\"test\", EdgeWorkersActivationArgs.builder()        \n            .edgeworkerId(1234)\n            .network(\"STAGING\")\n            .version(\"test1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: akamai:EdgeWorkersActivation\n    properties:\n      edgeworkerId: 1234\n      network: STAGING\n      version: test1\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "integer",
                    "description": "(Required) Unique identifier of the activation.\n"
                },
                "edgeworkerId": {
                    "type": "integer",
                    "description": "A unique identifier for the EdgeWorker ID you want to activate.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The EdgeWorker version you want to activate.\n"
                }
            },
            "required": [
                "activationId",
                "edgeworkerId",
                "network",
                "version"
            ],
            "inputProperties": {
                "edgeworkerId": {
                    "type": "integer",
                    "description": "A unique identifier for the EdgeWorker ID you want to activate.\n",
                    "willReplaceOnChanges": true
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The EdgeWorker version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "edgeworkerId",
                "network",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeWorkersActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "integer",
                        "description": "(Required) Unique identifier of the activation.\n"
                    },
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "A unique identifier for the EdgeWorker ID you want to activate.\n",
                        "willReplaceOnChanges": true
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The EdgeWorker version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/gtmAsmap:GtmAsmap": {
            "description": "Use the `akamai.GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address. \n\nYou can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin. \n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoAsmap = new akamai.GtmAsmap(\"demo_asmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other AS numbers\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_asmap = akamai.GtmAsmap(\"demoAsmap\",\n    default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other AS numbers\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoAsmap = new Akamai.GtmAsmap(\"demoAsmap\", new Akamai.GtmAsmapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmAsmapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Other AS numbers\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmAsmap(ctx, \"demoAsmap\", \u0026akamai.GtmAsmapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmAsmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other AS numbers\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmAsmap;\nimport com.pulumi.akamai.GtmAsmapArgs;\nimport com.pulumi.akamai.inputs.GtmAsmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoAsmap = new GtmAsmap(\"demoAsmap\", GtmAsmapArgs.builder()        \n            .defaultDatacenter(GtmAsmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other AS numbers\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoAsmap:\n    type: akamai:GtmAsmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other AS numbers\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM AS Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#asmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmAsmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                        },
                        "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                        "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM Domain name for the AS map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmASmap:GtmASmap"
                }
            ]
        },
        "akamai:index/gtmCidrmap:GtmCidrmap": {
            "description": "Use the `akamai.GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).\n\n CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined. \n \n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoCidrmap = new akamai.GtmCidrmap(\"demo_cidrmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other CIDR Blocks\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_cidrmap = akamai.GtmCidrmap(\"demoCidrmap\",\n    default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other CIDR Blocks\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoCidrmap = new Akamai.GtmCidrmap(\"demoCidrmap\", new Akamai.GtmCidrmapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmCidrmapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Other CIDR Blocks\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmCidrmap(ctx, \"demoCidrmap\", \u0026akamai.GtmCidrmapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmCidrmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other CIDR Blocks\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmCidrmap;\nimport com.pulumi.akamai.GtmCidrmapArgs;\nimport com.pulumi.akamai.inputs.GtmCidrmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoCidrmap = new GtmCidrmap(\"demoCidrmap\", GtmCidrmapArgs.builder()        \n            .defaultDatacenter(GtmCidrmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other CIDR Blocks\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoCidrmap:\n    type: akamai:GtmCidrmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other CIDR Blocks\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM CIDR Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#cidrmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the AS Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the AS Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmCidrmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                        },
                        "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                        "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the AS Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmCidrmap:GtmCidrmap"
                }
            ]
        },
        "akamai:index/gtmDatacenter:GtmDatacenter": {
            "description": "Use the `akamai.GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.\n\nGTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoDatacenter = new akamai.GtmDatacenter(\"demo_datacenter\", {\n    domain: \"demo_domain.akadns.net\",\n    nickname: \"demo_datacenter\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_datacenter = akamai.GtmDatacenter(\"demoDatacenter\",\n    domain=\"demo_domain.akadns.net\",\n    nickname=\"demo_datacenter\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoDatacenter = new Akamai.GtmDatacenter(\"demoDatacenter\", new Akamai.GtmDatacenterArgs\n        {\n            Domain = \"demo_domain.akadns.net\",\n            Nickname = \"demo_datacenter\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDatacenter(ctx, \"demoDatacenter\", \u0026akamai.GtmDatacenterArgs{\n\t\t\tDomain:   pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tNickname: pulumi.String(\"demo_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDatacenter;\nimport com.pulumi.akamai.GtmDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoDatacenter = new GtmDatacenter(\"demoDatacenter\", GtmDatacenterArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .nickname(\"demo_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoDatacenter:\n    type: akamai:GtmDatacenter\n    properties:\n      domain: demo_domain.akadns.net\n      nickname: demo_datacenter\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Data Center backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#datacenter) page.\n",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n* `ping_interval`\n* `ping_packet_size`\n* `score_penalty`\n* `servermonitor_liveness_count`\n* `servermonitor_load_count`\n* `servermonitor_pool`\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "scorePenalty": {
                    "type": "integer"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "virtual": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "datacenterId",
                "domain",
                "pingInterval",
                "pingPacketSize",
                "scorePenalty",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "virtual"
            ],
            "inputProperties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDatacenter resources.\n",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The name of the city where the data center is located.\n"
                    },
                    "cloneOf": {
                        "type": "integer",
                        "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                    },
                    "cloudServerHostHeaderOverride": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                    },
                    "cloudServerTargeting": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                    },
                    "continent": {
                        "type": "string",
                        "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                    },
                    "datacenterId": {
                        "type": "integer",
                        "description": "A unique identifier for an existing data center in the domain.\n* `ping_interval`\n* `ping_packet_size`\n* `score_penalty`\n* `servermonitor_liveness_count`\n* `servermonitor_load_count`\n* `servermonitor_pool`\n"
                    },
                    "defaultLoadObject": {
                        "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                        "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM domain name for the data center.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                    },
                    "nickname": {
                        "type": "string",
                        "description": "A descriptive label for the data center.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "scorePenalty": {
                        "type": "integer"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "stateOrProvince": {
                        "type": "string",
                        "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                    },
                    "virtual": {
                        "type": "boolean",
                        "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmDatacenter:GtmDatacenter"
                }
            ]
        },
        "akamai:index/gtmDomain:GtmDomain": {
            "description": "Use the `akamai.GtmDomain` resource to create, configure, and import a GTM Domain, which is a basic building block of a traffic management configuration.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demodomain = new akamai.GtmDomain(\"demodomain\", {\n    comment: \"some comment\",\n    contract: \"XXX\",\n    group: \"100\",\n    type: \"basic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemodomain = akamai.GtmDomain(\"demodomain\",\n    comment=\"some comment\",\n    contract=\"XXX\",\n    group=\"100\",\n    type=\"basic\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demodomain = new Akamai.GtmDomain(\"demodomain\", new Akamai.GtmDomainArgs\n        {\n            Comment = \"some comment\",\n            Contract = \"XXX\",\n            Group = \"100\",\n            Type = \"basic\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDomain(ctx, \"demodomain\", \u0026akamai.GtmDomainArgs{\n\t\t\tComment:  pulumi.String(\"some comment\"),\n\t\t\tContract: pulumi.String(\"XXX\"),\n\t\t\tGroup:    pulumi.String(\"100\"),\n\t\t\tType:     pulumi.String(\"basic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDomain;\nimport com.pulumi.akamai.GtmDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demodomain = new GtmDomain(\"demodomain\", GtmDomainArgs.builder()        \n            .comment(\"some comment\")\n            .contract(\"XXX\")\n            .group(100)\n            .type(\"basic\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demodomain:\n    type: akamai:GtmDomain\n    properties:\n      comment: some comment\n      contract: XXX\n      group: 100\n      type: basic\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Domain backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#domain) page.\n",
            "properties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultHealthMax": {
                    "type": "number"
                },
                "defaultHealthMultiplier": {
                    "type": "number"
                },
                "defaultHealthThreshold": {
                    "type": "number"
                },
                "defaultMaxUnreachablePenalty": {
                    "type": "integer"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "defaultUnreachableThreshold": {
                    "type": "number"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "mapUpdateInterval": {
                    "type": "integer"
                },
                "maxProperties": {
                    "type": "integer"
                },
                "maxResources": {
                    "type": "integer"
                },
                "maxTestTimeout": {
                    "type": "number"
                },
                "maxTtl": {
                    "type": "integer"
                },
                "minPingableRegionFraction": {
                    "type": "number"
                },
                "minTestInterval": {
                    "type": "integer"
                },
                "minTtl": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "roundRobinPrefix": {
                    "type": "string"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultHealthMax",
                "defaultHealthMultiplier",
                "defaultHealthThreshold",
                "defaultMaxUnreachablePenalty",
                "defaultUnreachableThreshold",
                "mapUpdateInterval",
                "maxProperties",
                "maxResources",
                "maxTestTimeout",
                "maxTtl",
                "minPingableRegionFraction",
                "minTestInterval",
                "minTtl",
                "name",
                "pingInterval",
                "pingPacketSize",
                "roundRobinPrefix",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "type"
            ],
            "inputProperties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDomain resources.\n",
                "properties": {
                    "cnameCoalescingEnabled": {
                        "type": "boolean",
                        "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "If creating a domain, the contract ID.\n"
                    },
                    "defaultErrorPenalty": {
                        "type": "integer",
                        "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                    },
                    "defaultHealthMax": {
                        "type": "number"
                    },
                    "defaultHealthMultiplier": {
                        "type": "number"
                    },
                    "defaultHealthThreshold": {
                        "type": "number"
                    },
                    "defaultMaxUnreachablePenalty": {
                        "type": "integer"
                    },
                    "defaultSslClientCertificate": {
                        "type": "string",
                        "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                    },
                    "defaultSslClientPrivateKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                    },
                    "defaultTimeoutPenalty": {
                        "type": "integer",
                        "description": "Specifies the timeout penalty score. Default is `25`.\n"
                    },
                    "defaultUnreachableThreshold": {
                        "type": "number"
                    },
                    "emailNotificationLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses to notify when a change is made to the domain.\n"
                    },
                    "endUserMappingEnabled": {
                        "type": "boolean",
                        "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "If creating a domain, the currently selected group ID.\n"
                    },
                    "loadFeedback": {
                        "type": "boolean",
                        "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                    },
                    "mapUpdateInterval": {
                        "type": "integer"
                    },
                    "maxProperties": {
                        "type": "integer"
                    },
                    "maxResources": {
                        "type": "integer"
                    },
                    "maxTestTimeout": {
                        "type": "number"
                    },
                    "maxTtl": {
                        "type": "integer"
                    },
                    "minPingableRegionFraction": {
                        "type": "number"
                    },
                    "minTestInterval": {
                        "type": "integer"
                    },
                    "minTtl": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS name for a collection of GTM Properties.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "roundRobinPrefix": {
                        "type": "string"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmDomain:GtmDomain"
                }
            ]
        },
        "akamai:index/gtmGeomap:GtmGeomap": {
            "description": "Use the `akamai.GtmGeomap` resource to create, configure, and import a GTM Geographic map. Geographic mapping lets you configure a property that returns a CNAME based on the geographic location of the request.\n\nYou can reuse maps for multiple properties or create new ones. To configure a property for geographic mapping, you need to define at least one geographic map for your domain. Each map needs at least two definitions. For example, you can have one definition that maps a set of countries to a specific data center, and a second definition that routes all other traffic.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoGeomap = new akamai.GtmGeomap(\"demo_geomap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Others\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_geomap = akamai.GtmGeomap(\"demoGeomap\",\n    default_datacenter=akamai.GtmGeomapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Others\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoGeomap = new Akamai.GtmGeomap(\"demoGeomap\", new Akamai.GtmGeomapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmGeomapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Others\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmGeomap(ctx, \"demoGeomap\", \u0026akamai.GtmGeomapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmGeomapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Others\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmGeomap;\nimport com.pulumi.akamai.GtmGeomapArgs;\nimport com.pulumi.akamai.inputs.GtmGeomapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoGeomap = new GtmGeomap(\"demoGeomap\", GtmGeomapArgs.builder()        \n            .defaultDatacenter(GtmGeomapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Others\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoGeomap:\n    type: akamai:GtmGeomap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Others\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Geographic Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#geographicmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmGeomap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                        },
                        "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                        "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the Geographic Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the Geographic map.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmGeomap:GtmGeomap"
                }
            ]
        },
        "akamai:index/gtmProperty:GtmProperty": {
            "description": "Use the `akamai.GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoProperty = new akamai.GtmProperty(\"demo_property\", {\n    domain: \"demo_domain.akadns.net\",\n    handoutLimit: 5,\n    handoutMode: \"normal\",\n    scoreAggregationType: \"median\",\n    trafficTargets: [{\n        datacenterId: 3131,\n    }],\n    type: \"weighted-round-robin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_property = akamai.GtmProperty(\"demoProperty\",\n    domain=\"demo_domain.akadns.net\",\n    handout_limit=5,\n    handout_mode=\"normal\",\n    score_aggregation_type=\"median\",\n    traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(\n        datacenter_id=3131,\n    )],\n    type=\"weighted-round-robin\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoProperty = new Akamai.GtmProperty(\"demoProperty\", new Akamai.GtmPropertyArgs\n        {\n            Domain = \"demo_domain.akadns.net\",\n            HandoutLimit = 5,\n            HandoutMode = \"normal\",\n            ScoreAggregationType = \"median\",\n            TrafficTargets = \n            {\n                new Akamai.Inputs.GtmPropertyTrafficTargetArgs\n                {\n                    DatacenterId = 3131,\n                },\n            },\n            Type = \"weighted-round-robin\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmProperty(ctx, \"demoProperty\", \u0026akamai.GtmPropertyArgs{\n\t\t\tDomain:               pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tHandoutLimit:         pulumi.Int(5),\n\t\t\tHandoutMode:          pulumi.String(\"normal\"),\n\t\t\tScoreAggregationType: pulumi.String(\"median\"),\n\t\t\tTrafficTargets: GtmPropertyTrafficTargetArray{\n\t\t\t\t\u0026GtmPropertyTrafficTargetArgs{\n\t\t\t\t\tDatacenterId: pulumi.Int(3131),\n\t\t\t\t},\n\t\t\t},\n\t\t\tType: pulumi.String(\"weighted-round-robin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmProperty;\nimport com.pulumi.akamai.GtmPropertyArgs;\nimport com.pulumi.akamai.inputs.GtmPropertyTrafficTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoProperty = new GtmProperty(\"demoProperty\", GtmPropertyArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .handoutLimit(5)\n            .handoutMode(\"normal\")\n            .scoreAggregationType(\"median\")\n            .trafficTargets(GtmPropertyTrafficTargetArgs.builder()\n                .datacenterId(3131)\n                .build())\n            .type(\"weighted-round-robin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoProperty:\n    type: akamai:GtmProperty\n    properties:\n      domain: demo_domain.akadns.net\n      handoutLimit: 5\n      handoutMode: normal\n      scoreAggregationType: median\n      trafficTargets:\n        - datacenterId: 3131\n      type: weighted-round-robin\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Property backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#property) page.\n",
            "properties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                },
                "weightedHashBitsForIpv4": {
                    "type": "integer"
                },
                "weightedHashBitsForIpv6": {
                    "type": "integer"
                }
            },
            "required": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "name",
                "scoreAggregationType",
                "type",
                "weightedHashBitsForIpv4",
                "weightedHashBitsForIpv6"
            ],
            "inputProperties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "scoreAggregationType",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmProperty resources.\n",
                "properties": {
                    "backupCname": {
                        "type": "string",
                        "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                    },
                    "backupIp": {
                        "type": "string",
                        "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                    },
                    "balanceByDownloadScore": {
                        "type": "boolean",
                        "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Indicates the fully qualified name aliased to a particular property.\n"
                    },
                    "comments": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this Property.\n"
                    },
                    "dynamicTtl": {
                        "type": "integer",
                        "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                    },
                    "failbackDelay": {
                        "type": "integer",
                        "description": "Specifies the failback delay in seconds.\n"
                    },
                    "failoverDelay": {
                        "type": "integer",
                        "description": "Specifies the failover delay in seconds.\n"
                    },
                    "ghostDemandReporting": {
                        "type": "boolean",
                        "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                    },
                    "handoutLimit": {
                        "type": "integer",
                        "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                    },
                    "handoutMode": {
                        "type": "string",
                        "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                    },
                    "healthMax": {
                        "type": "number",
                        "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                    },
                    "healthMultiplier": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "healthThreshold": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "ipv6": {
                        "type": "boolean",
                        "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                    },
                    "livenessTests": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                        },
                        "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                    },
                    "mapName": {
                        "type": "string",
                        "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                    },
                    "maxUnreachablePenalty": {
                        "type": "integer",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                    },
                    "minLiveFraction": {
                        "type": "number",
                        "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of HTTP header.\n"
                    },
                    "scoreAggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                    },
                    "staticRrSets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                        },
                        "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                    },
                    "staticTtl": {
                        "type": "integer"
                    },
                    "stickinessBonusConstant": {
                        "type": "integer",
                        "description": "Specifies a constant used to configure data center affinity.\n"
                    },
                    "stickinessBonusPercentage": {
                        "type": "integer",
                        "description": "Specifies a percentage used to configure data center affinity.\n"
                    },
                    "trafficTargets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                        },
                        "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The record type.\n"
                    },
                    "unreachableThreshold": {
                        "type": "number",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                    },
                    "useComputedTargets": {
                        "type": "boolean",
                        "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    },
                    "weightedHashBitsForIpv4": {
                        "type": "integer"
                    },
                    "weightedHashBitsForIpv6": {
                        "type": "integer"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmProperty:GtmProperty"
                }
            ]
        },
        "akamai:index/gtmResource:GtmResource": {
            "description": "The `akamai.GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second. \n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:\n`existing_resource_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoResource = new akamai.GtmResource(\"demo_resource\", {\n    aggregationType: \"latest\",\n    domain: \"demo_domain.akadns.net\",\n    type: \"XML load object via HTTP\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_resource = akamai.GtmResource(\"demoResource\",\n    aggregation_type=\"latest\",\n    domain=\"demo_domain.akadns.net\",\n    type=\"XML load object via HTTP\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoResource = new Akamai.GtmResource(\"demoResource\", new Akamai.GtmResourceArgs\n        {\n            AggregationType = \"latest\",\n            Domain = \"demo_domain.akadns.net\",\n            Type = \"XML load object via HTTP\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmResource(ctx, \"demoResource\", \u0026akamai.GtmResourceArgs{\n\t\t\tAggregationType: pulumi.String(\"latest\"),\n\t\t\tDomain:          pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tType:            pulumi.String(\"XML load object via HTTP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmResource;\nimport com.pulumi.akamai.GtmResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoResource = new GtmResource(\"demoResource\", GtmResourceArgs.builder()        \n            .aggregationType(\"latest\")\n            .domain(\"demo_domain.akadns.net\")\n            .type(\"XML load object via HTTP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoResource:\n    type: akamai:GtmResource\n    properties:\n      aggregationType: latest\n      domain: demo_domain.akadns.net\n      type: XML load object via HTTP\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Resource backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#resource) page.\n",
            "properties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "aggregationType",
                "domain",
                "name",
                "type"
            ],
            "inputProperties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "aggregationType",
                "domain",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmResource resources.\n",
                "properties": {
                    "aggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                    },
                    "constrainedProperty": {
                        "type": "string",
                        "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                    },
                    "decayRate": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A descriptive note to help you track what the resource constrains.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this property.\n"
                    },
                    "hostHeader": {
                        "type": "string",
                        "description": "Optionally specifies the host header used when fetching the load object.\n"
                    },
                    "leaderString": {
                        "type": "string",
                        "description": "Specifies the text that comes before the `load_object`.\n"
                    },
                    "leastSquaresDecay": {
                        "type": "number",
                        "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number"
                    },
                    "maxUMultiplicativeIncrement": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the GTM resource.\n"
                    },
                    "resourceInstances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                        },
                        "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                    },
                    "upperBound": {
                        "type": "integer",
                        "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmResource:GtmResource"
                }
            ]
        },
        "akamai:index/iamBlockedUserProperties:IamBlockedUserProperties": {
            "description": "Use the `akamai.IamBlockedUserProperties` resource to remove or grant access to properties. Administrators can block a user's access to any property, overriding any available role already assigned to that user.\n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamBlockedUserProperties(\"example\", {\n    blockedProperties: [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ],\n    groupId: 12345,\n    identityId: \"A-B-123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamBlockedUserProperties(\"example\",\n    blocked_properties=[\n        1,\n        2,\n        3,\n        4,\n        5,\n    ],\n    group_id=12345,\n    identity_id=\"A-B-123456\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.IamBlockedUserProperties(\"example\", new Akamai.IamBlockedUserPropertiesArgs\n        {\n            BlockedProperties = \n            {\n                1,\n                2,\n                3,\n                4,\n                5,\n            },\n            GroupId = 12345,\n            IdentityId = \"A-B-123456\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamBlockedUserProperties(ctx, \"example\", \u0026akamai.IamBlockedUserPropertiesArgs{\n\t\t\tBlockedProperties: pulumi.IntArray{\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(2),\n\t\t\t\tpulumi.Int(3),\n\t\t\t\tpulumi.Int(4),\n\t\t\t\tpulumi.Int(5),\n\t\t\t},\n\t\t\tGroupId:    pulumi.Int(12345),\n\t\t\tIdentityId: pulumi.String(\"A-B-123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamBlockedUserProperties;\nimport com.pulumi.akamai.IamBlockedUserPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamBlockedUserProperties(\"example\", IamBlockedUserPropertiesArgs.builder()        \n            .blockedProperties(            \n                1,\n                2,\n                3,\n                4,\n                5)\n            .groupId(12345)\n            .identityId(\"A-B-123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamBlockedUserProperties\n    properties:\n      blockedProperties:\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n      groupId: 12345\n      identityId: A-B-123456\n```\n\n## Attributes reference\n\nThis resource doesn't return any attributes.\n",
            "properties": {
                "blockedProperties": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "A unique identifier for a group. Each identifier must be an integer.\n"
                },
                "identityId": {
                    "type": "string",
                    "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                }
            },
            "required": [
                "blockedProperties",
                "groupId",
                "identityId"
            ],
            "inputProperties": {
                "blockedProperties": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "A unique identifier for a group. Each identifier must be an integer.\n",
                    "willReplaceOnChanges": true
                },
                "identityId": {
                    "type": "string",
                    "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                }
            },
            "requiredInputs": [
                "blockedProperties",
                "groupId",
                "identityId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamBlockedUserProperties resources.\n",
                "properties": {
                    "blockedProperties": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "A unique identifier for a group. Each identifier must be an integer.\n",
                        "willReplaceOnChanges": true
                    },
                    "identityId": {
                        "type": "string",
                        "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamGroup:IamGroup": {
            "description": "Use the `akamai.IamGroup` resource to list details about groups. Groups are organizational containers for the objects you use.  Groups can contain other groups, primary objects like properties, and secondary objects like edge hostnames or content provider (CP) codes. \n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamGroup(\"example\", {\n    parentGroupId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamGroup(\"example\", parent_group_id=12345)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.IamGroup(\"example\", new Akamai.IamGroupArgs\n        {\n            ParentGroupId = 12345,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamGroup(ctx, \"example\", \u0026akamai.IamGroupArgs{\n\t\t\tParentGroupId: pulumi.Int(12345),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamGroup;\nimport com.pulumi.akamai.IamGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamGroup(\"example\", IamGroupArgs.builder()        \n            .parentGroupId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamGroup\n    properties:\n      parentGroupId: 12345\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `sub_groups` - Sub-groups that are related to this group. Each identifier must be an integer.\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Human readable name for a group.\n"
                },
                "parentGroupId": {
                    "type": "integer",
                    "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                },
                "subGroups": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Subgroups IDs\n"
                }
            },
            "required": [
                "name",
                "parentGroupId",
                "subGroups"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Human readable name for a group.\n"
                },
                "parentGroupId": {
                    "type": "integer",
                    "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                }
            },
            "requiredInputs": [
                "parentGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamGroup resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Human readable name for a group.\n"
                    },
                    "parentGroupId": {
                        "type": "integer",
                        "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                    },
                    "subGroups": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Subgroups IDs\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamRole:IamRole": {
            "description": "Use the `akamai.IamRole` resource to list and create roles for users. Roles are lists of permissions that are explicitly tied to both a user and a group. Users need roles to act on objects in a group. \n\n## Basic usage\n\nThis example returns information on available roles:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamRole(\"example\", {\n    description: \"This role will allow you to view\",\n    grantedRoles: 2051,\n    type: \"custom\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamRole(\"example\",\n    description=\"This role will allow you to view\",\n    granted_roles=2051,\n    type=\"custom\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.IamRole(\"example\", new Akamai.IamRoleArgs\n        {\n            Description = \"This role will allow you to view\",\n            GrantedRoles = 2051,\n            Type = \"custom\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamRole(ctx, \"example\", \u0026akamai.IamRoleArgs{\n\t\t\tDescription:  pulumi.String(\"This role will allow you to view\"),\n\t\t\tGrantedRoles: pulumi.IntArray(2051),\n\t\t\tType:         pulumi.String(\"custom\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamRole;\nimport com.pulumi.akamai.IamRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamRole(\"example\", IamRoleArgs.builder()        \n            .description(\"This role will allow you to view\")\n            .grantedRoles(2051)\n            .type(\"custom\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamRole\n    properties:\n      description: This role will allow you to view\n      grantedRoles: 2051\n      type: custom\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `type` - The type indicates whether the role is `standard`, provided by Akamai, or `custom` for the account.\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for a role.\n"
                },
                "grantedRoles": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name you supply for a role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                }
            },
            "required": [
                "description",
                "grantedRoles",
                "name",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description for a role.\n"
                },
                "grantedRoles": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name you supply for a role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                }
            },
            "requiredInputs": [
                "description",
                "grantedRoles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamRole resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description for a role.\n"
                    },
                    "grantedRoles": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name you supply for a role.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamUser:IamUser": {
            "description": "The `akamai.IamUser` resource represents a user on the Akamai platform. \n\n## Basic usage\n\nThis example shows how to set up a user:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst exampleUser = new akamai.IamUser(\"example_user\", {\n    authGrantsJson: \"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n    country: \"Grenada\",\n    email: \"jperez@example.com\",\n    enableTfa: false,\n    firstName: \"Juan\",\n    lastName: \"Perez\",\n    phone: \"+1 206-555-0100\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample_user = akamai.IamUser(\"exampleUser\",\n    auth_grants_json=\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n    country=\"Grenada\",\n    email=\"jperez@example.com\",\n    enable_tfa=False,\n    first_name=\"Juan\",\n    last_name=\"Perez\",\n    phone=\"+1 206-555-0100\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleUser = new Akamai.IamUser(\"exampleUser\", new Akamai.IamUserArgs\n        {\n            AuthGrantsJson = \"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n            Country = \"Grenada\",\n            Email = \"jperez@example.com\",\n            EnableTfa = false,\n            FirstName = \"Juan\",\n            LastName = \"Perez\",\n            Phone = \"+1 206-555-0100\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamUser(ctx, \"exampleUser\", \u0026akamai.IamUserArgs{\n\t\t\tAuthGrantsJson: pulumi.String(\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\"),\n\t\t\tCountry:        pulumi.String(\"Grenada\"),\n\t\t\tEmail:          pulumi.String(\"jperez@example.com\"),\n\t\t\tEnableTfa:      pulumi.Bool(false),\n\t\t\tFirstName:      pulumi.String(\"Juan\"),\n\t\t\tLastName:       pulumi.String(\"Perez\"),\n\t\t\tPhone:          pulumi.String(\"+1 206-555-0100\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamUser;\nimport com.pulumi.akamai.IamUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleUser = new IamUser(\"exampleUser\", IamUserArgs.builder()        \n            .authGrantsJson(\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\")\n            .country(\"Grenada\")\n            .email(\"jperez@example.com\")\n            .enableTfa(false)\n            .firstName(\"Juan\")\n            .lastName(\"Perez\")\n            .phone(\"+1 206-555-0100\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUser:\n    type: akamai:IamUser\n    properties:\n      authGrantsJson: '[{\"groupId\":18451,\"roleId\":14},{\"groupId\":18453,\"roleId\":13}]'\n      country: Grenada\n      email: jperez@example.com\n      enableTfa: false\n      firstName: Juan\n      lastName: Perez\n      phone: +1 206-555-0100\n```\n\n## Attributes reference\n\nThis resource returns these attributes:\n\n* `session_timeout` - The number of seconds it takes for the user's session to time out if there hasn't been any activity.\n* `user_name` - A user's `loginId`. Typically, a user's email address.\n* `is_locked` - The user's lock status.\n* `last_login` - ISO 8601 timestamp indicating when the user last logged in.\n* `password_expired_after` - The date a user's password expires.\n* `tfa_configured` - Indicates whether two-factor authentication is configured.\n* `email_update_pending` - Indicates whether email update is pending.\n* `lock` - (Optional) Flag to block as user account.\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The user's street address.\n"
                },
                "authGrantsJson": {
                    "type": "string",
                    "description": "A user's per-group role assignments, in JSON form.\n"
                },
                "city": {
                    "type": "string",
                    "description": "The user's city.\n"
                },
                "contactType": {
                    "type": "string",
                    "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                },
                "country": {
                    "type": "string",
                    "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email address.\n"
                },
                "emailUpdatePending": {
                    "type": "boolean",
                    "description": "Indicates whether email update is pending\n"
                },
                "enableTfa": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is allowed.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "isLocked": {
                    "type": "boolean",
                    "description": "The user's lock status.\n",
                    "deprecationMessage": "The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead"
                },
                "jobTitle": {
                    "type": "string",
                    "description": "The user's position at your company\n"
                },
                "lastLogin": {
                    "type": "string",
                    "description": "ISO 8601 timestamp indicating when the user last logged in\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "lock": {
                    "type": "boolean",
                    "description": "Flag to block a user account\n"
                },
                "mobilePhone": {
                    "type": "string",
                    "description": "The user's mobile phone number.\n"
                },
                "passwordExpiredAfter": {
                    "type": "string",
                    "description": "The date a user's password expires\n"
                },
                "phone": {
                    "type": "string",
                    "description": "The user's main phone number.\n"
                },
                "preferredLanguage": {
                    "type": "string",
                    "description": "The value can be any that are available from the view-languages operation\n"
                },
                "secondaryEmail": {
                    "type": "string",
                    "description": "The user's secondary email address.\n"
                },
                "sessionTimeout": {
                    "type": "integer",
                    "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                },
                "state": {
                    "type": "string",
                    "description": "The user's state.\n"
                },
                "tfaConfigured": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is configured\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                },
                "userName": {
                    "type": "string",
                    "description": "A user's `loginId`. Typically, a user's email address\n"
                },
                "zipCode": {
                    "type": "string",
                    "description": "The user's five-digit ZIP code.\n"
                }
            },
            "required": [
                "address",
                "authGrantsJson",
                "contactType",
                "country",
                "email",
                "emailUpdatePending",
                "enableTfa",
                "firstName",
                "isLocked",
                "lastLogin",
                "lastName",
                "passwordExpiredAfter",
                "phone",
                "preferredLanguage",
                "sessionTimeout",
                "tfaConfigured",
                "timeZone",
                "userName"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The user's street address.\n"
                },
                "authGrantsJson": {
                    "type": "string",
                    "description": "A user's per-group role assignments, in JSON form.\n"
                },
                "city": {
                    "type": "string",
                    "description": "The user's city.\n"
                },
                "contactType": {
                    "type": "string",
                    "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                },
                "country": {
                    "type": "string",
                    "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email address.\n"
                },
                "enableTfa": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is allowed.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "jobTitle": {
                    "type": "string",
                    "description": "The user's position at your company\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "lock": {
                    "type": "boolean",
                    "description": "Flag to block a user account\n"
                },
                "mobilePhone": {
                    "type": "string",
                    "description": "The user's mobile phone number.\n"
                },
                "phone": {
                    "type": "string",
                    "description": "The user's main phone number.\n"
                },
                "preferredLanguage": {
                    "type": "string",
                    "description": "The value can be any that are available from the view-languages operation\n"
                },
                "secondaryEmail": {
                    "type": "string",
                    "description": "The user's secondary email address.\n"
                },
                "sessionTimeout": {
                    "type": "integer",
                    "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                },
                "state": {
                    "type": "string",
                    "description": "The user's state.\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                },
                "zipCode": {
                    "type": "string",
                    "description": "The user's five-digit ZIP code.\n"
                }
            },
            "requiredInputs": [
                "authGrantsJson",
                "country",
                "email",
                "enableTfa",
                "firstName",
                "lastName",
                "phone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamUser resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The user's street address.\n"
                    },
                    "authGrantsJson": {
                        "type": "string",
                        "description": "A user's per-group role assignments, in JSON form.\n"
                    },
                    "city": {
                        "type": "string",
                        "description": "The user's city.\n"
                    },
                    "contactType": {
                        "type": "string",
                        "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The user's email address.\n"
                    },
                    "emailUpdatePending": {
                        "type": "boolean",
                        "description": "Indicates whether email update is pending\n"
                    },
                    "enableTfa": {
                        "type": "boolean",
                        "description": "Indicates whether two-factor authentication is allowed.\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The user's first name.\n"
                    },
                    "isLocked": {
                        "type": "boolean",
                        "description": "The user's lock status.\n",
                        "deprecationMessage": "The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead"
                    },
                    "jobTitle": {
                        "type": "string",
                        "description": "The user's position at your company\n"
                    },
                    "lastLogin": {
                        "type": "string",
                        "description": "ISO 8601 timestamp indicating when the user last logged in\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "The user's last name.\n"
                    },
                    "lock": {
                        "type": "boolean",
                        "description": "Flag to block a user account\n"
                    },
                    "mobilePhone": {
                        "type": "string",
                        "description": "The user's mobile phone number.\n"
                    },
                    "passwordExpiredAfter": {
                        "type": "string",
                        "description": "The date a user's password expires\n"
                    },
                    "phone": {
                        "type": "string",
                        "description": "The user's main phone number.\n"
                    },
                    "preferredLanguage": {
                        "type": "string",
                        "description": "The value can be any that are available from the view-languages operation\n"
                    },
                    "secondaryEmail": {
                        "type": "string",
                        "description": "The user's secondary email address.\n"
                    },
                    "sessionTimeout": {
                        "type": "integer",
                        "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The user's state.\n"
                    },
                    "tfaConfigured": {
                        "type": "boolean",
                        "description": "Indicates whether two-factor authentication is configured\n"
                    },
                    "timeZone": {
                        "type": "string",
                        "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "A user's `loginId`. Typically, a user's email address\n"
                    },
                    "zipCode": {
                        "type": "string",
                        "description": "The user's five-digit ZIP code.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkList:NetworkList": {
            "description": "Use the `akamai.NetworkList` resource to create a network list, or to modify an existing list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkList = new akamai.NetworkList(\"networkList\", {\n    type: \"IP\",\n    description: \"network list description\",\n    lists: _var.list,\n    mode: \"APPEND\",\n    contractId: \"ABC-123\",\n    groupId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_list = akamai.NetworkList(\"networkList\",\n    type=\"IP\",\n    description=\"network list description\",\n    lists=var[\"list\"],\n    mode=\"APPEND\",\n    contract_id=\"ABC-123\",\n    group_id=12345)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var networkList = new Akamai.NetworkList(\"networkList\", new Akamai.NetworkListArgs\n        {\n            Type = \"IP\",\n            Description = \"network list description\",\n            Lists = @var.List,\n            Mode = \"APPEND\",\n            ContractId = \"ABC-123\",\n            GroupId = 12345,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewNetworkList(ctx, \"networkList\", \u0026akamai.NetworkListArgs{\n\t\t\tType:        pulumi.String(\"IP\"),\n\t\t\tDescription: pulumi.String(\"network list description\"),\n\t\t\tLists:       pulumi.Any(_var.List),\n\t\t\tMode:        pulumi.String(\"APPEND\"),\n\t\t\tContractId:  pulumi.String(\"ABC-123\"),\n\t\t\tGroupId:     pulumi.Int(12345),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.NetworkList;\nimport com.pulumi.akamai.NetworkListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var networkList = new NetworkList(\"networkList\", NetworkListArgs.builder()        \n            .type(\"IP\")\n            .description(\"network list description\")\n            .lists(var_.list())\n            .mode(\"APPEND\")\n            .contractId(\"ABC-123\")\n            .groupId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  networkList:\n    type: akamai:NetworkList\n    properties:\n      type: IP\n      description: network list description\n      lists: ${var.list}\n      mode: APPEND\n      contractId: ABC-123\n      groupId: 12345\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "contractId": {
                    "type": "string",
                    "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ": (Optional) A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list.\n"
                },
                "syncPoint": {
                    "type": "integer",
                    "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                },
                "uniqueid": {
                    "type": "string",
                    "description": "unique ID\n"
                }
            },
            "required": [
                "description",
                "mode",
                "name",
                "networkListId",
                "syncPoint",
                "type",
                "uniqueid"
            ],
            "inputProperties": {
                "contractId": {
                    "type": "string",
                    "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ": (Optional) A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                }
            },
            "requiredInputs": [
                "description",
                "mode",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkList resources.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description to be assigned to the network list.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ": (Optional) A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to be assigned to the network list.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of the network list.\n"
                    },
                    "syncPoint": {
                        "type": "integer",
                        "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                    },
                    "uniqueid": {
                        "type": "string",
                        "description": "unique ID\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListActivations:NetworkListActivations": {
            "description": "Use the `akamai.NetworkListActivations` resource to activate a network list in either the STAGING or PRODUCTION\nenvironment.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListsFilter = akamai.getNetworkLists({\n    name: _var.network_list,\n});\nconst activation = new akamai.NetworkListActivations(\"activation\", {\n    networkListId: networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.lists?[0]),\n    network: \"STAGING\",\n    notes: \"TEST Notes\",\n    notificationEmails: [\"user@example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_lists_filter = akamai.get_network_lists(name=var[\"network_list\"])\nactivation = akamai.NetworkListActivations(\"activation\",\n    network_list_id=network_lists_filter.lists[0],\n    network=\"STAGING\",\n    notes=\"TEST Notes\",\n    notification_emails=[\"user@example.com\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var networkListsFilter = Output.Create(Akamai.GetNetworkLists.InvokeAsync(new Akamai.GetNetworkListsArgs\n        {\n            Name = @var.Network_list,\n        }));\n        var activation = new Akamai.NetworkListActivations(\"activation\", new Akamai.NetworkListActivationsArgs\n        {\n            NetworkListId = networkListsFilter.Apply(networkListsFilter =\u003e networkListsFilter.Lists?[0]),\n            Network = \"STAGING\",\n            Notes = \"TEST Notes\",\n            NotificationEmails = \n            {\n                \"user@example.com\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkListsFilter, err := akamai.GetNetworkLists(ctx, \u0026GetNetworkListsArgs{\n\t\t\tName: pulumi.StringRef(_var.Network_list),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewNetworkListActivations(ctx, \"activation\", \u0026akamai.NetworkListActivationsArgs{\n\t\t\tNetworkListId: pulumi.String(networkListsFilter.Lists[0]),\n\t\t\tNetwork:       pulumi.String(\"STAGING\"),\n\t\t\tNotes:         pulumi.String(\"TEST Notes\"),\n\t\t\tNotificationEmails: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user@example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetNetworkListsArgs;\nimport com.pulumi.akamai.NetworkListActivations;\nimport com.pulumi.akamai.NetworkListActivationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()\n            .name(var_.network_list())\n            .build());\n\n        var activation = new NetworkListActivations(\"activation\", NetworkListActivationsArgs.builder()        \n            .networkListId(networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()[0]))\n            .network(\"STAGING\")\n            .notes(\"TEST Notes\")\n            .notificationEmails(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  activation:\n    type: akamai:NetworkListActivations\n    properties:\n      networkListId: ${networkListsFilter.lists[0]}\n      network: STAGING\n      notes: TEST Notes\n      notificationEmails:\n        - user@example.com\nvariables:\n  networkListsFilter:\n    Fn::Invoke:\n      Function: akamai:getNetworkLists\n      Arguments:\n        name: ${var.network_list}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activate": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"activate\" has been deprecated."
                },
                "network": {
                    "type": "string",
                    "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list to be activated\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A comment describing the activation.\n"
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network\nlist was not activated.\n"
                }
            },
            "required": [
                "networkListId",
                "notificationEmails",
                "status"
            ],
            "inputProperties": {
                "activate": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"activate\" has been deprecated."
                },
                "network": {
                    "type": "string",
                    "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list to be activated\n",
                    "willReplaceOnChanges": true
                },
                "notes": {
                    "type": "string",
                    "description": "A comment describing the activation.\n"
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                }
            },
            "requiredInputs": [
                "networkListId",
                "notificationEmails"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListActivations resources.\n",
                "properties": {
                    "activate": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"activate\" has been deprecated."
                    },
                    "network": {
                        "type": "string",
                        "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of the network list to be activated\n",
                        "willReplaceOnChanges": true
                    },
                    "notes": {
                        "type": "string",
                        "description": "A comment describing the activation.\n"
                    },
                    "notificationEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network\nlist was not activated.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListDescription:NetworkListDescription": {
            "description": "Use the `akamai.NetworkListDescription` resource to update the name or description of an existing network list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListDescription = new akamai.NetworkListDescription(\"networkListDescription\", {\n    networkListId: _var.network_list_id,\n    description: \"Test network list updated description\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_list_description = akamai.NetworkListDescription(\"networkListDescription\",\n    network_list_id=var[\"network_list_id\"],\n    description=\"Test network list updated description\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var networkListDescription = new Akamai.NetworkListDescription(\"networkListDescription\", new Akamai.NetworkListDescriptionArgs\n        {\n            NetworkListId = @var.Network_list_id,\n            Description = \"Test network list updated description\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewNetworkListDescription(ctx, \"networkListDescription\", \u0026akamai.NetworkListDescriptionArgs{\n\t\t\tNetworkListId: pulumi.Any(_var.Network_list_id),\n\t\t\tDescription:   pulumi.String(\"Test network list updated description\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.NetworkListDescription;\nimport com.pulumi.akamai.NetworkListDescriptionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var networkListDescription = new NetworkListDescription(\"networkListDescription\", NetworkListDescriptionArgs.builder()        \n            .networkListId(var_.network_list_id())\n            .description(\"Test network list updated description\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  networkListDescription:\n    type: akamai:NetworkListDescription\n    properties:\n      networkListId: ${var.network_list_id}\n      description: Test network list updated description\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The unique ID of the network list to use.\n"
                }
            },
            "required": [
                "description",
                "name",
                "networkListId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The unique ID of the network list to use.\n"
                }
            },
            "requiredInputs": [
                "description",
                "networkListId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListDescription resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description to be assigned to the network list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to be assigned to the network list.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The unique ID of the network list to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListSubscription:NetworkListSubscription": {
            "description": "Use the `akamai.NetworkListSubscription` resource to specify a set of email addresses to be notified of changes to any\nof a set of network lists.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListsFilter = akamai.getNetworkLists({\n    name: _var.network_list,\n});\nconst subscribe = new akamai.NetworkListSubscription(\"subscribe\", {\n    networkLists: networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.lists),\n    recipients: [\"user@example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_lists_filter = akamai.get_network_lists(name=var[\"network_list\"])\nsubscribe = akamai.NetworkListSubscription(\"subscribe\",\n    network_lists=network_lists_filter.lists,\n    recipients=[\"user@example.com\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var networkListsFilter = Output.Create(Akamai.GetNetworkLists.InvokeAsync(new Akamai.GetNetworkListsArgs\n        {\n            Name = @var.Network_list,\n        }));\n        var subscribe = new Akamai.NetworkListSubscription(\"subscribe\", new Akamai.NetworkListSubscriptionArgs\n        {\n            NetworkLists = networkListsFilter.Apply(networkListsFilter =\u003e networkListsFilter.Lists),\n            Recipients = \n            {\n                \"user@example.com\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkListsFilter, err := akamai.GetNetworkLists(ctx, \u0026GetNetworkListsArgs{\n\t\t\tName: pulumi.StringRef(_var.Network_list),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewNetworkListSubscription(ctx, \"subscribe\", \u0026akamai.NetworkListSubscriptionArgs{\n\t\t\tNetworkLists: interface{}(networkListsFilter.Lists),\n\t\t\tRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user@example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetNetworkListsArgs;\nimport com.pulumi.akamai.NetworkListSubscription;\nimport com.pulumi.akamai.NetworkListSubscriptionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()\n            .name(var_.network_list())\n            .build());\n\n        var subscribe = new NetworkListSubscription(\"subscribe\", NetworkListSubscriptionArgs.builder()        \n            .networkLists(networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()))\n            .recipients(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  subscribe:\n    type: akamai:NetworkListSubscription\n    properties:\n      networkLists: ${networkListsFilter.lists}\n      recipients:\n        - user@example.com\nvariables:\n  networkListsFilter:\n    Fn::Invoke:\n      Function: akamai:getNetworkLists\n      Arguments:\n        name: ${var.network_list}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "networkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                }
            },
            "required": [
                "networkLists",
                "recipients"
            ],
            "inputProperties": {
                "networkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                }
            },
            "requiredInputs": [
                "networkLists",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListSubscription resources.\n",
                "properties": {
                    "networkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                    },
                    "recipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/property:Property": {
            "description": "The `akamai.Property` resource represents an Akamai property configuration.\nThis resource lets you to create, update, and activate properties on the\nAkamai platform.\n\nAkamai's edge network caches your web assets near to servers that request them.\nA property provides the main way to control how edge servers respond to various\nkinds of requests for those assets. Properties apply rules to a set of hostnames,\nand you can only apply one property at a time to any given hostname. Each property\nis assigned to a product, which determines which behaviors you can use. Each\nproperty's default rule needs a valid content provider (CP) code assigned to bill\nand report for the service.\n\n\u003e **Note** In version 0.10 and earlier of this resource, it also controlled content provider (CP) codes, origin settings, rules, and hostname associations. Starting with version 1.0.0, this logic is broken out into individual resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: [\n        {\n            cnameFrom: \"example.com\",\n            cnameTo: \"example.com.edgekey.net\",\n            certProvisioningType: \"DEFAULT\",\n        },\n        {\n            cnameFrom: \"www.example.com\",\n            cnameTo: \"example.com.edgesuite.net\",\n            certProvisioningType: \"CPS_MANAGED\",\n        },\n    ],\n    ruleFormat: \"v2020-03-04\",\n    rules: data.akamai_property_rules_template.example.json,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames=[\n        akamai.PropertyHostnameArgs(\n            cname_from=\"example.com\",\n            cname_to=\"example.com.edgekey.net\",\n            cert_provisioning_type=\"DEFAULT\",\n        ),\n        akamai.PropertyHostnameArgs(\n            cname_from=\"www.example.com\",\n            cname_to=\"example.com.edgesuite.net\",\n            cert_provisioning_type=\"CPS_MANAGED\",\n        ),\n    ],\n    rule_format=\"v2020-03-04\",\n    rules=data[\"akamai_property_rules_template\"][\"example\"][\"json\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.Property(\"example\", new Akamai.PropertyArgs\n        {\n            ProductId = \"prd_SPM\",\n            ContractId = @var.Contractid,\n            GroupId = @var.Groupid,\n            Hostnames = \n            {\n                new Akamai.Inputs.PropertyHostnameArgs\n                {\n                    CnameFrom = \"example.com\",\n                    CnameTo = \"example.com.edgekey.net\",\n                    CertProvisioningType = \"DEFAULT\",\n                },\n                new Akamai.Inputs.PropertyHostnameArgs\n                {\n                    CnameFrom = \"www.example.com\",\n                    CnameTo = \"example.com.edgesuite.net\",\n                    CertProvisioningType = \"CPS_MANAGED\",\n                },\n            },\n            RuleFormat = \"v2020-03-04\",\n            Rules = data.Akamai_property_rules_template.Example.Json,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: PropertyHostnameArray{\n\t\t\t\t\u0026PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgekey.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"DEFAULT\"),\n\t\t\t\t},\n\t\t\t\t\u0026PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"www.example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgesuite.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"CPS_MANAGED\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      pulumi.Any(data.Akamai_property_rules_template.Example.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.inputs.PropertyHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(            \n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"example.com\")\n                    .cnameTo(\"example.com.edgekey.net\")\n                    .certProvisioningType(\"DEFAULT\")\n                    .build(),\n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"www.example.com\")\n                    .cnameTo(\"example.com.edgesuite.net\")\n                    .certProvisioningType(\"CPS_MANAGED\")\n                    .build())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(data.akamai_property_rules_template().example().json())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        - cnameFrom: example.com\n          cnameTo: example.com.edgekey.net\n          certProvisioningType: DEFAULT\n        - cnameFrom: www.example.com\n          cnameTo: example.com.edgesuite.net\n          certProvisioningType: CPS_MANAGED\n      ruleFormat: v2020-03-04\n      rules: ${data.akamai_property_rules_template.example.json}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic Usagehcl resource \"akamai_property\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import the latest Akamai property version by using either the `property_id` or a comma-delimited string of the property, contract, and group IDs. You'll need to enter the string of IDs if the property belongs to multiple groups or contracts. If using the string of IDs, you need to enter them in this order`property_id,contract_id,group_id` To import a specific property version, pass additional parameters, either* `LATEST` to import the latest version of the property, regardless of whether it's active or not. This works the same as providing just the `property_id` or a string of the property, contract, and group IDs, which is the default behavior. * `PRODUCTION`, `PROD`, or `P` to import the latest version activated on the production environment. * `STAGING`, `STAGE`, `STAG`, or `S` to import the latest version activated on the staging environment. * Version number or version number with the `ver_` prefix to import a specific property version. For example `3` and `ver_3` correspond to the same version number. Here are some examples for the latest property version\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123\n```\n\n Here are some examples for the latest active property version on the production network\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,P\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123,PROD\n```\n\n Here are some examples for the specific property version\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,3\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123,ver_3\n```\n\n ",
            "properties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "productionVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai production network.\n"
                },
                "readVersion": {
                    "type": "integer",
                    "description": "Required property's version to be read\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleError:PropertyRuleError"
                    },
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "stagingVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai staging network.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "latestVersion",
                "name",
                "product",
                "productId",
                "productionVersion",
                "readVersion",
                "ruleErrors",
                "ruleFormat",
                "ruleWarnings",
                "rules",
                "stagingVersion"
            ],
            "inputProperties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n",
                    "willReplaceOnChanges": true
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Property resources.\n",
                "properties": {
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "The setting \"contact\" has been deprecated."
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "cpCode": {
                        "type": "string",
                        "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                        },
                        "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                    },
                    "isSecure": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The property name.\n",
                        "willReplaceOnChanges": true
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                        },
                        "deprecationMessage": "The setting \"origin\" has been deprecated."
                    },
                    "product": {
                        "type": "string",
                        "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string",
                        "description": "Product ID to be assigned to the Property\n"
                    },
                    "productionVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai production network.\n"
                    },
                    "readVersion": {
                        "type": "integer",
                        "description": "Required property's version to be read\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyRuleError:PropertyRuleError"
                        },
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    },
                    "ruleFormat": {
                        "type": "string",
                        "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                        },
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "rules": {
                        "type": "string",
                        "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                    },
                    "stagingVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai staging network.\n"
                    },
                    "variables": {
                        "type": "string",
                        "deprecationMessage": "The setting \"variables\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/property:Property"
                }
            ]
        },
        "akamai:index/propertyActivation:PropertyActivation": {
            "description": "The `akamai.PropertyActivation` resource lets you activate a property version. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.  \n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst email = \"user@example.org\";\nconst ruleFormat = \"v2020-03-04\";\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: {\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    ruleFormat: ruleFormat,\n    rules: fs.readFileSync(`${path.module}/main.json`),\n});\nconst exampleStaging = new akamai.PropertyActivation(\"exampleStaging\", {\n    propertyId: example.id,\n    contacts: [email],\n    version: example.latestVersion,\n    note: \"Sample activation\",\n});\nconst exampleProd = new akamai.PropertyActivation(\"exampleProd\", {\n    propertyId: example.id,\n    network: \"PRODUCTION\",\n    version: 3,\n    contacts: [email],\n}, {\n    dependsOn: [exampleStaging],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nemail = \"user@example.org\"\nrule_format = \"v2020-03-04\"\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames={\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    rule_format=rule_format,\n    rules=(lambda path: open(path).read())(f\"{path['module']}/main.json\"))\nexample_staging = akamai.PropertyActivation(\"exampleStaging\",\n    property_id=example.id,\n    contacts=[email],\n    version=example.latest_version,\n    note=\"Sample activation\")\nexample_prod = akamai.PropertyActivation(\"exampleProd\",\n    property_id=example.id,\n    network=\"PRODUCTION\",\n    version=3,\n    contacts=[email],\n    opts=pulumi.ResourceOptions(depends_on=[example_staging]))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var email = \"user@example.org\";\n        var ruleFormat = \"v2020-03-04\";\n        var example = new Akamai.Property(\"example\", new Akamai.PropertyArgs\n        {\n            ProductId = \"prd_SPM\",\n            ContractId = @var.Contractid,\n            GroupId = @var.Groupid,\n            Hostnames = \n            {\n                { \"example.org\", \"example.org.edgesuite.net\" },\n                { \"www.example.org\", \"example.org.edgesuite.net\" },\n                { \"sub.example.org\", \"sub.example.org.edgesuite.net\" },\n            },\n            RuleFormat = ruleFormat,\n            Rules = File.ReadAllText($\"{path.Module}/main.json\"),\n        });\n        var exampleStaging = new Akamai.PropertyActivation(\"exampleStaging\", new Akamai.PropertyActivationArgs\n        {\n            PropertyId = example.Id,\n            Contacts = \n            {\n                email,\n            },\n            Version = example.LatestVersion,\n            Note = \"Sample activation\",\n        });\n        var exampleProd = new Akamai.PropertyActivation(\"exampleProd\", new Akamai.PropertyActivationArgs\n        {\n            PropertyId = example.Id,\n            Network = \"PRODUCTION\",\n            Version = 3,\n            Contacts = \n            {\n                email,\n            },\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                exampleStaging,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\temail := \"user@example.org\"\n\t\truleFormat := \"v2020-03-04\"\n\t\texample, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: PropertyHostnameArray{\n\t\t\t\tExample.org:     \"example.org.edgesuite.net\",\n\t\t\t\tWww.example.org: \"example.org.edgesuite.net\",\n\t\t\t\tSub.example.org: \"sub.example.org.edgesuite.net\",\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(ruleFormat),\n\t\t\tRules:      readFileOrPanic(fmt.Sprintf(\"%v/main.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleStaging, err := akamai.NewPropertyActivation(ctx, \"exampleStaging\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t\tVersion: example.LatestVersion,\n\t\t\tNote:    pulumi.String(\"Sample activation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewPropertyActivation(ctx, \"exampleProd\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tNetwork:    pulumi.String(\"PRODUCTION\"),\n\t\t\tVersion:    pulumi.Int(3),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleStaging,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.PropertyActivation;\nimport com.pulumi.akamai.PropertyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var email = \"user@example.org\";\n\n        final var ruleFormat = \"v2020-03-04\";\n\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(PropertyHostnameArgs.builder()\n%!v(PANIC=Format method: interface conversion: model.Expression is *model.TemplateExpression, not *model.LiteralValueExpression))\n                .ruleFormat(ruleFormat)\n                .rules(Files.readString(Paths.get(String.format(\"%s/main.json\", path.module()))))\n                .build());\n\n            var exampleStaging = new PropertyActivation(\"exampleStaging\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .contacts(email)\n                .version(example.latestVersion())\n                .note(\"Sample activation\")\n                .build());\n\n            var exampleProd = new PropertyActivation(\"exampleProd\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .network(\"PRODUCTION\")\n                .version(3)\n                .contacts(email)\n                .build(), CustomResourceOptions.builder()\n                    .dependsOn(exampleStaging)\n                    .build());\n\n        }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "errors": {
                    "type": "string",
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "status": {
                    "type": "string",
                    "description": "The property version's activation status on the selected network.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                }
            },
            "required": [
                "activationId",
                "contacts",
                "errors",
                "property",
                "propertyId",
                "ruleErrors",
                "ruleWarnings",
                "status",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                }
            },
            "requiredInputs": [
                "contacts",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "string",
                        "description": "The ID given to the activation event while it's in progress.\n"
                    },
                    "autoAcknowledgeRuleWarnings": {
                        "type": "boolean",
                        "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                    },
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more email addresses to send activation status changes to.\n"
                    },
                    "errors": {
                        "type": "string",
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "A log message you can assign to the activation request.\n"
                    },
                    "property": {
                        "type": "string",
                        "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"property\" has been deprecated."
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                        }
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                        },
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "status": {
                        "type": "string",
                        "description": "The property version's activation status on the selected network.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/propertyActivation:PropertyActivation"
                }
            ]
        },
        "akamai:properties/cpCode:CpCode": {
            "description": "The `akamai.CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.\n\nYou can create additional CP codes to support more detailed billing and reporting functions.\n\nBy default, the Akamai Provider uses your existing CP code instead of creating a new one.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst cpCode = new akamai.CpCode(\"cpCode\", {\n    contractId: akamai_contract.contract.id,\n    groupId: akamai_group.group.id,\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncp_code = akamai.CpCode(\"cpCode\",\n    contract_id=akamai_contract[\"contract\"][\"id\"],\n    group_id=akamai_group[\"group\"][\"id\"],\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var cpCode = new Akamai.CpCode(\"cpCode\", new Akamai.CpCodeArgs\n        {\n            ContractId = akamai_contract.Contract.Id,\n            GroupId = akamai_group.Group.Id,\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpCode(ctx, \"cpCode\", \u0026akamai.CpCodeArgs{\n\t\t\tContractId: pulumi.Any(akamai_contract.Contract.Id),\n\t\t\tGroupId:    pulumi.Any(akamai_group.Group.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cpCode = new CpCode(\"cpCode\", CpCodeArgs.builder()        \n            .contractId(akamai_contract.contract().id())\n            .groupId(akamai_group.group().id())\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cpCode:\n    type: akamai:CpCode\n    properties:\n      contractId: ${akamai_contract.contract.id}\n      groupId: ${akamai_group.group.id}\n      productId: prd_Object_Delivery\n```\n\nHere's a real-life example that includes other data sources as dependencies:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst groupName = \"example group name\";\nconst cpcodeName = \"My CP Code\";\nconst exampleContract = akamai.getContract({\n    groupName: groupName,\n});\nconst exampleGroup = exampleContract.then(exampleContract =\u003e akamai.getGroup({\n    name: groupName,\n    contractId: exampleContract.id,\n}));\nconst exampleCp = new akamai.CpCode(\"exampleCp\", {\n    groupId: exampleGroup.then(exampleGroup =\u003e exampleGroup.id),\n    contractId: exampleContract.then(exampleContract =\u003e exampleContract.id),\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ngroup_name = \"example group name\"\ncpcode_name = \"My CP Code\"\nexample_contract = akamai.get_contract(group_name=group_name)\nexample_group = akamai.get_group(name=group_name,\n    contract_id=example_contract.id)\nexample_cp = akamai.CpCode(\"exampleCp\",\n    group_id=example_group.id,\n    contract_id=example_contract.id,\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var groupName = \"example group name\";\n        var cpcodeName = \"My CP Code\";\n        var exampleContract = Output.Create(Akamai.GetContract.InvokeAsync(new Akamai.GetContractArgs\n        {\n            GroupName = groupName,\n        }));\n        var exampleGroup = exampleContract.Apply(exampleContract =\u003e Output.Create(Akamai.GetGroup.InvokeAsync(new Akamai.GetGroupArgs\n        {\n            Name = groupName,\n            ContractId = exampleContract.Id,\n        })));\n        var exampleCp = new Akamai.CpCode(\"exampleCp\", new Akamai.CpCodeArgs\n        {\n            GroupId = exampleGroup.Apply(exampleGroup =\u003e exampleGroup.Id),\n            ContractId = exampleContract.Apply(exampleContract =\u003e exampleContract.Id),\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroupName := \"example group name\"\n\t\t_ := \"My CP Code\"\n\t\texampleContract, err := akamai.GetContract(ctx, \u0026GetContractArgs{\n\t\t\tGroupName: pulumi.StringRef(groupName),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleGroup, err := akamai.GetGroup(ctx, \u0026GetGroupArgs{\n\t\t\tName:       pulumi.StringRef(groupName),\n\t\t\tContractId: pulumi.StringRef(exampleContract.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCpCode(ctx, \"exampleCp\", \u0026akamai.CpCodeArgs{\n\t\t\tGroupId:    pulumi.String(exampleGroup.Id),\n\t\t\tContractId: pulumi.String(exampleContract.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetContractArgs;\nimport com.pulumi.akamai.inputs.GetGroupArgs;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var groupName = \"example group name\";\n\n        final var cpcodeName = \"My CP Code\";\n\n        final var exampleContract = AkamaiFunctions.getContract(GetContractArgs.builder()\n            .groupName(groupName)\n            .build());\n\n        final var exampleGroup = AkamaiFunctions.getGroup(GetGroupArgs.builder()\n            .name(groupName)\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .build());\n\n        var exampleCp = new CpCode(\"exampleCp\", CpCodeArgs.builder()        \n            .groupId(exampleGroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCp:\n    type: akamai:CpCode\n    properties:\n      groupId: ${exampleGroup.id}\n      contractId: ${exampleContract.id}\n      productId: prd_Object_Delivery\nvariables:\n  groupName: example group name\n  cpcodeName: My CP Code\n  exampleGroup:\n    Fn::Invoke:\n      Function: akamai:getGroup\n      Arguments:\n        name: ${groupName}\n        contractId: ${exampleContract.id}\n  exampleContract:\n    Fn::Invoke:\n      Function: akamai:getContract\n      Arguments:\n        groupName: ${groupName}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `id` - The ID of the CP code.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cp_code\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example\n\n```sh\n $ pulumi import akamai:properties/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "name",
                "product",
                "productId"
            ],
            "inputProperties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpCode resources.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "- (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.CpCode has been deprecated in favor of akamai.CpCode"
        },
        "akamai:properties/edgeHostName:EdgeHostName": {
            "description": "The `akamai.EdgeHostName` resource lets you configure a secure edge hostname. Your\nedge hostname determines how requests for your site, app, or content are mapped to\nAkamai edge servers.\n\nAn edge hostname is the CNAME target you use when directing your end user traffic to\nAkamai. Each hostname assigned to a property has a corresponding edge hostname.\n\nAkamai supports three types of edge hostnames, depending on the level of security\nyou need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When\nentering the `edge_hostname` attribute, you need to include a specific domain suffix\nfor your edge hostname type:\n\n| Edge hostname type | Domain suffix |\n|------|-------|\n| Enhanced TLS | edgekey.net |\n| Standard TLS | edgesuite.net |\n| Shared Cert | akamaized.net |\n\nFor example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See the [Property Manager API (PAPI)](https://developer.akamai.com/api/core_features/property_manager/v1.html#createedgehostnames) for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst provider_demo = new akamai.EdgeHostName(\"provider-demo\", {\n    contractId: \"ctr_1-AB123\",\n    edgeHostname: \"www.example.org.edgesuite.net\",\n    groupId: \"grp_123\",\n    ipBehavior: \"IPV4\",\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nprovider_demo = akamai.EdgeHostName(\"provider-demo\",\n    contract_id=\"ctr_1-AB123\",\n    edge_hostname=\"www.example.org.edgesuite.net\",\n    group_id=\"grp_123\",\n    ip_behavior=\"IPV4\",\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var provider_demo = new Akamai.EdgeHostName(\"provider-demo\", new Akamai.EdgeHostNameArgs\n        {\n            ContractId = \"ctr_1-AB123\",\n            EdgeHostname = \"www.example.org.edgesuite.net\",\n            GroupId = \"grp_123\",\n            IpBehavior = \"IPV4\",\n            ProductId = \"prd_Object_Delivery\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeHostName(ctx, \"provider-demo\", \u0026akamai.EdgeHostNameArgs{\n\t\t\tContractId:   pulumi.String(\"ctr_1-AB123\"),\n\t\t\tEdgeHostname: pulumi.String(\"www.example.org.edgesuite.net\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tIpBehavior:   pulumi.String(\"IPV4\"),\n\t\t\tProductId:    pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeHostName;\nimport com.pulumi.akamai.EdgeHostNameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var provider_demo = new EdgeHostName(\"provider-demo\", EdgeHostNameArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .edgeHostname(\"www.example.org.edgesuite.net\")\n            .groupId(\"grp_123\")\n            .ipBehavior(\"IPV4\")\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  provider-demo:\n    type: akamai:EdgeHostName\n    properties:\n      contractId: ctr_1-AB123\n      edgeHostname: www.example.org.edgesuite.net\n      groupId: grp_123\n      ipBehavior: IPV4\n      productId: prd_Object_Delivery\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE` for version 6, or `IPV6_COMPLIANCE` for both.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_edge_hostname\" \"example\" {\n\n # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:\n\n`edge_hostname, contract_id, group_id` For example\n\n```sh\n $ pulumi import akamai:properties/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n"
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n"
                }
            },
            "required": [
                "contract",
                "contractId",
                "edgeHostname",
                "group",
                "groupId",
                "ipBehavior",
                "product",
                "productId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                    "willReplaceOnChanges": true
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeHostname",
                "ipBehavior"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeHostName resources.\n",
                "properties": {
                    "certificate": {
                        "type": "integer",
                        "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                        "willReplaceOnChanges": true
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "edgeHostname": {
                        "type": "string",
                        "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "ipBehavior": {
                        "type": "string",
                        "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    },
                    "statusUpdateEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                    },
                    "useCases": {
                        "type": "string",
                        "description": "A JSON encoded list of use cases.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.EdgeHostName has been deprecated in favor of akamai.EdgeHostName"
        },
        "akamai:properties/property:Property": {
            "description": "The `akamai.Property` resource represents an Akamai property configuration.\nThis resource lets you to create, update, and activate properties on the\nAkamai platform.\n\nAkamai's edge network caches your web assets near to servers that request them.\nA property provides the main way to control how edge servers respond to various\nkinds of requests for those assets. Properties apply rules to a set of hostnames,\nand you can only apply one property at a time to any given hostname. Each property\nis assigned to a product, which determines which behaviors you can use. Each\nproperty's default rule needs a valid content provider (CP) code assigned to bill\nand report for the service.\n\n\u003e **Note** In version 0.10 and earlier of this resource, it also controlled content provider (CP) codes, origin settings, rules, and hostname associations. Starting with version 1.0.0, this logic is broken out into individual resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: [\n        {\n            cnameFrom: \"example.com\",\n            cnameTo: \"example.com.edgekey.net\",\n            certProvisioningType: \"DEFAULT\",\n        },\n        {\n            cnameFrom: \"www.example.com\",\n            cnameTo: \"example.com.edgesuite.net\",\n            certProvisioningType: \"CPS_MANAGED\",\n        },\n    ],\n    ruleFormat: \"v2020-03-04\",\n    rules: data.akamai_property_rules_template.example.json,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames=[\n        akamai.PropertyHostnameArgs(\n            cname_from=\"example.com\",\n            cname_to=\"example.com.edgekey.net\",\n            cert_provisioning_type=\"DEFAULT\",\n        ),\n        akamai.PropertyHostnameArgs(\n            cname_from=\"www.example.com\",\n            cname_to=\"example.com.edgesuite.net\",\n            cert_provisioning_type=\"CPS_MANAGED\",\n        ),\n    ],\n    rule_format=\"v2020-03-04\",\n    rules=data[\"akamai_property_rules_template\"][\"example\"][\"json\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = new Akamai.Property(\"example\", new Akamai.PropertyArgs\n        {\n            ProductId = \"prd_SPM\",\n            ContractId = @var.Contractid,\n            GroupId = @var.Groupid,\n            Hostnames = \n            {\n                new Akamai.Inputs.PropertyHostnameArgs\n                {\n                    CnameFrom = \"example.com\",\n                    CnameTo = \"example.com.edgekey.net\",\n                    CertProvisioningType = \"DEFAULT\",\n                },\n                new Akamai.Inputs.PropertyHostnameArgs\n                {\n                    CnameFrom = \"www.example.com\",\n                    CnameTo = \"example.com.edgesuite.net\",\n                    CertProvisioningType = \"CPS_MANAGED\",\n                },\n            },\n            RuleFormat = \"v2020-03-04\",\n            Rules = data.Akamai_property_rules_template.Example.Json,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: PropertyHostnameArray{\n\t\t\t\t\u0026PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgekey.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"DEFAULT\"),\n\t\t\t\t},\n\t\t\t\t\u0026PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"www.example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgesuite.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"CPS_MANAGED\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      pulumi.Any(data.Akamai_property_rules_template.Example.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.inputs.PropertyHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(            \n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"example.com\")\n                    .cnameTo(\"example.com.edgekey.net\")\n                    .certProvisioningType(\"DEFAULT\")\n                    .build(),\n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"www.example.com\")\n                    .cnameTo(\"example.com.edgesuite.net\")\n                    .certProvisioningType(\"CPS_MANAGED\")\n                    .build())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(data.akamai_property_rules_template().example().json())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        - cnameFrom: example.com\n          cnameTo: example.com.edgekey.net\n          certProvisioningType: DEFAULT\n        - cnameFrom: www.example.com\n          cnameTo: example.com.edgesuite.net\n          certProvisioningType: CPS_MANAGED\n      ruleFormat: v2020-03-04\n      rules: ${data.akamai_property_rules_template.example.json}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic Usagehcl resource \"akamai_property\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import the latest Akamai property version by using either the `property_id` or a comma-delimited string of the property, contract, and group IDs. You'll need to enter the string of IDs if the property belongs to multiple groups or contracts. If using the string of IDs, you need to enter them in this order`property_id,contract_id,group_id` To import a specific property version, pass additional parameters, either* `LATEST` to import the latest version of the property, regardless of whether it's active or not. This works the same as providing just the `property_id` or a string of the property, contract, and group IDs, which is the default behavior. * `PRODUCTION`, `PROD`, or `P` to import the latest version activated on the production environment. * `STAGING`, `STAGE`, `STAG`, or `S` to import the latest version activated on the staging environment. * Version number or version number with the `ver_` prefix to import a specific property version. For example `3` and `ver_3` correspond to the same version number. Here are some examples for the latest property version\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123\n```\n\n Here are some examples for the latest active property version on the production network\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,P\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123,PROD\n```\n\n Here are some examples for the specific property version\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,3\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123,ver_3\n```\n\n ",
            "properties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "productionVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai production network.\n"
                },
                "readVersion": {
                    "type": "integer",
                    "description": "Required property's version to be read\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleError:PropertyRuleError"
                    },
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "stagingVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai staging network.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "latestVersion",
                "name",
                "product",
                "productId",
                "productionVersion",
                "readVersion",
                "ruleErrors",
                "ruleFormat",
                "ruleWarnings",
                "rules",
                "stagingVersion"
            ],
            "inputProperties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n",
                    "willReplaceOnChanges": true
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Property resources.\n",
                "properties": {
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "The setting \"contact\" has been deprecated."
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "cpCode": {
                        "type": "string",
                        "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                        },
                        "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                    },
                    "isSecure": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The property name.\n",
                        "willReplaceOnChanges": true
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                        },
                        "deprecationMessage": "The setting \"origin\" has been deprecated."
                    },
                    "product": {
                        "type": "string",
                        "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string",
                        "description": "Product ID to be assigned to the Property\n"
                    },
                    "productionVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai production network.\n"
                    },
                    "readVersion": {
                        "type": "integer",
                        "description": "Required property's version to be read\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyRuleError:PropertyRuleError"
                        },
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    },
                    "ruleFormat": {
                        "type": "string",
                        "description": "The [rule format](https://developer.akamai.com/api/core_features/property_manager/v1.html#getruleformats) to use. Uses the latest rule format by default.\n"
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                        },
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "rules": {
                        "type": "string",
                        "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                    },
                    "stagingVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai staging network.\n"
                    },
                    "variables": {
                        "type": "string",
                        "deprecationMessage": "The setting \"variables\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.Property has been deprecated in favor of akamai.Property"
        },
        "akamai:properties/propertyActivation:PropertyActivation": {
            "description": "The `akamai.PropertyActivation` resource lets you activate a property version. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.  \n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst email = \"user@example.org\";\nconst ruleFormat = \"v2020-03-04\";\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: {\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    ruleFormat: ruleFormat,\n    rules: fs.readFileSync(`${path.module}/main.json`),\n});\nconst exampleStaging = new akamai.PropertyActivation(\"exampleStaging\", {\n    propertyId: example.id,\n    contacts: [email],\n    version: example.latestVersion,\n    note: \"Sample activation\",\n});\nconst exampleProd = new akamai.PropertyActivation(\"exampleProd\", {\n    propertyId: example.id,\n    network: \"PRODUCTION\",\n    version: 3,\n    contacts: [email],\n}, {\n    dependsOn: [exampleStaging],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nemail = \"user@example.org\"\nrule_format = \"v2020-03-04\"\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames={\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    rule_format=rule_format,\n    rules=(lambda path: open(path).read())(f\"{path['module']}/main.json\"))\nexample_staging = akamai.PropertyActivation(\"exampleStaging\",\n    property_id=example.id,\n    contacts=[email],\n    version=example.latest_version,\n    note=\"Sample activation\")\nexample_prod = akamai.PropertyActivation(\"exampleProd\",\n    property_id=example.id,\n    network=\"PRODUCTION\",\n    version=3,\n    contacts=[email],\n    opts=pulumi.ResourceOptions(depends_on=[example_staging]))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var email = \"user@example.org\";\n        var ruleFormat = \"v2020-03-04\";\n        var example = new Akamai.Property(\"example\", new Akamai.PropertyArgs\n        {\n            ProductId = \"prd_SPM\",\n            ContractId = @var.Contractid,\n            GroupId = @var.Groupid,\n            Hostnames = \n            {\n                { \"example.org\", \"example.org.edgesuite.net\" },\n                { \"www.example.org\", \"example.org.edgesuite.net\" },\n                { \"sub.example.org\", \"sub.example.org.edgesuite.net\" },\n            },\n            RuleFormat = ruleFormat,\n            Rules = File.ReadAllText($\"{path.Module}/main.json\"),\n        });\n        var exampleStaging = new Akamai.PropertyActivation(\"exampleStaging\", new Akamai.PropertyActivationArgs\n        {\n            PropertyId = example.Id,\n            Contacts = \n            {\n                email,\n            },\n            Version = example.LatestVersion,\n            Note = \"Sample activation\",\n        });\n        var exampleProd = new Akamai.PropertyActivation(\"exampleProd\", new Akamai.PropertyActivationArgs\n        {\n            PropertyId = example.Id,\n            Network = \"PRODUCTION\",\n            Version = 3,\n            Contacts = \n            {\n                email,\n            },\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                exampleStaging,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\temail := \"user@example.org\"\n\t\truleFormat := \"v2020-03-04\"\n\t\texample, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: PropertyHostnameArray{\n\t\t\t\tExample.org:     \"example.org.edgesuite.net\",\n\t\t\t\tWww.example.org: \"example.org.edgesuite.net\",\n\t\t\t\tSub.example.org: \"sub.example.org.edgesuite.net\",\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(ruleFormat),\n\t\t\tRules:      readFileOrPanic(fmt.Sprintf(\"%v/main.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleStaging, err := akamai.NewPropertyActivation(ctx, \"exampleStaging\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t\tVersion: example.LatestVersion,\n\t\t\tNote:    pulumi.String(\"Sample activation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewPropertyActivation(ctx, \"exampleProd\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tNetwork:    pulumi.String(\"PRODUCTION\"),\n\t\t\tVersion:    pulumi.Int(3),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleStaging,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.PropertyActivation;\nimport com.pulumi.akamai.PropertyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var email = \"user@example.org\";\n\n        final var ruleFormat = \"v2020-03-04\";\n\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(PropertyHostnameArgs.builder()\n%!v(PANIC=Format method: interface conversion: model.Expression is *model.TemplateExpression, not *model.LiteralValueExpression))\n                .ruleFormat(ruleFormat)\n                .rules(Files.readString(Paths.get(String.format(\"%s/main.json\", path.module()))))\n                .build());\n\n            var exampleStaging = new PropertyActivation(\"exampleStaging\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .contacts(email)\n                .version(example.latestVersion())\n                .note(\"Sample activation\")\n                .build());\n\n            var exampleProd = new PropertyActivation(\"exampleProd\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .network(\"PRODUCTION\")\n                .version(3)\n                .contacts(email)\n                .build(), CustomResourceOptions.builder()\n                    .dependsOn(exampleStaging)\n                    .build());\n\n        }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "errors": {
                    "type": "string",
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "status": {
                    "type": "string",
                    "description": "The property version's activation status on the selected network.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                }
            },
            "required": [
                "activationId",
                "contacts",
                "errors",
                "property",
                "propertyId",
                "ruleErrors",
                "ruleWarnings",
                "status",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                }
            },
            "requiredInputs": [
                "contacts",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "string",
                        "description": "The ID given to the activation event while it's in progress.\n"
                    },
                    "autoAcknowledgeRuleWarnings": {
                        "type": "boolean",
                        "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                    },
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more email addresses to send activation status changes to.\n"
                    },
                    "errors": {
                        "type": "string",
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "A log message you can assign to the activation request.\n"
                    },
                    "property": {
                        "type": "string",
                        "description": "- (Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"property\" has been deprecated."
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "- (Required) The property's unique identifier, including the `prp_` prefix.\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                        }
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                        },
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "status": {
                        "type": "string",
                        "description": "The property version's activation status on the selected network.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the PAPI documentation.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.PropertyActivation has been deprecated in favor of akamai.PropertyActivation"
        },
        "akamai:trafficmanagement/gtmASmap:GtmASmap": {
            "description": "Use the `akamai.GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address. \n\nYou can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin. \n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoAsmap = new akamai.GtmAsmap(\"demo_asmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other AS numbers\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_asmap = akamai.GtmAsmap(\"demoAsmap\",\n    default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other AS numbers\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoAsmap = new Akamai.GtmAsmap(\"demoAsmap\", new Akamai.GtmAsmapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmAsmapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Other AS numbers\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmAsmap(ctx, \"demoAsmap\", \u0026akamai.GtmAsmapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmAsmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other AS numbers\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmAsmap;\nimport com.pulumi.akamai.GtmAsmapArgs;\nimport com.pulumi.akamai.inputs.GtmAsmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoAsmap = new GtmAsmap(\"demoAsmap\", GtmAsmapArgs.builder()        \n            .defaultDatacenter(GtmAsmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other AS numbers\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoAsmap:\n    type: akamai:GtmAsmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other AS numbers\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM AS Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#asmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmASmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                        },
                        "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                        "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM Domain name for the AS map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap"
        },
        "akamai:trafficmanagement/gtmCidrmap:GtmCidrmap": {
            "description": "Use the `akamai.GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).\n\n CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined. \n \n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoCidrmap = new akamai.GtmCidrmap(\"demo_cidrmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other CIDR Blocks\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_cidrmap = akamai.GtmCidrmap(\"demoCidrmap\",\n    default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other CIDR Blocks\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoCidrmap = new Akamai.GtmCidrmap(\"demoCidrmap\", new Akamai.GtmCidrmapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmCidrmapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Other CIDR Blocks\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmCidrmap(ctx, \"demoCidrmap\", \u0026akamai.GtmCidrmapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmCidrmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other CIDR Blocks\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmCidrmap;\nimport com.pulumi.akamai.GtmCidrmapArgs;\nimport com.pulumi.akamai.inputs.GtmCidrmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoCidrmap = new GtmCidrmap(\"demoCidrmap\", GtmCidrmapArgs.builder()        \n            .defaultDatacenter(GtmCidrmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other CIDR Blocks\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoCidrmap:\n    type: akamai:GtmCidrmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other CIDR Blocks\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM CIDR Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#cidrmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the AS Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the AS Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmCidrmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                        },
                        "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                        "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the AS Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmCidrmap has been deprecated in favor of akamai.GtmCidrmap"
        },
        "akamai:trafficmanagement/gtmDatacenter:GtmDatacenter": {
            "description": "Use the `akamai.GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.\n\nGTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoDatacenter = new akamai.GtmDatacenter(\"demo_datacenter\", {\n    domain: \"demo_domain.akadns.net\",\n    nickname: \"demo_datacenter\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_datacenter = akamai.GtmDatacenter(\"demoDatacenter\",\n    domain=\"demo_domain.akadns.net\",\n    nickname=\"demo_datacenter\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoDatacenter = new Akamai.GtmDatacenter(\"demoDatacenter\", new Akamai.GtmDatacenterArgs\n        {\n            Domain = \"demo_domain.akadns.net\",\n            Nickname = \"demo_datacenter\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDatacenter(ctx, \"demoDatacenter\", \u0026akamai.GtmDatacenterArgs{\n\t\t\tDomain:   pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tNickname: pulumi.String(\"demo_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDatacenter;\nimport com.pulumi.akamai.GtmDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoDatacenter = new GtmDatacenter(\"demoDatacenter\", GtmDatacenterArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .nickname(\"demo_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoDatacenter:\n    type: akamai:GtmDatacenter\n    properties:\n      domain: demo_domain.akadns.net\n      nickname: demo_datacenter\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Data Center backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#datacenter) page.\n",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n* `ping_interval`\n* `ping_packet_size`\n* `score_penalty`\n* `servermonitor_liveness_count`\n* `servermonitor_load_count`\n* `servermonitor_pool`\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "scorePenalty": {
                    "type": "integer"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "virtual": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "datacenterId",
                "domain",
                "pingInterval",
                "pingPacketSize",
                "scorePenalty",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "virtual"
            ],
            "inputProperties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDatacenter resources.\n",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The name of the city where the data center is located.\n"
                    },
                    "cloneOf": {
                        "type": "integer",
                        "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                    },
                    "cloudServerHostHeaderOverride": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                    },
                    "cloudServerTargeting": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                    },
                    "continent": {
                        "type": "string",
                        "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                    },
                    "datacenterId": {
                        "type": "integer",
                        "description": "A unique identifier for an existing data center in the domain.\n* `ping_interval`\n* `ping_packet_size`\n* `score_penalty`\n* `servermonitor_liveness_count`\n* `servermonitor_load_count`\n* `servermonitor_pool`\n"
                    },
                    "defaultLoadObject": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                        "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM domain name for the data center.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                    },
                    "nickname": {
                        "type": "string",
                        "description": "A descriptive label for the data center.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "scorePenalty": {
                        "type": "integer"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "stateOrProvince": {
                        "type": "string",
                        "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                    },
                    "virtual": {
                        "type": "boolean",
                        "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmDatacenter has been deprecated in favor of akamai.GtmDatacenter"
        },
        "akamai:trafficmanagement/gtmDomain:GtmDomain": {
            "description": "Use the `akamai.GtmDomain` resource to create, configure, and import a GTM Domain, which is a basic building block of a traffic management configuration.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demodomain = new akamai.GtmDomain(\"demodomain\", {\n    comment: \"some comment\",\n    contract: \"XXX\",\n    group: \"100\",\n    type: \"basic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemodomain = akamai.GtmDomain(\"demodomain\",\n    comment=\"some comment\",\n    contract=\"XXX\",\n    group=\"100\",\n    type=\"basic\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demodomain = new Akamai.GtmDomain(\"demodomain\", new Akamai.GtmDomainArgs\n        {\n            Comment = \"some comment\",\n            Contract = \"XXX\",\n            Group = \"100\",\n            Type = \"basic\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDomain(ctx, \"demodomain\", \u0026akamai.GtmDomainArgs{\n\t\t\tComment:  pulumi.String(\"some comment\"),\n\t\t\tContract: pulumi.String(\"XXX\"),\n\t\t\tGroup:    pulumi.String(\"100\"),\n\t\t\tType:     pulumi.String(\"basic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDomain;\nimport com.pulumi.akamai.GtmDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demodomain = new GtmDomain(\"demodomain\", GtmDomainArgs.builder()        \n            .comment(\"some comment\")\n            .contract(\"XXX\")\n            .group(100)\n            .type(\"basic\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demodomain:\n    type: akamai:GtmDomain\n    properties:\n      comment: some comment\n      contract: XXX\n      group: 100\n      type: basic\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Domain backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#domain) page.\n",
            "properties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultHealthMax": {
                    "type": "number"
                },
                "defaultHealthMultiplier": {
                    "type": "number"
                },
                "defaultHealthThreshold": {
                    "type": "number"
                },
                "defaultMaxUnreachablePenalty": {
                    "type": "integer"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "defaultUnreachableThreshold": {
                    "type": "number"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "mapUpdateInterval": {
                    "type": "integer"
                },
                "maxProperties": {
                    "type": "integer"
                },
                "maxResources": {
                    "type": "integer"
                },
                "maxTestTimeout": {
                    "type": "number"
                },
                "maxTtl": {
                    "type": "integer"
                },
                "minPingableRegionFraction": {
                    "type": "number"
                },
                "minTestInterval": {
                    "type": "integer"
                },
                "minTtl": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "roundRobinPrefix": {
                    "type": "string"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultHealthMax",
                "defaultHealthMultiplier",
                "defaultHealthThreshold",
                "defaultMaxUnreachablePenalty",
                "defaultUnreachableThreshold",
                "mapUpdateInterval",
                "maxProperties",
                "maxResources",
                "maxTestTimeout",
                "maxTtl",
                "minPingableRegionFraction",
                "minTestInterval",
                "minTtl",
                "name",
                "pingInterval",
                "pingPacketSize",
                "roundRobinPrefix",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "type"
            ],
            "inputProperties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDomain resources.\n",
                "properties": {
                    "cnameCoalescingEnabled": {
                        "type": "boolean",
                        "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "If creating a domain, the contract ID.\n"
                    },
                    "defaultErrorPenalty": {
                        "type": "integer",
                        "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                    },
                    "defaultHealthMax": {
                        "type": "number"
                    },
                    "defaultHealthMultiplier": {
                        "type": "number"
                    },
                    "defaultHealthThreshold": {
                        "type": "number"
                    },
                    "defaultMaxUnreachablePenalty": {
                        "type": "integer"
                    },
                    "defaultSslClientCertificate": {
                        "type": "string",
                        "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                    },
                    "defaultSslClientPrivateKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                    },
                    "defaultTimeoutPenalty": {
                        "type": "integer",
                        "description": "Specifies the timeout penalty score. Default is `25`.\n"
                    },
                    "defaultUnreachableThreshold": {
                        "type": "number"
                    },
                    "emailNotificationLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses to notify when a change is made to the domain.\n"
                    },
                    "endUserMappingEnabled": {
                        "type": "boolean",
                        "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "If creating a domain, the currently selected group ID.\n"
                    },
                    "loadFeedback": {
                        "type": "boolean",
                        "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                    },
                    "mapUpdateInterval": {
                        "type": "integer"
                    },
                    "maxProperties": {
                        "type": "integer"
                    },
                    "maxResources": {
                        "type": "integer"
                    },
                    "maxTestTimeout": {
                        "type": "number"
                    },
                    "maxTtl": {
                        "type": "integer"
                    },
                    "minPingableRegionFraction": {
                        "type": "number"
                    },
                    "minTestInterval": {
                        "type": "integer"
                    },
                    "minTtl": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS name for a collection of GTM Properties.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "roundRobinPrefix": {
                        "type": "string"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmDomain has been deprecated in favor of akamai.GtmDomain"
        },
        "akamai:trafficmanagement/gtmGeomap:GtmGeomap": {
            "description": "Use the `akamai.GtmGeomap` resource to create, configure, and import a GTM Geographic map. Geographic mapping lets you configure a property that returns a CNAME based on the geographic location of the request.\n\nYou can reuse maps for multiple properties or create new ones. To configure a property for geographic mapping, you need to define at least one geographic map for your domain. Each map needs at least two definitions. For example, you can have one definition that maps a set of countries to a specific data center, and a second definition that routes all other traffic.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoGeomap = new akamai.GtmGeomap(\"demo_geomap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Others\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_geomap = akamai.GtmGeomap(\"demoGeomap\",\n    default_datacenter=akamai.GtmGeomapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Others\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoGeomap = new Akamai.GtmGeomap(\"demoGeomap\", new Akamai.GtmGeomapArgs\n        {\n            DefaultDatacenter = new Akamai.Inputs.GtmGeomapDefaultDatacenterArgs\n            {\n                DatacenterId = 5400,\n                Nickname = \"All Others\",\n            },\n            Domain = \"demo_domain.akadns.net\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmGeomap(ctx, \"demoGeomap\", \u0026akamai.GtmGeomapArgs{\n\t\t\tDefaultDatacenter: \u0026GtmGeomapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Others\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmGeomap;\nimport com.pulumi.akamai.GtmGeomapArgs;\nimport com.pulumi.akamai.inputs.GtmGeomapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoGeomap = new GtmGeomap(\"demoGeomap\", GtmGeomapArgs.builder()        \n            .defaultDatacenter(GtmGeomapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Others\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoGeomap:\n    type: akamai:GtmGeomap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Others\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Geographic Map backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#geographicmap) page.\n",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmGeomap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                        },
                        "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                        "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the Geographic Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the Geographic map.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmGeomap has been deprecated in favor of akamai.GtmGeomap"
        },
        "akamai:trafficmanagement/gtmProperty:GtmProperty": {
            "description": "Use the `akamai.GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoProperty = new akamai.GtmProperty(\"demo_property\", {\n    domain: \"demo_domain.akadns.net\",\n    handoutLimit: 5,\n    handoutMode: \"normal\",\n    scoreAggregationType: \"median\",\n    trafficTargets: [{\n        datacenterId: 3131,\n    }],\n    type: \"weighted-round-robin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_property = akamai.GtmProperty(\"demoProperty\",\n    domain=\"demo_domain.akadns.net\",\n    handout_limit=5,\n    handout_mode=\"normal\",\n    score_aggregation_type=\"median\",\n    traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(\n        datacenter_id=3131,\n    )],\n    type=\"weighted-round-robin\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoProperty = new Akamai.GtmProperty(\"demoProperty\", new Akamai.GtmPropertyArgs\n        {\n            Domain = \"demo_domain.akadns.net\",\n            HandoutLimit = 5,\n            HandoutMode = \"normal\",\n            ScoreAggregationType = \"median\",\n            TrafficTargets = \n            {\n                new Akamai.Inputs.GtmPropertyTrafficTargetArgs\n                {\n                    DatacenterId = 3131,\n                },\n            },\n            Type = \"weighted-round-robin\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmProperty(ctx, \"demoProperty\", \u0026akamai.GtmPropertyArgs{\n\t\t\tDomain:               pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tHandoutLimit:         pulumi.Int(5),\n\t\t\tHandoutMode:          pulumi.String(\"normal\"),\n\t\t\tScoreAggregationType: pulumi.String(\"median\"),\n\t\t\tTrafficTargets: GtmPropertyTrafficTargetArray{\n\t\t\t\t\u0026GtmPropertyTrafficTargetArgs{\n\t\t\t\t\tDatacenterId: pulumi.Int(3131),\n\t\t\t\t},\n\t\t\t},\n\t\t\tType: pulumi.String(\"weighted-round-robin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmProperty;\nimport com.pulumi.akamai.GtmPropertyArgs;\nimport com.pulumi.akamai.inputs.GtmPropertyTrafficTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoProperty = new GtmProperty(\"demoProperty\", GtmPropertyArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .handoutLimit(5)\n            .handoutMode(\"normal\")\n            .scoreAggregationType(\"median\")\n            .trafficTargets(GtmPropertyTrafficTargetArgs.builder()\n                .datacenterId(3131)\n                .build())\n            .type(\"weighted-round-robin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoProperty:\n    type: akamai:GtmProperty\n    properties:\n      domain: demo_domain.akadns.net\n      handoutLimit: 5\n      handoutMode: normal\n      scoreAggregationType: median\n      trafficTargets:\n        - datacenterId: 3131\n      type: weighted-round-robin\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Property backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#property) page.\n",
            "properties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                },
                "weightedHashBitsForIpv4": {
                    "type": "integer"
                },
                "weightedHashBitsForIpv6": {
                    "type": "integer"
                }
            },
            "required": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "name",
                "scoreAggregationType",
                "type",
                "weightedHashBitsForIpv4",
                "weightedHashBitsForIpv6"
            ],
            "inputProperties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "scoreAggregationType",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmProperty resources.\n",
                "properties": {
                    "backupCname": {
                        "type": "string",
                        "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                    },
                    "backupIp": {
                        "type": "string",
                        "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                    },
                    "balanceByDownloadScore": {
                        "type": "boolean",
                        "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Indicates the fully qualified name aliased to a particular property.\n"
                    },
                    "comments": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this Property.\n"
                    },
                    "dynamicTtl": {
                        "type": "integer",
                        "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                    },
                    "failbackDelay": {
                        "type": "integer",
                        "description": "Specifies the failback delay in seconds.\n"
                    },
                    "failoverDelay": {
                        "type": "integer",
                        "description": "Specifies the failover delay in seconds.\n"
                    },
                    "ghostDemandReporting": {
                        "type": "boolean",
                        "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                    },
                    "handoutLimit": {
                        "type": "integer",
                        "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                    },
                    "handoutMode": {
                        "type": "string",
                        "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                    },
                    "healthMax": {
                        "type": "number",
                        "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                    },
                    "healthMultiplier": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "healthThreshold": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "ipv6": {
                        "type": "boolean",
                        "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                    },
                    "livenessTests": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                        },
                        "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                    },
                    "mapName": {
                        "type": "string",
                        "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                    },
                    "maxUnreachablePenalty": {
                        "type": "integer",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                    },
                    "minLiveFraction": {
                        "type": "number",
                        "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of HTTP header.\n"
                    },
                    "scoreAggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                    },
                    "staticRrSets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                        },
                        "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                    },
                    "staticTtl": {
                        "type": "integer"
                    },
                    "stickinessBonusConstant": {
                        "type": "integer",
                        "description": "Specifies a constant used to configure data center affinity.\n"
                    },
                    "stickinessBonusPercentage": {
                        "type": "integer",
                        "description": "Specifies a percentage used to configure data center affinity.\n"
                    },
                    "trafficTargets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                        },
                        "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The record type.\n"
                    },
                    "unreachableThreshold": {
                        "type": "number",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                    },
                    "useComputedTargets": {
                        "type": "boolean",
                        "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    },
                    "weightedHashBitsForIpv4": {
                        "type": "integer"
                    },
                    "weightedHashBitsForIpv6": {
                        "type": "integer"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmProperty has been deprecated in favor of akamai.GtmProperty"
        },
        "akamai:trafficmanagement/gtmResource:GtmResource": {
            "description": "The `akamai.GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second. \n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:\n`existing_resource_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoResource = new akamai.GtmResource(\"demo_resource\", {\n    aggregationType: \"latest\",\n    domain: \"demo_domain.akadns.net\",\n    type: \"XML load object via HTTP\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_resource = akamai.GtmResource(\"demoResource\",\n    aggregation_type=\"latest\",\n    domain=\"demo_domain.akadns.net\",\n    type=\"XML load object via HTTP\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demoResource = new Akamai.GtmResource(\"demoResource\", new Akamai.GtmResourceArgs\n        {\n            AggregationType = \"latest\",\n            Domain = \"demo_domain.akadns.net\",\n            Type = \"XML load object via HTTP\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmResource(ctx, \"demoResource\", \u0026akamai.GtmResourceArgs{\n\t\t\tAggregationType: pulumi.String(\"latest\"),\n\t\t\tDomain:          pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tType:            pulumi.String(\"XML load object via HTTP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmResource;\nimport com.pulumi.akamai.GtmResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoResource = new GtmResource(\"demoResource\", GtmResourceArgs.builder()        \n            .aggregationType(\"latest\")\n            .domain(\"demo_domain.akadns.net\")\n            .type(\"XML load object via HTTP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoResource:\n    type: akamai:GtmResource\n    properties:\n      aggregationType: latest\n      domain: demo_domain.akadns.net\n      type: XML load object via HTTP\n```\n{{% /example %}}\n{{% /examples %}}\n## Schema reference\n\nYou can download the GTM Resource backing schema from the [Global Traffic Management API](https://developer.akamai.com/api/web_performance/global_traffic_management/v1.html#resource) page.\n",
            "properties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "aggregationType",
                "domain",
                "name",
                "type"
            ],
            "inputProperties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "aggregationType",
                "domain",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmResource resources.\n",
                "properties": {
                    "aggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                    },
                    "constrainedProperty": {
                        "type": "string",
                        "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                    },
                    "decayRate": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A descriptive note to help you track what the resource constrains.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this property.\n"
                    },
                    "hostHeader": {
                        "type": "string",
                        "description": "Optionally specifies the host header used when fetching the load object.\n"
                    },
                    "leaderString": {
                        "type": "string",
                        "description": "Specifies the text that comes before the `load_object`.\n"
                    },
                    "leastSquaresDecay": {
                        "type": "number",
                        "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number"
                    },
                    "maxUMultiplicativeIncrement": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the GTM resource.\n"
                    },
                    "resourceInstances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                        },
                        "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                    },
                    "upperBound": {
                        "type": "integer",
                        "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmResource has been deprecated in favor of akamai.GtmResource"
        }
    },
    "functions": {
        "akamai:edgedns/getAuthoritiesSet:getAuthoritiesSet": {
            "description": "Use the `akamai.getAuthoritiesSet` data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getAuthoritiesSet({\n    contract: \"ctr_1-AB123\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_authorities_set(contract=\"ctr_1-AB123\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetAuthoritiesSet.InvokeAsync(new Akamai.GetAuthoritiesSetArgs\n        {\n            Contract = \"ctr_1-AB123\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAuthoritiesSet(ctx, \u0026GetAuthoritiesSetArgs{\n\t\t\tContract: \"ctr_1-AB123\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.edgedns.inputs.GetAuthoritiesSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()\n            .contract(\"ctr_1-AB123\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getAuthoritiesSet\n      Arguments:\n        contract: ctr_1-AB123\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source supports this attribute:\n\n* `authorities` - A list of authorities.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthoritiesSet.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contract"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthoritiesSet.\n",
                "properties": {
                    "authorities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "contract": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authorities",
                    "contract",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.edgedns.getAuthoritiesSet has been deprecated in favor of akamai.getAuthoritiesSet"
        },
        "akamai:edgedns/getDnsRecordSet:getDnsRecordSet": {
            "inputs": {
                "description": "A collection of arguments for invoking getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "recordType",
                    "zone"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rdatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "rdatas",
                    "recordType",
                    "zone",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.edgedns.getDnsRecordSet has been deprecated in favor of akamai.getDnsRecordSet"
        },
        "akamai:index/getAppSecAdvancedSettingsEvasivePathMatch:getAppSecAdvancedSettingsEvasivePathMatch": {
            "description": "**Scopes**: Security configuration; security policy \n\nUse the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the security_policy_id parameter. The information available is described [here](https://developer.akamai.com/api/cloud_security/application_security/v1.html#gethttpheaderloggingforaconfiguration).\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/put-evasive-path-match)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst evasivePathMatch = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsEvasivePathMatch({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsEvasivePathMatchOutput = evasivePathMatch.then(evasivePathMatch =\u003e evasivePathMatch.outputText);\nexport const advancedSettingsEvasivePathMatchJson = evasivePathMatch.then(evasivePathMatch =\u003e evasivePathMatch.json);\nconst policyOverride = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsEvasivePathMatch({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n}));\nexport const advancedSettingsPolicyEvasivePathMatchOutput = policyOverride.then(policyOverride =\u003e policyOverride.outputText);\nexport const advancedSettingsPolicyEvasivePathMatchJson = policyOverride.then(policyOverride =\u003e policyOverride.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\nevasive_path_match = akamai.get_app_sec_advanced_settings_evasive_path_match(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsEvasivePathMatchOutput\", evasive_path_match.output_text)\npulumi.export(\"advancedSettingsEvasivePathMatchJson\", evasive_path_match.json)\npolicy_override = akamai.get_app_sec_advanced_settings_evasive_path_match(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"])\npulumi.export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policy_override.output_text)\npulumi.export(\"advancedSettingsPolicyEvasivePathMatchJson\", policy_override.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = @var.Security_configuration,\n        }));\n        var evasivePathMatch = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecAdvancedSettingsEvasivePathMatch.InvokeAsync(new Akamai.GetAppSecAdvancedSettingsEvasivePathMatchArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.AdvancedSettingsEvasivePathMatchOutput = evasivePathMatch.Apply(evasivePathMatch =\u003e evasivePathMatch.OutputText);\n        this.AdvancedSettingsEvasivePathMatchJson = evasivePathMatch.Apply(evasivePathMatch =\u003e evasivePathMatch.Json);\n        var policyOverride = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecAdvancedSettingsEvasivePathMatch.InvokeAsync(new Akamai.GetAppSecAdvancedSettingsEvasivePathMatchArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = @var.Security_policy_id,\n        })));\n        this.AdvancedSettingsPolicyEvasivePathMatchOutput = policyOverride.Apply(policyOverride =\u003e policyOverride.OutputText);\n        this.AdvancedSettingsPolicyEvasivePathMatchJson = policyOverride.Apply(policyOverride =\u003e policyOverride.Json);\n    }\n\n    [Output(\"advancedSettingsEvasivePathMatchOutput\")]\n    public Output\u003cstring\u003e AdvancedSettingsEvasivePathMatchOutput { get; set; }\n    [Output(\"advancedSettingsEvasivePathMatchJson\")]\n    public Output\u003cstring\u003e AdvancedSettingsEvasivePathMatchJson { get; set; }\n    [Output(\"advancedSettingsPolicyEvasivePathMatchOutput\")]\n    public Output\u003cstring\u003e AdvancedSettingsPolicyEvasivePathMatchOutput { get; set; }\n    [Output(\"advancedSettingsPolicyEvasivePathMatchJson\")]\n    public Output\u003cstring\u003e AdvancedSettingsPolicyEvasivePathMatchJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevasivePathMatch, err := akamai.LookupAppSecAdvancedSettingsEvasivePathMatch(ctx, \u0026GetAppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsEvasivePathMatchOutput\", evasivePathMatch.OutputText)\n\t\tctx.Export(\"advancedSettingsEvasivePathMatchJson\", evasivePathMatch.Json)\n\t\tpolicyOverride, err := akamai.LookupAppSecAdvancedSettingsEvasivePathMatch(ctx, \u0026GetAppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policyOverride.OutputText)\n\t\tctx.Export(\"advancedSettingsPolicyEvasivePathMatchJson\", policyOverride.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsEvasivePathMatchOutput\", evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));\n        ctx.export(\"advancedSettingsEvasivePathMatchJson\", evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.json()));\n        final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .build());\n\n        ctx.export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));\n        ctx.export(\"advancedSettingsPolicyEvasivePathMatchJson\", policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n  evasivePathMatch:\n    Fn::Invoke:\n      Function: akamai:getAppSecAdvancedSettingsEvasivePathMatch\n      Arguments:\n        configId: ${configuration.configId}\n  policyOverride:\n    Fn::Invoke:\n      Function: akamai:getAppSecAdvancedSettingsEvasivePathMatch\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\noutputs:\n  advancedSettingsEvasivePathMatchOutput: ${evasivePathMatch.outputText}\n  advancedSettingsEvasivePathMatchJson: ${evasivePathMatch.json}\n  advancedSettingsPolicyEvasivePathMatchOutput: ${policyOverride.outputText}\n  advancedSettingsPolicyEvasivePathMatchJson: ${policyOverride.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsEvasivePathMatch.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "The configuration ID.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "The ID of the security policy to use.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsEvasivePathMatch.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "A JSON-formatted list of information about the evasive path match settings.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "A tabular display showing the evasive path match settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsLogging:getAppSecAdvancedSettingsLogging": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRules = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n}));\nexport const customRulesOutputText = customRules.then(customRules =\u003e customRules.outputText);\nexport const customRulesJson = customRules.then(customRules =\u003e customRules.json);\nexport const customRulesConfigId = customRules.then(customRules =\u003e customRules.configId);\nconst specificCustomRule = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n    customRuleId: 60029316,\n}));\nexport const specificCustomRuleJson = specificCustomRule.then(specificCustomRule =\u003e specificCustomRule.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rules = akamai.get_app_sec_custom_rules(config_id=configuration.config_id)\npulumi.export(\"customRulesOutputText\", custom_rules.output_text)\npulumi.export(\"customRulesJson\", custom_rules.json)\npulumi.export(\"customRulesConfigId\", custom_rules.config_id)\nspecific_custom_rule = akamai.get_app_sec_custom_rules(config_id=configuration.config_id,\n    custom_rule_id=60029316)\npulumi.export(\"specificCustomRuleJson\", specific_custom_rule.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var customRules = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomRules.InvokeAsync(new Akamai.GetAppSecCustomRulesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.CustomRulesOutputText = customRules.Apply(customRules =\u003e customRules.OutputText);\n        this.CustomRulesJson = customRules.Apply(customRules =\u003e customRules.Json);\n        this.CustomRulesConfigId = customRules.Apply(customRules =\u003e customRules.ConfigId);\n        var specificCustomRule = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomRules.InvokeAsync(new Akamai.GetAppSecCustomRulesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            CustomRuleId = 60029316,\n        })));\n        this.SpecificCustomRuleJson = specificCustomRule.Apply(specificCustomRule =\u003e specificCustomRule.Json);\n    }\n\n    [Output(\"customRulesOutputText\")]\n    public Output\u003cstring\u003e CustomRulesOutputText { get; set; }\n    [Output(\"customRulesJson\")]\n    public Output\u003cstring\u003e CustomRulesJson { get; set; }\n    [Output(\"customRulesConfigId\")]\n    public Output\u003cstring\u003e CustomRulesConfigId { get; set; }\n    [Output(\"specificCustomRuleJson\")]\n    public Output\u003cstring\u003e SpecificCustomRuleJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRules, err := akamai.GetAppSecCustomRules(ctx, \u0026GetAppSecCustomRulesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRulesOutputText\", customRules.OutputText)\n\t\tctx.Export(\"customRulesJson\", customRules.Json)\n\t\tctx.Export(\"customRulesConfigId\", customRules.ConfigId)\n\t\tspecificCustomRule, err := akamai.GetAppSecCustomRules(ctx, \u0026GetAppSecCustomRulesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomRuleId: pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"specificCustomRuleJson\", specificCustomRule.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customRulesOutputText\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.outputText()));\n        ctx.export(\"customRulesJson\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n        ctx.export(\"customRulesConfigId\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.configId()));\n        final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customRuleId(\"60029316\")\n            .build());\n\n        ctx.export(\"specificCustomRuleJson\", specificCustomRule.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRules:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n  specificCustomRule:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n        customRuleId: 60029316\noutputs:\n  customRulesOutputText: ${customRules.outputText}\n  customRulesJson: ${customRules.json}\n  customRulesConfigId: ${customRules.configId} # USE CASE: User wants to view a specific custom rule.\n  specificCustomRuleJson: ${specificCustomRule.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the logging settings.\n- `output_text`. Tabular report showing the logging settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsLogging.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the logging settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the logging settings. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsLogging.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsPragmaHeader:getAppSecAdvancedSettingsPragmaHeader": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.\n\nAdditional information is available from the [PragmaHeader members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#64c92ba1) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst pragmaHeader = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPragmaHeader({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsPragmaHeaderOutput = pragmaHeader.then(pragmaHeader =\u003e pragmaHeader.outputText);\nexport const advancedSettingsPragmaHeaderJson = pragmaHeader.then(pragmaHeader =\u003e pragmaHeader.json);\nconst policyPragmaHeader = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPragmaHeader({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const advancedSettingsPolicyPragmaHeaderOutput = policyPragmaHeader.then(policyPragmaHeader =\u003e policyPragmaHeader.outputText);\nexport const advancedSettingsPolicyPragmaHeaderJson = policyPragmaHeader.then(policyPragmaHeader =\u003e policyPragmaHeader.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npragma_header = akamai.get_app_sec_advanced_settings_pragma_header(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsPragmaHeaderOutput\", pragma_header.output_text)\npulumi.export(\"advancedSettingsPragmaHeaderJson\", pragma_header.json)\npolicy_pragma_header = akamai.get_app_sec_advanced_settings_pragma_header(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"advancedSettingsPolicyPragmaHeaderOutput\", policy_pragma_header.output_text)\npulumi.export(\"advancedSettingsPolicyPragmaHeaderJson\", policy_pragma_header.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var pragmaHeader = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecAdvancedSettingsPragmaHeader.InvokeAsync(new Akamai.GetAppSecAdvancedSettingsPragmaHeaderArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.AdvancedSettingsPragmaHeaderOutput = pragmaHeader.Apply(pragmaHeader =\u003e pragmaHeader.OutputText);\n        this.AdvancedSettingsPragmaHeaderJson = pragmaHeader.Apply(pragmaHeader =\u003e pragmaHeader.Json);\n        var policyPragmaHeader = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecAdvancedSettingsPragmaHeader.InvokeAsync(new Akamai.GetAppSecAdvancedSettingsPragmaHeaderArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.AdvancedSettingsPolicyPragmaHeaderOutput = policyPragmaHeader.Apply(policyPragmaHeader =\u003e policyPragmaHeader.OutputText);\n        this.AdvancedSettingsPolicyPragmaHeaderJson = policyPragmaHeader.Apply(policyPragmaHeader =\u003e policyPragmaHeader.Json);\n    }\n\n    [Output(\"advancedSettingsPragmaHeaderOutput\")]\n    public Output\u003cstring\u003e AdvancedSettingsPragmaHeaderOutput { get; set; }\n    [Output(\"advancedSettingsPragmaHeaderJson\")]\n    public Output\u003cstring\u003e AdvancedSettingsPragmaHeaderJson { get; set; }\n    [Output(\"advancedSettingsPolicyPragmaHeaderOutput\")]\n    public Output\u003cstring\u003e AdvancedSettingsPolicyPragmaHeaderOutput { get; set; }\n    [Output(\"advancedSettingsPolicyPragmaHeaderJson\")]\n    public Output\u003cstring\u003e AdvancedSettingsPolicyPragmaHeaderJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpragmaHeader, err := akamai.LookupAppSecAdvancedSettingsPragmaHeader(ctx, \u0026GetAppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPragmaHeaderOutput\", pragmaHeader.OutputText)\n\t\tctx.Export(\"advancedSettingsPragmaHeaderJson\", pragmaHeader.Json)\n\t\tpolicyPragmaHeader, err := akamai.LookupAppSecAdvancedSettingsPragmaHeader(ctx, \u0026GetAppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(\"gms1_134637\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPolicyPragmaHeaderOutput\", policyPragmaHeader.OutputText)\n\t\tctx.Export(\"advancedSettingsPolicyPragmaHeaderJson\", policyPragmaHeader.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsPragmaHeaderOutput\", pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));\n        ctx.export(\"advancedSettingsPragmaHeaderJson\", pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.json()));\n        final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"advancedSettingsPolicyPragmaHeaderOutput\", policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));\n        ctx.export(\"advancedSettingsPolicyPragmaHeaderJson\", policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  pragmaHeader:\n    Fn::Invoke:\n      Function: akamai:getAppSecAdvancedSettingsPragmaHeader\n      Arguments:\n        configId: ${configuration.configId}\n  policyPragmaHeader:\n    Fn::Invoke:\n      Function: akamai:getAppSecAdvancedSettingsPragmaHeader\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  advancedSettingsPragmaHeaderOutput: ${pragmaHeader.outputText}\n  advancedSettingsPragmaHeaderJson: ${pragmaHeader.json}\n  advancedSettingsPolicyPragmaHeaderOutput: ${policyPragmaHeader.outputText}\n  advancedSettingsPolicyPragmaHeaderJson: ${policyPragmaHeader.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the pragma header settings.\n- `output_text`. Tabular report showing the pragma header settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsPragmaHeader.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the pragma header settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the pragma header settings. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsPragmaHeader.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsPrefetch:getAppSecAdvancedSettingsPrefetch": {
            "description": "**Scopes**: Security configuration\n\nReturns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai's edge servers. When prefetch is enabled, requests between your origin servers and Akamai's edge servers can also be inspected by the firewall. The returned information is described in the [PrefetchRequest members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#deb7220d) section of the Application Security API.\n\n**Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst prefetch = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPrefetch({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsPrefetchOutput = prefetch.then(prefetch =\u003e prefetch.outputText);\nexport const advancedSettingsPrefetchJson = prefetch.then(prefetch =\u003e prefetch.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprefetch = akamai.get_app_sec_advanced_settings_prefetch(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsPrefetchOutput\", prefetch.output_text)\npulumi.export(\"advancedSettingsPrefetchJson\", prefetch.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var prefetch = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecAdvancedSettingsPrefetch.InvokeAsync(new Akamai.GetAppSecAdvancedSettingsPrefetchArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.AdvancedSettingsPrefetchOutput = prefetch.Apply(prefetch =\u003e prefetch.OutputText);\n        this.AdvancedSettingsPrefetchJson = prefetch.Apply(prefetch =\u003e prefetch.Json);\n    }\n\n    [Output(\"advancedSettingsPrefetchOutput\")]\n    public Output\u003cstring\u003e AdvancedSettingsPrefetchOutput { get; set; }\n    [Output(\"advancedSettingsPrefetchJson\")]\n    public Output\u003cstring\u003e AdvancedSettingsPrefetchJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefetch, err := akamai.LookupAppSecAdvancedSettingsPrefetch(ctx, \u0026GetAppSecAdvancedSettingsPrefetchArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPrefetchOutput\", prefetch.OutputText)\n\t\tctx.Export(\"advancedSettingsPrefetchJson\", prefetch.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsPrefetchOutput\", prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -\u003e getAppSecAdvancedSettingsPrefetchResult.outputText()));\n        ctx.export(\"advancedSettingsPrefetchJson\", prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -\u003e getAppSecAdvancedSettingsPrefetchResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  prefetch: # USE CASE: User wants to display returned data in a table.\n    Fn::Invoke:\n      Function: akamai:getAppSecAdvancedSettingsPrefetch\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  advancedSettingsPrefetchOutput: ${prefetch.outputText}\n  advancedSettingsPrefetchJson: ${prefetch.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the prefetch request settings.\n- `output_text`. Tabular report showing the prefetch request settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsPrefetch.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the prefetch settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsPrefetch.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecApiEndpoints:getAppSecApiEndpoints": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about the API endpoints associated with a security policy or configuration. The returned information is described in the [Endpoint members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#apiendpoint) section of the Application Security API documentation.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst apiEndpoints = pulumi.output(akamai.getAppSecApiEndpoints({\n    apiName: \"Contracts\",\n    configId: 58843,\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\napi_endpoints = akamai.get_app_sec_api_endpoints(api_name=\"Contracts\",\n    config_id=58843)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var apiEndpoints = Output.Create(Akamai.GetAppSecApiEndpoints.InvokeAsync(new Akamai.GetAppSecApiEndpointsArgs\n        {\n            ApiName = \"Contracts\",\n            ConfigId = 58843,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAppSecApiEndpoints(ctx, \u0026GetAppSecApiEndpointsArgs{\n\t\t\tApiName:  pulumi.StringRef(\"Contracts\"),\n\t\t\tConfigId: 58843,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()\n            .apiName(\"Contracts\")\n            .configId(58843)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  apiEndpoints:\n    Fn::Invoke:\n      Function: akamai:getAppSecApiEndpoints\n      Arguments:\n        apiName: Contracts\n        configId: 58843\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `id_list`. List of API endpoint IDs.\n- `json`. JSON-formatted list of information about the API endpoints.\n- `output_text`. Tabular report showing the ID and name of the API endpoints.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecApiEndpoints.\n",
                "properties": {
                    "apiName": {
                        "type": "string",
                        "description": ". Name of the API endpoint you want to return information for. If not included, information is returned for all your API endpoints.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API endpoints.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API endpoints. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecApiEndpoints.\n",
                "properties": {
                    "apiName": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "idLists": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "idLists",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecApiRequestConstraints:getAppSecApiRequestConstraints": {
            "description": "**Scopes**: Security policy; API endpoint\n\nReturns information about API endpoint constraints and actions. The returned information is described in the [API Constraints members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getapirequestconstraints) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst apisRequestConstraints = configuration.then(configuration =\u003e akamai.getAppSecApiRequestConstraints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const apisConstraintsText = apisRequestConstraints.then(apisRequestConstraints =\u003e apisRequestConstraints.outputText);\nexport const apisConstraintsJson = apisRequestConstraints.then(apisRequestConstraints =\u003e apisRequestConstraints.json);\nconst apiRequestConstraints = configuration.then(configuration =\u003e akamai.getAppSecApiRequestConstraints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    apiId: 624913,\n}));\nexport const apiConstraintsText = apiRequestConstraints.then(apiRequestConstraints =\u003e apiRequestConstraints.outputText);\nexport const apiConstraintsJson = apiRequestConstraints.then(apiRequestConstraints =\u003e apiRequestConstraints.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\napis_request_constraints = akamai.get_app_sec_api_request_constraints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"apisConstraintsText\", apis_request_constraints.output_text)\npulumi.export(\"apisConstraintsJson\", apis_request_constraints.json)\napi_request_constraints = akamai.get_app_sec_api_request_constraints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_id=624913)\npulumi.export(\"apiConstraintsText\", api_request_constraints.output_text)\npulumi.export(\"apiConstraintsJson\", api_request_constraints.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var apisRequestConstraints = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecApiRequestConstraints.InvokeAsync(new Akamai.GetAppSecApiRequestConstraintsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ApisConstraintsText = apisRequestConstraints.Apply(apisRequestConstraints =\u003e apisRequestConstraints.OutputText);\n        this.ApisConstraintsJson = apisRequestConstraints.Apply(apisRequestConstraints =\u003e apisRequestConstraints.Json);\n        var apiRequestConstraints = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecApiRequestConstraints.InvokeAsync(new Akamai.GetAppSecApiRequestConstraintsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n            ApiId = 624913,\n        })));\n        this.ApiConstraintsText = apiRequestConstraints.Apply(apiRequestConstraints =\u003e apiRequestConstraints.OutputText);\n        this.ApiConstraintsJson = apiRequestConstraints.Apply(apiRequestConstraints =\u003e apiRequestConstraints.Json);\n    }\n\n    [Output(\"apisConstraintsText\")]\n    public Output\u003cstring\u003e ApisConstraintsText { get; set; }\n    [Output(\"apisConstraintsJson\")]\n    public Output\u003cstring\u003e ApisConstraintsJson { get; set; }\n    [Output(\"apiConstraintsText\")]\n    public Output\u003cstring\u003e ApiConstraintsText { get; set; }\n    [Output(\"apiConstraintsJson\")]\n    public Output\u003cstring\u003e ApiConstraintsJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tapisRequestConstraints, err := akamai.LookupAppSecApiRequestConstraints(ctx, \u0026GetAppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"apisConstraintsText\", apisRequestConstraints.OutputText)\n\t\tctx.Export(\"apisConstraintsJson\", apisRequestConstraints.Json)\n\t\tapiRequestConstraints, err := akamai.LookupAppSecApiRequestConstraints(ctx, \u0026GetAppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t\tApiId:            pulumi.IntRef(624913),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"apiConstraintsText\", apiRequestConstraints.OutputText)\n\t\tctx.Export(\"apiConstraintsJson\", apiRequestConstraints.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"apisConstraintsText\", apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.outputText()));\n        ctx.export(\"apisConstraintsJson\", apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.json()));\n        final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiId(624913)\n            .build());\n\n        ctx.export(\"apiConstraintsText\", apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.outputText()));\n        ctx.export(\"apiConstraintsJson\", apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  apisRequestConstraints:\n    Fn::Invoke:\n      Function: akamai:getAppSecApiRequestConstraints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n  apiRequestConstraints:\n    Fn::Invoke:\n      Function: akamai:getAppSecApiRequestConstraints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        apiId: 624913\noutputs:\n  apisConstraintsText: ${apisRequestConstraints.outputText}\n  apisConstraintsJson: ${apisRequestConstraints.json} # USE CASE: User wants to view the action associated with an API request constraint.\n  apiConstraintsText: ${apiRequestConstraints.outputText}\n  apiConstraintsJson: ${apiRequestConstraints.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.\n- `output_text`. Tabular report of the APIs, their constraints, and their actions.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecApiRequestConstraints.\n",
                "properties": {
                    "apiId": {
                        "type": "integer",
                        "description": ". Unique identifier of the API endpoint you want to return constraint information for.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API constraints.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API constraints.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecApiRequestConstraints.\n",
                "properties": {
                    "apiId": {
                        "type": "integer"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAttackGroups:getAppSecAttackGroups": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAttackGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group you want to return information for. If not included, information is returned for all your attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the attack group.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the attack group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAttackGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "attackGroupAction": {
                        "type": "string"
                    },
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attackGroupAction",
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists": {
            "description": "**Scopes**: Security configuration\n\nReturns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking. The returned information is described in the [BypassNetworkList members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#bypassnetworklist) section of the Application Security API.\n\nNote that this data source is only applicable to WAP (Web Application Protector) configurations.\n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst bypassNetworkLists = configuration.then(configuration =\u003e akamai.getAppSecBypassNetworkLists({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const bypassNetworkListsOutput = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.outputText);\nexport const bypassNetworkListsJson = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.json);\nexport const bypassNetworkListsIdList = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.bypassNetworkLists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nbypass_network_lists = akamai.get_app_sec_bypass_network_lists(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"bypassNetworkListsOutput\", bypass_network_lists.output_text)\npulumi.export(\"bypassNetworkListsJson\", bypass_network_lists.json)\npulumi.export(\"bypassNetworkListsIdList\", bypass_network_lists.bypass_network_lists)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var bypassNetworkLists = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecBypassNetworkLists.InvokeAsync(new Akamai.GetAppSecBypassNetworkListsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.BypassNetworkListsOutput = bypassNetworkLists.Apply(bypassNetworkLists =\u003e bypassNetworkLists.OutputText);\n        this.BypassNetworkListsJson = bypassNetworkLists.Apply(bypassNetworkLists =\u003e bypassNetworkLists.Json);\n        this.BypassNetworkListsIdList = bypassNetworkLists.Apply(bypassNetworkLists =\u003e bypassNetworkLists.BypassNetworkLists);\n    }\n\n    [Output(\"bypassNetworkListsOutput\")]\n    public Output\u003cstring\u003e BypassNetworkListsOutput { get; set; }\n    [Output(\"bypassNetworkListsJson\")]\n    public Output\u003cstring\u003e BypassNetworkListsJson { get; set; }\n    [Output(\"bypassNetworkListsIdList\")]\n    public Output\u003cstring\u003e BypassNetworkListsIdList { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbypassNetworkLists, err := akamai.GetAppSecBypassNetworkLists(ctx, \u0026GetAppSecBypassNetworkListsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"bypassNetworkListsOutput\", bypassNetworkLists.OutputText)\n\t\tctx.Export(\"bypassNetworkListsJson\", bypassNetworkLists.Json)\n\t\tctx.Export(\"bypassNetworkListsIdList\", bypassNetworkLists.BypassNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"bypassNetworkListsOutput\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.outputText()));\n        ctx.export(\"bypassNetworkListsJson\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.json()));\n        ctx.export(\"bypassNetworkListsIdList\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.bypassNetworkLists()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  bypassNetworkLists: # USE CASE: User wants to display returned data in a table.\n    Fn::Invoke:\n      Function: akamai:getAppSecBypassNetworkLists\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  bypassNetworkListsOutput: ${bypassNetworkLists.outputText}\n  bypassNetworkListsJson: ${bypassNetworkLists.json}\n  bypassNetworkListsIdList: ${bypassNetworkLists.bypassNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `bypass_network_list`. List of network IDs.\n- `json`. JSON-formatted list of information about the bypass networks.\n- `output_text`. Tabular report showing the bypass network list information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecBypassNetworkLists.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the bypass network lists.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecBypassNetworkLists.\n",
                "properties": {
                    "bypassNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "bypassNetworkLists",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecConfiguration:getAppSecConfiguration": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecConfiguration.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": ". Name of the security configuration you want to return information for. If not included, information is returned for all your security configurations.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "latestVersion": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "productionVersion": {
                        "type": "integer"
                    },
                    "stagingVersion": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "latestVersion",
                    "outputText",
                    "productionVersion",
                    "stagingVersion",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecConfigurationVersion:getAppSecConfigurationVersion": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecConfigurationVersion.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return version information for.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration you want to return information about. If not included, information about all the security configuration's versions is returned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecConfigurationVersion.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "latestVersion": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "productionStatus": {
                        "type": "string"
                    },
                    "stagingStatus": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "latestVersion",
                    "outputText",
                    "productionStatus",
                    "stagingStatus",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecContractsGroups:getAppSecContractsGroups": {
            "description": "**Scopes**: Contract; group\n\nReturns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy. The returned information for this data source is described in the [List contracts and groups](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getcontractsandgroupswithksdorwaf) of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst contractsGroups = akamai.getAppSecContractsGroups({\n    contractid: \"5-2WA382\",\n    groupid: 12198,\n});\nexport const contractsGroupsList = contractsGroups.then(contractsGroups =\u003e contractsGroups.outputText);\nexport const contractsGroupsJson = contractsGroups.then(contractsGroups =\u003e contractsGroups.json);\nexport const contractGroupsDefaultContractid = contractsGroups.then(contractsGroups =\u003e contractsGroups.defaultContractid);\nexport const contractGroupsDefaultGroupid = contractsGroups.then(contractsGroups =\u003e contractsGroups.defaultGroupid);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncontracts_groups = akamai.get_app_sec_contracts_groups(contractid=\"5-2WA382\",\n    groupid=12198)\npulumi.export(\"contractsGroupsList\", contracts_groups.output_text)\npulumi.export(\"contractsGroupsJson\", contracts_groups.json)\npulumi.export(\"contractGroupsDefaultContractid\", contracts_groups.default_contractid)\npulumi.export(\"contractGroupsDefaultGroupid\", contracts_groups.default_groupid)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var contractsGroups = Output.Create(Akamai.GetAppSecContractsGroups.InvokeAsync(new Akamai.GetAppSecContractsGroupsArgs\n        {\n            Contractid = \"5-2WA382\",\n            Groupid = 12198,\n        }));\n        this.ContractsGroupsList = contractsGroups.Apply(contractsGroups =\u003e contractsGroups.OutputText);\n        this.ContractsGroupsJson = contractsGroups.Apply(contractsGroups =\u003e contractsGroups.Json);\n        this.ContractGroupsDefaultContractid = contractsGroups.Apply(contractsGroups =\u003e contractsGroups.DefaultContractid);\n        this.ContractGroupsDefaultGroupid = contractsGroups.Apply(contractsGroups =\u003e contractsGroups.DefaultGroupid);\n    }\n\n    [Output(\"contractsGroupsList\")]\n    public Output\u003cstring\u003e ContractsGroupsList { get; set; }\n    [Output(\"contractsGroupsJson\")]\n    public Output\u003cstring\u003e ContractsGroupsJson { get; set; }\n    [Output(\"contractGroupsDefaultContractid\")]\n    public Output\u003cstring\u003e ContractGroupsDefaultContractid { get; set; }\n    [Output(\"contractGroupsDefaultGroupid\")]\n    public Output\u003cstring\u003e ContractGroupsDefaultGroupid { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcontractsGroups, err := akamai.GetAppSecContractsGroups(ctx, \u0026GetAppSecContractsGroupsArgs{\n\t\t\tContractid: pulumi.StringRef(\"5-2WA382\"),\n\t\t\tGroupid:    pulumi.IntRef(12198),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"contractsGroupsList\", contractsGroups.OutputText)\n\t\tctx.Export(\"contractsGroupsJson\", contractsGroups.Json)\n\t\tctx.Export(\"contractGroupsDefaultContractid\", contractsGroups.DefaultContractid)\n\t\tctx.Export(\"contractGroupsDefaultGroupid\", contractsGroups.DefaultGroupid)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()\n            .contractid(\"5-2WA382\")\n            .groupid(12198)\n            .build());\n\n        ctx.export(\"contractsGroupsList\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.outputText()));\n        ctx.export(\"contractsGroupsJson\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.json()));\n        ctx.export(\"contractGroupsDefaultContractid\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.defaultContractid()));\n        ctx.export(\"contractGroupsDefaultGroupid\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.defaultGroupid()));\n    }\n}\n```\n```yaml\nvariables:\n  contractsGroups: # USE CASE: User wants to display returned data in a table.\n    Fn::Invoke:\n      Function: akamai:getAppSecContractsGroups\n      Arguments:\n        contractid: 5-2WA382\n        groupid: 12198\noutputs:\n  contractsGroupsList: ${contractsGroups.outputText}\n  contractsGroupsJson: ${contractsGroups.json} # USE CASE: User wants to return all available contracts and contract groups.\n  contractGroupsDefaultContractid: ${contractsGroups.defaultContractid}\n  contractGroupsDefaultGroupid: ${contractsGroups.defaultGroupid}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of contract and group information.\n- `output_text`. Tabular report of contract and group information.\n- `default_contractid`. Default contract ID for the specified contract and group.\n- `default_groupid`. Default group ID for the specified contract and group.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecContractsGroups.\n",
                "properties": {
                    "contractid": {
                        "type": "string",
                        "description": ". Unique identifier of an Akamai contract. If not included, information is returned for all the Akamai contracts associated with your account.\n"
                    },
                    "groupid": {
                        "type": "integer",
                        "description": ". Unique identifier of a contract group. If not included, information is returned for all the groups associated with your account.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecContractsGroups.\n",
                "properties": {
                    "contractid": {
                        "type": "string"
                    },
                    "defaultContractid": {
                        "type": "string"
                    },
                    "defaultGroupid": {
                        "type": "integer"
                    },
                    "groupid": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "defaultContractid",
                    "defaultGroupid",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomDeny:getAppSecCustomDeny": {
            "description": "**Scopes**: Security configuration; custom deny\n\nReturns information about custom deny actions: the returned information is described in the [CustomDeny members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#63df3de3) section of the Application Security API. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customDenyList = configuration.then(configuration =\u003e akamai.getAppSecCustomDeny({\n    configId: configuration.configId,\n}));\nexport const customDenyListOutput = customDenyList.then(customDenyList =\u003e customDenyList.outputText);\nexport const customDenyListJson = customDenyList.then(customDenyList =\u003e customDenyList.json);\nconst customDeny = configuration.then(configuration =\u003e akamai.getAppSecCustomDeny({\n    configId: configuration.configId,\n    customDenyId: \"deny_custom_64386\",\n}));\nexport const customDenyJson = customDeny.then(customDeny =\u003e customDeny.json);\nexport const customDenyOutput = customDeny.then(customDeny =\u003e customDeny.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_deny_list = akamai.get_app_sec_custom_deny(config_id=configuration.config_id)\npulumi.export(\"customDenyListOutput\", custom_deny_list.output_text)\npulumi.export(\"customDenyListJson\", custom_deny_list.json)\ncustom_deny = akamai.get_app_sec_custom_deny(config_id=configuration.config_id,\n    custom_deny_id=\"deny_custom_64386\")\npulumi.export(\"customDenyJson\", custom_deny.json)\npulumi.export(\"customDenyOutput\", custom_deny.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var customDenyList = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomDeny.InvokeAsync(new Akamai.GetAppSecCustomDenyArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.CustomDenyListOutput = customDenyList.Apply(customDenyList =\u003e customDenyList.OutputText);\n        this.CustomDenyListJson = customDenyList.Apply(customDenyList =\u003e customDenyList.Json);\n        var customDeny = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomDeny.InvokeAsync(new Akamai.GetAppSecCustomDenyArgs\n        {\n            ConfigId = configuration.ConfigId,\n            CustomDenyId = \"deny_custom_64386\",\n        })));\n        this.CustomDenyJson = customDeny.Apply(customDeny =\u003e customDeny.Json);\n        this.CustomDenyOutput = customDeny.Apply(customDeny =\u003e customDeny.OutputText);\n    }\n\n    [Output(\"customDenyListOutput\")]\n    public Output\u003cstring\u003e CustomDenyListOutput { get; set; }\n    [Output(\"customDenyListJson\")]\n    public Output\u003cstring\u003e CustomDenyListJson { get; set; }\n    [Output(\"customDenyJson\")]\n    public Output\u003cstring\u003e CustomDenyJson { get; set; }\n    [Output(\"customDenyOutput\")]\n    public Output\u003cstring\u003e CustomDenyOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomDenyList, err := akamai.LookupAppSecCustomDeny(ctx, \u0026GetAppSecCustomDenyArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyListOutput\", customDenyList.OutputText)\n\t\tctx.Export(\"customDenyListJson\", customDenyList.Json)\n\t\tcustomDeny, err := akamai.LookupAppSecCustomDeny(ctx, \u0026GetAppSecCustomDenyArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomDenyId: pulumi.StringRef(\"deny_custom_64386\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyJson\", customDeny.Json)\n\t\tctx.Export(\"customDenyOutput\", customDeny.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customDenyListOutput\", customDenyList.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.outputText()));\n        ctx.export(\"customDenyListJson\", customDenyList.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.json()));\n        final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customDenyId(\"deny_custom_64386\")\n            .build());\n\n        ctx.export(\"customDenyJson\", customDeny.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.json()));\n        ctx.export(\"customDenyOutput\", customDeny.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customDenyList: # USE CASE: User wants to display the returned data in a table.\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomDeny\n      Arguments:\n        configId: ${configuration.configId}\n  customDeny:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomDeny\n      Arguments:\n        configId: ${configuration.configId}\n        customDenyId: deny_custom_64386\noutputs:\n  customDenyListOutput: ${customDenyList.outputText}\n  customDenyListJson: ${customDenyList.json} # USE CASE: User wants to view a specific custom deny associated with a security configuration.\n  customDenyJson: ${customDeny.json}\n  customDenyOutput: ${customDeny.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of custom deny information.\n- `output_text`. Tabular report of the custom deny information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomDeny.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom denies.\n"
                    },
                    "customDenyId": {
                        "type": "string",
                        "description": ". Unique identifier of the custom deny you want to return information for. If not included. information is returned for all your custom denies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomDeny.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customDenyId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomRuleActions:getAppSecCustomRuleActions": {
            "description": "**Scopes**: Security policy; custom rule\n\nRetrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren't part of Akamai's Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRuleActionsAppSecCustomRuleActions = configuration.then(configuration =\u003e akamai.getAppSecCustomRuleActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const customRuleActions = customRuleActionsAppSecCustomRuleActions.then(customRuleActionsAppSecCustomRuleActions =\u003e customRuleActionsAppSecCustomRuleActions.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rule_actions_app_sec_custom_rule_actions = akamai.get_app_sec_custom_rule_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"customRuleActions\", custom_rule_actions_app_sec_custom_rule_actions.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var customRuleActionsAppSecCustomRuleActions = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomRuleActions.InvokeAsync(new Akamai.GetAppSecCustomRuleActionsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.CustomRuleActions = customRuleActionsAppSecCustomRuleActions.Apply(customRuleActionsAppSecCustomRuleActions =\u003e customRuleActionsAppSecCustomRuleActions.OutputText);\n    }\n\n    [Output(\"customRuleActions\")]\n    public Output\u003cstring\u003e CustomRuleActions { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRuleActionsAppSecCustomRuleActions, err := akamai.GetAppSecCustomRuleActions(ctx, \u0026GetAppSecCustomRuleActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRuleActions\", customRuleActionsAppSecCustomRuleActions.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"customRuleActions\", customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -\u003e getAppSecCustomRuleActionsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRuleActionsAppSecCustomRuleActions:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomRuleActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  customRuleActions: ${customRuleActionsAppSecCustomRuleActions.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID, name, and action of the custom rules.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomRuleActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rules.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule you want to return information for. If not included, action information is returned for all your custom rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the custom rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomRuleActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customRuleId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomRules:getAppSecCustomRules": {
            "description": "**Scopes**: Security configuration; custom rule\n\nReturns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRules = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n}));\nexport const customRulesOutputText = customRules.then(customRules =\u003e customRules.outputText);\nexport const customRulesJson = customRules.then(customRules =\u003e customRules.json);\nexport const customRulesConfigId = customRules.then(customRules =\u003e customRules.configId);\nconst specificCustomRule = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n    customRuleId: 60029316,\n}));\nexport const specificCustomRuleJson = specificCustomRule.then(specificCustomRule =\u003e specificCustomRule.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rules = akamai.get_app_sec_custom_rules(config_id=configuration.config_id)\npulumi.export(\"customRulesOutputText\", custom_rules.output_text)\npulumi.export(\"customRulesJson\", custom_rules.json)\npulumi.export(\"customRulesConfigId\", custom_rules.config_id)\nspecific_custom_rule = akamai.get_app_sec_custom_rules(config_id=configuration.config_id,\n    custom_rule_id=60029316)\npulumi.export(\"specificCustomRuleJson\", specific_custom_rule.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var customRules = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomRules.InvokeAsync(new Akamai.GetAppSecCustomRulesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.CustomRulesOutputText = customRules.Apply(customRules =\u003e customRules.OutputText);\n        this.CustomRulesJson = customRules.Apply(customRules =\u003e customRules.Json);\n        this.CustomRulesConfigId = customRules.Apply(customRules =\u003e customRules.ConfigId);\n        var specificCustomRule = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecCustomRules.InvokeAsync(new Akamai.GetAppSecCustomRulesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            CustomRuleId = 60029316,\n        })));\n        this.SpecificCustomRuleJson = specificCustomRule.Apply(specificCustomRule =\u003e specificCustomRule.Json);\n    }\n\n    [Output(\"customRulesOutputText\")]\n    public Output\u003cstring\u003e CustomRulesOutputText { get; set; }\n    [Output(\"customRulesJson\")]\n    public Output\u003cstring\u003e CustomRulesJson { get; set; }\n    [Output(\"customRulesConfigId\")]\n    public Output\u003cstring\u003e CustomRulesConfigId { get; set; }\n    [Output(\"specificCustomRuleJson\")]\n    public Output\u003cstring\u003e SpecificCustomRuleJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRules, err := akamai.GetAppSecCustomRules(ctx, \u0026GetAppSecCustomRulesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRulesOutputText\", customRules.OutputText)\n\t\tctx.Export(\"customRulesJson\", customRules.Json)\n\t\tctx.Export(\"customRulesConfigId\", customRules.ConfigId)\n\t\tspecificCustomRule, err := akamai.GetAppSecCustomRules(ctx, \u0026GetAppSecCustomRulesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomRuleId: pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"specificCustomRuleJson\", specificCustomRule.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customRulesOutputText\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.outputText()));\n        ctx.export(\"customRulesJson\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n        ctx.export(\"customRulesConfigId\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.configId()));\n        final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customRuleId(\"60029316\")\n            .build());\n\n        ctx.export(\"specificCustomRuleJson\", specificCustomRule.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRules:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n  specificCustomRule:\n    Fn::Invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n        customRuleId: 60029316\noutputs:\n  customRulesOutputText: ${customRules.outputText}\n  customRulesJson: ${customRules.json}\n  customRulesConfigId: ${customRules.configId} # USE CASE: User wants to view a specific custom rule.\n  specificCustomRuleJson: ${specificCustomRule.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and name of the custom rule information.\n- `json`. JSON-formatted report of the custom rule information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rules.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule you want to return information for. If not included, information is returned for all your custom rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customRuleId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEval:getAppSecEval": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEval.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEval.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalGroups:getAppSecEvalGroups": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique identifier of the evaluation attack group you want to return information for. If not included, information is returned for all your evaluation attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation attack group.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation attack group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "attackGroupAction": {
                        "type": "string"
                    },
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attackGroupAction",
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalPenaltyBox:getAppSecEvalPenaltyBox": {
            "description": "**Scopes**: Security policy\n\n __ASE_Beta__.:\nReturns the penalty box settings for a security policy in evaluation mode - evaluation penalty box. \nWhen the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalPenaltyBox = configuration.then(configuration =\u003e akamai.getAppSecEvalPenaltyBox({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const evalPenaltyBoxAction = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.action);\nexport const evalPenaltyBoxEnabled = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.enabled);\nexport const evalPenaltyBoxText = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_penalty_box = akamai.get_app_sec_eval_penalty_box(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"evalPenaltyBoxAction\", eval_penalty_box.action)\npulumi.export(\"evalPenaltyBoxEnabled\", eval_penalty_box.enabled)\npulumi.export(\"evalPenaltyBoxText\", eval_penalty_box.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalPenaltyBox = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecEvalPenaltyBox.InvokeAsync(new Akamai.GetAppSecEvalPenaltyBoxArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.EvalPenaltyBoxAction = evalPenaltyBox.Apply(evalPenaltyBox =\u003e evalPenaltyBox.Action);\n        this.EvalPenaltyBoxEnabled = evalPenaltyBox.Apply(evalPenaltyBox =\u003e evalPenaltyBox.Enabled);\n        this.EvalPenaltyBoxText = evalPenaltyBox.Apply(evalPenaltyBox =\u003e evalPenaltyBox.OutputText);\n    }\n\n    [Output(\"evalPenaltyBoxAction\")]\n    public Output\u003cstring\u003e EvalPenaltyBoxAction { get; set; }\n    [Output(\"evalPenaltyBoxEnabled\")]\n    public Output\u003cstring\u003e EvalPenaltyBoxEnabled { get; set; }\n    [Output(\"evalPenaltyBoxText\")]\n    public Output\u003cstring\u003e EvalPenaltyBoxText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalPenaltyBox, err := akamai.LookupAppSecEvalPenaltyBox(ctx, \u0026GetAppSecEvalPenaltyBoxArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalPenaltyBoxAction\", evalPenaltyBox.Action)\n\t\tctx.Export(\"evalPenaltyBoxEnabled\", evalPenaltyBox.Enabled)\n\t\tctx.Export(\"evalPenaltyBoxText\", evalPenaltyBox.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"evalPenaltyBoxAction\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.action()));\n        ctx.export(\"evalPenaltyBoxEnabled\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.enabled()));\n        ctx.export(\"evalPenaltyBoxText\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  evalPenaltyBox:\n    Fn::Invoke:\n      Function: akamai:getAppSecEvalPenaltyBox\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  evalPenaltyBoxAction: ${evalPenaltyBox.action}\n  evalPenaltyBoxEnabled: ${evalPenaltyBox.enabled}\n  evalPenaltyBoxText: ${evalPenaltyBox.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the penalty box is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. The request is blocked.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.\n- `output_text`. Tabular report of evaluation penalty box protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalPenaltyBox.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalPenaltyBox.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "enabled",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalRules:getAppSecEvalRules": {
            "description": "**Scopes**: Security policy; evaluation rule\n\nReturns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalRule = configuration.then(configuration =\u003e akamai.getAppSecEvalRules({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n}));\nexport const evalRuleAction = evalRule.then(evalRule =\u003e evalRule.evalRuleAction);\nexport const conditionException = evalRule.then(evalRule =\u003e evalRule.conditionException);\nexport const json = evalRule.then(evalRule =\u003e evalRule.json);\nexport const outputText = evalRule.then(evalRule =\u003e evalRule.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_rule = akamai.get_app_sec_eval_rules(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316)\npulumi.export(\"evalRuleAction\", eval_rule.eval_rule_action)\npulumi.export(\"conditionException\", eval_rule.condition_exception)\npulumi.export(\"json\", eval_rule.json)\npulumi.export(\"outputText\", eval_rule.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var evalRule = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecEvalRules.InvokeAsync(new Akamai.GetAppSecEvalRulesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n            RuleId = 60029316,\n        })));\n        this.EvalRuleAction = evalRule.Apply(evalRule =\u003e evalRule.EvalRuleAction);\n        this.ConditionException = evalRule.Apply(evalRule =\u003e evalRule.ConditionException);\n        this.Json = evalRule.Apply(evalRule =\u003e evalRule.Json);\n        this.OutputText = evalRule.Apply(evalRule =\u003e evalRule.OutputText);\n    }\n\n    [Output(\"evalRuleAction\")]\n    public Output\u003cstring\u003e EvalRuleAction { get; set; }\n    [Output(\"conditionException\")]\n    public Output\u003cstring\u003e ConditionException { get; set; }\n    [Output(\"json\")]\n    public Output\u003cstring\u003e Json { get; set; }\n    [Output(\"outputText\")]\n    public Output\u003cstring\u003e OutputText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalRule, err := akamai.GetAppSecEvalRules(ctx, \u0026GetAppSecEvalRulesArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t\tRuleId:           pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalRuleAction\", evalRule.EvalRuleAction)\n\t\tctx.Export(\"conditionException\", evalRule.ConditionException)\n\t\tctx.Export(\"json\", evalRule.Json)\n\t\tctx.Export(\"outputText\", evalRule.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(\"60029316\")\n            .build());\n\n        ctx.export(\"evalRuleAction\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.evalRuleAction()));\n        ctx.export(\"conditionException\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.conditionException()));\n        ctx.export(\"json\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.json()));\n        ctx.export(\"outputText\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  evalRule:\n    Fn::Invoke:\n      Function: akamai:getAppSecEvalRules\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        ruleId: 60029316\noutputs:\n  evalRuleAction: ${evalRule.evalRuleAction}\n  conditionException: ${evalRule.conditionException}\n  json: ${evalRule.json}\n  outputText: ${evalRule.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `eval_rule_action`. Action taken anytime the evaluation rule is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. Reject the request.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `condition_exception`. Conditions and exceptions associated with the rule.\n- `json`. JSON-formatted list of the action and the condition-exception information for the rule. This output is only generated if the `rule_id` argument is included.\n- `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration running in evaluation mode.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the evaluation rule you want to return information for. If not included, information is returned for all your evaluation rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation rule.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalRules.\n",
                "properties": {
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "evalRuleAction": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "conditionException",
                    "configId",
                    "evalRuleAction",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecExportConfiguration:getAppSecExportConfiguration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst export = Promise.all([configuration, configuration]).then(([configuration, configuration1]) =\u003e akamai.getAppSecExportConfiguration({\n    configId: configuration.configId,\n    version: configuration1.latestVersion,\n    searches: [\n        \"securityPolicies\",\n        \"selectedHosts\",\n    ],\n}));\nexport const json = _export.then(_export =\u003e _export.json);\nexport const text = _export.then(_export =\u003e _export.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nexport = akamai.get_app_sec_export_configuration(config_id=configuration.config_id,\n    version=configuration.latest_version,\n    searches=[\n        \"securityPolicies\",\n        \"selectedHosts\",\n    ])\npulumi.export(\"json\", export.json)\npulumi.export(\"text\", export.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var export = Output.Tuple(configuration, configuration).Apply(values =\u003e\n        {\n            var configuration = values.Item1;\n            var configuration1 = values.Item2;\n            return Output.Create(Akamai.GetAppSecExportConfiguration.InvokeAsync(new Akamai.GetAppSecExportConfigurationArgs\n            {\n                ConfigId = configuration.ConfigId,\n                Version = configuration1.LatestVersion,\n                Searches = \n                {\n                    \"securityPolicies\",\n                    \"selectedHosts\",\n                },\n            }));\n        });\n        this.Json = export.Apply(export =\u003e export.Json);\n        this.Text = export.Apply(export =\u003e export.OutputText);\n    }\n\n    [Output(\"json\")]\n    public Output\u003cstring\u003e Json { get; set; }\n    [Output(\"text\")]\n    public Output\u003cstring\u003e Text { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texport, err := akamai.GetAppSecExportConfiguration(ctx, \u0026GetAppSecExportConfigurationArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tVersion:  configuration.LatestVersion,\n\t\t\tSearches: []string{\n\t\t\t\t\"securityPolicies\",\n\t\t\t\t\"selectedHosts\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"json\", export.Json)\n\t\tctx.Export(\"text\", export.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .version(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.latestVersion()))\n            .searches(            \n                \"securityPolicies\",\n                \"selectedHosts\")\n            .build());\n\n        ctx.export(\"json\", export.applyValue(getAppSecExportConfigurationResult -\u003e getAppSecExportConfigurationResult.json()));\n        ctx.export(\"text\", export.applyValue(getAppSecExportConfigurationResult -\u003e getAppSecExportConfigurationResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  export:\n    Fn::Invoke:\n      Function: akamai:getAppSecExportConfiguration\n      Arguments:\n        configId: ${configuration.configId}\n        version: ${configuration.latestVersion}\n        searches:\n          - securityPolicies\n          - selectedHosts\noutputs:\n  json: ${export.json}\n  text: ${export.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.\n- `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecExportConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    },
                    "searches": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of strings specifying the types of information to be retrieved. Note that there are two different ways to return data by using the `search` parameter. To return data in tabular format, use one or more of the following terms:\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecExportConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "searches": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecFailoverHostnames:getAppSecFailoverHostnames": {
            "description": "**Scopes**: Security configuration\n\nReturns a list of the failover hostnames in a configuration. The returned information is described in the [List failover hostnames](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getfailoverhostnames) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst failoverHostnamesAppSecFailoverHostnames = configuration.then(configuration =\u003e akamai.getAppSecFailoverHostnames({\n    configId: configuration.configId,\n}));\nexport const failoverHostnames = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.hostnames);\nexport const failoverHostnamesOutput = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.outputText);\nexport const failoverHostnamesJson = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nfailover_hostnames_app_sec_failover_hostnames = akamai.get_app_sec_failover_hostnames(config_id=configuration.config_id)\npulumi.export(\"failoverHostnames\", failover_hostnames_app_sec_failover_hostnames.hostnames)\npulumi.export(\"failoverHostnamesOutput\", failover_hostnames_app_sec_failover_hostnames.output_text)\npulumi.export(\"failoverHostnamesJson\", failover_hostnames_app_sec_failover_hostnames.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var failoverHostnamesAppSecFailoverHostnames = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecFailoverHostnames.InvokeAsync(new Akamai.GetAppSecFailoverHostnamesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.FailoverHostnames = failoverHostnamesAppSecFailoverHostnames.Apply(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.Hostnames);\n        this.FailoverHostnamesOutput = failoverHostnamesAppSecFailoverHostnames.Apply(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.OutputText);\n        this.FailoverHostnamesJson = failoverHostnamesAppSecFailoverHostnames.Apply(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.Json);\n    }\n\n    [Output(\"failoverHostnames\")]\n    public Output\u003cstring\u003e FailoverHostnames { get; set; }\n    [Output(\"failoverHostnamesOutput\")]\n    public Output\u003cstring\u003e FailoverHostnamesOutput { get; set; }\n    [Output(\"failoverHostnamesJson\")]\n    public Output\u003cstring\u003e FailoverHostnamesJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfailoverHostnamesAppSecFailoverHostnames, err := akamai.GetAppSecFailoverHostnames(ctx, \u0026GetAppSecFailoverHostnamesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"failoverHostnames\", failoverHostnamesAppSecFailoverHostnames.Hostnames)\n\t\tctx.Export(\"failoverHostnamesOutput\", failoverHostnamesAppSecFailoverHostnames.OutputText)\n\t\tctx.Export(\"failoverHostnamesJson\", failoverHostnamesAppSecFailoverHostnames.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"failoverHostnames\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.hostnames()));\n        ctx.export(\"failoverHostnamesOutput\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.outputText()));\n        ctx.export(\"failoverHostnamesJson\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  failoverHostnamesAppSecFailoverHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecFailoverHostnames\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  failoverHostnames: ${failoverHostnamesAppSecFailoverHostnames.hostnames}\n  failoverHostnamesOutput: ${failoverHostnamesAppSecFailoverHostnames.outputText}\n  failoverHostnamesJson: ${failoverHostnamesAppSecFailoverHostnames.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of the failover hostnames.\n- `json`. JSON-formatted list of the failover hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecFailoverHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the failover hosts.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecFailoverHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostnames",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverage:getAppSecHostnameCoverage": {
            "description": "**Scopes**: Individual account\n\nReturns information about the hostnames associated with your account; the returned data includes the hostname's protections, activation status, and other summary information. This information is described in the [HostnameCoverage members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getfailoverhostnames) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst hostnameCoverage = akamai.getAppSecHostnameCoverage({});\nexport const hostnameCoverageListJson = hostnameCoverage.then(hostnameCoverage =\u003e hostnameCoverage.json);\nexport const hostnameCoverageListOutput = hostnameCoverage.then(hostnameCoverage =\u003e hostnameCoverage.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nhostname_coverage = akamai.get_app_sec_hostname_coverage()\npulumi.export(\"hostnameCoverageListJson\", hostname_coverage.json)\npulumi.export(\"hostnameCoverageListOutput\", hostname_coverage.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var hostnameCoverage = Output.Create(Akamai.GetAppSecHostnameCoverage.InvokeAsync());\n        this.HostnameCoverageListJson = hostnameCoverage.Apply(hostnameCoverage =\u003e hostnameCoverage.Json);\n        this.HostnameCoverageListOutput = hostnameCoverage.Apply(hostnameCoverage =\u003e hostnameCoverage.OutputText);\n    }\n\n    [Output(\"hostnameCoverageListJson\")]\n    public Output\u003cstring\u003e HostnameCoverageListJson { get; set; }\n    [Output(\"hostnameCoverageListOutput\")]\n    public Output\u003cstring\u003e HostnameCoverageListOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thostnameCoverage, err := akamai.GetAppSecHostnameCoverage(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"hostnameCoverageListJson\", hostnameCoverage.Json)\n\t\tctx.Export(\"hostnameCoverageListOutput\", hostnameCoverage.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  hostnameCoverage:\n    Fn::Invoke:\n      Function: akamai:getAppSecHostnameCoverage\n      Arguments: {}\noutputs:\n  hostnameCoverageListJson: ${hostnameCoverage.json} # USE CASE: User wants to display the returned data in a table.\n  hostnameCoverageListOutput: ${hostnameCoverage.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the hostname coverage information.\n- `output_text`. Tabular report of the hostname coverage information.\n",
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverage.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverageMatchTargets:getAppSecHostnameCoverageMatchTargets": {
            "description": "**Scopes**: Hostname\n\nReturns information about the API and website match targets used to protect a hostname. The returned information is described in the [Get the hostname coverage match targets](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getfailoverhostnames) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargets = configuration.then(configuration =\u003e akamai.getAppSecHostnameCoverageMatchTargets({\n    configId: configuration.configId,\n    hostname: \"documentation.akamai.com\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_targets = akamai.get_app_sec_hostname_coverage_match_targets(config_id=configuration.config_id,\n    hostname=\"documentation.akamai.com\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var matchTargets = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecHostnameCoverageMatchTargets.InvokeAsync(new Akamai.GetAppSecHostnameCoverageMatchTargetsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            Hostname = \"documentation.akamai.com\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.GetAppSecHostnameCoverageMatchTargets(ctx, \u0026GetAppSecHostnameCoverageMatchTargetsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tHostname: \"documentation.akamai.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostname(\"documentation.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  matchTargets:\n    Fn::Invoke:\n      Function: akamai:getAppSecHostnameCoverageMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n        hostname: documentation.akamai.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the coverage information.\n- `output_text`. Tabular report of the coverage information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecHostnameCoverageMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostname": {
                        "type": "string",
                        "description": ". Name of the host you want to return information for. You can only return information for a single host and hostname at a time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverageMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverageOverlapping:getAppSecHostnameCoverageOverlapping": {
            "description": "**Scopes**: Security configuration; hostname\n\nReturns information about any other configuration versions that contain a hostname found in the current configuration version. The returned information is described in the [List hostname overlaps](https://developer.akamai.com/api/cloud_security/application_security/v1.html#gethostnamecoverageoverlapping) section of the Application Security API.\n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst test = configuration.then(configuration =\u003e akamai.getAppSecHostnameCoverageOverlapping({\n    configId: configuration.configId,\n    hostname: \"documentation.akamai.com\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ntest = akamai.get_app_sec_hostname_coverage_overlapping(config_id=configuration.config_id,\n    hostname=\"documentation.akamai.com\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var test = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecHostnameCoverageOverlapping.InvokeAsync(new Akamai.GetAppSecHostnameCoverageOverlappingArgs\n        {\n            ConfigId = configuration.ConfigId,\n            Hostname = \"documentation.akamai.com\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.GetAppSecHostnameCoverageOverlapping(ctx, \u0026GetAppSecHostnameCoverageOverlappingArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tHostname: \"documentation.akamai.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostname(\"documentation.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  test:\n    Fn::Invoke:\n      Function: akamai:getAppSecHostnameCoverageOverlapping\n      Arguments:\n        configId: ${configuration.configId}\n        hostname: documentation.akamai.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the overlap information.\n- `output_text`. Tabular report of the overlap information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecHostnameCoverageOverlapping.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": ". Name of the host you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverageOverlapping.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecIPGeo:getAppSecIPGeo": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ipGeo = configuration.then(configuration =\u003e akamai.getAppSecIPGeo({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const ipGeoMode = ipGeo.then(ipGeo =\u003e ipGeo.mode);\nexport const geoNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.geoNetworkLists);\nexport const ipNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.ipNetworkLists);\nexport const exceptionIpNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.exceptionIpNetworkLists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nip_geo = akamai.get_app_sec_ip_geo(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ipGeoMode\", ip_geo.mode)\npulumi.export(\"geoNetworkLists\", ip_geo.geo_network_lists)\npulumi.export(\"ipNetworkLists\", ip_geo.ip_network_lists)\npulumi.export(\"exceptionIpNetworkLists\", ip_geo.exception_ip_network_lists)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ipGeo = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecIPGeo.InvokeAsync(new Akamai.GetAppSecIPGeoArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.IpGeoMode = ipGeo.Apply(ipGeo =\u003e ipGeo.Mode);\n        this.GeoNetworkLists = ipGeo.Apply(ipGeo =\u003e ipGeo.GeoNetworkLists);\n        this.IpNetworkLists = ipGeo.Apply(ipGeo =\u003e ipGeo.IpNetworkLists);\n        this.ExceptionIpNetworkLists = ipGeo.Apply(ipGeo =\u003e ipGeo.ExceptionIpNetworkLists);\n    }\n\n    [Output(\"ipGeoMode\")]\n    public Output\u003cstring\u003e IpGeoMode { get; set; }\n    [Output(\"geoNetworkLists\")]\n    public Output\u003cstring\u003e GeoNetworkLists { get; set; }\n    [Output(\"ipNetworkLists\")]\n    public Output\u003cstring\u003e IpNetworkLists { get; set; }\n    [Output(\"exceptionIpNetworkLists\")]\n    public Output\u003cstring\u003e ExceptionIpNetworkLists { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeo, err := akamai.LookupAppSecIPGeo(ctx, \u0026GetAppSecIPGeoArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ipGeoMode\", ipGeo.Mode)\n\t\tctx.Export(\"geoNetworkLists\", ipGeo.GeoNetworkLists)\n\t\tctx.Export(\"ipNetworkLists\", ipGeo.IpNetworkLists)\n\t\tctx.Export(\"exceptionIpNetworkLists\", ipGeo.ExceptionIpNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ipGeoMode\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.mode()));\n        ctx.export(\"geoNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.geoNetworkLists()));\n        ctx.export(\"ipNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.ipNetworkLists()));\n        ctx.export(\"exceptionIpNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.exceptionIpNetworkLists()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view IP/Geo firewall settings.\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ipGeo:\n    Fn::Invoke:\n      Function: akamai:getAppSecIPGeo\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  ipGeoMode: ${ipGeo.mode}\n  geoNetworkLists: ${ipGeo.geoNetworkLists}\n  ipNetworkLists: ${ipGeo.ipNetworkLists}\n  exceptionIpNetworkLists: ${ipGeo.exceptionIpNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:\n  - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.\n  - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.\n- `geo_network_lists`. Network lists blocked or allowed based on geographic location.\n- `ip_network_lists`. Network lists blocked or allowed based on IP address.\n- `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.\n- `output_text`. Tabular report of the IP/Geo firewall settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecIPGeo.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo lists.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo lists. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecIPGeo.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "exceptionIpNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "geoNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "mode": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "exceptionIpNetworkLists",
                    "geoNetworkLists",
                    "ipNetworkLists",
                    "mode",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecMatchTargets:getAppSecMatchTargets": {
            "description": "**Scopes**: Security configuration; match target\n\nReturns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargetsAppSecMatchTargets = configuration.then(configuration =\u003e akamai.getAppSecMatchTargets({\n    configId: configuration.configId,\n}));\nexport const matchTargets = matchTargetsAppSecMatchTargets.then(matchTargetsAppSecMatchTargets =\u003e matchTargetsAppSecMatchTargets.outputText);\nconst matchTarget = configuration.then(configuration =\u003e akamai.getAppSecMatchTargets({\n    configId: configuration.configId,\n    matchTargetId: 2712938,\n}));\nexport const matchTargetOutput = matchTarget.then(matchTarget =\u003e matchTarget.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_targets_app_sec_match_targets = akamai.get_app_sec_match_targets(config_id=configuration.config_id)\npulumi.export(\"matchTargets\", match_targets_app_sec_match_targets.output_text)\nmatch_target = akamai.get_app_sec_match_targets(config_id=configuration.config_id,\n    match_target_id=2712938)\npulumi.export(\"matchTargetOutput\", match_target.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var matchTargetsAppSecMatchTargets = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecMatchTargets.InvokeAsync(new Akamai.GetAppSecMatchTargetsArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.MatchTargets = matchTargetsAppSecMatchTargets.Apply(matchTargetsAppSecMatchTargets =\u003e matchTargetsAppSecMatchTargets.OutputText);\n        var matchTarget = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecMatchTargets.InvokeAsync(new Akamai.GetAppSecMatchTargetsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            MatchTargetId = 2712938,\n        })));\n        this.MatchTargetOutput = matchTarget.Apply(matchTarget =\u003e matchTarget.OutputText);\n    }\n\n    [Output(\"matchTargets\")]\n    public Output\u003cstring\u003e MatchTargets { get; set; }\n    [Output(\"matchTargetOutput\")]\n    public Output\u003cstring\u003e MatchTargetOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmatchTargetsAppSecMatchTargets, err := akamai.GetAppSecMatchTargets(ctx, \u0026GetAppSecMatchTargetsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"matchTargets\", matchTargetsAppSecMatchTargets.OutputText)\n\t\tmatchTarget, err := akamai.GetAppSecMatchTargets(ctx, \u0026GetAppSecMatchTargetsArgs{\n\t\t\tConfigId:      configuration.ConfigId,\n\t\t\tMatchTargetId: pulumi.IntRef(2712938),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"matchTargetOutput\", matchTarget.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"matchTargets\", matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -\u003e getAppSecMatchTargetsResult.outputText()));\n        final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTargetId(\"2712938\")\n            .build());\n\n        ctx.export(\"matchTargetOutput\", matchTarget.applyValue(getAppSecMatchTargetsResult -\u003e getAppSecMatchTargetsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  matchTargetsAppSecMatchTargets:\n    Fn::Invoke:\n      Function: akamai:getAppSecMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n  matchTarget:\n    Fn::Invoke:\n      Function: akamai:getAppSecMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n        matchTargetId: 2712938\noutputs:\n  matchTargets: ${matchTargetsAppSecMatchTargets.outputText} # USE CASE: User wants to view a single match target.\n  matchTargetOutput: ${matchTarget.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and security policy ID of your match targets.\n- `json`. JSON-formatted list of the match target information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match targets.\n"
                    },
                    "matchTargetId": {
                        "type": "integer",
                        "description": ". Unique identifier of the match target you want to return information for. If not included, information is returned for all your match targets.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchTargetId": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecPenaltyBox:getAppSecPenaltyBox": {
            "description": "**Scopes**: Security policy\n\nReturns penalty box settings for the specified security policy. \nWhen the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst penaltyBox = configuration.then(configuration =\u003e akamai.getAppSecPenaltyBox({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const penaltyBoxAction = penaltyBox.then(penaltyBox =\u003e penaltyBox.action);\nexport const penaltyBoxEnabled = penaltyBox.then(penaltyBox =\u003e penaltyBox.enabled);\nexport const penaltyBoxText = penaltyBox.then(penaltyBox =\u003e penaltyBox.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npenalty_box = akamai.get_app_sec_penalty_box(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"penaltyBoxAction\", penalty_box.action)\npulumi.export(\"penaltyBoxEnabled\", penalty_box.enabled)\npulumi.export(\"penaltyBoxText\", penalty_box.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var penaltyBox = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecPenaltyBox.InvokeAsync(new Akamai.GetAppSecPenaltyBoxArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.PenaltyBoxAction = penaltyBox.Apply(penaltyBox =\u003e penaltyBox.Action);\n        this.PenaltyBoxEnabled = penaltyBox.Apply(penaltyBox =\u003e penaltyBox.Enabled);\n        this.PenaltyBoxText = penaltyBox.Apply(penaltyBox =\u003e penaltyBox.OutputText);\n    }\n\n    [Output(\"penaltyBoxAction\")]\n    public Output\u003cstring\u003e PenaltyBoxAction { get; set; }\n    [Output(\"penaltyBoxEnabled\")]\n    public Output\u003cstring\u003e PenaltyBoxEnabled { get; set; }\n    [Output(\"penaltyBoxText\")]\n    public Output\u003cstring\u003e PenaltyBoxText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpenaltyBox, err := akamai.LookupAppSecPenaltyBox(ctx, \u0026GetAppSecPenaltyBoxArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"penaltyBoxAction\", penaltyBox.Action)\n\t\tctx.Export(\"penaltyBoxEnabled\", penaltyBox.Enabled)\n\t\tctx.Export(\"penaltyBoxText\", penaltyBox.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"penaltyBoxAction\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.action()));\n        ctx.export(\"penaltyBoxEnabled\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.enabled()));\n        ctx.export(\"penaltyBoxText\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  penaltyBox:\n    Fn::Invoke:\n      Function: akamai:getAppSecPenaltyBox\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  penaltyBoxAction: ${penaltyBox.action}\n  penaltyBoxEnabled: ${penaltyBox.enabled}\n  penaltyBoxText: ${penaltyBox.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the penalty box is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. The request is blocked.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.\n- `output_text`. Tabular report of penalty box protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecPenaltyBox.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the penalty box settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the penalty box settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecPenaltyBox.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "enabled",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRatePolicies:getAppSecRatePolicies": {
            "description": "**Scopes**: Security configuration; rate policy\n\nReturns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.\n\n**Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicies = configuration.then(configuration =\u003e akamai.getAppSecRatePolicies({\n    configId: configuration.configId,\n}));\nexport const ratePoliciesOutput = ratePolicies.then(ratePolicies =\u003e ratePolicies.outputText);\nexport const ratePoliciesJson = ratePolicies.then(ratePolicies =\u003e ratePolicies.json);\nconst ratePolicy = configuration.then(configuration =\u003e akamai.getAppSecRatePolicies({\n    configId: configuration.configId,\n    ratePolicyId: 122149,\n}));\nexport const ratePolicyJson = ratePolicy.then(ratePolicy =\u003e ratePolicy.json);\nexport const ratePolicyOutput = ratePolicy.then(ratePolicy =\u003e ratePolicy.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policies = akamai.get_app_sec_rate_policies(config_id=configuration.config_id)\npulumi.export(\"ratePoliciesOutput\", rate_policies.output_text)\npulumi.export(\"ratePoliciesJson\", rate_policies.json)\nrate_policy = akamai.get_app_sec_rate_policies(config_id=configuration.config_id,\n    rate_policy_id=122149)\npulumi.export(\"ratePolicyJson\", rate_policy.json)\npulumi.export(\"ratePolicyOutput\", rate_policy.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ratePolicies = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecRatePolicies.InvokeAsync(new Akamai.GetAppSecRatePoliciesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.RatePoliciesOutput = ratePolicies.Apply(ratePolicies =\u003e ratePolicies.OutputText);\n        this.RatePoliciesJson = ratePolicies.Apply(ratePolicies =\u003e ratePolicies.Json);\n        var ratePolicy = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecRatePolicies.InvokeAsync(new Akamai.GetAppSecRatePoliciesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            RatePolicyId = 122149,\n        })));\n        this.RatePolicyJson = ratePolicy.Apply(ratePolicy =\u003e ratePolicy.Json);\n        this.RatePolicyOutput = ratePolicy.Apply(ratePolicy =\u003e ratePolicy.OutputText);\n    }\n\n    [Output(\"ratePoliciesOutput\")]\n    public Output\u003cstring\u003e RatePoliciesOutput { get; set; }\n    [Output(\"ratePoliciesJson\")]\n    public Output\u003cstring\u003e RatePoliciesJson { get; set; }\n    [Output(\"ratePolicyJson\")]\n    public Output\u003cstring\u003e RatePolicyJson { get; set; }\n    [Output(\"ratePolicyOutput\")]\n    public Output\u003cstring\u003e RatePolicyOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicies, err := akamai.GetAppSecRatePolicies(ctx, \u0026GetAppSecRatePoliciesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePoliciesOutput\", ratePolicies.OutputText)\n\t\tctx.Export(\"ratePoliciesJson\", ratePolicies.Json)\n\t\tratePolicy, err := akamai.GetAppSecRatePolicies(ctx, \u0026GetAppSecRatePoliciesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tRatePolicyId: pulumi.IntRef(122149),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyJson\", ratePolicy.Json)\n\t\tctx.Export(\"ratePolicyOutput\", ratePolicy.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"ratePoliciesOutput\", ratePolicies.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.outputText()));\n        ctx.export(\"ratePoliciesJson\", ratePolicies.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.json()));\n        final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicyId(\"122149\")\n            .build());\n\n        ctx.export(\"ratePolicyJson\", ratePolicy.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.json()));\n        ctx.export(\"ratePolicyOutput\", ratePolicy.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ratePolicies:\n    Fn::Invoke:\n      Function: akamai:getAppSecRatePolicies\n      Arguments:\n        configId: ${configuration.configId}\n  ratePolicy:\n    Fn::Invoke:\n      Function: akamai:getAppSecRatePolicies\n      Arguments:\n        configId: ${configuration.configId}\n        ratePolicyId: 122149\noutputs:\n  ratePoliciesOutput: ${ratePolicies.outputText}\n  ratePoliciesJson: ${ratePolicies.json} # USE CASE: User wants to see a specific rate policy.\n  ratePolicyJson: ${ratePolicy.json}\n  ratePolicyOutput: ${ratePolicy.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and name of the rate policies.\n- `json`. JSON-formatted list of the rate policy information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRatePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policies.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy you want to return information for. If not included, information is returned for all your rate policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRatePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ratePolicyId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRatePolicyActions:getAppSecRatePolicyActions": {
            "description": "**Scopes**: Security policy; rate policy\n\nReturns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.\n\n**Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicyActionsAppSecRatePolicyActions = configuration.then(configuration =\u003e akamai.getAppSecRatePolicyActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const ratePolicyActions = ratePolicyActionsAppSecRatePolicyActions.then(ratePolicyActionsAppSecRatePolicyActions =\u003e ratePolicyActionsAppSecRatePolicyActions.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policy_actions_app_sec_rate_policy_actions = akamai.get_app_sec_rate_policy_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ratePolicyActions\", rate_policy_actions_app_sec_rate_policy_actions.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var ratePolicyActionsAppSecRatePolicyActions = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecRatePolicyActions.InvokeAsync(new Akamai.GetAppSecRatePolicyActionsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.RatePolicyActions = ratePolicyActionsAppSecRatePolicyActions.Apply(ratePolicyActionsAppSecRatePolicyActions =\u003e ratePolicyActionsAppSecRatePolicyActions.OutputText);\n    }\n\n    [Output(\"ratePolicyActions\")]\n    public Output\u003cstring\u003e RatePolicyActions { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicyActionsAppSecRatePolicyActions, err := akamai.GetAppSecRatePolicyActions(ctx, \u0026GetAppSecRatePolicyActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyActions\", ratePolicyActionsAppSecRatePolicyActions.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ratePolicyActions\", ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -\u003e getAppSecRatePolicyActionsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ratePolicyActionsAppSecRatePolicyActions:\n    Fn::Invoke:\n      Function: akamai:getAppSecRatePolicyActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  ratePolicyActions: ${ratePolicyActionsAppSecRatePolicyActions.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRatePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policies and rate policy actions.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy you want to return action information for. If not included, action information is returned for all your rate policies.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate policies and rate policy actions.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRatePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ratePolicyId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions": {
            "description": "## akamai.getAppSecReputationProfileActions\n\n**Scopes**: Security policy; reputation profile\n\nReturns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfileActions = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const reputationProfileActionsText = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.outputText);\nexport const reputationProfileActionsJson = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.json);\nconst reputationProfileActions2AppSecReputationProfileActions = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    reputationProfileId: 12345,\n}));\nexport const reputationProfileActions2 = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.action);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"reputationProfileActionsText\", reputation_profile_actions.output_text)\npulumi.export(\"reputationProfileActionsJson\", reputation_profile_actions.json)\nreputation_profile_actions2_app_sec_reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    reputation_profile_id=12345)\npulumi.export(\"reputationProfileActions2\", reputation_profile_actions.action)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var reputationProfileActions = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecReputationProfileActions.InvokeAsync(new Akamai.GetAppSecReputationProfileActionsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ReputationProfileActionsText = reputationProfileActions.Apply(reputationProfileActions =\u003e reputationProfileActions.OutputText);\n        this.ReputationProfileActionsJson = reputationProfileActions.Apply(reputationProfileActions =\u003e reputationProfileActions.Json);\n        var reputationProfileActions2AppSecReputationProfileActions = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecReputationProfileActions.InvokeAsync(new Akamai.GetAppSecReputationProfileActionsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n            ReputationProfileId = 12345,\n        })));\n        this.ReputationProfileActions2 = reputationProfileActions.Apply(reputationProfileActions =\u003e reputationProfileActions.Action);\n    }\n\n    [Output(\"reputationProfileActionsText\")]\n    public Output\u003cstring\u003e ReputationProfileActionsText { get; set; }\n    [Output(\"reputationProfileActionsJson\")]\n    public Output\u003cstring\u003e ReputationProfileActionsJson { get; set; }\n    [Output(\"reputationProfileActions2\")]\n    public Output\u003cstring\u003e ReputationProfileActions2 { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfileActions, err := akamai.GetAppSecReputationProfileActions(ctx, \u0026GetAppSecReputationProfileActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileActionsText\", reputationProfileActions.OutputText)\n\t\tctx.Export(\"reputationProfileActionsJson\", reputationProfileActions.Json)\n\t\t_, err = akamai.GetAppSecReputationProfileActions(ctx, \u0026GetAppSecReputationProfileActionsArgs{\n\t\t\tConfigId:            configuration.ConfigId,\n\t\t\tSecurityPolicyId:    \"gms1_134637\",\n\t\t\tReputationProfileId: pulumi.IntRef(12345),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileActions2\", reputationProfileActions.Action)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"reputationProfileActionsText\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.outputText()));\n        ctx.export(\"reputationProfileActionsJson\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.json()));\n        final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .reputationProfileId(\"12345\")\n            .build());\n\n        ctx.export(\"reputationProfileActions2\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.action()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationProfileActions:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfileActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n  reputationProfileActions2AppSecReputationProfileActions:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfileActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        reputationProfileId: 12345\noutputs:\n  reputationProfileActionsText: ${reputationProfileActions.outputText}\n  reputationProfileActionsJson: ${reputationProfileActions.json} # USE CASE: User wants to view the action for a specific reputation profile.\n  reputationProfileActions2: ${reputationProfileActions.action}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the reputation profile is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. Block the request.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `json`. JSON-formatted report of the reputation profile action information.\n- `output_text`. Tabular report of the reputation profile action information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfileActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profiles.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profiles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfileActions.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "reputationProfileId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfileAnalysis:getAppSecReputationProfileAnalysis": {
            "description": "**Scopes**: Security policy\n\nReturns information about the following two reputation analysis settings:\n\n- `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.\n- `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.\n\nThe returned information is described in the [ReputationAnalysis members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#f06bb20c) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationAnalysis = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileAnalysis({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const reputationAnalysisText = reputationAnalysis.then(reputationAnalysis =\u003e reputationAnalysis.outputText);\nexport const reputationAnalysisJson = reputationAnalysis.then(reputationAnalysis =\u003e reputationAnalysis.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_analysis = akamai.get_app_sec_reputation_profile_analysis(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"reputationAnalysisText\", reputation_analysis.output_text)\npulumi.export(\"reputationAnalysisJson\", reputation_analysis.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var reputationAnalysis = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecReputationProfileAnalysis.InvokeAsync(new Akamai.GetAppSecReputationProfileAnalysisArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ReputationAnalysisText = reputationAnalysis.Apply(reputationAnalysis =\u003e reputationAnalysis.OutputText);\n        this.ReputationAnalysisJson = reputationAnalysis.Apply(reputationAnalysis =\u003e reputationAnalysis.Json);\n    }\n\n    [Output(\"reputationAnalysisText\")]\n    public Output\u003cstring\u003e ReputationAnalysisText { get; set; }\n    [Output(\"reputationAnalysisJson\")]\n    public Output\u003cstring\u003e ReputationAnalysisJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationAnalysis, err := akamai.LookupAppSecReputationProfileAnalysis(ctx, \u0026GetAppSecReputationProfileAnalysisArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationAnalysisText\", reputationAnalysis.OutputText)\n\t\tctx.Export(\"reputationAnalysisJson\", reputationAnalysis.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"reputationAnalysisText\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.outputText()));\n        ctx.export(\"reputationAnalysisJson\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationAnalysis:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfileAnalysis\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  reputationAnalysisText: ${reputationAnalysis.outputText}\n  reputationAnalysisJson: ${reputationAnalysis.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the reputation analysis settings.\n- `output_text`. Tabular report showing the reputation analysis settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfileAnalysis.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfileAnalysis.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfiles:getAppSecReputationProfiles": {
            "description": "**Scopes**: Security configuration; reputation profile\n\nReturns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfiles = configuration.then(configuration =\u003e akamai.getAppSecReputationProfiles({\n    configId: configuration.configId,\n}));\nexport const reputationProfilesOutput = reputationProfiles.then(reputationProfiles =\u003e reputationProfiles.outputText);\nexport const reputationProfilesJson = reputationProfiles.then(reputationProfiles =\u003e reputationProfiles.json);\nconst reputationProfile = configuration.then(configuration =\u003e akamai.getAppSecReputationProfiles({\n    configId: configuration.configId,\n    reputationProfileId: 12345,\n}));\nexport const reputationProfileJson = reputationProfile.then(reputationProfile =\u003e reputationProfile.json);\nexport const reputationProfileOutput = reputationProfile.then(reputationProfile =\u003e reputationProfile.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profiles = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id)\npulumi.export(\"reputationProfilesOutput\", reputation_profiles.output_text)\npulumi.export(\"reputationProfilesJson\", reputation_profiles.json)\nreputation_profile = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id,\n    reputation_profile_id=12345)\npulumi.export(\"reputationProfileJson\", reputation_profile.json)\npulumi.export(\"reputationProfileOutput\", reputation_profile.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var reputationProfiles = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecReputationProfiles.InvokeAsync(new Akamai.GetAppSecReputationProfilesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.ReputationProfilesOutput = reputationProfiles.Apply(reputationProfiles =\u003e reputationProfiles.OutputText);\n        this.ReputationProfilesJson = reputationProfiles.Apply(reputationProfiles =\u003e reputationProfiles.Json);\n        var reputationProfile = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecReputationProfiles.InvokeAsync(new Akamai.GetAppSecReputationProfilesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            ReputationProfileId = 12345,\n        })));\n        this.ReputationProfileJson = reputationProfile.Apply(reputationProfile =\u003e reputationProfile.Json);\n        this.ReputationProfileOutput = reputationProfile.Apply(reputationProfile =\u003e reputationProfile.OutputText);\n    }\n\n    [Output(\"reputationProfilesOutput\")]\n    public Output\u003cstring\u003e ReputationProfilesOutput { get; set; }\n    [Output(\"reputationProfilesJson\")]\n    public Output\u003cstring\u003e ReputationProfilesJson { get; set; }\n    [Output(\"reputationProfileJson\")]\n    public Output\u003cstring\u003e ReputationProfileJson { get; set; }\n    [Output(\"reputationProfileOutput\")]\n    public Output\u003cstring\u003e ReputationProfileOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfiles, err := akamai.GetAppSecReputationProfiles(ctx, \u0026GetAppSecReputationProfilesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfilesOutput\", reputationProfiles.OutputText)\n\t\tctx.Export(\"reputationProfilesJson\", reputationProfiles.Json)\n\t\treputationProfile, err := akamai.GetAppSecReputationProfiles(ctx, \u0026GetAppSecReputationProfilesArgs{\n\t\t\tConfigId:            configuration.ConfigId,\n\t\t\tReputationProfileId: pulumi.IntRef(12345),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileJson\", reputationProfile.Json)\n\t\tctx.Export(\"reputationProfileOutput\", reputationProfile.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"reputationProfilesOutput\", reputationProfiles.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.outputText()));\n        ctx.export(\"reputationProfilesJson\", reputationProfiles.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.json()));\n        final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .reputationProfileId(\"12345\")\n            .build());\n\n        ctx.export(\"reputationProfileJson\", reputationProfile.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.json()));\n        ctx.export(\"reputationProfileOutput\", reputationProfile.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view all the reputation profiles associated with a security configuration.\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationProfiles:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfiles\n      Arguments:\n        configId: ${configuration.configId}\n  reputationProfile:\n    Fn::Invoke:\n      Function: akamai:getAppSecReputationProfiles\n      Arguments:\n        configId: ${configuration.configId}\n        reputationProfileId: 12345\noutputs:\n  reputationProfilesOutput: ${reputationProfiles.outputText}\n  reputationProfilesJson: ${reputationProfiles.json} # USE CASE: User wants to view a specific reputation profile associated with a given configuration\n  reputationProfileJson: ${reputationProfile.json}\n  reputationProfileOutput: ${reputationProfile.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report of the details about the specified reputation profile or profiles.\n- `json`. JSON-formatted report of the details about the specified reputation profile or profiles.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfiles.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profiles.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfiles.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "reputationProfileId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRuleUpgradeDetails:getAppSecRuleUpgradeDetails": {
            "description": "**Scopes**: Security policy\n\nReturns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst upgradeDetails = configuration.then(configuration =\u003e akamai.getAppSecRuleUpgradeDetails({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const upgradeDetailsText = upgradeDetails.then(upgradeDetails =\u003e upgradeDetails.outputText);\nexport const upgradeDetailsJson = upgradeDetails.then(upgradeDetails =\u003e upgradeDetails.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nupgrade_details = akamai.get_app_sec_rule_upgrade_details(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"upgradeDetailsText\", upgrade_details.output_text)\npulumi.export(\"upgradeDetailsJson\", upgrade_details.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var upgradeDetails = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecRuleUpgradeDetails.InvokeAsync(new Akamai.GetAppSecRuleUpgradeDetailsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.UpgradeDetailsText = upgradeDetails.Apply(upgradeDetails =\u003e upgradeDetails.OutputText);\n        this.UpgradeDetailsJson = upgradeDetails.Apply(upgradeDetails =\u003e upgradeDetails.Json);\n    }\n\n    [Output(\"upgradeDetailsText\")]\n    public Output\u003cstring\u003e UpgradeDetailsText { get; set; }\n    [Output(\"upgradeDetailsJson\")]\n    public Output\u003cstring\u003e UpgradeDetailsJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tupgradeDetails, err := akamai.GetAppSecRuleUpgradeDetails(ctx, \u0026GetAppSecRuleUpgradeDetailsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"upgradeDetailsText\", upgradeDetails.OutputText)\n\t\tctx.Export(\"upgradeDetailsJson\", upgradeDetails.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"upgradeDetailsText\", upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -\u003e getAppSecRuleUpgradeDetailsResult.outputText()));\n        ctx.export(\"upgradeDetailsJson\", upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -\u003e getAppSecRuleUpgradeDetailsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  upgradeDetails:\n    Fn::Invoke:\n      Function: akamai:getAppSecRuleUpgradeDetails\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  upgradeDetailsText: ${upgradeDetails.outputText}\n  upgradeDetailsJson: ${upgradeDetails.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.\n- `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRuleUpgradeDetails.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Sets.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Sets.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRuleUpgradeDetails.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRules:getAppSecRules": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rules.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the Kona Rule Set rule you want to return information for. If not included, information is returned for all your KRS rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRules.\n",
                "properties": {
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ruleAction": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "ruleAction",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSecurityPolicy:getAppSecSecurityPolicy": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSecurityPolicy.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policies.\n- `security_policy_name`. (Optional). Name of the security policy you want to return information for (be sure to reference the policy name and not the policy ID). If not included, information is returned for all your security policies.\n"
                    },
                    "securityPolicyName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSecurityPolicy.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "securityPolicyIdLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "securityPolicyName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "securityPolicyIdLists",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSecurityPolicyProtections:getAppSecSecurityPolicyProtections": {
            "description": "**Scopes**: Security policy\n\nReturns information about the protections in effect for the specified security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protections = configuration.then(configuration =\u003e akamai.getAppSecSecurityPolicyProtections({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const protectionsJson = protections.then(protections =\u003e protections.json);\nexport const protectionsApplyApiConstraints = protections.then(protections =\u003e protections.applyApiConstraints);\nexport const protectionsApplyApplicationLayerControls = protections.then(protections =\u003e protections.applyApplicationLayerControls);\nexport const protectionsApplyBotmanControls = protections.then(protections =\u003e protections.applyBotmanControls);\nexport const protectionsApplyNetworkLayerControls = protections.then(protections =\u003e protections.applyNetworkLayerControls);\nexport const protectionsApplyRateControls = protections.then(protections =\u003e protections.applyRateControls);\nexport const protectionsApplyReputationControls = protections.then(protections =\u003e protections.applyReputationControls);\nexport const protectionsApplySlowPostControls = protections.then(protections =\u003e protections.applySlowPostControls);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotections = akamai.get_app_sec_security_policy_protections(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"protectionsJson\", protections.json)\npulumi.export(\"protectionsApplyApiConstraints\", protections.apply_api_constraints)\npulumi.export(\"protectionsApplyApplicationLayerControls\", protections.apply_application_layer_controls)\npulumi.export(\"protectionsApplyBotmanControls\", protections.apply_botman_controls)\npulumi.export(\"protectionsApplyNetworkLayerControls\", protections.apply_network_layer_controls)\npulumi.export(\"protectionsApplyRateControls\", protections.apply_rate_controls)\npulumi.export(\"protectionsApplyReputationControls\", protections.apply_reputation_controls)\npulumi.export(\"protectionsApplySlowPostControls\", protections.apply_slow_post_controls)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var protections = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecSecurityPolicyProtections.InvokeAsync(new Akamai.GetAppSecSecurityPolicyProtectionsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ProtectionsJson = protections.Apply(protections =\u003e protections.Json);\n        this.ProtectionsApplyApiConstraints = protections.Apply(protections =\u003e protections.ApplyApiConstraints);\n        this.ProtectionsApplyApplicationLayerControls = protections.Apply(protections =\u003e protections.ApplyApplicationLayerControls);\n        this.ProtectionsApplyBotmanControls = protections.Apply(protections =\u003e protections.ApplyBotmanControls);\n        this.ProtectionsApplyNetworkLayerControls = protections.Apply(protections =\u003e protections.ApplyNetworkLayerControls);\n        this.ProtectionsApplyRateControls = protections.Apply(protections =\u003e protections.ApplyRateControls);\n        this.ProtectionsApplyReputationControls = protections.Apply(protections =\u003e protections.ApplyReputationControls);\n        this.ProtectionsApplySlowPostControls = protections.Apply(protections =\u003e protections.ApplySlowPostControls);\n    }\n\n    [Output(\"protectionsJson\")]\n    public Output\u003cstring\u003e ProtectionsJson { get; set; }\n    [Output(\"protectionsApplyApiConstraints\")]\n    public Output\u003cstring\u003e ProtectionsApplyApiConstraints { get; set; }\n    [Output(\"protectionsApplyApplicationLayerControls\")]\n    public Output\u003cstring\u003e ProtectionsApplyApplicationLayerControls { get; set; }\n    [Output(\"protectionsApplyBotmanControls\")]\n    public Output\u003cstring\u003e ProtectionsApplyBotmanControls { get; set; }\n    [Output(\"protectionsApplyNetworkLayerControls\")]\n    public Output\u003cstring\u003e ProtectionsApplyNetworkLayerControls { get; set; }\n    [Output(\"protectionsApplyRateControls\")]\n    public Output\u003cstring\u003e ProtectionsApplyRateControls { get; set; }\n    [Output(\"protectionsApplyReputationControls\")]\n    public Output\u003cstring\u003e ProtectionsApplyReputationControls { get; set; }\n    [Output(\"protectionsApplySlowPostControls\")]\n    public Output\u003cstring\u003e ProtectionsApplySlowPostControls { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprotections, err := akamai.GetAppSecSecurityPolicyProtections(ctx, \u0026GetAppSecSecurityPolicyProtectionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"protectionsJson\", protections.Json)\n\t\tctx.Export(\"protectionsApplyApiConstraints\", protections.ApplyApiConstraints)\n\t\tctx.Export(\"protectionsApplyApplicationLayerControls\", protections.ApplyApplicationLayerControls)\n\t\tctx.Export(\"protectionsApplyBotmanControls\", protections.ApplyBotmanControls)\n\t\tctx.Export(\"protectionsApplyNetworkLayerControls\", protections.ApplyNetworkLayerControls)\n\t\tctx.Export(\"protectionsApplyRateControls\", protections.ApplyRateControls)\n\t\tctx.Export(\"protectionsApplyReputationControls\", protections.ApplyReputationControls)\n\t\tctx.Export(\"protectionsApplySlowPostControls\", protections.ApplySlowPostControls)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"protectionsJson\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.json()));\n        ctx.export(\"protectionsApplyApiConstraints\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));\n        ctx.export(\"protectionsApplyApplicationLayerControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));\n        ctx.export(\"protectionsApplyBotmanControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));\n        ctx.export(\"protectionsApplyNetworkLayerControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));\n        ctx.export(\"protectionsApplyRateControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyRateControls()));\n        ctx.export(\"protectionsApplyReputationControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));\n        ctx.export(\"protectionsApplySlowPostControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  protections:\n    Fn::Invoke:\n      Function: akamai:getAppSecSecurityPolicyProtections\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  protectionsJson: ${protections.json}\n  protectionsApplyApiConstraints: ${protections.applyApiConstraints}\n  protectionsApplyApplicationLayerControls: ${protections.applyApplicationLayerControls}\n  protectionsApplyBotmanControls: ${protections.applyBotmanControls}\n  protectionsApplyNetworkLayerControls: ${protections.applyNetworkLayerControls}\n  protectionsApplyRateControls: ${protections.applyRateControls}\n  protectionsApplyReputationControls: ${protections.applyReputationControls}\n  protectionsApplySlowPostControls: ${protections.applySlowPostControls}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.\n- `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.\n- `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.\n- `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.\n- `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.\n- `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.\n- `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.\n- `json`. JSON-formatted list showing the status of the protection settings.\n- `output_text`. Tabular report showing the status of the protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSecurityPolicyProtections.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policy protections.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy you want to return protections information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSecurityPolicyProtections.\n",
                "properties": {
                    "applyApiConstraints": {
                        "type": "boolean"
                    },
                    "applyApplicationLayerControls": {
                        "type": "boolean"
                    },
                    "applyBotmanControls": {
                        "type": "boolean"
                    },
                    "applyNetworkLayerControls": {
                        "type": "boolean"
                    },
                    "applyRateControls": {
                        "type": "boolean"
                    },
                    "applyReputationControls": {
                        "type": "boolean"
                    },
                    "applySlowPostControls": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "applyApiConstraints",
                    "applyApplicationLayerControls",
                    "applyBotmanControls",
                    "applyNetworkLayerControls",
                    "applyRateControls",
                    "applyReputationControls",
                    "applySlowPostControls",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSelectableHostnames:getAppSecSelectableHostnames": {
            "description": "**Scopes**: Security configuration; contract; group\n\nReturns the list of hostnames that can be (but aren't yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"selectableHostnames\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()));\n        ctx.export(\"selectableHostnamesJson\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectableHostnamesOutputText\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.outputText()));\n        final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .build());\n\n        ctx.export(\"selectableHostnamesForCreateConfiguration\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()));\n        ctx.export(\"selectableHostnamesForCreateConfigurationJson\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectableHostnamesForCreateConfigurationOutputText\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  selectableHostnamesAppSecSelectableHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        configId: ${configuration.configId}\n  selectableHostnamesForCreateConfigurationAppSecSelectableHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        contractId: 5-2WA382\n        groupId: 12198\noutputs:\n  selectableHostnames: ${selectableHostnamesAppSecSelectableHostnames.hostnames} # USE CASE: User wants to view all the unprotected hostnames.\n  selectableHostnamesJson: ${selectableHostnamesAppSecSelectableHostnames.hostnamesJson} # USE CASE: user wants to view the same list of unprotected hostnames, in tabular form\n  selectableHostnamesOutputText: ${selectableHostnamesAppSecSelectableHostnames.outputText} # USE CASE: User wants to view the list of hosts available for the specified contract and contract group before creating a new security configuration.\n  selectableHostnamesForCreateConfiguration: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnames} # USE CASE: User wants to view the available hostnames in JSON format.\n  selectableHostnamesForCreateConfigurationJson: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnamesJson} # USE CASE: User wants to view the available hostnames in a table.\n  selectableHostnamesForCreateConfigurationOutputText: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of selectable hostnames.\n- `hostnames_json`. JSON-formatted list of selectable hostnames.\n- `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSelectableHostnames.\n",
                "properties": {
                    "activeInProduction": {
                        "type": "boolean"
                    },
                    "activeInStaging": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return hostname information for. If not included, information is returned for all your security configurations. Note that argument can't be used with either the `contractid` or the `groupid` arguments.\n"
                    },
                    "contractid": {
                        "type": "string",
                        "description": ". Unique identifier of the Akamai contract you want to return hostname information for. If not included, information is returned for all the Akamai contracts associated with your account. Note that this argument can't be used with the `config_id` argument.\n"
                    },
                    "groupid": {
                        "type": "integer",
                        "description": ". Unique identifier of the contract group you want to return hostname information for. If not included, information is returned for all your contract groups. (Or, if you include the `contractid` argument, all the groups associated with the specified contract.) Note that this argument can't be used with the `config_id` argument.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSelectableHostnames.\n",
                "properties": {
                    "activeInProduction": {
                        "type": "boolean"
                    },
                    "activeInStaging": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "contractid": {
                        "type": "string"
                    },
                    "groupid": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "hostnamesJson": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostnames",
                    "hostnamesJson",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSelectedHostnames:getAppSecSelectedHostnames": {
            "description": "**Scopes**: Security configuration\n\nReturns a list of the hostnames currently protected by the specified security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst selectedHostnamesAppSecSelectedHostnames = configuration.then(configuration =\u003e akamai.getAppSecSelectedHostnames({\n    configId: configuration.configId,\n}));\nexport const selectedHostnames = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.hostnames);\nexport const selectedHostnamesJson = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.hostnamesJson);\nexport const selectedHostnamesOutputText = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nselected_hostnames_app_sec_selected_hostnames = akamai.get_app_sec_selected_hostnames(config_id=configuration.config_id)\npulumi.export(\"selectedHostnames\", selected_hostnames_app_sec_selected_hostnames.hostnames)\npulumi.export(\"selectedHostnamesJson\", selected_hostnames_app_sec_selected_hostnames.hostnames_json)\npulumi.export(\"selectedHostnamesOutputText\", selected_hostnames_app_sec_selected_hostnames.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var selectedHostnamesAppSecSelectedHostnames = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecSelectedHostnames.InvokeAsync(new Akamai.GetAppSecSelectedHostnamesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.SelectedHostnames = selectedHostnamesAppSecSelectedHostnames.Apply(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.Hostnames);\n        this.SelectedHostnamesJson = selectedHostnamesAppSecSelectedHostnames.Apply(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.HostnamesJson);\n        this.SelectedHostnamesOutputText = selectedHostnamesAppSecSelectedHostnames.Apply(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.OutputText);\n    }\n\n    [Output(\"selectedHostnames\")]\n    public Output\u003cstring\u003e SelectedHostnames { get; set; }\n    [Output(\"selectedHostnamesJson\")]\n    public Output\u003cstring\u003e SelectedHostnamesJson { get; set; }\n    [Output(\"selectedHostnamesOutputText\")]\n    public Output\u003cstring\u003e SelectedHostnamesOutputText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselectedHostnamesAppSecSelectedHostnames, err := akamai.LookupAppSecSelectedHostnames(ctx, \u0026GetAppSecSelectedHostnamesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"selectedHostnames\", selectedHostnamesAppSecSelectedHostnames.Hostnames)\n\t\tctx.Export(\"selectedHostnamesJson\", selectedHostnamesAppSecSelectedHostnames.HostnamesJson)\n\t\tctx.Export(\"selectedHostnamesOutputText\", selectedHostnamesAppSecSelectedHostnames.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"selectedHostnames\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.hostnames()));\n        ctx.export(\"selectedHostnamesJson\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectedHostnamesOutputText\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  selectedHostnamesAppSecSelectedHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecSelectedHostnames\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  selectedHostnames: ${selectedHostnamesAppSecSelectedHostnames.hostnames}\n  selectedHostnamesJson: ${selectedHostnamesAppSecSelectedHostnames.hostnamesJson}\n  selectedHostnamesOutputText: ${selectedHostnamesAppSecSelectedHostnames.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of selected hostnames.\n- `hostnames_json`. JSON-formatted list of selected hostnames.\n- `output_text`. Tabular report of the selected hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the protected hosts.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "hostnamesJson": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostnames",
                    "hostnamesJson",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSiemDefinitions:getAppSecSiemDefinitions": {
            "description": "**Scopes**: SIEM definition\n\nReturns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://developer.akamai.com/api/cloud_security/application_security/v1.html#getsiemversions) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst siemDefinitions = akamai.getAppSecSiemDefinitions({});\nexport const siemDefinitionsJson = siemDefinitions.then(siemDefinitions =\u003e siemDefinitions.json);\nexport const siemDefinitionsOutput = siemDefinitions.then(siemDefinitions =\u003e siemDefinitions.outputText);\nconst siemDefinition = akamai.getAppSecSiemDefinitions({\n    siemDefinitionName: \"SIEM Version 01\",\n});\nexport const siemDefinitionId = siemDefinition.then(siemDefinition =\u003e siemDefinition.id);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nsiem_definitions = akamai.get_app_sec_siem_definitions()\npulumi.export(\"siemDefinitionsJson\", siem_definitions.json)\npulumi.export(\"siemDefinitionsOutput\", siem_definitions.output_text)\nsiem_definition = akamai.get_app_sec_siem_definitions(siem_definition_name=\"SIEM Version 01\")\npulumi.export(\"siemDefinitionId\", siem_definition.id)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var siemDefinitions = Output.Create(Akamai.GetAppSecSiemDefinitions.InvokeAsync());\n        this.SiemDefinitionsJson = siemDefinitions.Apply(siemDefinitions =\u003e siemDefinitions.Json);\n        this.SiemDefinitionsOutput = siemDefinitions.Apply(siemDefinitions =\u003e siemDefinitions.OutputText);\n        var siemDefinition = Output.Create(Akamai.GetAppSecSiemDefinitions.InvokeAsync(new Akamai.GetAppSecSiemDefinitionsArgs\n        {\n            SiemDefinitionName = \"SIEM Version 01\",\n        }));\n        this.SiemDefinitionId = siemDefinition.Apply(siemDefinition =\u003e siemDefinition.Id);\n    }\n\n    [Output(\"siemDefinitionsJson\")]\n    public Output\u003cstring\u003e SiemDefinitionsJson { get; set; }\n    [Output(\"siemDefinitionsOutput\")]\n    public Output\u003cstring\u003e SiemDefinitionsOutput { get; set; }\n    [Output(\"siemDefinitionId\")]\n    public Output\u003cstring\u003e SiemDefinitionId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsiemDefinitions, err := akamai.GetAppSecSiemDefinitions(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemDefinitionsJson\", siemDefinitions.Json)\n\t\tctx.Export(\"siemDefinitionsOutput\", siemDefinitions.OutputText)\n\t\tsiemDefinition, err := akamai.GetAppSecSiemDefinitions(ctx, \u0026GetAppSecSiemDefinitionsArgs{\n\t\t\tSiemDefinitionName: pulumi.StringRef(\"SIEM Version 01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemDefinitionId\", siemDefinition.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();\n\n        ctx.export(\"siemDefinitionsJson\", siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.json()));\n        ctx.export(\"siemDefinitionsOutput\", siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.outputText()));\n        final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()\n            .siemDefinitionName(\"SIEM Version 01\")\n            .build());\n\n        ctx.export(\"siemDefinitionId\", siemDefinition.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.id()));\n    }\n}\n```\n```yaml\nvariables:\n  siemDefinitions:\n    Fn::Invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments: {}\n  siemDefinition:\n    Fn::Invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments:\n        siemDefinitionName: SIEM Version 01\noutputs:\n  siemDefinitionsJson: ${siemDefinitions.json}\n  siemDefinitionsOutput: ${siemDefinitions.outputText}\n  siemDefinitionId: ${siemDefinition.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the SIEM version information.\n- `output_text`. Tabular report showing the ID and name of each SIEM version.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSiemDefinitions.\n",
                "properties": {
                    "siemDefinitionName": {
                        "type": "string",
                        "description": ". Name of the SIEM definition you want to return information for. If not included, information is returned for all your SIEM definitions.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSiemDefinitions.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "siemDefinitionName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSiemSettings:getAppSecSiemSettings": {
            "description": "**Scopes**: Security configuration\n\nReturns the SIEM (Security Event and Information Management) settings for a security configuration. The returned information is described in the [SIEM members](https://developer.akamai.com/api/cloud_security/application_security/v1.html#d8470aff) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst siemSettings = configuration.then(configuration =\u003e akamai.getAppSecSiemSettings({\n    configId: configuration.configId,\n}));\nexport const siemSettingsJson = siemSettings.then(siemSettings =\u003e siemSettings.json);\nexport const siemSettingsOutput = siemSettings.then(siemSettings =\u003e siemSettings.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsiem_settings = akamai.get_app_sec_siem_settings(config_id=configuration.config_id)\npulumi.export(\"siemSettingsJson\", siem_settings.json)\npulumi.export(\"siemSettingsOutput\", siem_settings.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var siemSettings = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecSiemSettings.InvokeAsync(new Akamai.GetAppSecSiemSettingsArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.SiemSettingsJson = siemSettings.Apply(siemSettings =\u003e siemSettings.Json);\n        this.SiemSettingsOutput = siemSettings.Apply(siemSettings =\u003e siemSettings.OutputText);\n    }\n\n    [Output(\"siemSettingsJson\")]\n    public Output\u003cstring\u003e SiemSettingsJson { get; set; }\n    [Output(\"siemSettingsOutput\")]\n    public Output\u003cstring\u003e SiemSettingsOutput { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsiemSettings, err := akamai.LookupAppSecSiemSettings(ctx, \u0026GetAppSecSiemSettingsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemSettingsJson\", siemSettings.Json)\n\t\tctx.Export(\"siemSettingsOutput\", siemSettings.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"siemSettingsJson\", siemSettings.applyValue(getAppSecSiemSettingsResult -\u003e getAppSecSiemSettingsResult.json()));\n        ctx.export(\"siemSettingsOutput\", siemSettings.applyValue(getAppSecSiemSettingsResult -\u003e getAppSecSiemSettingsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  siemSettings:\n    Fn::Invoke:\n      Function: akamai:getAppSecSiemSettings\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  siemSettingsJson: ${siemSettings.json}\n  siemSettingsOutput: ${siemSettings.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the SIEM setting information.\n- `output_text`. Tabular report showing the SIEM setting information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSiemSettings.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSiemSettings.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSlowPost:getAppSecSlowPost": {
            "description": "**Scopes**: Security policy\n\nReturns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst slowPost = configuration.then(configuration =\u003e akamai.getAppSecSlowPost({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const slowPostOutputText = slowPost.then(slowPost =\u003e slowPost.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nslow_post = akamai.get_app_sec_slow_post(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"slowPostOutputText\", slow_post.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var slowPost = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecSlowPost.InvokeAsync(new Akamai.GetAppSecSlowPostArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.SlowPostOutputText = slowPost.Apply(slowPost =\u003e slowPost.OutputText);\n    }\n\n    [Output(\"slowPostOutputText\")]\n    public Output\u003cstring\u003e SlowPostOutputText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tslowPost, err := akamai.LookupAppSecSlowPost(ctx, \u0026GetAppSecSlowPostArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"slowPostOutputText\", slowPost.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"slowPostOutputText\", slowPost.applyValue(getAppSecSlowPostResult -\u003e getAppSecSlowPostResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  slowPost:\n    Fn::Invoke:\n      Function: akamai:getAppSecSlowPost\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  slowPostOutputText: ${slowPost.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report including the following:\n  - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:\n    - **alert**. Record the event.\n    - **abort**. Block the request.\n  - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n  - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n  - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSlowPost.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSlowPost.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecThreatIntel:getAppSecThreatIntel": {
            "description": "**Scopes**: Security policy\n\nReturns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst threatIntelAppSecThreatIntel = configuration.then(configuration =\u003e akamai.getAppSecThreatIntel({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const threatIntel = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.threatIntel);\nexport const json = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.json);\nexport const outputText = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nthreat_intel_app_sec_threat_intel = akamai.get_app_sec_threat_intel(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"threatIntel\", threat_intel_app_sec_threat_intel.threat_intel)\npulumi.export(\"json\", threat_intel_app_sec_threat_intel.json)\npulumi.export(\"outputText\", threat_intel_app_sec_threat_intel.output_text)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var threatIntelAppSecThreatIntel = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecThreatIntel.InvokeAsync(new Akamai.GetAppSecThreatIntelArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ThreatIntel = threatIntelAppSecThreatIntel.Apply(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.ThreatIntel);\n        this.Json = threatIntelAppSecThreatIntel.Apply(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.Json);\n        this.OutputText = threatIntelAppSecThreatIntel.Apply(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.OutputText);\n    }\n\n    [Output(\"threatIntel\")]\n    public Output\u003cstring\u003e ThreatIntel { get; set; }\n    [Output(\"json\")]\n    public Output\u003cstring\u003e Json { get; set; }\n    [Output(\"outputText\")]\n    public Output\u003cstring\u003e OutputText { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthreatIntelAppSecThreatIntel, err := akamai.LookupAppSecThreatIntel(ctx, \u0026GetAppSecThreatIntelArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"threatIntel\", threatIntelAppSecThreatIntel.ThreatIntel)\n\t\tctx.Export(\"json\", threatIntelAppSecThreatIntel.Json)\n\t\tctx.Export(\"outputText\", threatIntelAppSecThreatIntel.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"threatIntel\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.threatIntel()));\n        ctx.export(\"json\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.json()));\n        ctx.export(\"outputText\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  threatIntelAppSecThreatIntel:\n    Fn::Invoke:\n      Function: akamai:getAppSecThreatIntel\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  threatIntel: ${threatIntelAppSecThreatIntel.threatIntel}\n  json: ${threatIntelAppSecThreatIntel.json}\n  outputText: ${threatIntelAppSecThreatIntel.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.\n- `json`. JSON-formatted threat intelligence report.\n- `output_text`. Tabular report of the threat intelligence information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecThreatIntel.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the threat intelligence settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the threat intelligence settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecThreatIntel.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "threatIntel": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "threatIntel",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecTuningRecommendations:getAppSecTuningRecommendations": {
            "description": "Returns tuning recommendations for the specified attack group (or, if the `attack_group` argument is not included, returns tuning recommendations for all the attack groups in the specified security policy).\nTuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.\nTuning recommendations are returned as attack group exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to a security policy or attack group.\nIf the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.\nIf you need, you can manually merge a recommended exception for an attack group with the exception previously configured in the attack group resource.\nYou can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).\n\n**Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst policyRecommendations = configuration.then(configuration =\u003e akamai.getAppSecTuningRecommendations({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n}));\nexport const policyRecommendationsJson = policyRecommendations.then(policyRecommendations =\u003e policyRecommendations.json);\nconst attackGroupRecommendations = configuration.then(configuration =\u003e akamai.getAppSecTuningRecommendations({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n    rulesetType: _var.ruleset_type,\n    attackGroup: _var.attack_group,\n}));\nexport const attackGroupRecommendationsJson = attackGroupRecommendations.then(attackGroupRecommendations =\u003e attackGroupRecommendations.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\npolicy_recommendations = akamai.get_app_sec_tuning_recommendations(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"])\npulumi.export(\"policyRecommendationsJson\", policy_recommendations.json)\nattack_group_recommendations = akamai.get_app_sec_tuning_recommendations(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"],\n    ruleset_type=var[\"ruleset_type\"],\n    attack_group=var[\"attack_group\"])\npulumi.export(\"attackGroupRecommendationsJson\", attack_group_recommendations.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = @var.Security_configuration,\n        }));\n        var policyRecommendations = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecTuningRecommendations.InvokeAsync(new Akamai.GetAppSecTuningRecommendationsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = @var.Security_policy_id,\n        })));\n        this.PolicyRecommendationsJson = policyRecommendations.Apply(policyRecommendations =\u003e policyRecommendations.Json);\n        var attackGroupRecommendations = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecTuningRecommendations.InvokeAsync(new Akamai.GetAppSecTuningRecommendationsArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = @var.Security_policy_id,\n            RulesetType = @var.Ruleset_type,\n            AttackGroup = @var.Attack_group,\n        })));\n        this.AttackGroupRecommendationsJson = attackGroupRecommendations.Apply(attackGroupRecommendations =\u003e attackGroupRecommendations.Json);\n    }\n\n    [Output(\"policyRecommendationsJson\")]\n    public Output\u003cstring\u003e PolicyRecommendationsJson { get; set; }\n    [Output(\"attackGroupRecommendationsJson\")]\n    public Output\u003cstring\u003e AttackGroupRecommendationsJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpolicyRecommendations, err := akamai.GetAppSecTuningRecommendations(ctx, \u0026GetAppSecTuningRecommendationsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyRecommendationsJson\", policyRecommendations.Json)\n\t\tattackGroupRecommendations, err := akamai.GetAppSecTuningRecommendations(ctx, \u0026GetAppSecTuningRecommendationsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t\tRulesetType:      pulumi.StringRef(_var.Ruleset_type),\n\t\t\tAttackGroup:      pulumi.StringRef(_var.Attack_group),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"attackGroupRecommendationsJson\", attackGroupRecommendations.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .build());\n\n        ctx.export(\"policyRecommendationsJson\", policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -\u003e getAppSecTuningRecommendationsResult.json()));\n        final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .rulesetType(var_.ruleset_type())\n            .attackGroup(var_.attack_group())\n            .build());\n\n        ctx.export(\"attackGroupRecommendationsJson\", attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -\u003e getAppSecTuningRecommendationsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n  policyRecommendations:\n    Fn::Invoke:\n      Function: akamai:getAppSecTuningRecommendations\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\n  attackGroupRecommendations:\n    Fn::Invoke:\n      Function: akamai:getAppSecTuningRecommendations\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\n        rulesetType: ${var.ruleset_type}\n        attackGroup: ${var.attack_group}\noutputs:\n  policyRecommendationsJson: ${policyRecommendations.json}\n  attackGroupRecommendationsJson: ${attackGroupRecommendations.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecTuningRecommendations.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group you want tuning recommendations for. If not included, recommendations are returned for all attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want tuning recommendations for.\n"
                    },
                    "rulesetType": {
                        "type": "string",
                        "description": ". Type of ruleset used by the security configuration you want tuning recommendations for. Supported values are `active` and `evaluation`. Defaults to `active`.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy you want tuning recommendations for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecTuningRecommendations.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON-formatted list of the tuning recommendations for the security policy or the attack group. The exception block format in a recommendation conforms to the exception block format used in `condition_exception` element of `attack_group` resource.\n"
                    },
                    "rulesetType": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecVersionNotes:getAppSecVersionNotes": {
            "description": "**Scopes**: Security configuration\n\nReturns the most recent version notes for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst versionNotes = configuration.then(configuration =\u003e akamai.getAppSecVersionNotes({\n    configId: configuration.configId,\n}));\nexport const versionNotesText = versionNotes.then(versionNotes =\u003e versionNotes.outputText);\nexport const versionNotesJson = versionNotes.then(versionNotes =\u003e versionNotes.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nversion_notes = akamai.get_app_sec_version_notes(config_id=configuration.config_id)\npulumi.export(\"versionNotesText\", version_notes.output_text)\npulumi.export(\"versionNotesJson\", version_notes.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var versionNotes = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecVersionNotes.InvokeAsync(new Akamai.GetAppSecVersionNotesArgs\n        {\n            ConfigId = configuration.ConfigId,\n        })));\n        this.VersionNotesText = versionNotes.Apply(versionNotes =\u003e versionNotes.OutputText);\n        this.VersionNotesJson = versionNotes.Apply(versionNotes =\u003e versionNotes.Json);\n    }\n\n    [Output(\"versionNotesText\")]\n    public Output\u003cstring\u003e VersionNotesText { get; set; }\n    [Output(\"versionNotesJson\")]\n    public Output\u003cstring\u003e VersionNotesJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversionNotes, err := akamai.GetAppSecVersionNotes(ctx, \u0026GetAppSecVersionNotesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"versionNotesText\", versionNotes.OutputText)\n\t\tctx.Export(\"versionNotesJson\", versionNotes.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"versionNotesText\", versionNotes.applyValue(getAppSecVersionNotesResult -\u003e getAppSecVersionNotesResult.outputText()));\n        ctx.export(\"versionNotesJson\", versionNotes.applyValue(getAppSecVersionNotesResult -\u003e getAppSecVersionNotesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view the version notes for the most-recent version of a security configuration.\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  versionNotes:\n    Fn::Invoke:\n      Function: akamai:getAppSecVersionNotes\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  versionNotesText: ${versionNotes.outputText}\n  versionNotesJson: ${versionNotes.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list showing the version notes.\n- `output_text`. Tabular report showing the version notes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecVersionNotes.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecVersionNotes.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecWafMode:getAppSecWafMode": {
            "description": "**Scopes**: Security policy\n\nReturns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wafMode = configuration.then(configuration =\u003e akamai.getAppSecWafMode({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const wafModeMode = wafMode.then(wafMode =\u003e wafMode.mode);\nexport const wafModeCurrentRuleset = wafMode.then(wafMode =\u003e wafMode.currentRuleset);\nexport const wafModeEvalStatus = wafMode.then(wafMode =\u003e wafMode.evalStatus);\nexport const wafModeEvalRuleset = wafMode.then(wafMode =\u003e wafMode.evalRuleset);\nexport const wafModeEvalExpirationDate = wafMode.then(wafMode =\u003e wafMode.evalExpirationDate);\nexport const wafModeText = wafMode.then(wafMode =\u003e wafMode.outputText);\nexport const wafModeJson = wafMode.then(wafMode =\u003e wafMode.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwaf_mode = akamai.get_app_sec_waf_mode(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"wafModeMode\", waf_mode.mode)\npulumi.export(\"wafModeCurrentRuleset\", waf_mode.current_ruleset)\npulumi.export(\"wafModeEvalStatus\", waf_mode.eval_status)\npulumi.export(\"wafModeEvalRuleset\", waf_mode.eval_ruleset)\npulumi.export(\"wafModeEvalExpirationDate\", waf_mode.eval_expiration_date)\npulumi.export(\"wafModeText\", waf_mode.output_text)\npulumi.export(\"wafModeJson\", waf_mode.json)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var wafMode = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecWafMode.InvokeAsync(new Akamai.GetAppSecWafModeArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.WafModeMode = wafMode.Apply(wafMode =\u003e wafMode.Mode);\n        this.WafModeCurrentRuleset = wafMode.Apply(wafMode =\u003e wafMode.CurrentRuleset);\n        this.WafModeEvalStatus = wafMode.Apply(wafMode =\u003e wafMode.EvalStatus);\n        this.WafModeEvalRuleset = wafMode.Apply(wafMode =\u003e wafMode.EvalRuleset);\n        this.WafModeEvalExpirationDate = wafMode.Apply(wafMode =\u003e wafMode.EvalExpirationDate);\n        this.WafModeText = wafMode.Apply(wafMode =\u003e wafMode.OutputText);\n        this.WafModeJson = wafMode.Apply(wafMode =\u003e wafMode.Json);\n    }\n\n    [Output(\"wafModeMode\")]\n    public Output\u003cstring\u003e WafModeMode { get; set; }\n    [Output(\"wafModeCurrentRuleset\")]\n    public Output\u003cstring\u003e WafModeCurrentRuleset { get; set; }\n    [Output(\"wafModeEvalStatus\")]\n    public Output\u003cstring\u003e WafModeEvalStatus { get; set; }\n    [Output(\"wafModeEvalRuleset\")]\n    public Output\u003cstring\u003e WafModeEvalRuleset { get; set; }\n    [Output(\"wafModeEvalExpirationDate\")]\n    public Output\u003cstring\u003e WafModeEvalExpirationDate { get; set; }\n    [Output(\"wafModeText\")]\n    public Output\u003cstring\u003e WafModeText { get; set; }\n    [Output(\"wafModeJson\")]\n    public Output\u003cstring\u003e WafModeJson { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twafMode, err := akamai.LookupAppSecWafMode(ctx, \u0026GetAppSecWafModeArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafModeMode\", wafMode.Mode)\n\t\tctx.Export(\"wafModeCurrentRuleset\", wafMode.CurrentRuleset)\n\t\tctx.Export(\"wafModeEvalStatus\", wafMode.EvalStatus)\n\t\tctx.Export(\"wafModeEvalRuleset\", wafMode.EvalRuleset)\n\t\tctx.Export(\"wafModeEvalExpirationDate\", wafMode.EvalExpirationDate)\n\t\tctx.Export(\"wafModeText\", wafMode.OutputText)\n\t\tctx.Export(\"wafModeJson\", wafMode.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecWafModeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"wafModeMode\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.mode()));\n        ctx.export(\"wafModeCurrentRuleset\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.currentRuleset()));\n        ctx.export(\"wafModeEvalStatus\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalStatus()));\n        ctx.export(\"wafModeEvalRuleset\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalRuleset()));\n        ctx.export(\"wafModeEvalExpirationDate\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalExpirationDate()));\n        ctx.export(\"wafModeText\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.outputText()));\n        ctx.export(\"wafModeJson\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  wafMode:\n    Fn::Invoke:\n      Function: akamai:getAppSecWafMode\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  wafModeMode: ${wafMode.mode}\n  wafModeCurrentRuleset: ${wafMode.currentRuleset}\n  wafModeEvalStatus: ${wafMode.evalStatus}\n  wafModeEvalRuleset: ${wafMode.evalRuleset}\n  wafModeEvalExpirationDate: ${wafMode.evalExpirationDate}\n  wafModeText: ${wafMode.outputText}\n  wafModeJson: ${wafMode.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you'll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.\n- `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.\n- `eval_status`. Specifies whether evaluation mode is enabled or disabled.\n- `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.\n- `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.\n- `output_text`. Tabular report of the mode information.\n- `json`. JSON-formatted list of the mode information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecWafMode.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Set rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecWafMode.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "currentRuleset": {
                        "type": "string"
                    },
                    "evalExpirationDate": {
                        "type": "string"
                    },
                    "evalRuleset": {
                        "type": "string"
                    },
                    "evalStatus": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "currentRuleset",
                    "evalExpirationDate",
                    "evalRuleset",
                    "evalStatus",
                    "json",
                    "mode",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecWapSelectedHostnames:getAppSecWapSelectedHostnames": {
            "description": "**Scopes**: Security policy\n\nReturns hostnames currently protected or being evaluated by a configuration and security policy.\nThis resource is available only to organizations running Web Application Protector (WAP).\nNote that the WAP selected hostnames feature is currently in beta.\nPlease contact your Akamai representative for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wapSelectedHostnames = configuration.then(configuration =\u003e akamai.getAppSecWapSelectedHostnames({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const protectedHostnames = wapSelectedHostnames.then(wapSelectedHostnames =\u003e wapSelectedHostnames.protectedHosts);\nexport const evaluatedHostnames = wapSelectedHostnames.then(wapSelectedHostnames =\u003e wapSelectedHostnames.evaluatedHosts);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwap_selected_hostnames = akamai.get_app_sec_wap_selected_hostnames(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"protectedHostnames\", wap_selected_hostnames.protected_hosts)\npulumi.export(\"evaluatedHostnames\", wap_selected_hostnames.evaluated_hosts)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var configuration = Output.Create(Akamai.GetAppSecConfiguration.InvokeAsync(new Akamai.GetAppSecConfigurationArgs\n        {\n            Name = \"Documentation\",\n        }));\n        var wapSelectedHostnames = configuration.Apply(configuration =\u003e Output.Create(Akamai.GetAppSecWapSelectedHostnames.InvokeAsync(new Akamai.GetAppSecWapSelectedHostnamesArgs\n        {\n            ConfigId = configuration.ConfigId,\n            SecurityPolicyId = \"gms1_134637\",\n        })));\n        this.ProtectedHostnames = wapSelectedHostnames.Apply(wapSelectedHostnames =\u003e wapSelectedHostnames.ProtectedHosts);\n        this.EvaluatedHostnames = wapSelectedHostnames.Apply(wapSelectedHostnames =\u003e wapSelectedHostnames.EvaluatedHosts);\n    }\n\n    [Output(\"protectedHostnames\")]\n    public Output\u003cstring\u003e ProtectedHostnames { get; set; }\n    [Output(\"evaluatedHostnames\")]\n    public Output\u003cstring\u003e EvaluatedHostnames { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026GetAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twapSelectedHostnames, err := akamai.LookupAppSecWapSelectedHostnames(ctx, \u0026GetAppSecWapSelectedHostnamesArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"protectedHostnames\", wapSelectedHostnames.ProtectedHosts)\n\t\tctx.Export(\"evaluatedHostnames\", wapSelectedHostnames.EvaluatedHosts)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"protectedHostnames\", wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -\u003e getAppSecWapSelectedHostnamesResult.protectedHosts()));\n        ctx.export(\"evaluatedHostnames\", wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -\u003e getAppSecWapSelectedHostnamesResult.evaluatedHosts()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    Fn::Invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  wapSelectedHostnames:\n    Fn::Invoke:\n      Function: akamai:getAppSecWapSelectedHostnames\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  protectedHostnames: ${wapSelectedHostnames.protectedHosts}\n  evaluatedHostnames: ${wapSelectedHostnames.evaluatedHosts}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.\n- `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.\n- `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.\n- `output_text`. Tabular reports of the protected and evaluated hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecWapSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the hostnames.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecWapSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "evaluatedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchTargets": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "protectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "selectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "evaluatedHosts",
                    "json",
                    "matchTargets",
                    "outputText",
                    "protectedHosts",
                    "securityPolicyId",
                    "selectedHosts",
                    "id"
                ]
            }
        },
        "akamai:index/getAuthoritiesSet:getAuthoritiesSet": {
            "description": "Use the `akamai.getAuthoritiesSet` data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getAuthoritiesSet({\n    contract: \"ctr_1-AB123\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_authorities_set(contract=\"ctr_1-AB123\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetAuthoritiesSet.InvokeAsync(new Akamai.GetAuthoritiesSetArgs\n        {\n            Contract = \"ctr_1-AB123\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAuthoritiesSet(ctx, \u0026GetAuthoritiesSetArgs{\n\t\t\tContract: \"ctr_1-AB123\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.edgedns.inputs.GetAuthoritiesSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()\n            .contract(\"ctr_1-AB123\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getAuthoritiesSet\n      Arguments:\n        contract: ctr_1-AB123\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source supports this attribute:\n\n* `authorities` - A list of authorities.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthoritiesSet.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contract"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthoritiesSet.\n",
                "properties": {
                    "authorities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "contract": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authorities",
                    "contract",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRule:getCloudletsApiPrioritizationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the API Prioritization Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsApiPrioritizationMatchRule({\n    matchRules: [{\n        disabled: false,\n        end: 1645037845,\n        matchUrl: \"example.com\",\n        matches: [{\n            caseSensitive: true,\n            matchOperator: \"equals\",\n            matchType: \"method\",\n            negate: false,\n            objectMatchValues: [{\n                type: \"simple\",\n                values: [\"POST\"],\n            }],\n        }],\n        name: \"rule\",\n        passThroughPercent: 10,\n        start: 1644865045,\n    }],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()\n            .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()\n                .disabled(false)\n                .end(1645037845)\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(true)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .passThroughPercent(10)\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsApiPrioritizationMatchRule\n      Arguments:\n        matchRules:\n          - disabled: false\n            end: 1.645037845e+09\n            matchUrl: example.com\n            matches:\n              - caseSensitive: true\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - POST\n            name: rule\n            passThroughPercent: 10\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApiPrioritizationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApiPrioritizationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancer:getCloudletsApplicationLoadBalancer": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.\n\n## Basic usage\n\nThis example returns the load balancing configuration details based on the origin ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsApplicationLoadBalancer({\n    originId: \"alb_test_1\",\n    version: 1,\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_application_load_balancer(origin_id=\"alb_test_1\",\n    version=1)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetCloudletsApplicationLoadBalancer.InvokeAsync(new Akamai.GetCloudletsApplicationLoadBalancerArgs\n        {\n            OriginId = \"alb_test_1\",\n            Version = 1,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.LookupCloudletsApplicationLoadBalancer(ctx, \u0026GetCloudletsApplicationLoadBalancerArgs{\n\t\t\tOriginId: \"alb_test_1\",\n\t\t\tVersion:  pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()\n            .originId(\"alb_test_1\")\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsApplicationLoadBalancer\n      Arguments:\n        originId: alb_test_1\n        version: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `description` - The description of the load balancing configuration.\n* `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.\n* `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n* `created_by` - The name of the user who created this load balancing configuration.\n* `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.\n* `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.\n* `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.\n* `last_modified_by` - The user who last modified the load balancing configuration.\n* `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.\n* `warnings` - A list of warnings that occured during the activation of the load balancing configuration.\n* `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n  * `city` - The city in which the data center is located.\n  * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.\n  * `cloud_service` - Whether this datacenter is a cloud service.\n  * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.\n  * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.\n  * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.\n  * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.\n  * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.\n  * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.\n  * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n  * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.\n  * `state_or_province` - The state, province, or region where the data center is located.\n* `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.\n  * `host_header` - The Host header for the liveness HTTP request.\n  * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.\n  * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.\n  * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.\n  * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.\n  * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.\n  * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.\n  * `request_string` - The request used for TCP and TCPS tests.\n  * `response_string` - The response used for TCP and TCPS tests.\n  * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.\n  * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.\n  * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.\n  * `timeout` - The number of seconds the system waits before failing the liveness test.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApplicationLoadBalancer.\n",
                "properties": {
                    "originId": {
                        "type": "string",
                        "description": "- (Required) A unique identifier for the Conditional Origin that supports the load balancing configuration. The Conditional Origin type must be set to `APPLICATION_LOAD_BALANCER` in the `origin` behavior. See property rules for more information.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version number of the load balancing configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "originId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApplicationLoadBalancer.\n",
                "properties": {
                    "balancingType": {
                        "type": "string"
                    },
                    "createdBy": {
                        "type": "string"
                    },
                    "createdDate": {
                        "type": "string"
                    },
                    "dataCenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerDataCenter:getCloudletsApplicationLoadBalancerDataCenter"
                        }
                    },
                    "deleted": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "immutable": {
                        "type": "boolean"
                    },
                    "lastModifiedBy": {
                        "type": "string"
                    },
                    "lastModifiedDate": {
                        "type": "string"
                    },
                    "livenessSettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerLivenessSetting:getCloudletsApplicationLoadBalancerLivenessSetting"
                        }
                    },
                    "originId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    },
                    "warnings": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "balancingType",
                    "createdBy",
                    "createdDate",
                    "dataCenters",
                    "deleted",
                    "description",
                    "immutable",
                    "lastModifiedBy",
                    "lastModifiedDate",
                    "livenessSettings",
                    "originId",
                    "type",
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRule:getCloudletsApplicationLoadBalancerMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsApplicationLoadBalancerMatchRule({\n    matchRules: [{\n        end: 1645037845,\n        forwardSettings: [{\n            originId: \"alb_test_1\",\n        }],\n        matchUrl: \"example.com\",\n        matches: [{\n            caseSensitive: false,\n            matchOperator: \"equals\",\n            matchType: \"method\",\n            negate: false,\n            objectMatchValues: [{\n                type: \"simple\",\n                values: [\"GET\"],\n            }],\n        }],\n        name: \"rule\",\n        start: 1644865045,\n    }],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()\n            .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()\n                    .originId(\"alb_test_1\")\n                    .build())\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsApplicationLoadBalancerMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            forwardSettings:\n              - originId: alb_test_1\n            matchUrl: example.com\n            matches:\n              - caseSensitive: false\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - GET\n            name: rule\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApplicationLoadBalancerMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApplicationLoadBalancerMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRule:getCloudletsAudienceSegmentationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsAudienceSegmentationMatchRule({\n    matchRules: [{\n        forwardSettings: {\n            originId: \"123\",\n            pathAndQs: \"/test\",\n            useIncomingQueryString: true,\n        },\n        matches: [{\n            matchOperator: \"contains\",\n            matchType: \"header\",\n            objectMatchValues: [{\n                name: \"cookie\",\n                options: {\n                    values: [\"abcd\"],\n                },\n                type: \"object\",\n            }],\n        }],\n        name: \"rule\",\n    }],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()\n            .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()\n                .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"123\")\n                    .pathAndQs(\"/test\")\n                    .useIncomingQueryString(true)\n                    .build())\n                .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()\n                    .matchOperator(\"contains\")\n                    .matchType(\"header\")\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsAudienceSegmentationMatchRule\n      Arguments:\n        matchRules:\n          - forwardSettings:\n              originId: 123\n              pathAndQs: /test\n              useIncomingQueryString: true\n            matches:\n              - matchOperator: contains\n                matchType: header\n                objectMatchValue:\n                  - name: cookie\n                    options:\n                      value:\n                        - abcd\n                    type: object\n            name: rule\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsAudienceSegmentationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsAudienceSegmentationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRule:getCloudletsEdgeRedirectorMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Edge Redirector Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsEdgeRedirectorMatchRule({\n    matchRules: [{\n        end: 1645037845,\n        matchUrl: \"example.com\",\n        matches: [{\n            caseSensitive: false,\n            matchOperator: \"equals\",\n            matchType: \"method\",\n            negate: false,\n            objectMatchValues: [{\n                type: \"simple\",\n                values: [\"GET\"],\n            }],\n        }],\n        name: \"rule\",\n        redirectUrl: \"https://www.example.com\",\n        start: 1644865045,\n        statusCode: 301,\n        useIncomingQueryString: false,\n        useRelativeUrl: \"none\",\n    }],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()\n            .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .redirectUrl(\"https://www.example.com\")\n                .start(1644865045)\n                .statusCode(301)\n                .useIncomingQueryString(false)\n                .useRelativeUrl(\"none\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsEdgeRedirectorMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            matchUrl: example.com\n            matches:\n              - caseSensitive: false\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - GET\n            name: rule\n            redirectUrl: https://www.example.com\n            start: 1.644865045e+09\n            statusCode: 301\n            useIncomingQueryString: false\n            useRelativeUrl: none\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsEdgeRedirectorMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsEdgeRedirectorMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsForwardRewriteMatchRule:getCloudletsForwardRewriteMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsForwardRewriteMatchRule({\n    matchRules: [{\n        forwardSettings: {\n            originId: \"1234\",\n            pathAndQs: \"/path\",\n            useIncomingQueryString: true,\n        },\n        matches: [{\n            caseSensitive: false,\n            checkIps: \"CONNECTING_IP XFF_HEADERS\",\n            matchOperator: \"equals\",\n            matchType: \"clientip\",\n            matchValue: \"192.0.2.0\",\n            negate: false,\n        }],\n        name: \"rule\",\n    }],\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_forward_rewrite_match_rule(match_rules=[akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleArgs(\n    forward_settings=akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs(\n        origin_id=\"1234\",\n        path_and_qs=\"/path\",\n        use_incoming_query_string=True,\n    ),\n    matches=[akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs(\n        case_sensitive=False,\n        check_ips=\"CONNECTING_IP XFF_HEADERS\",\n        match_operator=\"equals\",\n        match_type=\"clientip\",\n        match_value=\"192.0.2.0\",\n        negate=False,\n    )],\n    name=\"rule\",\n)])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetCloudletsForwardRewriteMatchRule.InvokeAsync(new Akamai.GetCloudletsForwardRewriteMatchRuleArgs\n        {\n            MatchRules = \n            {\n                new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleArgs\n                {\n                    ForwardSettings = new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs\n                    {\n                        OriginId = \"1234\",\n                        PathAndQs = \"/path\",\n                        UseIncomingQueryString = true,\n                    },\n                    Matches = \n                    {\n                        new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs\n                        {\n                            CaseSensitive = false,\n                            CheckIps = \"CONNECTING_IP XFF_HEADERS\",\n                            MatchOperator = \"equals\",\n                            MatchType = \"clientip\",\n                            MatchValue = \"192.0.2.0\",\n                            Negate = false,\n                        },\n                    },\n                    Name = \"rule\",\n                },\n            },\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCloudletsForwardRewriteMatchRule(ctx, \u0026GetCloudletsForwardRewriteMatchRuleArgs{\n\t\t\tMatchRules: []GetCloudletsForwardRewriteMatchRuleMatchRule{\n\t\t\t\tGetCloudletsForwardRewriteMatchRuleMatchRule{\n\t\t\t\t\tForwardSettings: GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings{\n\t\t\t\t\t\tOriginId:               pulumi.StringRef(\"1234\"),\n\t\t\t\t\t\tPathAndQs:              pulumi.StringRef(\"/path\"),\n\t\t\t\t\t\tUseIncomingQueryString: pulumi.BoolRef(true),\n\t\t\t\t\t},\n\t\t\t\t\tMatches: []GetCloudletsForwardRewriteMatchRuleMatchRuleMatch{\n\t\t\t\t\t\tGetCloudletsForwardRewriteMatchRuleMatchRuleMatch{\n\t\t\t\t\t\t\tCaseSensitive: pulumi.BoolRef(false),\n\t\t\t\t\t\t\tCheckIps:      pulumi.StringRef(\"CONNECTING_IP XFF_HEADERS\"),\n\t\t\t\t\t\t\tMatchOperator: pulumi.StringRef(\"equals\"),\n\t\t\t\t\t\t\tMatchType:     pulumi.StringRef(\"clientip\"),\n\t\t\t\t\t\t\tMatchValue:    pulumi.StringRef(\"192.0.2.0\"),\n\t\t\t\t\t\t\tNegate:        pulumi.BoolRef(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.StringRef(\"rule\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()\n            .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()\n                .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"1234\")\n                    .pathAndQs(\"/path\")\n                    .useIncomingQueryString(true)\n                    .build())\n                .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                    .matchOperator(\"equals\")\n                    .matchType(\"clientip\")\n                    .matchValue(\"192.0.2.0\")\n                    .negate(false)\n                    .build())\n                .name(\"rule\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsForwardRewriteMatchRule\n      Arguments:\n        matchRules:\n          - forwardSettings:\n              originId: 1234\n              pathAndQs: /path\n              useIncomingQueryString: true\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: equals\n                matchType: clientip\n                matchValue: 192.0.2.0\n                negate: false\n            name: rule\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsForwardRewriteMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsForwardRewriteMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRule:getCloudletsPhasedReleaseMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Phased Release Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsPhasedReleaseMatchRule({\n    matchRules: [{\n        end: 1645037845,\n        forwardSettings: {\n            originId: \"1234\",\n            percent: 100,\n        },\n        matches: [{\n            caseSensitive: false,\n            checkIps: \"CONNECTING_IP XFF_HEADERS\",\n            matchOperator: \"equals\",\n            matchType: \"header\",\n            negate: false,\n            objectMatchValues: [{\n                name: \"Content-Type\",\n                options: {\n                    values: [\"application/json\"],\n                },\n                type: \"object\",\n            }],\n        }],\n        name: \"rule\",\n        start: 1644865045,\n    }],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()\n            .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"1234\")\n                    .percent(100)\n                    .build())\n                .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                    .matchOperator(\"equals\")\n                    .matchType(\"header\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsPhasedReleaseMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            forwardSettings:\n              originId: 1234\n              percent: 100\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: equals\n                matchType: header\n                negate: false\n                objectMatchValue:\n                  - name: Content-Type\n                    options:\n                      value:\n                        - application/json\n                    type: object\n            name: rule\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsPhasedReleaseMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsPhasedReleaseMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsPolicy:getCloudletsPolicy": {
            "description": "Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.\n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsPolicy({\n    policyId: 1234,\n    version: 1,\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_policy(policy_id=1234,\n    version=1)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetCloudletsPolicy.InvokeAsync(new Akamai.GetCloudletsPolicyArgs\n        {\n            PolicyId = 1234,\n            Version = 1,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.LookupCloudletsPolicy(ctx, \u0026GetCloudletsPolicyArgs{\n\t\t\tPolicyId: 1234,\n\t\t\tVersion:  pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()\n            .policyId(1234)\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsPolicy\n      Arguments:\n        policyId: 1234\n        version: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `group_id` - Defines the group association for the policy. You must have edit privileges for the group.\n* `name` - The unique name of the policy.\n* `api_version` - The specific version of the Cloudlets API.\n* `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `5` for API Prioritization, `7` for Phased Release, or `9` for Application Load Balancer.\n* `cloudlet_code` - The two- or three- character code for the type of Cloudlet, `ALB` for Application Load Balancer, `AP` for API Prioritization, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, and `VP` for Visitor Prioritization.\n* `revision_id` - A unique identifier given to every policy version update.\n* `description` - The description of this specific policy.\n* `version_description` - The description of this specific policy version.\n* `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.\n* `match_rules`- A JSON structure that defines the rules for this policy.\n* `match_rule_format` - The format of the Cloudlet-specific `match_rules`.\n* `warnings` - A JSON encoded list of warnings.\n* `activations` - A list of of current policy activation information, including:\n  * `api_version` - The specific version of the Cloudlets API.\n  * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.\n  * `policy_info` - A list of Cloudlet policy information, including:\n      * `policy_id` - An integer identifier that is associated with all versions of a policy.\n      * `name` - The name of the policy.\n      * `version` - The version number of the policy.\n      * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.\n      * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.\n      * `activated_by` - The name of the user who activated the policy.\n      * `activation_date` - The date on which the policy was activated in milliseconds since epoch.\n  * `property_info` A list of Cloudlet property information, including:\n      * `name` - The name of the property.\n      * `version` - The version number of the activated property.\n      * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.\n      * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.\n      * `activated_by` - The name of the user who activated the property.\n      * `activation_date` - The date on which the property was activated in milliseconds since epoch.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsPolicy.\n",
                "properties": {
                    "policyId": {
                        "type": "integer",
                        "description": "- (Required) An integer identifier that is associated with all versions of a policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version number of a policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "policyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsPolicy.\n",
                "properties": {
                    "activations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPolicyActivation:getCloudletsPolicyActivation"
                        }
                    },
                    "apiVersion": {
                        "type": "string"
                    },
                    "cloudletCode": {
                        "type": "string"
                    },
                    "cloudletId": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "matchRuleFormat": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policyId": {
                        "type": "integer"
                    },
                    "revisionId": {
                        "type": "integer"
                    },
                    "rulesLocked": {
                        "type": "boolean"
                    },
                    "version": {
                        "type": "integer"
                    },
                    "versionDescription": {
                        "type": "string"
                    },
                    "warnings": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "activations",
                    "apiVersion",
                    "cloudletCode",
                    "cloudletId",
                    "description",
                    "groupId",
                    "matchRuleFormat",
                    "matchRules",
                    "name",
                    "policyId",
                    "revisionId",
                    "rulesLocked",
                    "versionDescription",
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRule:getCloudletsRequestControlMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet. \n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Request Control Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsRequestControlMatchRule({\n    matchRules: [\n        {\n            allowDeny: \"allow\",\n            disabled: false,\n            end: 2,\n            matches: [{\n                caseSensitive: false,\n                checkIps: \"CONNECTING_IP XFF_HEADERS\",\n                matchOperator: \"contains\",\n                matchType: \"method\",\n                negate: false,\n                objectMatchValues: [{\n                    nameCaseSensitive: true,\n                    nameHasWildcard: true,\n                    type: \"simple\",\n                    values: [\"GET\"],\n                }],\n            }],\n            name: \"rule 1\",\n            start: 1,\n        },\n        {\n            allowDeny: \"deny\",\n            disabled: true,\n            end: 2,\n            matches: [{\n                caseSensitive: false,\n                checkIps: \"XFF_HEADERS\",\n                matchOperator: \"contains\",\n                matchType: \"header\",\n                negate: false,\n                objectMatchValues: [{\n                    name: \"object 1\",\n                    nameCaseSensitive: true,\n                    nameHasWildcard: true,\n                    options: {\n                        values: [\n                            \"text/html*\",\n                            \"text/css*\",\n                            \"application/x-javascript*\",\n                        ],\n                        valueCaseSensitive: true,\n                        valueEscaped: true,\n                        valueHasWildcard: true,\n                    },\n                    type: \"object\",\n                }],\n            }],\n            name: \"rule 2\",\n            start: 1,\n        },\n    ],\n}));\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()\n            .matchRules(            \n                GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()\n                    .allowDeny(\"allow\")\n                    .disabled(false)\n                    .end(2)\n                    .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()\n                        .caseSensitive(false)\n                        .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                        .matchOperator(\"contains\")\n                        .matchType(\"method\")\n                        .negate(false)\n                        .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .name(\"rule 1\")\n                    .start(1)\n                    .build(),\n                GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()\n                    .allowDeny(\"deny\")\n                    .disabled(true)\n                    .end(2)\n                    .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()\n                        .caseSensitive(false)\n                        .checkIps(\"XFF_HEADERS\")\n                        .matchOperator(\"contains\")\n                        .matchType(\"header\")\n                        .negate(false)\n                        .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .name(\"rule 2\")\n                    .start(1)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getCloudletsRequestControlMatchRule\n      Arguments:\n        matchRules:\n          - allowDeny: allow\n            disabled: false\n            end: 2\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: contains\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - nameCaseSensitive: true\n                    nameHasWildcard: true\n                    type: simple\n                    value:\n                      - GET\n            name: rule 1\n            start: 1\n          - allowDeny: deny\n            disabled: true\n            end: 2\n            matches:\n              - caseSensitive: false\n                checkIps: XFF_HEADERS\n                matchOperator: contains\n                matchType: header\n                negate: false\n                objectMatchValue:\n                  - name: object 1\n                    nameCaseSensitive: true\n                    nameHasWildcard: true\n                    options:\n                      value:\n                        - text/html*\n                        - text/css*\n                        - application/x-javascript*\n                      valueCaseSensitive: true\n                      valueEscaped: true\n                      valueHasWildcard: true\n                    type: object\n            name: rule 2\n            start: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsRequestControlMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsRequestControlMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRule:getCloudletsVisitorPrioritizationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getCloudletsVisitorPrioritizationMatchRule({\n    matchRules: [{\n        end: 1645037845,\n        matchUrl: \"example.com\",\n        matches: [{\n            caseSensitive: false,\n            checkIps: \"CONNECTING_IP\",\n            matchOperator: \"equals\",\n            matchType: \"protocol\",\n            matchValue: \"http\",\n            negate: false,\n        }],\n        name: \"rule\",\n        passThroughPercent: -1,\n        start: 1644865045,\n    }],\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_visitor_prioritization_match_rule(match_rules=[akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs(\n    end=1645037845,\n    match_url=\"example.com\",\n    matches=[akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs(\n        case_sensitive=False,\n        check_ips=\"CONNECTING_IP\",\n        match_operator=\"equals\",\n        match_type=\"protocol\",\n        match_value=\"http\",\n        negate=False,\n    )],\n    name=\"rule\",\n    pass_through_percent=-1,\n    start=1644865045,\n)])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetCloudletsVisitorPrioritizationMatchRule.InvokeAsync(new Akamai.GetCloudletsVisitorPrioritizationMatchRuleArgs\n        {\n            MatchRules = \n            {\n                new Akamai.Inputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs\n                {\n                    End = 1645037845,\n                    MatchUrl = \"example.com\",\n                    Matches = \n                    {\n                        new Akamai.Inputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs\n                        {\n                            CaseSensitive = false,\n                            CheckIps = \"CONNECTING_IP\",\n                            MatchOperator = \"equals\",\n                            MatchType = \"protocol\",\n                            MatchValue = \"http\",\n                            Negate = false,\n                        },\n                    },\n                    Name = \"rule\",\n                    PassThroughPercent = -1,\n                    Start = 1644865045,\n                },\n            },\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCloudletsVisitorPrioritizationMatchRule(ctx, \u0026GetCloudletsVisitorPrioritizationMatchRuleArgs{\n\t\t\tMatchRules: []GetCloudletsVisitorPrioritizationMatchRuleMatchRule{\n\t\t\t\tGetCloudletsVisitorPrioritizationMatchRuleMatchRule{\n\t\t\t\t\tEnd:      pulumi.IntRef(1645037845),\n\t\t\t\t\tMatchUrl: pulumi.StringRef(\"example.com\"),\n\t\t\t\t\tMatches: []GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch{\n\t\t\t\t\t\tGetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch{\n\t\t\t\t\t\t\tCaseSensitive: pulumi.BoolRef(false),\n\t\t\t\t\t\t\tCheckIps:      pulumi.StringRef(\"CONNECTING_IP\"),\n\t\t\t\t\t\t\tMatchOperator: pulumi.StringRef(\"equals\"),\n\t\t\t\t\t\t\tMatchType:     pulumi.StringRef(\"protocol\"),\n\t\t\t\t\t\t\tMatchValue:    pulumi.StringRef(\"http\"),\n\t\t\t\t\t\t\tNegate:        pulumi.BoolRef(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName:               pulumi.StringRef(\"rule\"),\n\t\t\t\t\tPassThroughPercent: -1,\n\t\t\t\t\tStart:              pulumi.IntRef(1644865045),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsVisitorPrioritizationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule"
                        },
                        "description": "- (Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsVisitorPrioritizationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getContract:getContract": {
            "description": "Use the `akamai.getContract` data source to find a contract ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst exampleContract = pulumi.output(akamai.getContract({\n    groupName: \"example group name\",\n}));\nconst exampleProperty = new akamai.Property(\"example\", {\n    contractId: \"\",\n    \"data.akamai_contract.example.id\": [{}],\n});\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `id` - The contract's unique ID, including the `ctr_` prefix.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContract.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "Either the group ID or the group name that includes the contract. You can't use this argument with `group_id` and `group_name`.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The unique ID of the group containing the contract, including the  `grp_` prefix.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group containing the contract.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getContract.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "groupName",
                    "id"
                ]
            }
        },
        "akamai:index/getContracts:getContracts": {
            "description": "Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn contracts associated with the EdgeGrid API client token currently used for authentication:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getContracts({});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_contracts()\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_example = Output.Create(Akamai.GetContracts.InvokeAsync());\n        this.PropertyMatch = my_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetContracts(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  my-example:\n    Fn::Invoke:\n      Function: akamai:getContracts\n      Arguments: {}\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `contracts` - A list of supported contracts, with the following properties:\n  * `contract_id` - The contract's unique ID, including the `ctr_` prefix.\n  * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.\n",
            "outputs": {
                "description": "A collection of values returned by getContracts.\n",
                "properties": {
                    "contracts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getContractsContract:getContractsContract"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contracts",
                    "id"
                ]
            }
        },
        "akamai:index/getCpCode:getCpCode": {
            "inputs": {
                "description": "A collection of arguments for invoking getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The group's unique ID, including the `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the CP code.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "productIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "group",
                    "groupId",
                    "name",
                    "productIds",
                    "id"
                ]
            }
        },
        "akamai:index/getDatastreamActivationHistory:getDatastreamActivationHistory": {
            "description": "Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the activation history for a provided stream ID:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst ds = akamai.getDatastreamActivationHistory({\n    streamId: 12345,\n});\nexport const dsHistoryStreamId = ds.then(ds =\u003e ds.streamId);\nexport const dsHistoryActivations = ds.then(ds =\u003e ds.activations);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nds = akamai.get_datastream_activation_history(stream_id=12345)\npulumi.export(\"dsHistoryStreamId\", ds.stream_id)\npulumi.export(\"dsHistoryActivations\", ds.activations)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ds = Output.Create(Akamai.GetDatastreamActivationHistory.InvokeAsync(new Akamai.GetDatastreamActivationHistoryArgs\n        {\n            StreamId = 12345,\n        }));\n        this.DsHistoryStreamId = ds.Apply(ds =\u003e ds.StreamId);\n        this.DsHistoryActivations = ds.Apply(ds =\u003e ds.Activations);\n    }\n\n    [Output(\"dsHistoryStreamId\")]\n    public Output\u003cstring\u003e DsHistoryStreamId { get; set; }\n    [Output(\"dsHistoryActivations\")]\n    public Output\u003cstring\u003e DsHistoryActivations { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tds, err := akamai.GetDatastreamActivationHistory(ctx, \u0026GetDatastreamActivationHistoryArgs{\n\t\t\tStreamId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dsHistoryStreamId\", ds.StreamId)\n\t\tctx.Export(\"dsHistoryActivations\", ds.Activations)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()\n            .streamId(12345)\n            .build());\n\n        ctx.export(\"dsHistoryStreamId\", ds.applyValue(getDatastreamActivationHistoryResult -\u003e getDatastreamActivationHistoryResult.streamId()));\n        ctx.export(\"dsHistoryActivations\", ds.applyValue(getDatastreamActivationHistoryResult -\u003e getDatastreamActivationHistoryResult.activations()));\n    }\n}\n```\n```yaml\nvariables:\n  ds:\n    Fn::Invoke:\n      Function: akamai:getDatastreamActivationHistory\n      Arguments:\n        streamId: 12345\noutputs:\n  dsHistoryStreamId: ${ds.streamId}\n  dsHistoryActivations: ${ds.activations}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `activations` - Detailed information about an activation status change for a version of a stream, including:\n  * `created_by` - The user who activated or deactivated the stream.\n  * `created_date` - The date and time of an activation status change.\n  * `stream_id` - A stream's unique identifier.\n  * `stream_version_id` - A stream version's unique identifier.\n  * `is_active` -\tWhether the version of the stream is active.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastreamActivationHistory.\n",
                "properties": {
                    "streamId": {
                        "type": "integer",
                        "description": "- (Required) A stream's unique identifier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "streamId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastreamActivationHistory.\n",
                "properties": {
                    "activations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getDatastreamActivationHistoryActivation:getDatastreamActivationHistoryActivation"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "streamId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "activations",
                    "streamId",
                    "id"
                ]
            }
        },
        "akamai:index/getDatastreamDatasetFields:getDatastreamDatasetFields": {
            "description": "Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns data set fields for a default template:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst fields = pulumi.output(akamai.getDatastreamDatasetFields());\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nfields = akamai.get_datastream_dataset_fields()\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var fields = Output.Create(Akamai.GetDatastreamDatasetFields.InvokeAsync());\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetDatastreamDatasetFields(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fields = AkamaiFunctions.getDatastreamDatasetFields();\n\n    }\n}\n```\n```yaml\nvariables:\n  fields:\n    Fn::Invoke:\n      Function: akamai:getDatastreamDatasetFields\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `fields` - A group of data set fields available in a template, including:\n  * `dataset_group_name` - The name of the data set group.\n  * `dataset_group_description` - Additional information about the data set group.\n  * `dataset_fields` - A list of data set fields available within the data set group, including:\n      * `dataset_field_description` - Additional information about the data set field.\n      * `dataset_field_id` - Unique identifier for the field.\n      * `dataset_field_json_key` - The JSON key for the field in a log line.\n      * `dataset_field_name` - The name of the data set field.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastreamDatasetFields.\n",
                "properties": {
                    "templateName": {
                        "type": "string",
                        "description": "- (Optional) The name of the data set template you use in your stream configuration. Currently, `EDGE_LOGS` is the only available data set template and the default value for this argument.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatastreamDatasetFields.\n",
                "properties": {
                    "fields": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getDatastreamDatasetFieldsField:getDatastreamDatasetFieldsField"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "templateName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "fields",
                    "id"
                ]
            }
        },
        "akamai:index/getDnsRecordSet:getDnsRecordSet": {
            "inputs": {
                "description": "A collection of arguments for invoking getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "recordType",
                    "zone"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rdatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "rdatas",
                    "recordType",
                    "zone",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorkersPropertyRules:getEdgeWorkersPropertyRules": {
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorkersPropertyRules.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "Unique identifier of an EdgeWorker ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorkersPropertyRules.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId",
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorkersResourceTier:getEdgeWorkersResourceTier": {
            "description": "Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the resource tier fields for an EdgeWorker ID:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = pulumi.output(akamai.getEdgeWorkersResourceTier({\n    contractId: \"1-ABC\",\n    resourceTierName: \"Basic Compute\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_edge_workers_resource_tier(contract_id=\"1-ABC\",\n    resource_tier_name=\"Basic Compute\")\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetEdgeWorkersResourceTier.InvokeAsync(new Akamai.GetEdgeWorkersResourceTierArgs\n        {\n            ContractId = \"1-ABC\",\n            ResourceTierName = \"Basic Compute\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetEdgeWorkersResourceTier(ctx, \u0026GetEdgeWorkersResourceTierArgs{\n\t\t\tContractId:       \"1-ABC\",\n\t\t\tResourceTierName: \"Basic Compute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()\n            .contractId(\"1-ABC\")\n            .resourceTierName(\"Basic Compute\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getEdgeWorkersResourceTier\n      Arguments:\n        contractId: 1-ABC\n        resourceTierName: Basic Compute\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `resource_tier_id` - Unique identifier of the resource tier.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorkersResourceTier.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "Unique identifier of a contract.\n"
                    },
                    "resourceTierName": {
                        "type": "string",
                        "description": "Unique name of the resource tier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "resourceTierName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorkersResourceTier.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "resourceTierId": {
                        "type": "integer"
                    },
                    "resourceTierName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "resourceTierId",
                    "resourceTierName",
                    "id"
                ]
            }
        },
        "akamai:index/getGroup:getGroup": {
            "description": "Use the `akamai.getGroup` data source to get a group by name.\n\nEach account features a hierarchy of groups, which control access to your\nAkamai configurations and help consolidate reporting functions, typically\nmapping to an organizational hierarchy. Using either Control Center or the\n[Identity Management: User Administration API](https://developer.akamai.com/en-us/api/core_features/identity_management_user_admin/v2.html),\naccount administrators can assign properties to specific groups, each with\nits own set of users and accompanying roles.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst exampleGroup = pulumi.output(akamai.getGroup({\n    contractId: \"\",\n    \"data.akamai_contract.example.id\": [{}],\n    groupName: \"example group name\",\n}));\nconst exampleContract = pulumi.output(akamai.getContract({\n    groupName: \"example group name\",\n}));\nconst exampleProperty = new akamai.Property(\"example\", {\n    \"data.akamai_group.example.id\": [{}],\n    groupId: \"\",\n});\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `id` - The group's unique ID, including the `grp_` prefix.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The group name.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Replaced by `group_name`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"name\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "deprecationMessage": "The setting \"name\" has been deprecated."
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "groupName",
                    "name",
                    "id"
                ]
            }
        },
        "akamai:index/getGroups:getGroups": {
            "description": "Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n## Basic usage\n\nReturn groups associated with the EdgeGrid API client token you're using:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getGroups({});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_groups()\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_example = Output.Create(Akamai.GetGroups.InvokeAsync());\n        this.PropertyMatch = my_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetGroups(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  my-example:\n    Fn::Invoke:\n      Function: akamai:getGroups\n      Arguments: {}\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `groups` - A list of supported groups, with the following attributes:\n  * `group_id` - A group's unique ID, including the `grp_` prefix.\n  * `group_name` - The name of the group.\n  * `parent_group_id` - The ID of the parent group, if applicable.\n  * `contract_ids` - An array of strings listing the contract IDs for each group.\n",
            "outputs": {
                "description": "A collection of values returned by getGroups.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getGroupsGroup:getGroupsGroup"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "id"
                ]
            }
        },
        "akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter": {
            "description": "Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.\n\n## Attributes reference\n\nThis data source supports these attributes:\n\n* `id` - The data resource ID. Enter in this format: `\u003cdomain\u003e:default_datacenter:\u003cdatacenter_id\u003e`.\n* `datacenter_id` - The default data center ID.\n* `nickname` - The default data center nickname.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer",
                        "description": "The default is `5400`.\n"
                    },
                    "domain": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "domain"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer"
                    },
                    "datacenterId": {
                        "type": "integer"
                    },
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nickname": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "domain",
                    "nickname",
                    "id"
                ]
            }
        },
        "akamai:index/getIamContactTypes:getIamContactTypes": {
            "description": "Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user's contact type.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst contactTypes = akamai.getIamContactTypes({});\nexport const supportedContactTypes = contactTypes;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncontact_types = akamai.get_iam_contact_types()\npulumi.export(\"supportedContactTypes\", contact_types)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var contactTypes = Output.Create(Akamai.GetIamContactTypes.InvokeAsync());\n        this.SupportedContactTypes = contactTypes;\n    }\n\n    [Output(\"supportedContactTypes\")]\n    public Output\u003cstring\u003e SupportedContactTypes { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcontactTypes, err := akamai.GetIamContactTypes(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedContactTypes\", contactTypes)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  contactTypes:\n    Fn::Invoke:\n      Function: akamai:getIamContactTypes\n      Arguments: {}\noutputs:\n  supportedContactTypes: ${contactTypes}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `contact_types` — A list of contact types.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadmincontacttypes)\n",
            "outputs": {
                "description": "A collection of values returned by getIamContactTypes.\n",
                "properties": {
                    "contactTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contactTypes",
                    "id"
                ]
            }
        },
        "akamai:index/getIamCountries:getIamCountries": {
            "description": "Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user's country information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst countries = akamai.getIamCountries({});\nexport const supportedCountries = countries;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncountries = akamai.get_iam_countries()\npulumi.export(\"supportedCountries\", countries)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var countries = Output.Create(Akamai.GetIamCountries.InvokeAsync());\n        this.SupportedCountries = countries;\n    }\n\n    [Output(\"supportedCountries\")]\n    public Output\u003cstring\u003e SupportedCountries { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcountries, err := akamai.GetIamCountries(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedCountries\", countries)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  countries:\n    Fn::Invoke:\n      Function: akamai:getIamCountries\n      Arguments: {}\noutputs:\n  supportedCountries: ${countries}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `countries` — A list of countries.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadmincountries)\n",
            "outputs": {
                "description": "A collection of values returned by getIamCountries.\n",
                "properties": {
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "countries",
                    "id"
                ]
            }
        },
        "akamai:index/getIamGrantableRoles:getIamGrantableRoles": {
            "description": "List which grantable roles you can include in a new custom role or add to an existing custom role. \n\n## Basic usage\n\nThis example returns the available roles to grant to users:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getIamGrantableRoles({});\nexport const akaGrantableRolesCount = data.akamai_iam_grantable_roles.test.grantable_roles.length;\nexport const akaGrantableRoles = data.akamai_iam_grantable_roles.test;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_iam_grantable_roles()\npulumi.export(\"akaGrantableRolesCount\", len(data[\"akamai_iam_grantable_roles\"][\"test\"][\"grantable_roles\"]))\npulumi.export(\"akaGrantableRoles\", data[\"akamai_iam_grantable_roles\"][\"test\"])\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetIamGrantableRoles.InvokeAsync());\n        this.AkaGrantableRolesCount = data.Akamai_iam_grantable_roles.Test.Grantable_roles.Length;\n        this.AkaGrantableRoles = data.Akamai_iam_grantable_roles.Test;\n    }\n\n    [Output(\"akaGrantableRolesCount\")]\n    public Output\u003cstring\u003e AkaGrantableRolesCount { get; set; }\n    [Output(\"akaGrantableRoles\")]\n    public Output\u003cstring\u003e AkaGrantableRoles { get; set; }\n}\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role. \n  * `granted_role_id` - Granted role ID.\n  * `name` - Granted role name.\n  * `description` - Granted role description.\n",
            "outputs": {
                "description": "A collection of values returned by getIamGrantableRoles.\n",
                "properties": {
                    "grantableRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamGrantableRolesGrantableRole:getIamGrantableRolesGrantableRole"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "grantableRoles",
                    "id"
                ]
            }
        },
        "akamai:index/getIamRoles:getIamRoles": {
            "description": "Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user's auth grants.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-roles = akamai.getIamRoles({});\nexport const roles = my_roles;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_roles = akamai.get_iam_roles()\npulumi.export(\"roles\", my_roles)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_roles = Output.Create(Akamai.GetIamRoles.InvokeAsync());\n        this.Roles = my_roles;\n    }\n\n    [Output(\"roles\")]\n    public Output\u003cstring\u003e Roles { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_roles, err := akamai.GetIamRoles(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"roles\", my_roles)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  my-roles:\n    Fn::Invoke:\n      Function: akamai:getIamRoles\n      Arguments: {}\noutputs:\n  roles: ${[\"my-roles\"]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `roles` — A list of roles.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getroles)\n",
            "outputs": {
                "description": "A collection of values returned by getIamRoles.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamRolesRole:getIamRolesRole"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "roles",
                    "id"
                ]
            }
        },
        "akamai:index/getIamStates:getIamStates": {
            "description": "Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don't know a user's state. Administrators use this data source to set a user's state.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst states = akamai.getIamStates({\n    country: \"canada\",\n});\nexport const supportedStates = states;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nstates = akamai.get_iam_states(country=\"canada\")\npulumi.export(\"supportedStates\", states)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var states = Output.Create(Akamai.GetIamStates.InvokeAsync(new Akamai.GetIamStatesArgs\n        {\n            Country = \"canada\",\n        }));\n        this.SupportedStates = states;\n    }\n\n    [Output(\"supportedStates\")]\n    public Output\u003cstring\u003e SupportedStates { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstates, err := akamai.GetIamStates(ctx, \u0026GetIamStatesArgs{\n\t\t\tCountry: \"canada\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedStates\", states)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetIamStatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()\n            .country(\"canada\")\n            .build());\n\n        ctx.export(\"supportedStates\", states.applyValue(getIamStatesResult -\u003e getIamStatesResult));\n    }\n}\n```\n```yaml\nvariables:\n  states:\n    Fn::Invoke:\n      Function: akamai:getIamStates\n      Arguments:\n        country: canada\noutputs:\n  supportedStates: ${states}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `states` — A list of states.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadmincountrystates)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIamStates.\n",
                "properties": {
                    "country": {
                        "type": "string",
                        "description": "— (required, string) Sepcifies USA or Canada.\n"
                    }
                },
                "type": "object",
                "required": [
                    "country"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIamStates.\n",
                "properties": {
                    "country": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "states": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "country",
                    "states",
                    "id"
                ]
            }
        },
        "akamai:index/getIamSupportedLangs:getIamSupportedLangs": {
            "description": "Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst supportedLangs = akamai.getIamSupportedLangs({});\nexport const supportedSupportedLangs = supportedLangs;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nsupported_langs = akamai.get_iam_supported_langs()\npulumi.export(\"supportedSupportedLangs\", supported_langs)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var supportedLangs = Output.Create(Akamai.GetIamSupportedLangs.InvokeAsync());\n        this.SupportedSupportedLangs = supportedLangs;\n    }\n\n    [Output(\"supportedSupportedLangs\")]\n    public Output\u003cstring\u003e SupportedSupportedLangs { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsupportedLangs, err := akamai.GetIamSupportedLangs(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedSupportedLangs\", supportedLangs)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  supportedLangs:\n    Fn::Invoke:\n      Function: akamai:getIamSupportedLangs\n      Arguments: {}\noutputs:\n  supportedSupportedLangs: ${supportedLangs}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `languages` — Languages supported by Akamai\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadminsupportedlanguages)\n",
            "outputs": {
                "description": "A collection of values returned by getIamSupportedLangs.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "languages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "languages",
                    "id"
                ]
            }
        },
        "akamai:index/getIamTimeoutPolicies:getIamTimeoutPolicies": {
            "description": "Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst timeoutPolicies = akamai.getIamTimeoutPolicies({});\nexport const supportedTimeoutPolicies = timeoutPolicies;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntimeout_policies = akamai.get_iam_timeout_policies()\npulumi.export(\"supportedTimeoutPolicies\", timeout_policies)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var timeoutPolicies = Output.Create(Akamai.GetIamTimeoutPolicies.InvokeAsync());\n        this.SupportedTimeoutPolicies = timeoutPolicies;\n    }\n\n    [Output(\"supportedTimeoutPolicies\")]\n    public Output\u003cstring\u003e SupportedTimeoutPolicies { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttimeoutPolicies, err := akamai.GetIamTimeoutPolicies(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedTimeoutPolicies\", timeoutPolicies)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nvariables:\n  timeoutPolicies:\n    Fn::Invoke:\n      Function: akamai:getIamTimeoutPolicies\n      Arguments: {}\noutputs:\n  supportedTimeoutPolicies: ${timeoutPolicies}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `policies` — A map of session timeout policy names to their value in seconds.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadmintimeoutpolicies)\n",
            "outputs": {
                "description": "A collection of values returned by getIamTimeoutPolicies.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "policies": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "policies",
                    "id"
                ]
            }
        },
        "akamai:index/getIamTimezones:getIamTimezones": {
            "description": "Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user's time zone. The default time zone is GMT. \n\n## Attributes reference\n\nThese attributes are returned:\n\n* `timezones` — Supported timezones.\n  * `timezone` - The time zone ID.\n  * `description` - The description of a time zone, including the GMT +/-.\n  * `offset` - The time zone offset from GMT.\n  * `posix` - The time zone posix.\n\n[API Reference](https://developer.akamai.com/api/core_features/identity_management_user_admin/v2.html#getadmintimezones)\n",
            "outputs": {
                "description": "A collection of values returned by getIamTimezones.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "timezones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamTimezonesTimezone:getIamTimezonesTimezone"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "timezones",
                    "id"
                ]
            }
        },
        "akamai:index/getNetworkLists:getNetworkLists": {
            "description": "Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,\noptionally filtered by list type or based on a search string. The information available is described\n[here](https://developer.akamai.com/api/cloud_security/network_lists/v2.html#getlists). \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkLists = akamai.getNetworkLists({});\nexport const networkListsText = networkLists.then(networkLists =\u003e networkLists.outputText);\nexport const networkListsJson = networkLists.then(networkLists =\u003e networkLists.json);\nexport const networkListsList = networkLists.then(networkLists =\u003e networkLists.lists);\nconst networkListsFilter = akamai.getNetworkLists({\n    name: \"Test Whitelist\",\n    type: \"IP\",\n});\nexport const networkListsFilterText = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.outputText);\nexport const networkListsFilterJson = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.json);\nexport const networkListsFilterList = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.lists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_lists = akamai.get_network_lists()\npulumi.export(\"networkListsText\", network_lists.output_text)\npulumi.export(\"networkListsJson\", network_lists.json)\npulumi.export(\"networkListsList\", network_lists.lists)\nnetwork_lists_filter = akamai.get_network_lists(name=\"Test Whitelist\",\n    type=\"IP\")\npulumi.export(\"networkListsFilterText\", network_lists_filter.output_text)\npulumi.export(\"networkListsFilterJson\", network_lists_filter.json)\npulumi.export(\"networkListsFilterList\", network_lists_filter.lists)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var networkLists = Output.Create(Akamai.GetNetworkLists.InvokeAsync());\n        this.NetworkListsText = networkLists.Apply(networkLists =\u003e networkLists.OutputText);\n        this.NetworkListsJson = networkLists.Apply(networkLists =\u003e networkLists.Json);\n        this.NetworkListsList = networkLists.Apply(networkLists =\u003e networkLists.Lists);\n        var networkListsFilter = Output.Create(Akamai.GetNetworkLists.InvokeAsync(new Akamai.GetNetworkListsArgs\n        {\n            Name = \"Test Whitelist\",\n            Type = \"IP\",\n        }));\n        this.NetworkListsFilterText = networkListsFilter.Apply(networkListsFilter =\u003e networkListsFilter.OutputText);\n        this.NetworkListsFilterJson = networkListsFilter.Apply(networkListsFilter =\u003e networkListsFilter.Json);\n        this.NetworkListsFilterList = networkListsFilter.Apply(networkListsFilter =\u003e networkListsFilter.Lists);\n    }\n\n    [Output(\"networkListsText\")]\n    public Output\u003cstring\u003e NetworkListsText { get; set; }\n    [Output(\"networkListsJson\")]\n    public Output\u003cstring\u003e NetworkListsJson { get; set; }\n    [Output(\"networkListsList\")]\n    public Output\u003cstring\u003e NetworkListsList { get; set; }\n    [Output(\"networkListsFilterText\")]\n    public Output\u003cstring\u003e NetworkListsFilterText { get; set; }\n    [Output(\"networkListsFilterJson\")]\n    public Output\u003cstring\u003e NetworkListsFilterJson { get; set; }\n    [Output(\"networkListsFilterList\")]\n    public Output\u003cstring\u003e NetworkListsFilterList { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkLists, err := akamai.GetNetworkLists(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"networkListsText\", networkLists.OutputText)\n\t\tctx.Export(\"networkListsJson\", networkLists.Json)\n\t\tctx.Export(\"networkListsList\", networkLists.Lists)\n\t\tnetworkListsFilter, err := akamai.GetNetworkLists(ctx, \u0026GetNetworkListsArgs{\n\t\t\tName: pulumi.StringRef(\"Test Whitelist\"),\n\t\t\tType: pulumi.StringRef(\"IP\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"networkListsFilterText\", networkListsFilter.OutputText)\n\t\tctx.Export(\"networkListsFilterJson\", networkListsFilter.Json)\n\t\tctx.Export(\"networkListsFilterList\", networkListsFilter.Lists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetNetworkListsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkLists = AkamaiFunctions.getNetworkLists();\n\n        ctx.export(\"networkListsText\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.outputText()));\n        ctx.export(\"networkListsJson\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.json()));\n        ctx.export(\"networkListsList\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()));\n        final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()\n            .name(\"Test Whitelist\")\n            .type(\"IP\")\n            .build());\n\n        ctx.export(\"networkListsFilterText\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.outputText()));\n        ctx.export(\"networkListsFilterJson\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.json()));\n        ctx.export(\"networkListsFilterList\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()));\n    }\n}\n```\n```yaml\nvariables:\n  networkLists:\n    Fn::Invoke:\n      Function: akamai:getNetworkLists\n      Arguments: {}\n  networkListsFilter:\n    Fn::Invoke:\n      Function: akamai:getNetworkLists\n      Arguments:\n        name: Test Whitelist\n        type: IP\noutputs:\n  # tabular data of id, name, type, elementCount, syncPoint, readonly\n  networkListsText: ${networkLists.outputText}\n  networkListsJson: ${networkLists.json}\n  # custom output of network list ids\n  networkListsList: ${networkLists.lists}\n  networkListsFilterText: ${networkListsFilter.outputText}\n  networkListsFilterJson: ${networkListsFilter.json}\n  # custom output of single network list id\n  networkListsFilterList: ${networkListsFilter.lists}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkLists.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of a specific network list to retrieve. If not supplied, information about all network\nlists will be returned.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of a specific network list to retrieve.\nIf not supplied, information about all network lists will be returned.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of network lists to be retrieved; must be either \"IP\" or \"GEO\". If not supplied,\ninformation about both types will be returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkLists.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "A JSON-formatted list of information about the specified network list(s).\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list containing the IDs of the specified network lists(s).\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkListId": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "A tabular display showing the network list information.\n"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "json",
                    "lists",
                    "networkListId",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getProperties:getProperties": {
            "description": "Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract\nbased on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn properties associated with the EdgeGrid API client token currently used for authentication:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const myPropertyList = data.akamai_properties.example;\n```\n```python\nimport pulumi\n\npulumi.export(\"myPropertyList\", data[\"akamai_properties\"][\"example\"])\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        this.MyPropertyList = data.Akamai_properties.Example;\n    }\n\n    [Output(\"myPropertyList\")]\n    public Output\u003cstring\u003e MyPropertyList { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"myPropertyList\", data.Akamai_properties.Example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"myPropertyList\", data.akamai_properties().example());\n    }\n}\n```\n```yaml\noutputs:\n  myPropertyList: ${data.akamai_properties.example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `properties` - A list of properties available for the contract and group IDs provided.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperties.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperties.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertiesProperty:getPropertiesProperty"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "properties",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertiesSearch:getPropertiesSearch": {
            "description": "Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn properties associated with the EdgeGrid API client token currently used for authentication:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const myPropertyList = data.akamai_properties_search.example;\n```\n```python\nimport pulumi\n\npulumi.export(\"myPropertyList\", data[\"akamai_properties_search\"][\"example\"])\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        this.MyPropertyList = data.Akamai_properties_search.Example;\n    }\n\n    [Output(\"myPropertyList\")]\n    public Output\u003cstring\u003e MyPropertyList { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"myPropertyList\", data.Akamai_properties_search.Example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"myPropertyList\", data.akamai_properties_search().example());\n    }\n}\n```\n```yaml\noutputs:\n  myPropertyList: ${data.akamai_properties_search.example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `properties` - A list of property version matching the given criteria.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertiesSearch.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key used for search. Valid values are:\n* **hostname**\n* **edgeHostname**\n* **propertyName**\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "- (Required) Value to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "value"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertiesSearch.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertiesSearchProperty:getPropertiesSearchProperty"
                        }
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "properties",
                    "value",
                    "id"
                ]
            }
        },
        "akamai:index/getProperty:getProperty": {
            "description": "Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the property ID and rule tree based on the property name and optional version argument:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getProperty({\n    name: \"terraform-demo\",\n    version: 1,\n});\nexport const myPropertyID = example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_property(name=\"terraform-demo\",\n    version=1)\npulumi.export(\"myPropertyID\", example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetProperty.InvokeAsync(new Akamai.GetPropertyArgs\n        {\n            Name = \"terraform-demo\",\n            Version = 1,\n        }));\n        this.MyPropertyID = example;\n    }\n\n    [Output(\"myPropertyID\")]\n    public Output\u003cstring\u003e MyPropertyID { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.LookupProperty(ctx, \u0026GetPropertyArgs{\n\t\t\tName:    \"terraform-demo\",\n\t\t\tVersion: pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myPropertyID\", example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()\n            .name(\"terraform-demo\")\n            .version(\"1\")\n            .build());\n\n        ctx.export(\"myPropertyID\", example.applyValue(getPropertyResult -\u003e getPropertyResult));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getProperty\n      Arguments:\n        name: terraform-demo\n        version: 1\noutputs:\n  myPropertyID: ${example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `property_ID` - A property's unique identifier, including the `prp_` prefix.\n* `rules` - A JSON-encoded rule tree for a given property.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperty.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "- (Required) The property name.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version of the property whose ID you want to list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperty.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rules",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyHostnames:getPropertyHostnames": {
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyHostnames.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "- (Required) A property's unique ID, including the `prp_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyHostnames.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyHostnamesHostname:getPropertyHostnamesHostname"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "hostnames",
                    "propertyId",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyProducts:getPropertyProducts": {
            "description": "Use the `akamai.getPropertyProducts` data source to list the products included on a contract.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const propertyMatch = data.akamai_property_products[\"my-example\"];\n```\n```python\nimport pulumi\n\npulumi.export(\"propertyMatch\", data[\"akamai_property_products\"][\"my-example\"])\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        this.PropertyMatch = data.Akamai_property_products.My_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"propertyMatch\", data.Akamai_property_products.My-example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"propertyMatch\", data.akamai_property_products().my-example());\n    }\n}\n```\n```yaml\noutputs:\n  propertyMatch: ${data.akamai_property_products\"my-example\"[%!s(MISSING)]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `products` - A list of supported products for the contract, including:\n  * `product_id` - The product's unique ID, including the `prd_` prefix.\n  * `product_name` - A string containing the product name.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyProducts.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyProducts.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyProductsProduct:getPropertyProductsProduct"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "products",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRuleFormats:getPropertyRuleFormats": {
            "description": "Use the `akamai.getPropertyRuleFormats` data source to query the list of\nknown rule formats.\nYou use rule formats to [freeze](https://developer.akamai.com/api/core_features/property_manager/v1.html#freezerf) or\n[update](https://developer.akamai.com/api/core_features/property_manager/v1.html#updaterf) the versioned set of behaviors\nand criteria a rule tree invokes. Without this mechanism, behaviors and criteria\nwould update automatically and generate unexpected errors.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nUse this example to list available property rule formats:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const propertyMatch = data.akamai_property_rule_formats[\"my-example\"];\n```\n```python\nimport pulumi\n\npulumi.export(\"propertyMatch\", data[\"akamai_property_rule_formats\"][\"my-example\"])\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        this.PropertyMatch = data.Akamai_property_rule_formats.My_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"propertyMatch\", data.Akamai_property_rule_formats.My-example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"propertyMatch\", data.akamai_property_rule_formats().my-example());\n    }\n}\n```\n```yaml\noutputs:\n  propertyMatch: ${data.akamai_property_rule_formats\"my-example\"[%!s(MISSING)]}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getPropertyRuleFormats.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ruleFormats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "ruleFormats",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRules:getPropertyRules": {
            "description": "Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of\nan existing property version. This data source lets you search across the contracts\nand groups you have access to.\n\n## Basic usage\n\nThis example returns the rule tree for version 3 of a property based on the selected contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getPropertyRules({\n    propertyId: \"prp_123\",\n    groupId: \"grp_12345\",\n    contractId: \"ctr_1-AB123\",\n    version: 3,\n});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_property_rules(property_id=\"prp_123\",\n    group_id=\"grp_12345\",\n    contract_id=\"ctr_1-AB123\",\n    version=3)\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_example = Output.Create(Akamai.GetPropertyRules.InvokeAsync(new Akamai.GetPropertyRulesArgs\n        {\n            PropertyId = \"prp_123\",\n            GroupId = \"grp_12345\",\n            ContractId = \"ctr_1-AB123\",\n            Version = 3,\n        }));\n        this.PropertyMatch = my_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetPropertyRules(ctx, \u0026GetPropertyRulesArgs{\n\t\t\tPropertyId: \"prp_123\",\n\t\t\tGroupId:    pulumi.StringRef(\"grp_12345\"),\n\t\t\tContractId: pulumi.StringRef(\"ctr_1-AB123\"),\n\t\t\tVersion:    pulumi.IntRef(3),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()\n            .propertyId(\"prp_123\")\n            .groupId(\"grp_12345\")\n            .contractId(\"ctr_1-AB123\")\n            .version(3)\n            .build());\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    Fn::Invoke:\n      Function: akamai:getPropertyRules\n      Arguments:\n        propertyId: prp_123\n        groupId: grp_12345\n        contractId: ctr_1-AB123\n        version: 3\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [About rule formats](https://developer.akamai.com/api/core_features/property_manager/vlatest.html#rf) to learn more.\n* `rules` - A JSON-encoded rule tree for the property.\n* `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the Property Manager API documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "- (Required) A property's unique ID, including the `prp_` prefix.\n"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version to return. Returns the latest version by default.\n"
                    }
                },
                "type": "object",
                "required": [
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "errors": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "errors",
                    "groupId",
                    "propertyId",
                    "rules",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRulesTemplate:getPropertyRulesTemplate": {
            "description": "The `akamai.getPropertyRulesTemplate` data source lets you define a rule tree. A rule tree is a nested block of property rules in JSON format that includes match criteria and behaviors. You can break a rule tree out into smaller JSON  template files that cover individual rules.\n\nWith this data source, you define which JSON template files to use for your property. You can also set values for variables.\n\nThis data source uses the rule template format from the [Property Manager CLI](https://github.com/akamai/cli-property-manager#set-up-property-snippets).\n\n\u003e You can define variables either by using the Property Manager CLI syntax or by using standard variables.\n\n## How to work with JSON template files\n\nYou have a few options when working with rule template files:\n\n* Use a single JSON file that includes all rules for the property.\n* Create separate JSON template files for each rule and store them in the `property-snippets` directory.\n* Reference individual template files directly in this data source.\n\n### Create a set of JSON template files\n\nIf you have a set of JSON template files you want to call:\n\n1. Put them all in a directory called `property-snippets`.\n1. Make sure the `property-snippets` folder only contains `.json` files.\n1. Add the `template_dir` argument. For example: `template_dir = \"property-snippets/\"`.\n\n\u003e This directory name is different from the one required for the Property Manager CLI, which is called `config-snippets`.\n\n## How to use property variables with a template\n\nYou can also add variables to a template by using a string like `“${env.\u003cvariableName\u003e}\"`. These property variables follow the file structure and syntax used when [creating a pipeline in the Property Manager CLI](https://github.com/akamai/cli-property-manager#create-and-set-up-a-new-pipeline).\n\nYou need to create these files when using property variables:\n\n* a `variableDefinitions.json` file to define your variables and their default values.\n* one or more `variables.json` files to define settings specific to an environment. \u003cbr\u003e The file name should always be `variables.json`. If using multiple environments, set up a directory for each environment to store this file in.\n\n\u003e Property variables are separate from variables.\n\n{{% examples %}}\n## Example Usage\n\n### JSON Template Files\n\nHere are some examples of how you can set up your JSON template files for use with this data source.\n{{% example %}}\n### Single JSON template that calls other templates\n\nHere's an example of a JSON template file with nested templates:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n{{% /example %}}\n{{% example %}}\n### Individual JSON rule template file\n\nHere’s a simple default rule example that you can include inside the `template_data` argument:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\n{{% /example %}}\n### Add Templates To The Data Source\n\nHere are some examples of how you can call your JSON template files with this data source.\n{{% example %}}\n### Call individual template files with this data source\n\nThis second example shows how to call a specific JSON template using the `template_data` field:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst examplePropertyRulesTemplate = akamai.getPropertyRulesTemplate({\n    templates: [{\n        templateData: JSON.stringify({\n            rules: {\n                name: \"default\",\n                children: [\"#include:rules.json\"],\n            },\n        }),\n        templateDir: \"property-snippets/\",\n    }],\n});\nconst exampleProperty = new akamai.Property(\"exampleProperty\", {\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    ruleFormat: \"v2020-03-04\",\n    rules: examplePropertyRulesTemplate.then(examplePropertyRulesTemplate =\u003e examplePropertyRulesTemplate.json),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_akamai as akamai\n\nexample_property_rules_template = akamai.get_property_rules_template(templates=[akamai.GetPropertyRulesTemplateTemplateArgs(\n    template_data=json.dumps({\n        \"rules\": {\n            \"name\": \"default\",\n            \"children\": [\"#include:rules.json\"],\n        },\n    }),\n    template_dir=\"property-snippets/\",\n)])\nexample_property = akamai.Property(\"exampleProperty\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    rule_format=\"v2020-03-04\",\n    rules=example_property_rules_template.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var examplePropertyRulesTemplate = Output.Create(Akamai.GetPropertyRulesTemplate.InvokeAsync(new Akamai.GetPropertyRulesTemplateArgs\n        {\n            Templates = \n            {\n                new Akamai.Inputs.GetPropertyRulesTemplateTemplateArgs\n                {\n                    TemplateData = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                    {\n                        { \"rules\", new Dictionary\u003cstring, object?\u003e\n                        {\n                            { \"name\", \"default\" },\n                            { \"children\", new[]\n                                {\n                                    \"#include:rules.json\",\n                                }\n                             },\n                        } },\n                    }),\n                    TemplateDir = \"property-snippets/\",\n                },\n            },\n        }));\n        var exampleProperty = new Akamai.Property(\"exampleProperty\", new Akamai.PropertyArgs\n        {\n            ContractId = @var.Contractid,\n            GroupId = @var.Groupid,\n            RuleFormat = \"v2020-03-04\",\n            Rules = examplePropertyRulesTemplate.Apply(examplePropertyRulesTemplate =\u003e examplePropertyRulesTemplate.Json),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"rules\": map[string]interface{}{\n\t\t\t\t\"name\": \"default\",\n\t\t\t\t\"children\": []string{\n\t\t\t\t\t\"#include:rules.json\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\texamplePropertyRulesTemplate, err := akamai.GetPropertyRulesTemplate(ctx, \u0026GetPropertyRulesTemplateArgs{\n\t\t\tTemplates: []GetPropertyRulesTemplateTemplate{\n\t\t\t\tGetPropertyRulesTemplateTemplate{\n\t\t\t\t\tTemplateData: json0,\n\t\t\t\t\tTemplateDir:  \"property-snippets/\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewProperty(ctx, \"exampleProperty\", \u0026akamai.PropertyArgs{\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      pulumi.String(examplePropertyRulesTemplate.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()\n            .templates(GetPropertyRulesTemplateTemplateArgs.builder()\n                .templateData(serializeJson(\n                    jsonObject(\n                        jsonProperty(\"rules\", jsonObject(\n                            jsonProperty(\"name\", \"default\"),\n                            jsonProperty(\"children\", jsonArray(\"#include:rules.json\"))\n                        ))\n                    )))\n                .templateDir(\"property-snippets/\")\n                .build())\n            .build());\n\n        var exampleProperty = new Property(\"exampleProperty\", PropertyArgs.builder()        \n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -\u003e getPropertyRulesTemplateResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleProperty:\n    type: akamai:Property\n    properties:\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      ruleFormat: v2020-03-04\n      rules: ${examplePropertyRulesTemplate.json}\nvariables:\n  examplePropertyRulesTemplate:\n    Fn::Invoke:\n      Function: akamai:getPropertyRulesTemplate\n      Arguments:\n        templates:\n          - templateData:\n              Fn::ToJSON:\n                rules:\n                  name: default\n                  children:\n                    - '#include:rules.json'\n            templateDir: property-snippets/\n```\n\n{{% /example %}}\n### Variables\n\nYou can add variables individually or reference variable definition files.\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `json` - The fully expanded template with variables and all nested templates resolved.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRulesTemplate.\n",
                "properties": {
                    "templateFile": {
                        "type": "string",
                        "description": "The absolute path to your top-level JSON template file. The top-level template combines smaller, nested JSON templates to form your property rule tree. This argument conflicts with the `template` argument.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate"
                        },
                        "description": "The template you use in your configuration. This argument conflicts with the `template_file` argument.\n"
                    },
                    "varDefinitionFile": {
                        "type": "string",
                        "description": "Required when using `var_values_file`. The absolute path to the file containing variable definitions and defaults. This argument conflicts with the `variables` argument.\n"
                    },
                    "varValuesFile": {
                        "type": "string",
                        "description": "Required when using `var_definition_file`. The absolute path to the file containing variable values. This argument conflicts with the `variables` argument.\n"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable"
                        },
                        "description": "The definition of one or more variables. This argument conflicts with the `var_definition_file` and `var_values_file` arguments. A `variables` block includes:\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRulesTemplate.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "templateFile": {
                        "type": "string"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate"
                        }
                    },
                    "varDefinitionFile": {
                        "type": "string"
                    },
                    "varValuesFile": {
                        "type": "string"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:properties/getCpCode:getCpCode": {
            "inputs": {
                "description": "A collection of arguments for invoking getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The group's unique ID, including the `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the CP code.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "productIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "group",
                    "groupId",
                    "name",
                    "productIds",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode"
        },
        "akamai:properties/getProperty:getProperty": {
            "description": "Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the property ID and rule tree based on the property name and optional version argument:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getProperty({\n    name: \"terraform-demo\",\n    version: 1,\n});\nexport const myPropertyID = example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_property(name=\"terraform-demo\",\n    version=1)\npulumi.export(\"myPropertyID\", example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var example = Output.Create(Akamai.GetProperty.InvokeAsync(new Akamai.GetPropertyArgs\n        {\n            Name = \"terraform-demo\",\n            Version = 1,\n        }));\n        this.MyPropertyID = example;\n    }\n\n    [Output(\"myPropertyID\")]\n    public Output\u003cstring\u003e MyPropertyID { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.LookupProperty(ctx, \u0026GetPropertyArgs{\n\t\t\tName:    \"terraform-demo\",\n\t\t\tVersion: pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myPropertyID\", example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()\n            .name(\"terraform-demo\")\n            .version(\"1\")\n            .build());\n\n        ctx.export(\"myPropertyID\", example.applyValue(getPropertyResult -\u003e getPropertyResult));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    Fn::Invoke:\n      Function: akamai:getProperty\n      Arguments:\n        name: terraform-demo\n        version: 1\noutputs:\n  myPropertyID: ${example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `property_ID` - A property's unique identifier, including the `prp_` prefix.\n* `rules` - A JSON-encoded rule tree for a given property.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperty.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "- (Required) The property name.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version of the property whose ID you want to list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperty.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rules",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getProperty has been deprecated in favor of akamai.getProperty"
        },
        "akamai:properties/getPropertyRules:getPropertyRules": {
            "description": "Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of\nan existing property version. This data source lets you search across the contracts\nand groups you have access to.\n\n## Basic usage\n\nThis example returns the rule tree for version 3 of a property based on the selected contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getPropertyRules({\n    propertyId: \"prp_123\",\n    groupId: \"grp_12345\",\n    contractId: \"ctr_1-AB123\",\n    version: 3,\n});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_property_rules(property_id=\"prp_123\",\n    group_id=\"grp_12345\",\n    contract_id=\"ctr_1-AB123\",\n    version=3)\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var my_example = Output.Create(Akamai.GetPropertyRules.InvokeAsync(new Akamai.GetPropertyRulesArgs\n        {\n            PropertyId = \"prp_123\",\n            GroupId = \"grp_12345\",\n            ContractId = \"ctr_1-AB123\",\n            Version = 3,\n        }));\n        this.PropertyMatch = my_example;\n    }\n\n    [Output(\"propertyMatch\")]\n    public Output\u003cstring\u003e PropertyMatch { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v3/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetPropertyRules(ctx, \u0026GetPropertyRulesArgs{\n\t\t\tPropertyId: \"prp_123\",\n\t\t\tGroupId:    pulumi.StringRef(\"grp_12345\"),\n\t\t\tContractId: pulumi.StringRef(\"ctr_1-AB123\"),\n\t\t\tVersion:    pulumi.IntRef(3),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()\n            .propertyId(\"prp_123\")\n            .groupId(\"grp_12345\")\n            .contractId(\"ctr_1-AB123\")\n            .version(3)\n            .build());\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    Fn::Invoke:\n      Function: akamai:getPropertyRules\n      Arguments:\n        propertyId: prp_123\n        groupId: grp_12345\n        contractId: ctr_1-AB123\n        version: 3\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [About rule formats](https://developer.akamai.com/api/core_features/property_manager/vlatest.html#rf) to learn more.\n* `rules` - A JSON-encoded rule tree for the property.\n* `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://developer.akamai.com/api/core_features/property_manager/v1.html#errors) in the Property Manager API documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "- (Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "- (Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "- (Required) A property's unique ID, including the `prp_` prefix.\n"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer",
                        "description": "- (Optional) The version to return. Returns the latest version by default.\n"
                    }
                },
                "type": "object",
                "required": [
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "errors": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "errors",
                    "groupId",
                    "propertyId",
                    "rules",
                    "version",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getPropertyRules has been deprecated in favor of akamai.getPropertyRules"
        },
        "akamai:trafficmanagement/getGtmDefaultDatacenter:getGtmDefaultDatacenter": {
            "description": "Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.\n\n## Attributes reference\n\nThis data source supports these attributes:\n\n* `id` - The data resource ID. Enter in this format: `\u003cdomain\u003e:default_datacenter:\u003cdatacenter_id\u003e`.\n* `datacenter_id` - The default data center ID.\n* `nickname` - The default data center nickname.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer",
                        "description": "The default is `5400`.\n"
                    },
                    "domain": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "domain"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer"
                    },
                    "datacenterId": {
                        "type": "integer"
                    },
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nickname": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "domain",
                    "nickname",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter"
        }
    }
}