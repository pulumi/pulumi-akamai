{
    "name": "akamai",
    "description": "A Pulumi package for creating and managing akamai cloud resources.",
    "keywords": [
        "pulumi",
        "akamai"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`akamai` Terraform Provider](https://github.com/akamai/terraform-provider-akamai).",
    "repository": "https://github.com/pulumi/pulumi-akamai",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "akamai": "Akamai"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing akamai cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/akamai/terraform-provider-akamai)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-akamai` repo](https://github.com/pulumi/pulumi-akamai/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-akamai` repo](https://github.com/akamai/terraform-provider-akamai/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/akamai/terraform-provider-akamai)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-akamai` repo](https://github.com/pulumi/pulumi-akamai/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-akamai` repo](https://github.com/akamai/terraform-provider-akamai/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:config/appsecs:appsecs"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:config/config:config",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:config/dns:dns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:config/gtm:gtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:config/networks:networks"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:config/property:property",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        }
    },
    "types": {
        "akamai:config/appsecs:appsecs": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/config:config": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/dns:dns": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/gtm:gtm": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/networks:networks": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:config/property:property": {
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "accountKey": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string"
                },
                "clientToken": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "maxBody": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "The hashing algorithm.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The key name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "String known between transfer endpoints.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "name",
                "secret"
            ]
        },
        "akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter": {
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city in which the data center is located.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "Whether to override the cloud server host header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudService": {
                    "type": "boolean",
                    "description": "Whether this datacenter is a cloud service.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "continent": {
                    "type": "string",
                    "description": "The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "description": "The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "description": "The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latitude": {
                    "type": "number",
                    "description": "The latitude value for the data center. This member supports six decimal places of precision.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "livenessHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longitude": {
                    "type": "number",
                    "description": "The longitude value for the data center. This member supports six decimal places of precision.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "number",
                    "description": "The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "The state, province, or region where the data center is located.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "continent",
                "country",
                "latitude",
                "longitude",
                "originId",
                "percent"
            ]
        },
        "akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings": {
            "properties": {
                "additionalHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Maps additional case-insensitive HTTP header names included to the liveness testing requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeader": {
                    "type": "string",
                    "description": "The Host header for the liveness HTTP request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "interval": {
                    "type": "integer",
                    "description": "The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "Whether to validate the origin certificate for an HTTPS request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "description": "The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol or scheme for the database, either `HTTP` or `HTTPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "The request used for TCP and TCPS tests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "The response used for TCP and TCPS tests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status3xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status4xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status5xxFailure": {
                    "type": "boolean",
                    "description": "If set to `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "number",
                    "description": "The number of seconds the system waits before failing the liveness test.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path",
                "port",
                "protocol"
            ]
        },
        "akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr": {
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "description": "Your organizational unit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "description": "Your state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "countryCode",
                "organization",
                "organizationalUnit",
                "state"
            ]
        },
        "akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domain",
                        "fullPath",
                        "responseBody"
                    ]
                }
            }
        },
        "akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domain",
                        "fullPath",
                        "responseBody"
                    ]
                }
            }
        },
        "akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration": {
            "properties": {
                "clientMutualAuthentication": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication:CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication",
                    "description": "The configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloneDnsNames": {
                    "type": "boolean",
                    "description": "Whether CPS should direct traffic using all the SANs you listed in the SANs parameter when you created your enrollment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disallowedTlsVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The TLS protocol version to disallow. CPS uses the TLS protocols that Akamai currently supports as a best practice.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geography": {
                    "type": "string",
                    "description": "Lists where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia. You can only use the setting to include China and Russia if your Akamai contract specifies your ability to do so and you have approval from the Chinese and Russian government.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mustHaveCiphers": {
                    "type": "string",
                    "description": "The ciphers to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ocspStapling": {
                    "type": "string",
                    "description": "Whether to use OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response must be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want visitors to your site to contact the CA directly for an OSCP response. OCSP allows you to obtain the revocation status of a certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferredCiphers": {
                    "type": "string",
                    "description": "Ciphers that you preferably want to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quicEnabled": {
                    "type": "boolean",
                    "description": "Whether to use the QUIC transport layer network protocol.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "geography"
            ]
        },
        "akamai:index/CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication:CpsDvEnrollmentNetworkConfigurationClientMutualAuthentication": {
            "properties": {
                "ocspEnabled": {
                    "type": "boolean",
                    "description": "Whether you want to enable the Online Certificate Status Protocol (OCSP) stapling for client certificates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sendCaListToClient": {
                    "type": "boolean",
                    "description": "Whether you want to enable the server to send the certificate authority (CA) list to the client.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setId": {
                    "type": "string",
                    "description": "The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "name",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsThirdPartyEnrollmentAdminContact:CpsThirdPartyEnrollmentAdminContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsThirdPartyEnrollmentCsr:CpsThirdPartyEnrollmentCsr": {
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "description": "Your organizational unit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "description": "Your state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "countryCode",
                "organization",
                "organizationalUnit",
                "state"
            ]
        },
        "akamai:index/CpsThirdPartyEnrollmentNetworkConfiguration:CpsThirdPartyEnrollmentNetworkConfiguration": {
            "properties": {
                "clientMutualAuthentication": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication:CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication",
                    "description": "The configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloneDnsNames": {
                    "type": "boolean",
                    "description": "Whether CPS should direct traffic using all the SANs you listed in the SANs parameter when you created your enrollment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disallowedTlsVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The TLS protocol version to disallow. CPS uses the TLS protocols that Akamai currently supports as a best practice.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geography": {
                    "type": "string",
                    "description": "Lists where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia. You can only use the setting to include China and Russia if your Akamai contract specifies your ability to do so and you have approval from the Chinese and Russian government.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mustHaveCiphers": {
                    "type": "string",
                    "description": "The ciphers to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ocspStapling": {
                    "type": "string",
                    "description": "Whether to use OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. This response must be signed by the CA, not the server, therefore ensuring security. Disable OSCP Stapling if you want visitors to your site to contact the CA directly for an OSCP response. OCSP allows you to obtain the revocation status of a certificate.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferredCiphers": {
                    "type": "string",
                    "description": "Ciphers that you preferably want to include for the enrollment while deploying it on the network. Defaults to `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quicEnabled": {
                    "type": "boolean",
                    "description": "Whether to use the QUIC transport layer network protocol.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "geography"
            ]
        },
        "akamai:index/CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication:CpsThirdPartyEnrollmentNetworkConfigurationClientMutualAuthentication": {
            "properties": {
                "ocspEnabled": {
                    "type": "boolean",
                    "description": "Whether you want to enable the Online Certificate Status Protocol (OCSP) stapling for client certificates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sendCaListToClient": {
                    "type": "boolean",
                    "description": "Whether you want to enable the server to send the certificate authority (CA) list to the client.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setId": {
                    "type": "string",
                    "description": "The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/CpsThirdPartyEnrollmentOrganization:CpsThirdPartyEnrollmentOrganization": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "name",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/CpsThirdPartyEnrollmentTechContact:CpsThirdPartyEnrollmentTechContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "description": "The address of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "description": "The city where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "description": "The code for the country where your organization resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "description": "The email address of the technical contact at Akamai, accessible at the `akamai.com` domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The first name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "The last name of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "description": "Your organization information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "description": "The phone number of the administrator who you want to use as a contact at your company.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "description": "The postal code of your organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The region of your organization, typically a state or province.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "description": "The title of the technical contact at Akamai.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ]
        },
        "akamai:index/DatastreamAzureConnector:DatastreamAzureConnector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "accountName": {
                    "type": "string",
                    "description": "Specifies the Azure Storage account name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containerName": {
                    "type": "string",
                    "description": "Specifies the Azure Storage container name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "accountName",
                "connectorName",
                "containerName",
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "accountName",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "containerName",
                        "path"
                    ]
                }
            }
        },
        "akamai:index/DatastreamConfig:DatastreamConfig": {
            "properties": {
                "delimiter": {
                    "type": "string",
                    "description": "A delimiter that you want to use to separate data set fields in the log lines. Currently, `SPACE` is the only available delimiter. This field is required for the `STRUCTURED` log file `format`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "format": {
                    "type": "string",
                    "description": "The format in which you want to receive log files, either `STRUCTURED` or `JSON`. When `delimiter` is present in the request, `STRUCTURED` is the mandatory format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequency": {
                    "$ref": "#/types/akamai:index/DatastreamConfigFrequency:DatastreamConfigFrequency",
                    "description": "How often you want to collect logs from each uploader and send them to a destination.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uploadFilePrefix": {
                    "type": "string",
                    "description": "The prefix of the log file that you want to send to a destination. It’s a string of at most 200 characters. If unspecified, defaults to `ak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uploadFileSuffix": {
                    "type": "string",
                    "description": "The suffix of the log file that you want to send to a destination. It’s a static string of at most 10 characters. If unspecified, defaults to `ds`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "format",
                "frequency"
            ]
        },
        "akamai:index/DatastreamConfigFrequency:DatastreamConfigFrequency": {
            "properties": {
                "timeInSec": {
                    "type": "integer",
                    "description": "The time in seconds after which the system bundles log lines into a file and sends it to a destination. `30` or `60` are the possible values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "timeInSec"
            ]
        },
        "akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector": {
            "properties": {
                "authToken": {
                    "type": "string",
                    "description": "**Secret**. Your Log API token for your account in New Relic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "service": {
                    "type": "string",
                    "description": "The service of the Datadog connector. A service groups together endpoints, queries, or jobs for the purposes of scaling instances. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#reserved-attributes).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "source": {
                    "type": "string",
                    "description": "The source of the Datadog connector. See [View Datadog reserved attribute list](https://docs.datadoghq.com/logs/log_collection/?tab=http#reserved-attributes).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tags": {
                    "type": "string",
                    "description": "The tags you can use to segment and filter log events in Loggly. Learn more about [Tags](https://documentation.solarwinds.com/en/success_center/loggly/content/admin/tags.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authToken",
                "connectorName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authToken",
                        "connectorId",
                        "connectorName",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamElasticsearchConnector:DatastreamElasticsearchConnector": {
            "properties": {
                "caCert": {
                    "type": "string",
                    "description": "**Secret**. The certification authority (CA) certificate used to verify the origin server's certificate. It's needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientCert": {
                    "type": "string",
                    "description": "**Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "**Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type to pass in the log file header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "The Elasticsearch bulk endpoint URL in the format: `https://\u003chostname\u003e.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. \n\u003cbr\u003eLearn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexName": {
                    "type": "string",
                    "description": "**Secret**. The index name of the Elastic cloud where you want to store log files.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "mTls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "**Secret**. The Elasticsearch basic access authentication password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tlsHostname": {
                    "type": "string",
                    "description": "The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "**Secret**. The Elasticsearch basic access authentication username.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "connectorName",
                "endpoint",
                "indexName",
                "password",
                "userName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectorName",
                        "endpoint",
                        "indexName",
                        "mTls",
                        "password",
                        "userName"
                    ]
                }
            }
        },
        "akamai:index/DatastreamGcsConnector:DatastreamGcsConnector": {
            "properties": {
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "description": "**Secret**. The contents of the JSON private key you generated and downloaded in your Google Cloud Storage account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID of your Google Cloud project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceAccountName": {
                    "type": "string",
                    "description": "The name of the service account with the storage.object.create permission or Storage Object Creator role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucket",
                "connectorName",
                "privateKey",
                "projectId",
                "serviceAccountName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "privateKey",
                        "projectId",
                        "serviceAccountName"
                    ]
                }
            }
        },
        "akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector": {
            "properties": {
                "authenticationType": {
                    "type": "string",
                    "description": "Either `NONE` for no authentication, or `BASIC`. For basic authentication, provide the `user_name` and `password` you set in your custom HTTPS endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caCert": {
                    "type": "string",
                    "description": "**Secret**. The certification authority (CA) certificate used to verify the origin server's certificate. It's needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientCert": {
                    "type": "string",
                    "description": "**Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "**Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type to pass in the log file header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mTls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "**Secret**. The Elasticsearch basic access authentication password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tlsHostname": {
                    "type": "string",
                    "description": "The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "**Secret**. The Elasticsearch basic access authentication username.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "authenticationType",
                "connectorName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authenticationType",
                        "connectorId",
                        "connectorName",
                        "mTls",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamLogglyConnector:DatastreamLogglyConnector": {
            "properties": {
                "authToken": {
                    "type": "string",
                    "description": "**Secret**. Your Log API token for your account in New Relic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type to pass in the log file header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "The Elasticsearch bulk endpoint URL in the format: `https://\u003chostname\u003e.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. \n\u003cbr\u003eLearn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tags": {
                    "type": "string",
                    "description": "The tags you can use to segment and filter log events in Loggly. Learn more about [Tags](https://documentation.solarwinds.com/en/success_center/loggly/content/admin/tags.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authToken",
                "connectorName",
                "endpoint"
            ]
        },
        "akamai:index/DatastreamNewRelicConnector:DatastreamNewRelicConnector": {
            "properties": {
                "authToken": {
                    "type": "string",
                    "description": "**Secret**. Your Log API token for your account in New Relic.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type to pass in the log file header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "The Elasticsearch bulk endpoint URL in the format: `https://\u003chostname\u003e.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. \n\u003cbr\u003eLearn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authToken",
                "connectorName",
                "endpoint"
            ]
        },
        "akamai:index/DatastreamOracleConnector:DatastreamOracleConnector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace of your Oracle Cloud Storage account. See [Understanding Object Storage namespaces](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/understandingnamespaces.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "**Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "bucket",
                "connectorName",
                "namespace",
                "path",
                "region",
                "secretAccessKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "namespace",
                        "path",
                        "region",
                        "secretAccessKey"
                    ]
                }
            }
        },
        "akamai:index/DatastreamS3Connector:DatastreamS3Connector": {
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "**Secret**. The access key identifier that you use to authenticate requests to your Oracle Cloud account. See [Managing user credentials in OCS](https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the Oracle Cloud Storage bucket. See [Working with Oracle Cloud Storage buckets](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/managingbuckets.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the folder within your Oracle Cloud Storage bucket where you want to store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The Oracle Cloud Storage region where your bucket resides. See [Regions and availability domains in OCS](https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "**Secret**. The secret access key identifier that you use to authenticate requests to your Oracle Cloud account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "accessKey",
                "bucket",
                "connectorName",
                "path",
                "region",
                "secretAccessKey"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessKey",
                        "bucket",
                        "compressLogs",
                        "connectorId",
                        "connectorName",
                        "path",
                        "region",
                        "secretAccessKey"
                    ]
                }
            }
        },
        "akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector": {
            "properties": {
                "caCert": {
                    "type": "string",
                    "description": "**Secret**. The certification authority (CA) certificate used to verify the origin server's certificate. It's needed if the certificate stored in `client_cert` is not signed by a well-known certification authority, enter the CA certificate in the PEM format for verification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientCert": {
                    "type": "string",
                    "description": "**Secret**. The PEM-formatted digital certificate you want to authenticate requests to your destination with. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "clientKey": {
                    "type": "string",
                    "description": "**Secret**. The private key in the non-encrypted PKCS8 format you want to use to authenticate with the backend server. If you want to use mutual authentication, you need to provide both the client certificate and the client key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventCollectorToken": {
                    "type": "string",
                    "description": "**Secret**. The Event Collector token associated with your Splunk account. See [View usage of Event Collector token in Splunk](https://docs.splunk.com/Documentation/Splunk/8.0.3/Data/UsetheHTTPEventCollector).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "mTls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tlsHostname": {
                    "type": "string",
                    "description": "The hostname that verifies the server's certificate and matches the Subject Alternative Names (SANs) in the certificate. If not provided, DataStream fetches the hostname from the endpoint URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Enter the secure URL where you want to send and store your logs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectorName",
                "eventCollectorToken",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectorId",
                        "connectorName",
                        "eventCollectorToken",
                        "mTls",
                        "url"
                    ]
                }
            }
        },
        "akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector": {
            "properties": {
                "collectorCode": {
                    "type": "string",
                    "description": "**Secret**. The unique HTTP collector code of your Sumo Logic `endpoint`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "compressLogs": {
                    "type": "boolean",
                    "description": "Enables GZIP compression for a log file sent to a destination. If unspecified, this defaults to `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectorName": {
                    "type": "string",
                    "description": "The name of the connector.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentType": {
                    "type": "string",
                    "description": "Content type to pass in the log file header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderName": {
                    "type": "string",
                    "description": "A human-readable name for the request's custom header, containing only alphanumeric, dash, and underscore characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customHeaderValue": {
                    "type": "string",
                    "description": "The custom header's contents passed with the request that contains information about the client connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoint": {
                    "type": "string",
                    "description": "The Elasticsearch bulk endpoint URL in the format: `https://\u003chostname\u003e.elastic-cloud.com:9243/_bulk/`. Set `index_name` in the appropriate field instead of providing it in the URL. You can use Akamaized property hostnames as endpoint URLs. \n\u003cbr\u003eLearn more about how to [Stream logs to Elasticsearch](https://techdocs.akamai.com/datastream2/docs/stream-elasticsearch).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collectorCode",
                "connectorName",
                "endpoint"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collectorCode",
                        "connectorId",
                        "connectorName",
                        "endpoint"
                    ]
                }
            }
        },
        "akamai:index/DnsZoneTsigKey:DnsZoneTsigKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "The hashing algorithm.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The key name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "String known between transfer endpoints.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "name",
                "secret"
            ]
        },
        "akamai:index/EdgeKvInitialData:EdgeKvInitialData": {
            "properties": {
                "group": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "akamai:index/GtmAsmapAssignment:GtmAsmapAssignment": {
            "properties": {
                "asNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies an array of AS numbers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "asNumbers",
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment": {
            "properties": {
                "blocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of CIDR blocks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject": {
            "properties": {
                "loadObject": {
                    "type": "string",
                    "description": "A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port to connect to when requesting the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of servers to request the load object from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmGeomapAssignment:GtmGeomapAssignment": {
            "properties": {
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest": {
            "properties": {
                "answersRequired": {
                    "type": "boolean",
                    "description": "If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableNonstandardPortWarning": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, disables warnings when non-standard ports are used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorPenalty": {
                    "type": "number",
                    "description": "Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError3xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError4xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError5xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader"
                    },
                    "description": "Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "recursionRequested": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "Specifies a request string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceType": {
                    "type": "string",
                    "description": "Specifies the query type, if `test_object_protocol` is DNS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "Specifies a response string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientCertificate": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientPrivateKey": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testInterval": {
                    "type": "integer",
                    "description": "Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObject": {
                    "type": "string",
                    "description": "Specifies the static text that acts as a stand-in for the data that you're sending on the network.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPassword": {
                    "type": "string",
                    "description": "Specifies the test object's password. It is required if testObjectProtocol is ftp.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPort": {
                    "type": "integer",
                    "description": "Specifies the port number for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectProtocol": {
                    "type": "string",
                    "description": "Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectUsername": {
                    "type": "string",
                    "description": "A descriptive name for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testTimeout": {
                    "type": "number",
                    "description": "Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeoutPenalty": {
                    "type": "number",
                    "description": "Specifies the score to be reported if the liveness test times out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "testInterval",
                "testObject",
                "testObjectProtocol",
                "testTimeout"
            ]
        },
        "akamai:index/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet": {
            "properties": {
                "rdatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) An array of data strings, representing multiple records within a set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "The number of seconds that this record should live in a resolver's cache before being refetched.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "handoutCname": {
                    "type": "string",
                    "description": "Specifies an optional data center for the property. Used when there are no servers configured for the property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Identifies the IP address or the hostnames of the servers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "Specifies the traffic weight for the target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObject": {
                    "type": "string",
                    "description": "Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port of the `load_object`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Specifies a list of servers from which to request the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useDefaultLoadObject": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether a default `load_object` is used for the resources.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:index/PropertyActivationRuleError:PropertyActivationRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyHostname:PropertyHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "description": "The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostnameCertStatus:PropertyHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "description": "A string containing the original origin's hostname. For example, `\"example.org\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "description": "A string containing the hostname for edge content. For example,  `\"example.org.edgesuite.net\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "cnameFrom",
                "cnameTo"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certProvisioningType",
                        "certStatuses",
                        "cnameFrom",
                        "cnameTo",
                        "cnameType",
                        "edgeHostnameId"
                    ]
                }
            }
        },
        "akamai:index/PropertyHostnameCertStatus:PropertyHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "hostname",
                        "productionStatus",
                        "stagingStatus",
                        "target"
                    ]
                }
            }
        },
        "akamai:index/PropertyIncludeActivationComplianceRecord:PropertyIncludeActivationComplianceRecord": {
            "properties": {
                "customerEmail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noncomplianceReason": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "otherNoncomplianceReason": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerReviewedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ticketId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unitTested": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "noncomplianceReason"
            ]
        },
        "akamai:index/PropertyOrigin:PropertyOrigin": {
            "properties": {
                "cacheKeyHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableTrueClientIp": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyRuleError:PropertyRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/PropertyRuleWarning:PropertyRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderAppsec:ProviderAppsec": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderConfig:ProviderConfig": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderDns:ProviderDns": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderGtm:ProviderGtm": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderNetwork:ProviderNetwork": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/ProviderProperty:ProviderProperty": {
            "properties": {
                "accessToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "accountKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxBody": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCPSEnrollmentAdminContact:getCPSEnrollmentAdminContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentCsr:getCPSEnrollmentCsr": {
            "properties": {
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "countryCode",
                "organization",
                "organizationalUnit",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentDnsChallenge:getCPSEnrollmentDnsChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domain",
                "fullPath",
                "responseBody"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentHttpChallenge:getCPSEnrollmentHttpChallenge": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseBody": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domain",
                "fullPath",
                "responseBody"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentNetworkConfiguration:getCPSEnrollmentNetworkConfiguration": {
            "properties": {
                "clientMutualAuthentications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentNetworkConfigurationClientMutualAuthentication:getCPSEnrollmentNetworkConfigurationClientMutualAuthentication"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloneDnsNames": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disallowedTlsVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geography": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mustHaveCiphers": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ocspStapling": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferredCiphers": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quicEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "clientMutualAuthentications",
                "cloneDnsNames",
                "disallowedTlsVersions",
                "geography",
                "mustHaveCiphers",
                "ocspStapling",
                "preferredCiphers",
                "quicEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentNetworkConfigurationClientMutualAuthentication:getCPSEnrollmentNetworkConfigurationClientMutualAuthentication": {
            "properties": {
                "ocspEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sendCaListToClient": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ocspEnabled",
                "sendCaListToClient",
                "setId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentOrganization:getCPSEnrollmentOrganization": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "addressLineTwo",
                "city",
                "countryCode",
                "name",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentTechContact:getCPSEnrollmentTechContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollment:getCPSEnrollmentsEnrollment": {
            "properties": {
                "adminContacts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentAdminContact:getCPSEnrollmentsEnrollmentAdminContact"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificateChainType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificateType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "commonName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "csrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentCsr:getCPSEnrollmentsEnrollmentCsr"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableMultiStackedCertificates": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enrollmentId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentNetworkConfiguration:getCPSEnrollmentsEnrollmentNetworkConfiguration"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentOrganization:getCPSEnrollmentsEnrollmentOrganization"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pendingChanges": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "registrationAuthority": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secureNetwork": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sniOnly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "techContacts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentTechContact:getCPSEnrollmentsEnrollmentTechContact"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validationType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "adminContacts",
                "certificateChainType",
                "certificateType",
                "commonName",
                "csrs",
                "enableMultiStackedCertificates",
                "enrollmentId",
                "networkConfigurations",
                "organizations",
                "pendingChanges",
                "registrationAuthority",
                "sans",
                "secureNetwork",
                "signatureAlgorithm",
                "sniOnly",
                "techContacts",
                "validationType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentAdminContact:getCPSEnrollmentsEnrollmentAdminContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentCsr:getCPSEnrollmentsEnrollmentCsr": {
            "properties": {
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationalUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "countryCode",
                "organization",
                "organizationalUnit",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentNetworkConfiguration:getCPSEnrollmentsEnrollmentNetworkConfiguration": {
            "properties": {
                "clientMutualAuthentications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication:getCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloneDnsNames": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disallowedTlsVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "geography": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mustHaveCiphers": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ocspStapling": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "preferredCiphers": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quicEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "clientMutualAuthentications",
                "cloneDnsNames",
                "disallowedTlsVersions",
                "geography",
                "mustHaveCiphers",
                "ocspStapling",
                "preferredCiphers",
                "quicEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication:getCPSEnrollmentsEnrollmentNetworkConfigurationClientMutualAuthentication": {
            "properties": {
                "ocspEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sendCaListToClient": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ocspEnabled",
                "sendCaListToClient",
                "setId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentOrganization:getCPSEnrollmentsEnrollmentOrganization": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "addressLineTwo",
                "city",
                "countryCode",
                "name",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCPSEnrollmentsEnrollmentTechContact:getCPSEnrollmentsEnrollmentTechContact": {
            "properties": {
                "addressLineOne": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "addressLineTwo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "countryCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organization": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "phone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postalCode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "addressLineOne",
                "city",
                "countryCode",
                "email",
                "firstName",
                "lastName",
                "organization",
                "phone",
                "postalCode",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatch:getCloudletsApiPrioritizationMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passThroughPercent": {
                    "type": "number",
                    "description": "(Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "passThroughPercent",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "passThroughPercent"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatch:getCloudletsApiPrioritizationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApiPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApplicationLoadBalancerDataCenter:getCloudletsApplicationLoadBalancerDataCenter": {
            "properties": {
                "city": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudService": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "continent": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "country": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "livenessHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "longitude": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "originId": {
                    "type": "string",
                    "description": "(Required) A unique identifier for the Conditional Origin that supports the load balancing configuration. The Conditional Origin type must be set to `APPLICATION_LOAD_BALANCER` in the `origin` behavior. See property rules for more information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateOrProvince": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "city",
                "cloudServerHostHeaderOverride",
                "cloudService",
                "continent",
                "country",
                "hostname",
                "latitude",
                "livenessHosts",
                "longitude",
                "originId",
                "percent",
                "stateOrProvince"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerLivenessSetting:getCloudletsApplicationLoadBalancerLivenessSetting": {
            "properties": {
                "additionalHeaders": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostHeader": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "interval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status3xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status4xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status5xxFailure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalHeaders",
                "hostHeader",
                "interval",
                "path",
                "peerCertificateVerification",
                "port",
                "protocol",
                "requestString",
                "responseString",
                "status3xxFailure",
                "status4xxFailure",
                "status5xxFailure",
                "timeout"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting"
                    },
                    "description": "(Required) Defines data used to construct a new request URL if all conditions are met. If all of the conditions you set are true, the Edge Server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "integer",
                    "description": "(Optional) An identifier for Akamai internal use only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) The URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match supports default rules that apply to all requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSetting": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "(Required) The ID of the Conditional Origin the requests are forwarded to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "originId"
            ]
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `clientip`, `continent`, `cookie`, `countrycode`, `deviceCharacteristics`, `extension`, `header`, `hostname`, `method`, `path`, `protocol`, `proxy`, `query`, `regioncode`, or `range`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule either includes more complex match criteria, like multiple value attributes, or a range match. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object`, `range`, or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple` or `range`, specify the values in the incoming request to match on. With `range`, you can only specify an array of integers, for example `[1, 2]`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings:getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings:getCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "(Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pathAndQs": {
                    "type": "string",
                    "description": "(Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "(Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsAudienceSegmentationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "(Required) The URL Edge Redirector redirects the request to. If you're using `use_relative_url`, you can enter a path for the value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "description": "(Required) The HTTP response status code, which is either `301` (permanent redirect) or `302` (temporary redirect).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "(Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useRelativeUrl": {
                    "type": "string",
                    "description": "(Optional) If set to `relative_url`, takes the path you specify in the `redirect_url` argument and sets it in the response’s Location header. The client or browser receiving the request decides which protocol and hostname to use. If set to `copy_scheme_hostname`, creates an absolute path by taking the protocol and hostname from the incoming request and combining them with path information you specify in the `redirect_url` argument. This absolute path is set in the response’s Location header. If you do not specify use_relative_url or set to `none`, then specify the `redirect_url` argument as a fully-qualified URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "redirectUrl",
                "statusCode",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "redirectUrl",
                        "statusCode"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsEdgeRedirectorMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings:getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatch:getCloudletsForwardRewriteMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings:getCloudletsForwardRewriteMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "(Optional) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pathAndQs": {
                    "type": "string",
                    "description": "(Optional) When match conditions are met, this value defines the path, resource, or query string added to the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useIncomingQueryString": {
                    "type": "boolean",
                    "description": "(Optional) Whether the Cloudlet should include the query string from the request in the rewritten or forwarded URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatch:getCloudletsForwardRewriteMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `regex`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsForwardRewriteMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardSettings": {
                    "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings:getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings",
                    "description": "(Required) The data used to construct a new request URL if all match conditions are met. If all conditions are met, the edge server returns an HTTP response from the rewritten URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatch:getCloudletsPhasedReleaseMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match supports default rules that apply to all requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "forwardSettings",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "forwardSettings"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings:getCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettings": {
            "properties": {
                "originId": {
                    "type": "string",
                    "description": "(Required) The ID of the new origin requests are forwarded to. This type of origin is known as a Conditional Origin. See Property requirements for Cloudlets that forward requests to learn more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "percent": {
                    "type": "integer",
                    "description": "(Required)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "originId",
                "percent"
            ]
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatch:getCloudletsPhasedReleaseMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsPhasedReleaseMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsPolicyActivation:getCloudletsPolicyActivation": {
            "properties": {
                "apiVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "network": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPolicyActivationPolicyInfo:getCloudletsPolicyActivationPolicyInfo"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsPolicyActivationPropertyInfo:getCloudletsPolicyActivationPropertyInfo"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiVersion",
                "network",
                "policyInfos",
                "propertyInfos"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsPolicyActivationPolicyInfo:getCloudletsPolicyActivationPolicyInfo": {
            "properties": {
                "activatedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "activationDate": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyId": {
                    "type": "integer",
                    "description": "(Required) An integer identifier that is associated with all versions of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusDetail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "description": "(Optional) The version number of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "activatedBy",
                "activationDate",
                "name",
                "policyId",
                "status",
                "statusDetail",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsPolicyActivationPropertyInfo:getCloudletsPolicyActivationPropertyInfo": {
            "properties": {
                "activatedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "activationDate": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "description": "(Optional) The version number of a policy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "activatedBy",
                "activationDate",
                "groupId",
                "name",
                "status",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule": {
            "properties": {
                "allowDeny": {
                    "type": "string",
                    "description": "(Required) If set to `allow`, the request is sent to origin when all conditions are true. If set to `deny`, the request is denied when all conditions are true. If set to `denybranded`, the request is denied and rerouted according to the Request Control behavior settings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule. When a rule is disabled it's not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatch:getCloudletsRequestControlMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchesAlways": {
                    "type": "boolean",
                    "description": "(Optional) Match on all incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowDeny",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "allowDeny"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatch:getCloudletsRequestControlMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsRequestControlMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "(Optional) Whether to disable a rule so it is not evaluated against incoming requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "end": {
                    "type": "integer",
                    "description": "(Optional) The end time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchUrl": {
                    "type": "string",
                    "description": "(Optional) If you're using a URL match, this specifies the URL that the Cloudlet uses to match the incoming request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matches": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch"
                    },
                    "description": "(Optional) A list of conditions to apply to a Cloudlet, including:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "passThroughPercent": {
                    "type": "number",
                    "description": "(Required) Entering a value in the range of `0.0` to `99.0` specifies the percent of requests that pass through to the origin. Enter `100` to always have the request pass through to the origin. Enter `-1` to send everyone to the waiting room.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "start": {
                    "type": "integer",
                    "description": "(Optional) The start time for this match. Specify the value in UTC in seconds since the epoch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "passThroughPercent",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "passThroughPercent"
                    ]
                }
            }
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch": {
            "properties": {
                "caseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the match is case sensitive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "checkIps": {
                    "type": "string",
                    "description": "(Optional) For `clientip`, `continent`, `countrycode`, `proxy`, and `regioncode` match types, this defines the part of the request that determines the IP address to use. Values include the connecting IP address (`CONNECTING_IP`) and the X_Forwarded_For header (`XFF_HEADERS`). To select both, enter the two values separated by a space delimiter. When both values are included, the connecting IP address is evaluated first.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchOperator": {
                    "type": "string",
                    "description": "(Optional) Compares a string expression with a pattern, either `contains`, `exists`, or `equals`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchType": {
                    "type": "string",
                    "description": "(Optional) The type of match used, either `header`, `hostname`, `path`, `extension`, `query`, `cookie`, `deviceCharacteristics`, `clientip`, `continent`, `countrycode`, `regioncode`, `protocol`, `method`, or `proxy`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchValue": {
                    "type": "string",
                    "description": "(Optional) This depends on the `match_type`. If the `match_type` is `hostname`, then `match_value` is the fully qualified domain name, like `www.akamai.com`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "negate": {
                    "type": "boolean",
                    "description": "(Optional) Whether to negate the match.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "objectMatchValues": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue"
                    },
                    "description": "(Optional) If `match_value` is empty, this argument is required. An object used when a rule includes more complex match criteria, like multiple value attributes. Includes these sub-arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValue": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "(Optional) If you're using a `match_type` that supports name attributes, specify the part the incoming request to match on, either `cookie`, `header`, `parameter`, or `query`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nameHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `name` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions",
                    "description": "(Optional) If you set the `type` argument to `object`, use this array to list the values to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) The type of the array, either `object` or `simple`. Use the `simple` option when adding only an array of string-based values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions:getCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchObjectMatchValueOptions": {
            "properties": {
                "valueCaseSensitive": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be evaluated based on case sensitivity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueEscaped": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument should be compared in an escaped form.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueHasWildcard": {
                    "type": "boolean",
                    "description": "(Optional) Whether the `value` argument includes wildcards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Optional) If you set the `type` argument to `simple`, specify the values in the incoming request to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:index/getContractsContract:getContractsContract": {
            "properties": {
                "contractId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contractTypeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractId",
                "contractTypeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamActivationHistoryActivation:getDatastreamActivationHistoryActivation": {
            "properties": {
                "createdBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isActive": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamId": {
                    "type": "integer",
                    "description": "(Required) A stream's unique identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamVersionId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdBy",
                "createdDate",
                "isActive",
                "streamId",
                "streamVersionId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamDatasetFieldsField:getDatastreamDatasetFieldsField": {
            "properties": {
                "datasetFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getDatastreamDatasetFieldsFieldDatasetField:getDatastreamDatasetFieldsFieldDatasetField"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetGroupDescription": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetGroupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datasetFields",
                "datasetGroupDescription",
                "datasetGroupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamDatasetFieldsFieldDatasetField:getDatastreamDatasetFieldsFieldDatasetField": {
            "properties": {
                "datasetFieldDescription": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldJsonKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datasetFieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datasetFieldDescription",
                "datasetFieldId",
                "datasetFieldJsonKey",
                "datasetFieldName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamsStream:getDatastreamsStream": {
            "properties": {
                "activationStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "archived": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectors": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contractId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "currentVersionId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getDatastreamsStreamError:getDatastreamsStreamError"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "integer",
                    "description": "Unique identifier of the group that can access the product.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "properties": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getDatastreamsStreamProperty:getDatastreamsStreamProperty"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamTypeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "streamVersionId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "activationStatus",
                "archived",
                "connectors",
                "contractId",
                "createdBy",
                "createdDate",
                "currentVersionId",
                "errors",
                "groupId",
                "groupName",
                "properties",
                "streamId",
                "streamName",
                "streamTypeName",
                "streamVersionId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamsStreamError:getDatastreamsStreamError": {
            "properties": {
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "detail",
                "title",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getDatastreamsStreamProperty:getDatastreamsStreamProperty": {
            "properties": {
                "propertyId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "propertyId",
                "propertyName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getGroupsGroup:getGroupsGroup": {
            "properties": {
                "contractIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "parentGroupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractIds",
                "groupId",
                "groupName",
                "parentGroupId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamGrantableRolesGrantableRole:getIamGrantableRolesGrantableRole": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "grantedRoleId": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "description",
                "grantedRoleId",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamRolesRole:getIamRolesRole": {
            "properties": {
                "createdBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "modifiedBy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeCreated": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeModified": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdBy",
                "description",
                "modifiedBy",
                "name",
                "roleId",
                "timeCreated",
                "timeModified",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getIamTimezonesTimezone:getIamTimezonesTimezone": {
            "properties": {
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "offset": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "posix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timezone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "description",
                "offset",
                "posix",
                "timezone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertiesProperty:getPropertiesProperty": {
            "properties": {
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latestVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "note": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ruleFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contractId",
                "groupId",
                "latestVersion",
                "note",
                "productId",
                "productionVersion",
                "propertyId",
                "propertyName",
                "ruleFormat",
                "stagingVersion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertiesSearchProperty:getPropertiesSearchProperty": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "assetId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contractId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propertyVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updatedByUser": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updatedDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "assetId",
                "contractId",
                "edgeHostname",
                "groupId",
                "hostname",
                "productionStatus",
                "propertyId",
                "propertyName",
                "propertyVersion",
                "stagingStatus",
                "updatedByUser",
                "updatedDate"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyHostnamesHostname:getPropertyHostnamesHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/getPropertyHostnamesHostnameCertStatus:getPropertyHostnamesHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "certStatuses",
                "cnameFrom",
                "cnameTo",
                "cnameType",
                "edgeHostnameId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyHostnamesHostnameCertStatus:getPropertyHostnamesHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "hostname",
                "productionStatus",
                "stagingStatus",
                "target"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyIncludeParentsParent:getPropertyIncludeParentsParent": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isIncludeUsedInProductionVersion": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isIncludeUsedInStagingVersion": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "isIncludeUsedInProductionVersion",
                "isIncludeUsedInStagingVersion",
                "name",
                "productionVersion",
                "stagingVersion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyIncludesInclude:getPropertyIncludesInclude": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "latestVersion": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingVersion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Optional) Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "latestVersion",
                "name",
                "productionVersion",
                "stagingVersion",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyIncludesParentProperty:getPropertyIncludesParentProperty": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "version": {
                    "type": "integer",
                    "description": "(Required) The version of the activated parent property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "version"
            ]
        },
        "akamai:index/getPropertyProductsProduct:getPropertyProductsProduct": {
            "properties": {
                "productId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "productId",
                "productName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate": {
            "properties": {
                "templateData": {
                    "type": "string",
                    "description": "The content of the JSON template as a string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "templateDir": {
                    "type": "string",
                    "description": "The absolute or relative path to the directory containing the template files. The path must end with `property-snippets`, the required directory name. For example: `template_dir = abspath(\"${path.root}/property-snippets/\")`, or `template_dir = \"property-snippets/\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "templateData",
                "templateDir"
            ]
        },
        "akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the variable used in the template.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of variable: `string`, `number`, `bool`, or `jsonBlock`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable passed as a string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyHostname:PropertyHostname": {
            "properties": {
                "certProvisioningType": {
                    "type": "string",
                    "description": "The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostnameCertStatus:PropertyHostnameCertStatus"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameFrom": {
                    "type": "string",
                    "description": "A string containing the original origin's hostname. For example, `\"example.org\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameTo": {
                    "type": "string",
                    "description": "A string containing the hostname for edge content. For example,  `\"example.org.edgesuite.net\"`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cnameType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "edgeHostnameId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certProvisioningType",
                "cnameFrom",
                "cnameTo"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "certProvisioningType",
                        "certStatuses",
                        "cnameFrom",
                        "cnameTo",
                        "cnameType",
                        "edgeHostnameId"
                    ]
                }
            }
        },
        "akamai:properties/PropertyHostnameCertStatus:PropertyHostnameCertStatus": {
            "properties": {
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productionStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stagingStatus": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "target": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "hostname",
                        "productionStatus",
                        "stagingStatus",
                        "target"
                    ]
                }
            }
        },
        "akamai:properties/PropertyOrigin:PropertyOrigin": {
            "properties": {
                "cacheKeyHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableTrueClientIp": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forwardHostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostname": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyRuleError:PropertyRuleError": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:properties/PropertyRuleWarning:PropertyRuleWarning": {
            "properties": {
                "behaviorName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "detail": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorLocation": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instance": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusCode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "title": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment": {
            "properties": {
                "asNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies an array of AS numbers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "asNumbers",
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment": {
            "properties": {
                "blocks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of CIDR blocks.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR zone group, up to 256 characters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject": {
            "properties": {
                "loadObject": {
                    "type": "string",
                    "description": "A load object is a file that provides real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port to connect to when requesting the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of servers to request the load object from.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment": {
            "properties": {
                "countries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an array of two-letter ISO 3166 country codes, or for finer subdivisions, the two-letter country code and the two-letter stateOrProvince code separated by a forward slash.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "nickname"
            ]
        },
        "akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        },
        "akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest": {
            "properties": {
                "answersRequired": {
                    "type": "boolean",
                    "description": "If `test_object_protocol` is DNS, enter a boolean value if an answer is needed for the DNS query to be successful.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disableNonstandardPortWarning": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, disables warnings when non-standard ports are used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the liveness test is disabled. When disabled, GTM stops running the test, effectively treating it as if it no longer exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorPenalty": {
                    "type": "number",
                    "description": "Specifies the score that's reported if the liveness test encounters an error other than timeout, such as connection refused, and 404.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError3xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 3xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError4xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 4xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpError5xx": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, treats a 5xx HTTP response as a failure if the `test_object_protocol` is `http`, `https`, or `ftp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader"
                    },
                    "description": "Contains HTTP headers to send if the `test_object_protocol` is `http` or `https`. You can have multiple `http_header` entries. Requires these arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peerCertificateVerification": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, validates the origin certificate. Applies only to tests with `test_object_protocol` of https.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "recursionRequested": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the `test_object_protocol` is DNS. The DNS query is recursive.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestString": {
                    "type": "string",
                    "description": "Specifies a request string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceType": {
                    "type": "string",
                    "description": "Specifies the query type, if `test_object_protocol` is DNS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseString": {
                    "type": "string",
                    "description": "Specifies a response string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientCertificate": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded certificate. SSL client certificates are available for livenessTests that use secure protocols.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sslClientPrivateKey": {
                    "type": "string",
                    "description": "Indicates a Base64-encoded private key. The private key used to generate or request a certificate for livenessTests can't have a passphrase nor be used for any other purpose.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testInterval": {
                    "type": "integer",
                    "description": "Indicates the interval at which the liveness test is run, in seconds. Requires a minimum of 10 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObject": {
                    "type": "string",
                    "description": "Specifies the static text that acts as a stand-in for the data that you're sending on the network.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPassword": {
                    "type": "string",
                    "description": "Specifies the test object's password. It is required if testObjectProtocol is ftp.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectPort": {
                    "type": "integer",
                    "description": "Specifies the port number for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectProtocol": {
                    "type": "string",
                    "description": "Specifies the test protocol. Possible values include `DNS`, `HTTP`, `HTTPS`, `FTP`, `POP`, `POPS`, `SMTP`, `SMTPS`, `TCP`, or `TCPS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testObjectUsername": {
                    "type": "string",
                    "description": "A descriptive name for the testObject.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testTimeout": {
                    "type": "number",
                    "description": "Specifies the duration of the liveness test before it fails. The range is from 0.001 to 60 seconds.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeoutPenalty": {
                    "type": "number",
                    "description": "Specifies the score to be reported if the liveness test times out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "testInterval",
                "testObject",
                "testObjectProtocol",
                "testTimeout"
            ]
        },
        "akamai:trafficmanagement/GtmPropertyLivenessTestHttpHeader:GtmPropertyLivenessTestHttpHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet": {
            "properties": {
                "rdatas": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) An array of data strings, representing multiple records within a set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ttl": {
                    "type": "integer",
                    "description": "The number of seconds that this record should live in a resolver's cache before being refetched.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the traffic target is used. You can also omit the traffic target, which has the same result as the false value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "handoutCname": {
                    "type": "string",
                    "description": "Specifies an optional data center for the property. Used when there are no servers configured for the property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Identifies the IP address or the hostnames of the servers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "weight": {
                    "type": "number",
                    "description": "Specifies the traffic weight for the target.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance": {
            "properties": {
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObject": {
                    "type": "string",
                    "description": "Identifies the load object file used to report real-time information about the current load, maximum allowable load, and target load on each resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadObjectPort": {
                    "type": "integer",
                    "description": "Specifies the TCP port of the `load_object`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(List) Specifies a list of servers from which to request the load object.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useDefaultLoadObject": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether a default `load_object` is used for the resources.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "datacenterId"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the akamai package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderAppsec:ProviderAppsec"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:index/ProviderConfig:ProviderConfig",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:index/ProviderDns:ProviderDns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:index/ProviderGtm:ProviderGtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderNetwork:ProviderNetwork"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:index/ProviderProperty:ProviderProperty",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        },
        "inputProperties": {
            "appsecSection": {
                "type": "string",
                "deprecationMessage": "The setting \"appsec_section\" has been deprecated."
            },
            "appsecs": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderAppsec:ProviderAppsec"
                },
                "deprecationMessage": "The setting \"appsec\" has been deprecated."
            },
            "cacheEnabled": {
                "type": "boolean"
            },
            "config": {
                "$ref": "#/types/akamai:index/ProviderConfig:ProviderConfig",
                "language": {
                    "csharp": {
                        "name": "ConfigDetails"
                    }
                }
            },
            "configSection": {
                "type": "string",
                "description": "The section of the edgerc file to use for configuration\n"
            },
            "dns": {
                "$ref": "#/types/akamai:index/ProviderDns:ProviderDns",
                "deprecationMessage": "The setting \"dns\" has been deprecated."
            },
            "dnsSection": {
                "type": "string",
                "deprecationMessage": "The setting \"dns_section\" has been deprecated."
            },
            "edgerc": {
                "type": "string"
            },
            "gtm": {
                "$ref": "#/types/akamai:index/ProviderGtm:ProviderGtm",
                "deprecationMessage": "The setting \"gtm\" has been deprecated."
            },
            "gtmSection": {
                "type": "string",
                "deprecationMessage": "The setting \"gtm_section\" has been deprecated."
            },
            "networklistSection": {
                "type": "string",
                "deprecationMessage": "The setting \"networklist_section\" has been deprecated."
            },
            "networks": {
                "type": "array",
                "items": {
                    "$ref": "#/types/akamai:index/ProviderNetwork:ProviderNetwork"
                }
            },
            "papiSection": {
                "type": "string",
                "deprecationMessage": "The setting \"papi_section\" has been deprecated."
            },
            "property": {
                "$ref": "#/types/akamai:index/ProviderProperty:ProviderProperty",
                "deprecationMessage": "The setting \"property\" has been deprecated."
            },
            "propertySection": {
                "type": "string",
                "deprecationMessage": "The setting \"property_section\" has been deprecated."
            }
        }
    },
    "resources": {
        "akamai:edgedns/dnsRecord:DnsRecord": {
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "answerType": {
                    "type": "string"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "dnsName": {
                    "type": "string"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordSha": {
                    "type": "string"
                },
                "recordtype": {
                    "type": "string"
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "serial": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string"
                }
            },
            "required": [
                "answerType",
                "dnsName",
                "name",
                "recordSha",
                "recordtype",
                "serial",
                "ttl",
                "zone"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordtype": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "recordtype",
                "ttl",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsRecord resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "algorithm": {
                        "type": "integer"
                    },
                    "answerType": {
                        "type": "string"
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "digest": {
                        "type": "string"
                    },
                    "digestType": {
                        "type": "integer"
                    },
                    "dnsName": {
                        "type": "string"
                    },
                    "emailAddress": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string"
                    },
                    "expiry": {
                        "type": "integer"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "fingerprintType": {
                        "type": "integer"
                    },
                    "flags": {
                        "type": "integer"
                    },
                    "flagsnaptr": {
                        "type": "string"
                    },
                    "hardware": {
                        "type": "string"
                    },
                    "inception": {
                        "type": "string"
                    },
                    "iterations": {
                        "type": "integer"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keytag": {
                        "type": "integer"
                    },
                    "labels": {
                        "type": "integer"
                    },
                    "mailbox": {
                        "type": "string"
                    },
                    "matchType": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "nameServer": {
                        "type": "string"
                    },
                    "nextHashedOwnerName": {
                        "type": "string"
                    },
                    "nxdomainTtl": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "integer"
                    },
                    "originalTtl": {
                        "type": "integer"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "preference": {
                        "type": "integer"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "priorityIncrement": {
                        "type": "integer"
                    },
                    "protocol": {
                        "type": "integer"
                    },
                    "recordSha": {
                        "type": "string"
                    },
                    "recordtype": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "refresh": {
                        "type": "integer"
                    },
                    "regexp": {
                        "type": "string"
                    },
                    "replacement": {
                        "type": "string"
                    },
                    "retry": {
                        "type": "integer"
                    },
                    "salt": {
                        "type": "string"
                    },
                    "selector": {
                        "type": "integer"
                    },
                    "serial": {
                        "type": "integer"
                    },
                    "service": {
                        "type": "string"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "signer": {
                        "type": "string"
                    },
                    "software": {
                        "type": "string"
                    },
                    "subtype": {
                        "type": "integer"
                    },
                    "svcParams": {
                        "type": "string"
                    },
                    "svcPriority": {
                        "type": "integer"
                    },
                    "targetName": {
                        "type": "string"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ttl": {
                        "type": "integer"
                    },
                    "txt": {
                        "type": "string"
                    },
                    "typeBitmaps": {
                        "type": "string"
                    },
                    "typeCovered": {
                        "type": "string"
                    },
                    "typeMnemonic": {
                        "type": "string"
                    },
                    "typeValue": {
                        "type": "integer"
                    },
                    "usage": {
                        "type": "integer"
                    },
                    "weight": {
                        "type": "integer"
                    },
                    "zone": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.edgedns.DnsRecord has been deprecated in favor of akamai.DnsRecord"
        },
        "akamai:edgedns/dnsZone:DnsZone": {
            "properties": {
                "activationState": {
                    "type": "string"
                },
                "aliasCount": {
                    "type": "integer"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n"
                },
                "versionId": {
                    "type": "string"
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "required": [
                "activationState",
                "aliasCount",
                "contract",
                "type",
                "versionId",
                "zone"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                    "willReplaceOnChanges": true
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "requiredInputs": [
                "contract",
                "type",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsZone resources.\n",
                "properties": {
                    "activationState": {
                        "type": "string"
                    },
                    "aliasCount": {
                        "type": "integer"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive comment.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    },
                    "endCustomerId": {
                        "type": "string",
                        "description": "A free form identifier for the zone.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The currently selected group ID.\n"
                    },
                    "masters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                    },
                    "signAndServe": {
                        "type": "boolean",
                        "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                    },
                    "signAndServeAlgorithm": {
                        "type": "string",
                        "description": "The algorithm used by Sign and Serve.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The name of the zone whose configuration this zone will copy.\n"
                    },
                    "tsigKey": {
                        "$ref": "#/types/akamai:edgedns/DnsZoneTsigKey:DnsZoneTsigKey",
                        "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                        "willReplaceOnChanges": true
                    },
                    "versionId": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The domain zone, encapsulating any nested subdomains.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone"
        },
        "akamai:index/appSecActivations:AppSecActivations": {
            "properties": {
                "activate": {
                    "type": "boolean",
                    "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                },
                "network": {
                    "type": "string",
                    "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                },
                "note": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                },
                "notes": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The results of the activation\n"
                },
                "version": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                }
            },
            "required": [
                "configId",
                "notificationEmails",
                "status",
                "version"
            ],
            "inputProperties": {
                "activate": {
                    "type": "boolean",
                    "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                },
                "network": {
                    "type": "string",
                    "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                },
                "note": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                },
                "notes": {
                    "type": "string",
                    "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                    "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                },
                "version": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "notificationEmails",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecActivations resources.\n",
                "properties": {
                    "activate": {
                        "type": "boolean",
                        "description": ". Set to **true** to activate the specified security configuration or set to **false** to deactivate the configuration. If not included, the security configuration is activated. This argument applies only to versions prior to 2.0.0.\n",
                        "deprecationMessage": "The setting activate has been deprecated; \"terraform apply\" will always perform activation. (Use \"terraform destroy\" for deactivation.)"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration being activated. This is unchanged from previous versions.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": ". Network on which activation will occur; if not included, activation takes place on the staging network. Allowed values are:\n* **PRODUCTION**\n* **STAGING**\n"
                    },
                    "note": {
                        "type": "string",
                        "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger these processes. Because of that, it's recommended that you always update the **note** argument. That ensures that the resource is called and that activation or deactivation occurs.\n"
                    },
                    "notes": {
                        "type": "string",
                        "description": ". Brief description of the activation or deactivation process. If no attributes have changed since the last time you called the **akamai_appsec_activations** resource, neither activation nor deactivation takes place. That's because something must be different in order to trigger one of these processes. Because of that, it's recommended that you always update the `notes` argument. Doing so ensures that the resource is called and activation or deactivation occurs. This argument applies only to versions prior to 2.0.0.\n",
                        "deprecationMessage": "The setting notes has been deprecated. Use \"note\" instead."
                    },
                    "notificationEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array containing the email addresses of the people to be notified when activation is complete. This is unchanged from previous versions.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The results of the activation\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration being activated. This can be a hard-coded version number (for example, **5**), or you can use the security configuration’s **latest_version** attribute (data.akamai_appsec_configuration.configuration.latest_version). If you do the latter, you’ll always activate the most recent version of the configuration. This argument applies only to versions 2.0.0 and later.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsEvasivePathMatch:AppSecAdvancedSettingsEvasivePathMatch": {
            "description": "**Scopes**: Security configuration; security policy\n\nThe `resource_akamai_appsec_advanced_settings_evasive_path_match` resource allows you to enable, disable, or update the evasive path match setting for a configuration.\nThis setting determines whether fuzzy matching is used to make URL matching more inclusive.\nThis operation applies at the configuration level, and therefore applies to all policies within a configuration.\nYou may override this setting for a particular policy by specifying the policy using the security_policy_id parameter.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/put-evasive-path-match)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst configEvasivePathMatch = new akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enablePathMatch: true,\n});\n// USE CASE: user wants to override the evasive path match setting for a security policy\nconst policyOverride = new akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: _var.security_policy_id,\n    enablePathMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\nconfig_evasive_path_match = akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\",\n    config_id=configuration.config_id,\n    enable_path_match=True)\n# USE CASE: user wants to override the evasive path match setting for a security policy\npolicy_override = akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\",\n    config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"],\n    enable_path_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = @var.Security_configuration,\n    });\n\n    var configEvasivePathMatch = new Akamai.AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        EnablePathMatch = true,\n    });\n\n    // USE CASE: user wants to override the evasive path match setting for a security policy\n    var policyOverride = new Akamai.AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = @var.Security_policy_id,\n        EnablePathMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsEvasivePathMatch(ctx, \"configEvasivePathMatch\", \u0026akamai.AppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:        *pulumi.Int(configuration.ConfigId),\n\t\t\tEnablePathMatch: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsEvasivePathMatch(ctx, \"policyOverride\", \u0026akamai.AppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.Any(_var.Security_policy_id),\n\t\t\tEnablePathMatch:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsEvasivePathMatch;\nimport com.pulumi.akamai.AppSecAdvancedSettingsEvasivePathMatchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        var configEvasivePathMatch = new AppSecAdvancedSettingsEvasivePathMatch(\"configEvasivePathMatch\", AppSecAdvancedSettingsEvasivePathMatchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enablePathMatch(true)\n            .build());\n\n        var policyOverride = new AppSecAdvancedSettingsEvasivePathMatch(\"policyOverride\", AppSecAdvancedSettingsEvasivePathMatchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .enablePathMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  configEvasivePathMatch:\n    type: akamai:AppSecAdvancedSettingsEvasivePathMatch\n    properties:\n      configId: ${configuration.configId}\n      enablePathMatch: true\n  # USE CASE: user wants to override the evasive path match setting for a security policy\n  policyOverride:\n    type: akamai:AppSecAdvancedSettingsEvasivePathMatch\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: ${var.security_policy_id}\n      enablePathMatch: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": "The ID of the security configuration to use.\n"
                },
                "enablePathMatch": {
                    "type": "boolean",
                    "description": "Whether to enable path match.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                }
            },
            "required": [
                "configId",
                "enablePathMatch"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": "The ID of the security configuration to use.\n"
                },
                "enablePathMatch": {
                    "type": "boolean",
                    "description": "Whether to enable path match.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enablePathMatch"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsEvasivePathMatch resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "The ID of the security configuration to use.\n"
                    },
                    "enablePathMatch": {
                        "type": "boolean",
                        "description": "Whether to enable path match.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsLogging:AppSecAdvancedSettingsLogging": {
            "description": "**Scopes**: Security configuration; security policy\n\nEnables, disables, or updates HTTP header logging settings.\nBy default, this operation applies at the configuration level, which means that it applies to all the security policies within that configuration.\nHowever, by using the `security_policy_id` parameter you can specify custom settings for an individual security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/put-policies-logging)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst logging = new akamai.AppSecAdvancedSettingsLogging(\"logging\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    logging: fs.readFileSync(`${path.module}/logging.json`),\n});\n// USE CASE: User wants to configure logging settings for a security policy.\nconst policyLogging = new akamai.AppSecAdvancedSettingsLogging(\"policyLogging\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    logging: fs.readFileSync(`${path.module}/logging.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nlogging = akamai.AppSecAdvancedSettingsLogging(\"logging\",\n    config_id=configuration.config_id,\n    logging=(lambda path: open(path).read())(f\"{path['module']}/logging.json\"))\n# USE CASE: User wants to configure logging settings for a security policy.\npolicy_logging = akamai.AppSecAdvancedSettingsLogging(\"policyLogging\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    logging=(lambda path: open(path).read())(f\"{path['module']}/logging.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var logging = new Akamai.AppSecAdvancedSettingsLogging(\"logging\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Logging = File.ReadAllText($\"{path.Module}/logging.json\"),\n    });\n\n    // USE CASE: User wants to configure logging settings for a security policy.\n    var policyLogging = new Akamai.AppSecAdvancedSettingsLogging(\"policyLogging\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Logging = File.ReadAllText($\"{path.Module}/logging.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsLogging(ctx, \"logging\", \u0026akamai.AppSecAdvancedSettingsLoggingArgs{\n\t\t\tConfigId: *pulumi.Int(configuration.ConfigId),\n\t\t\tLogging:  readFileOrPanic(fmt.Sprintf(\"%v/logging.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsLogging(ctx, \"policyLogging\", \u0026akamai.AppSecAdvancedSettingsLoggingArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tLogging:          readFileOrPanic(fmt.Sprintf(\"%v/logging.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsLogging;\nimport com.pulumi.akamai.AppSecAdvancedSettingsLoggingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var logging = new AppSecAdvancedSettingsLogging(\"logging\", AppSecAdvancedSettingsLoggingArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .logging(Files.readString(Paths.get(String.format(\"%s/logging.json\", path.module()))))\n            .build());\n\n        var policyLogging = new AppSecAdvancedSettingsLogging(\"policyLogging\", AppSecAdvancedSettingsLoggingArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .logging(Files.readString(Paths.get(String.format(\"%s/logging.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  logging: # USE CASE: User wants to configure logging settings for a security policy.\n    type: akamai:AppSecAdvancedSettingsLogging\n    properties:\n      configId: ${configuration.configId}\n      logging:\n        fn::readFile: ${path.module}/logging.json\n  policyLogging:\n    type: akamai:AppSecAdvancedSettingsLogging\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      logging:\n        fn::readFile: ${path.module}/logging.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                },
                "logging": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the logging settings to be configured.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "required": [
                "configId",
                "logging"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                },
                "logging": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the logging settings to be configured.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "logging"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsLogging resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration containing the logging settings being modified.\n"
                    },
                    "logging": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the logging settings to be configured.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsPragmaHeader:AppSecAdvancedSettingsPragmaHeader": {
            "description": "**Scopes**: Security configuration; security policy\n\nSpecifies the headers you can exclude from inspection when you are working with a Pragma debug header, a header that provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; whether a request was cached or not; etc. By default, pragma headers are removed from all responses.\n\nThis operation can be applied at the security configuration level (in which case it applies to all the security policies in the configuration), or can be customized for an individual security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/put-policies-pragma-header)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst pragmaHeader = new akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    pragmaHeader: fs.readFileSync(`${path.module}/pragma_header.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npragma_header = akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    pragma_header=(lambda path: open(path).read())(f\"{path['module']}/pragma_header.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var pragmaHeader = new Akamai.AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        PragmaHeader = File.ReadAllText($\"{path.Module}/pragma_header.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsPragmaHeader(ctx, \"pragmaHeader\", \u0026akamai.AppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tPragmaHeader:     readFileOrPanic(fmt.Sprintf(\"%v/pragma_header.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPragmaHeader;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPragmaHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var pragmaHeader = new AppSecAdvancedSettingsPragmaHeader(\"pragmaHeader\", AppSecAdvancedSettingsPragmaHeaderArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .pragmaHeader(Files.readString(Paths.get(String.format(\"%s/pragma_header.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pragmaHeader:\n    type: akamai:AppSecAdvancedSettingsPragmaHeader\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      pragmaHeader:\n        fn::readFile: ${path.module}/pragma_header.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                },
                "pragmaHeader": {
                    "type": "string",
                    "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "required": [
                "configId",
                "pragmaHeader"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                },
                "pragmaHeader": {
                    "type": "string",
                    "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "pragmaHeader"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsPragmaHeader resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the pragma header settings being modified.\n"
                    },
                    "pragmaHeader": {
                        "type": "string",
                        "description": ". Path to a JSON file containing information about the conditions to exclude from the default remove action. By default, the Pragma header debugging information is stripped from an operation's response except in cases where you set `excludeCondition`.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the pragma header settings being modified. If not included, pragma header settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAdvancedSettingsPrefetch:AppSecAdvancedSettingsPrefetch": {
            "description": "**Scopes**: Security configuration\n\nEnables inspection of internal requests (that is, requests between your origin servers and Akamai's edge servers). You can also use this resource to apply rate controls to prefetch requests.\n\nWhen prefetch is enabled, internal requests are inspected by your firewall the same way that external requests (requests that originate outside the firewall and outside Akamai's edge servers) are inspected.\n\nThis operation applies at the security configuration level, meaning that the settings affect all the security policies in that configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/put-advanced-settings-prefetch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst prefetch = new akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enableAppLayer: false,\n    allExtensions: true,\n    enableRateControls: false,\n    extensions: [\n        \".tiff\",\n        \".bmp\",\n        \".jpg\",\n        \".gif\",\n        \".png\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprefetch = akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\",\n    config_id=configuration.config_id,\n    enable_app_layer=False,\n    all_extensions=True,\n    enable_rate_controls=False,\n    extensions=[\n        \".tiff\",\n        \".bmp\",\n        \".jpg\",\n        \".gif\",\n        \".png\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var prefetch = new Akamai.AppSecAdvancedSettingsPrefetch(\"prefetch\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        EnableAppLayer = false,\n        AllExtensions = true,\n        EnableRateControls = false,\n        Extensions = new[]\n        {\n            \".tiff\",\n            \".bmp\",\n            \".jpg\",\n            \".gif\",\n            \".png\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAdvancedSettingsPrefetch(ctx, \"prefetch\", \u0026akamai.AppSecAdvancedSettingsPrefetchArgs{\n\t\t\tConfigId:           *pulumi.Int(configuration.ConfigId),\n\t\t\tEnableAppLayer:     pulumi.Bool(false),\n\t\t\tAllExtensions:      pulumi.Bool(true),\n\t\t\tEnableRateControls: pulumi.Bool(false),\n\t\t\tExtensions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\".tiff\"),\n\t\t\t\tpulumi.String(\".bmp\"),\n\t\t\t\tpulumi.String(\".jpg\"),\n\t\t\t\tpulumi.String(\".gif\"),\n\t\t\t\tpulumi.String(\".png\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPrefetch;\nimport com.pulumi.akamai.AppSecAdvancedSettingsPrefetchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var prefetch = new AppSecAdvancedSettingsPrefetch(\"prefetch\", AppSecAdvancedSettingsPrefetchArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enableAppLayer(false)\n            .allExtensions(true)\n            .enableRateControls(false)\n            .extensions(            \n                \".tiff\",\n                \".bmp\",\n                \".jpg\",\n                \".gif\",\n                \".png\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prefetch:\n    type: akamai:AppSecAdvancedSettingsPrefetch\n    properties:\n      configId: ${configuration.configId}\n      enableAppLayer: false\n      allExtensions: true\n      enableRateControls: false\n      extensions:\n        - .tiff\n        - .bmp\n        - .jpg\n        - .gif\n        - .png\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "allExtensions": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                },
                "enableAppLayer": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                },
                "enableRateControls": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                },
                "extensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                }
            },
            "required": [
                "allExtensions",
                "configId",
                "enableAppLayer",
                "enableRateControls",
                "extensions"
            ],
            "inputProperties": {
                "allExtensions": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                },
                "enableAppLayer": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                },
                "enableRateControls": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                },
                "extensions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                }
            },
            "requiredInputs": [
                "allExtensions",
                "configId",
                "enableAppLayer",
                "enableRateControls",
                "extensions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAdvancedSettingsPrefetch resources.\n",
                "properties": {
                    "allExtensions": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests for all file extensions; set to **false** to enable prefetch requests on only a specified set of file extensions. If set to false you must include the `extensions` argument.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the prefetch settings being modified.\n"
                    },
                    "enableAppLayer": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests; set to **false** to disable prefetch requests.\n"
                    },
                    "enableRateControls": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable prefetch requests for rate controls; set to **false** to disable prefetch requests for rate controls.\n"
                    },
                    "extensions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". If `all_extensions` is **false**, this must be a JSON array of all the file extensions for which prefetch requests are enabled: prefetch requests won't be used with any file extensions not included in the array. If `all_extensions` is **true**, then this argument must be set to an empty array: **[]**.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecApiConstraintsProtection:AppSecApiConstraintsProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables API constraints protection. These constraints specify the action to be taken when designated API endpoints are invoked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecApiConstraintsProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecApiConstraintsProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecApiConstraintsProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecApiConstraintsProtection(ctx, \"protection\", \u0026akamai.AppSecApiConstraintsProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecApiConstraintsProtection;\nimport com.pulumi.akamai.AppSecApiConstraintsProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecApiConstraintsProtection(\"protection\", AppSecApiConstraintsProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecApiConstraintsProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": "Unique identifier of the security configuration\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable API constraints protection\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "Unique identifier of the security policy\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": "Unique identifier of the security configuration\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether to enable API constraints protection\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "Unique identifier of the security policy\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecApiConstraintsProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "Unique identifier of the security configuration\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether to enable API constraints protection\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "Unique identifier of the security policy\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecApiRequestConstraints:AppSecApiRequestConstraints": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst apiEndpoint = configuration.then(configuration =\u003e akamai.getAppSecApiEndpoints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    apiName: \"Contracts\",\n}));\nconst apiRequestConstraints = new akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    apiEndpointId: apiEndpoint.then(apiEndpoint =\u003e apiEndpoint.id),\n    action: \"alert\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\napi_endpoint = akamai.get_app_sec_api_endpoints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_name=\"Contracts\")\napi_request_constraints = akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_endpoint_id=api_endpoint.id,\n    action=\"alert\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var apiEndpoint = Akamai.GetAppSecApiEndpoints.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ApiName = \"Contracts\",\n    });\n\n    var apiRequestConstraints = new Akamai.AppSecApiRequestConstraints(\"apiRequestConstraints\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ApiEndpointId = apiEndpoint.Apply(getAppSecApiEndpointsResult =\u003e getAppSecApiEndpointsResult.Id),\n        Action = \"alert\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tapiEndpoint, err := akamai.GetAppSecApiEndpoints(ctx, \u0026akamai.GetAppSecApiEndpointsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(\"gms1_134637\"),\n\t\t\tApiName:          pulumi.StringRef(\"Contracts\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecApiRequestConstraints(ctx, \"apiRequestConstraints\", \u0026akamai.AppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tApiEndpointId:    *pulumi.String(apiEndpoint.Id),\n\t\t\tAction:           pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;\nimport com.pulumi.akamai.AppSecApiRequestConstraints;\nimport com.pulumi.akamai.AppSecApiRequestConstraintsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var apiEndpoint = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiName(\"Contracts\")\n            .build());\n\n        var apiRequestConstraints = new AppSecApiRequestConstraints(\"apiRequestConstraints\", AppSecApiRequestConstraintsArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiEndpointId(apiEndpoint.applyValue(getAppSecApiEndpointsResult -\u003e getAppSecApiEndpointsResult.id()))\n            .action(\"alert\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  apiRequestConstraints:\n    type: akamai:AppSecApiRequestConstraints\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      apiEndpointId: ${apiEndpoint.id}\n      action: alert\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  apiEndpoint:\n    fn::invoke:\n      Function: akamai:getAppSecApiEndpoints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        apiName: Contracts\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "apiEndpointId": {
                    "type": "integer",
                    "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                }
            },
            "required": [
                "action",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "apiEndpointId": {
                    "type": "integer",
                    "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                }
            },
            "requiredInputs": [
                "action",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecApiRequestConstraints resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": ". Action to assign to the API request constraint. Allowed values are:\n- **alert**, Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "apiEndpointId": {
                        "type": "integer",
                        "description": ". ID of the API endpoint the constraint will be assigned to.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API request constraint settings being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API request constraint settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecAttackGroup:AppSecAttackGroup": {
            "description": "**Scopes**: Attack group\n\nModify an attack group's action, conditions, and exceptions. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst attackGroup = new akamai.AppSecAttackGroup(\"attackGroup\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    attackGroup: \"SQL\",\n    attackGroupAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nattack_group = akamai.AppSecAttackGroup(\"attackGroup\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    attack_group=\"SQL\",\n    attack_group_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var attackGroup = new Akamai.AppSecAttackGroup(\"attackGroup\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        AttackGroup = \"SQL\",\n        AttackGroupAction = \"deny\",\n        ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecAttackGroup(ctx, \"attackGroup\", \u0026akamai.AppSecAttackGroupArgs{\n\t\t\tConfigId:           *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tAttackGroup:        pulumi.String(\"SQL\"),\n\t\t\tAttackGroupAction:  pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecAttackGroup;\nimport com.pulumi.akamai.AppSecAttackGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var attackGroup = new AppSecAttackGroup(\"attackGroup\", AppSecAttackGroupArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .attackGroup(\"SQL\")\n            .attackGroupAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attackGroup:\n    type: akamai:AppSecAttackGroup\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      attackGroup: SQL\n      attackGroupAction: deny\n      conditionException:\n        fn::readFile: ${path.module}/condition_exception.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique name of the attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                }
            },
            "required": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique name of the attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                }
            },
            "requiredInputs": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecAttackGroup resources.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group being modified.\n"
                    },
                    "attackGroupAction": {
                        "type": "string",
                        "description": ". Action taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record information about the request.\n- **deny**. Block the request,\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the attack group being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the attack group being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecByPassNetworkList:AppSecByPassNetworkList": {
            "description": "**Scopes**: Security configuration\n\nSpecifies the networks that appear on the bypass network list. Networks on this list are allowed to bypass the Web Application Firewall.\n\nNote that this resource is only applicable to WAP (Web Application Protector) configurations.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/put-bypass-network-lists)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst bypassNetworkLists = new akamai.AppSecByPassNetworkList(\"bypassNetworkLists\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    bypassNetworkLists: [\n        \"DocumentationNetworkList\",\n        \"TrainingNetworkList\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nbypass_network_lists = akamai.AppSecByPassNetworkList(\"bypassNetworkLists\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    bypass_network_lists=[\n        \"DocumentationNetworkList\",\n        \"TrainingNetworkList\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var bypassNetworkLists = new Akamai.AppSecByPassNetworkList(\"bypassNetworkLists\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        BypassNetworkLists = new[]\n        {\n            \"DocumentationNetworkList\",\n            \"TrainingNetworkList\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecByPassNetworkList(ctx, \"bypassNetworkLists\", \u0026akamai.AppSecByPassNetworkListArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tBypassNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DocumentationNetworkList\"),\n\t\t\t\tpulumi.String(\"TrainingNetworkList\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecByPassNetworkList;\nimport com.pulumi.akamai.AppSecByPassNetworkListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var bypassNetworkLists = new AppSecByPassNetworkList(\"bypassNetworkLists\", AppSecByPassNetworkListArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .bypassNetworkLists(            \n                \"DocumentationNetworkList\",\n                \"TrainingNetworkList\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bypassNetworkLists:\n    type: akamai:AppSecByPassNetworkList\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      bypassNetworkLists:\n        - DocumentationNetworkList\n        - TrainingNetworkList\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated list of bypass network IDs.\n",
            "properties": {
                "bypassNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network IDs that comprise the bypass list.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                }
            },
            "required": [
                "bypassNetworkLists",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "bypassNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network IDs that comprise the bypass list.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                }
            },
            "requiredInputs": [
                "bypassNetworkLists",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecByPassNetworkList resources.\n",
                "properties": {
                    "bypassNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of network IDs that comprise the bypass list.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the bypass network lists being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecConfiguration:AppSecConfiguration": {
            "description": "**Scopes**: Contract and group\n\nCreates a new WAP (Web Application Protector) or KSD (Kona Site Defender) security configuration. KSD security configurations start out empty (i.e., unconfigured), while WAP configurations are created using preset values. The contract referenced in the request body determines the type of configuration you can create.\n\nIn addition to manually creating a new configuration, you can use the `create_from_config_id` argument to clone an existing configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs](https://techdocs.akamai.com/application-security/reference/post-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst selectableHostnames = akamai.getAppSecSelectableHostnames({\n    configId: \"Documentation\",\n});\nconst createConfig = new akamai.AppSecConfiguration(\"createConfig\", {\n    description: \"This configuration is used as a testing environment for the documentation team.\",\n    contractId: \"5-2WA382\",\n    groupId: 12198,\n    hostNames: [\n        \"documentation.akamai.com\",\n        \"training.akamai.com\",\n    ],\n});\nexport const createConfigId = createConfig.configId;\nconst cloneConfig = new akamai.AppSecConfiguration(\"cloneConfig\", {\n    description: \"This configuration is used as a testing environment for the documentation team.\",\n    createFromConfigId: data.akamai_appsec_configuration.configuration.config_id,\n    createFromVersion: data.akamai_appsec_configuration.configuration.latest_version,\n    contractId: \"5-2WA382\",\n    groupId: 12198,\n    hostNames: selectableHostnames.then(selectableHostnames =\u003e selectableHostnames.hostnames),\n});\nexport const cloneConfigId = cloneConfig.configId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nselectable_hostnames = akamai.get_app_sec_selectable_hostnames(config_id=\"Documentation\")\ncreate_config = akamai.AppSecConfiguration(\"createConfig\",\n    description=\"This configuration is used as a testing environment for the documentation team.\",\n    contract_id=\"5-2WA382\",\n    group_id=12198,\n    host_names=[\n        \"documentation.akamai.com\",\n        \"training.akamai.com\",\n    ])\npulumi.export(\"createConfigId\", create_config.config_id)\nclone_config = akamai.AppSecConfiguration(\"cloneConfig\",\n    description=\"This configuration is used as a testing environment for the documentation team.\",\n    create_from_config_id=data[\"akamai_appsec_configuration\"][\"configuration\"][\"config_id\"],\n    create_from_version=data[\"akamai_appsec_configuration\"][\"configuration\"][\"latest_version\"],\n    contract_id=\"5-2WA382\",\n    group_id=12198,\n    host_names=selectable_hostnames.hostnames)\npulumi.export(\"cloneConfigId\", clone_config.config_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var selectableHostnames = Akamai.GetAppSecSelectableHostnames.Invoke(new()\n    {\n        ConfigId = \"Documentation\",\n    });\n\n    var createConfig = new Akamai.AppSecConfiguration(\"createConfig\", new()\n    {\n        Description = \"This configuration is used as a testing environment for the documentation team.\",\n        ContractId = \"5-2WA382\",\n        GroupId = 12198,\n        HostNames = new[]\n        {\n            \"documentation.akamai.com\",\n            \"training.akamai.com\",\n        },\n    });\n\n    var cloneConfig = new Akamai.AppSecConfiguration(\"cloneConfig\", new()\n    {\n        Description = \"This configuration is used as a testing environment for the documentation team.\",\n        CreateFromConfigId = data.Akamai_appsec_configuration.Configuration.Config_id,\n        CreateFromVersion = data.Akamai_appsec_configuration.Configuration.Latest_version,\n        ContractId = \"5-2WA382\",\n        GroupId = 12198,\n        HostNames = selectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.Hostnames),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"createConfigId\"] = createConfig.ConfigId,\n        [\"cloneConfigId\"] = cloneConfig.ConfigId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tselectableHostnames, err := akamai.GetAppSecSelectableHostnames(ctx, \u0026akamai.GetAppSecSelectableHostnamesArgs{\n\t\t\tConfigId: pulumi.IntRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateConfig, err := akamai.NewAppSecConfiguration(ctx, \"createConfig\", \u0026akamai.AppSecConfigurationArgs{\n\t\t\tDescription: pulumi.String(\"This configuration is used as a testing environment for the documentation team.\"),\n\t\t\tContractId:  pulumi.String(\"5-2WA382\"),\n\t\t\tGroupId:     pulumi.Int(12198),\n\t\t\tHostNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"documentation.akamai.com\"),\n\t\t\t\tpulumi.String(\"training.akamai.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"createConfigId\", createConfig.ConfigId)\n\t\tcloneConfig, err := akamai.NewAppSecConfiguration(ctx, \"cloneConfig\", \u0026akamai.AppSecConfigurationArgs{\n\t\t\tDescription:        pulumi.String(\"This configuration is used as a testing environment for the documentation team.\"),\n\t\t\tCreateFromConfigId: pulumi.Any(data.Akamai_appsec_configuration.Configuration.Config_id),\n\t\t\tCreateFromVersion:  pulumi.Any(data.Akamai_appsec_configuration.Configuration.Latest_version),\n\t\t\tContractId:         pulumi.String(\"5-2WA382\"),\n\t\t\tGroupId:            pulumi.Int(12198),\n\t\t\tHostNames:          interface{}(selectableHostnames.Hostnames),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"cloneConfigId\", cloneConfig.ConfigId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;\nimport com.pulumi.akamai.AppSecConfiguration;\nimport com.pulumi.akamai.AppSecConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var selectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .configId(\"Documentation\")\n            .build());\n\n        var createConfig = new AppSecConfiguration(\"createConfig\", AppSecConfigurationArgs.builder()        \n            .description(\"This configuration is used as a testing environment for the documentation team.\")\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .hostNames(            \n                \"documentation.akamai.com\",\n                \"training.akamai.com\")\n            .build());\n\n        ctx.export(\"createConfigId\", createConfig.configId());\n        var cloneConfig = new AppSecConfiguration(\"cloneConfig\", AppSecConfigurationArgs.builder()        \n            .description(\"This configuration is used as a testing environment for the documentation team.\")\n            .createFromConfigId(data.akamai_appsec_configuration().configuration().config_id())\n            .createFromVersion(data.akamai_appsec_configuration().configuration().latest_version())\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .hostNames(selectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()))\n            .build());\n\n        ctx.export(\"cloneConfigId\", cloneConfig.configId());\n    }\n}\n```\n```yaml\nresources:\n  createConfig:\n    type: akamai:AppSecConfiguration\n    properties:\n      description: This configuration is used as a testing environment for the documentation team.\n      contractId: 5-2WA382\n      groupId: 12198\n      hostNames:\n        - documentation.akamai.com\n        - training.akamai.com\n  cloneConfig:\n    type: akamai:AppSecConfiguration\n    properties:\n      description: This configuration is used as a testing environment for the documentation team.\n      createFromConfigId: ${data.akamai_appsec_configuration.configuration.config_id}\n      createFromVersion: ${data.akamai_appsec_configuration.configuration.latest_version}\n      contractId: 5-2WA382\n      groupId: 12198\n      hostNames: ${selectableHostnames.hostnames}\nvariables:\n  selectableHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        configId: Documentation\noutputs:\n  createConfigId: ${createConfig.configId} # USE CASE: User wants to clone a new security configuration from an existing configuration and version.\n  cloneConfigId: ${cloneConfig.configId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `config_id`. ID of the new security configuration.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": "Unique identifier of the new security configuration\n"
                },
                "contractId": {
                    "type": "string",
                    "description": ". Unique identifier of the Akamai contract associated with the new configuration.\n"
                },
                "createFromConfigId": {
                    "type": "integer",
                    "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                },
                "createFromVersion": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being cloned.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the new configuration.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                },
                "hostNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". Name of the new configuration.\n"
                }
            },
            "required": [
                "configId",
                "contractId",
                "description",
                "groupId",
                "hostNames",
                "name"
            ],
            "inputProperties": {
                "contractId": {
                    "type": "string",
                    "description": ". Unique identifier of the Akamai contract associated with the new configuration.\n"
                },
                "createFromConfigId": {
                    "type": "integer",
                    "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                },
                "createFromVersion": {
                    "type": "integer",
                    "description": ". Version number of the security configuration being cloned.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the new configuration.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                },
                "hostNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". Name of the new configuration.\n"
                }
            },
            "requiredInputs": [
                "contractId",
                "description",
                "groupId",
                "hostNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecConfiguration resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "Unique identifier of the new security configuration\n"
                    },
                    "contractId": {
                        "type": "string",
                        "description": ". Unique identifier of the Akamai contract associated with the new configuration.\n"
                    },
                    "createFromConfigId": {
                        "type": "integer",
                        "description": ". Unique identifier of the existing configuration being cloned in order to create the new configuration.\n"
                    },
                    "createFromVersion": {
                        "type": "integer",
                        "description": ". Version number of the security configuration being cloned.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": ". Brief description of the new configuration.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": ". Unique identifier of the contract group associated with the new configuration.\n"
                    },
                    "hostNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": ". Name of the new configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecConfigurationRename:AppSecConfigurationRename": {
            "description": "**Scopes**: Security configuration\n\nRenames an existing security configuration.\nNote that you can change only the configuration name. You can't modify the ID assigned to a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}](https://techdocs.akamai.com/application-security/reference/put-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configurationAppSecConfiguration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst configurationAppSecConfigurationRename = new akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", {\n    configId: configurationAppSecConfiguration.then(configurationAppSecConfiguration =\u003e configurationAppSecConfiguration.configId),\n    description: \"This configuration is by both the documentation team and the training team.\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration_app_sec_configuration = akamai.get_app_sec_configuration(name=\"Documentation\")\nconfiguration_app_sec_configuration_rename = akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\",\n    config_id=configuration_app_sec_configuration.config_id,\n    description=\"This configuration is by both the documentation team and the training team.\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configurationAppSecConfiguration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var configurationAppSecConfigurationRename = new Akamai.AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", new()\n    {\n        ConfigId = configurationAppSecConfiguration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Description = \"This configuration is by both the documentation team and the training team.\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfigurationAppSecConfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecConfigurationRename(ctx, \"configurationAppSecConfigurationRename\", \u0026akamai.AppSecConfigurationRenameArgs{\n\t\t\tConfigId:    *pulumi.Int(configurationAppSecConfiguration.ConfigId),\n\t\t\tDescription: pulumi.String(\"This configuration is by both the documentation team and the training team.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecConfigurationRename;\nimport com.pulumi.akamai.AppSecConfigurationRenameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configurationAppSecConfiguration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var configurationAppSecConfigurationRename = new AppSecConfigurationRename(\"configurationAppSecConfigurationRename\", AppSecConfigurationRenameArgs.builder()        \n            .configId(configurationAppSecConfiguration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .description(\"This configuration is by both the documentation team and the training team.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  configurationAppSecConfigurationRename:\n    type: akamai:AppSecConfigurationRename\n    properties:\n      configId: ${configurationAppSecConfiguration.configId}\n      description: This configuration is by both the documentation team and the training team.\nvariables:\n  configurationAppSecConfiguration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuring being renamed.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the security configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". New name for the security configuration.\n"
                }
            },
            "required": [
                "configId",
                "description",
                "name"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuring being renamed.\n"
                },
                "description": {
                    "type": "string",
                    "description": ". Brief description of the security configuration.\n"
                },
                "name": {
                    "type": "string",
                    "description": ". New name for the security configuration.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "description"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecConfigurationRename resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuring being renamed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": ". Brief description of the security configuration.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": ". New name for the security configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomDeny:AppSecCustomDeny": {
            "description": "**Scopes**: Custom deny\n\nModifies a custom deny action. Custom denies enable you to craft your own error message or redirect pages for use when HTTP requests are denied.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customDeny = new akamai.AppSecCustomDeny(\"customDeny\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    customDeny: fs.readFileSync(`${path.module}/custom_deny.json`),\n});\nexport const customDenyId = customDeny.customDenyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_deny = akamai.AppSecCustomDeny(\"customDeny\",\n    config_id=configuration.config_id,\n    custom_deny=(lambda path: open(path).read())(f\"{path['module']}/custom_deny.json\"))\npulumi.export(\"customDenyId\", custom_deny.custom_deny_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var customDeny = new Akamai.AppSecCustomDeny(\"customDeny\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        CustomDeny = File.ReadAllText($\"{path.Module}/custom_deny.json\"),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customDenyId\"] = customDeny.CustomDenyId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomDeny, err := akamai.NewAppSecCustomDeny(ctx, \"customDeny\", \u0026akamai.AppSecCustomDenyArgs{\n\t\t\tConfigId:   *pulumi.Int(configuration.ConfigId),\n\t\t\tCustomDeny: readFileOrPanic(fmt.Sprintf(\"%v/custom_deny.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyId\", customDeny.CustomDenyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecCustomDeny;\nimport com.pulumi.akamai.AppSecCustomDenyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var customDeny = new AppSecCustomDeny(\"customDeny\", AppSecCustomDenyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customDeny(Files.readString(Paths.get(String.format(\"%s/custom_deny.json\", path.module()))))\n            .build());\n\n        ctx.export(\"customDenyId\", customDeny.customDenyId());\n    }\n}\n```\n```yaml\nresources:\n  customDeny:\n    type: akamai:AppSecCustomDeny\n    properties:\n      configId: ${configuration.configId}\n      customDeny:\n        fn::readFile: ${path.module}/custom_deny.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  customDenyId: ${customDeny.customDenyId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `custom_deny_id`. ID of the new custom deny action.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                },
                "customDeny": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the custom deny.\n"
                },
                "customDenyId": {
                    "type": "string",
                    "description": "custom_deny_id\n"
                }
            },
            "required": [
                "configId",
                "customDeny",
                "customDenyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                },
                "customDeny": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the custom deny.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customDeny"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomDeny resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom deny.\n"
                    },
                    "customDeny": {
                        "type": "string",
                        "description": ". Path to a JSON file containing properties and property values for the custom deny.\n"
                    },
                    "customDenyId": {
                        "type": "string",
                        "description": "custom_deny_id\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomRule:AppSecCustomRule": {
            "description": "**Scopes**: Security configuration\n\nCreates a custom rule associated with a security configuration. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules]https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                },
                "customRule": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.\n"
                },
                "customRuleId": {
                    "type": "integer",
                    "description": ". ID of the new custom rule.\n"
                }
            },
            "required": [
                "configId",
                "customRule",
                "customRuleId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                },
                "customRule": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customRule"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomRule resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rule being modified.\n"
                    },
                    "customRule": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". ID of the new custom rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecCustomRuleAction:AppSecCustomRuleAction": {
            "description": "**Scopes**: Custom rule\n\nAssociates an action with a custom rule. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst createCustomRuleAction = new akamai.AppSecCustomRuleAction(\"createCustomRuleAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    customRuleId: 12345,\n    customRuleAction: \"alert\",\n});\nexport const customRuleId = createCustomRuleAction.customRuleId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncreate_custom_rule_action = akamai.AppSecCustomRuleAction(\"createCustomRuleAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    custom_rule_id=12345,\n    custom_rule_action=\"alert\")\npulumi.export(\"customRuleId\", create_custom_rule_action.custom_rule_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var createCustomRuleAction = new Akamai.AppSecCustomRuleAction(\"createCustomRuleAction\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        CustomRuleId = 12345,\n        CustomRuleAction = \"alert\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customRuleId\"] = createCustomRuleAction.CustomRuleId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateCustomRuleAction, err := akamai.NewAppSecCustomRuleAction(ctx, \"createCustomRuleAction\", \u0026akamai.AppSecCustomRuleActionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tCustomRuleId:     pulumi.Int(12345),\n\t\t\tCustomRuleAction: pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRuleId\", createCustomRuleAction.CustomRuleId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecCustomRuleAction;\nimport com.pulumi.akamai.AppSecCustomRuleActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var createCustomRuleAction = new AppSecCustomRuleAction(\"createCustomRuleAction\", AppSecCustomRuleActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .customRuleId(12345)\n            .customRuleAction(\"alert\")\n            .build());\n\n        ctx.export(\"customRuleId\", createCustomRuleAction.customRuleId());\n    }\n}\n```\n```yaml\nresources:\n  createCustomRuleAction:\n    type: akamai:AppSecCustomRuleAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      customRuleId: 12345\n      customRuleAction: alert\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  customRuleId: ${createCustomRuleAction.customRuleId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                },
                "customRuleAction": {
                    "type": "string",
                    "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "customRuleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                }
            },
            "required": [
                "configId",
                "customRuleAction",
                "customRuleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                },
                "customRuleAction": {
                    "type": "string",
                    "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "customRuleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "customRuleAction",
                "customRuleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecCustomRuleAction resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rule action being modified.\n"
                    },
                    "customRuleAction": {
                        "type": "string",
                        "description": ". Action to be taken when the custom rule is invoked. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the custom rule action being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEval:AppSecEval": {
            "description": "**Scopes**: Security policy\n\nIssues an evaluation mode command (`Start`, `Stop`, `Restart`, `Update`, or `Complete`) to a security configuration.\nEvaluation mode is used for testing and fine-tuning your Kona Rule Set rules and configuration settings.\nIn evaluation mode rules are triggered by events, but the only thing those rules do is record the actions they *would* have taken had the event occurred on the production network.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval](https://techdocs.akamai.com/application-security/reference/post-policy-eval)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalOperation = new akamai.AppSecEval(\"evalOperation\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    evalOperation: \"START\",\n});\nexport const evalModeEvaluatingRuleset = evalOperation.evaluatingRuleset;\nexport const evalModeExpirationDate = evalOperation.expirationDate;\nexport const evalModeCurrentRuleset = evalOperation.currentRuleset;\nexport const evalModeStatus = evalOperation.evalStatus;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_operation = akamai.AppSecEval(\"evalOperation\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    eval_operation=\"START\")\npulumi.export(\"evalModeEvaluatingRuleset\", eval_operation.evaluating_ruleset)\npulumi.export(\"evalModeExpirationDate\", eval_operation.expiration_date)\npulumi.export(\"evalModeCurrentRuleset\", eval_operation.current_ruleset)\npulumi.export(\"evalModeStatus\", eval_operation.eval_status)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalOperation = new Akamai.AppSecEval(\"evalOperation\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        EvalOperation = \"START\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"evalModeEvaluatingRuleset\"] = evalOperation.EvaluatingRuleset,\n        [\"evalModeExpirationDate\"] = evalOperation.ExpirationDate,\n        [\"evalModeCurrentRuleset\"] = evalOperation.CurrentRuleset,\n        [\"evalModeStatus\"] = evalOperation.EvalStatus,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalOperation, err := akamai.NewAppSecEval(ctx, \"evalOperation\", \u0026akamai.AppSecEvalArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEvalOperation:    pulumi.String(\"START\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalModeEvaluatingRuleset\", evalOperation.EvaluatingRuleset)\n\t\tctx.Export(\"evalModeExpirationDate\", evalOperation.ExpirationDate)\n\t\tctx.Export(\"evalModeCurrentRuleset\", evalOperation.CurrentRuleset)\n\t\tctx.Export(\"evalModeStatus\", evalOperation.EvalStatus)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEval;\nimport com.pulumi.akamai.AppSecEvalArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalOperation = new AppSecEval(\"evalOperation\", AppSecEvalArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .evalOperation(\"START\")\n            .build());\n\n        ctx.export(\"evalModeEvaluatingRuleset\", evalOperation.evaluatingRuleset());\n        ctx.export(\"evalModeExpirationDate\", evalOperation.expirationDate());\n        ctx.export(\"evalModeCurrentRuleset\", evalOperation.currentRuleset());\n        ctx.export(\"evalModeStatus\", evalOperation.evalStatus());\n    }\n}\n```\n```yaml\nresources:\n  evalOperation:\n    type: akamai:AppSecEval\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      evalOperation: START\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  evalModeEvaluatingRuleset: ${evalOperation.evaluatingRuleset}\n  evalModeExpirationDate: ${evalOperation.expirationDate}\n  evalModeCurrentRuleset: ${evalOperation.currentRuleset}\n  evalModeStatus: ${evalOperation.evalStatus}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `evaluating_ruleset`. Versioning information for the Kona Rule Set being evaluated.\n- `expiration_date`. Date when the evaluation period ends.\n- `current_ruleset`. Versioning information for the Kona Rule Set currently in use on the production network.\n- `eval_status`. If **true**, an evaluation is currently in progress; if **false**, evaluation is either paused or is not running.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                },
                "currentRuleset": {
                    "type": "string",
                    "description": "Versioning information for the Kona Rule Set currently in use in production\n"
                },
                "evalMode": {
                    "type": "string",
                    "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                },
                "evalOperation": {
                    "type": "string",
                    "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                },
                "evalStatus": {
                    "type": "string",
                    "description": "Whether an evaluation is currently in progress\n"
                },
                "evaluatingRuleset": {
                    "type": "string",
                    "description": "Versioning information for the Kona Rule Set being evaluated\n"
                },
                "expirationDate": {
                    "type": "string",
                    "description": "Date when the evaluation period ends\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalOperation",
                "evalStatus",
                "evaluatingRuleset",
                "expirationDate",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                },
                "evalMode": {
                    "type": "string",
                    "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                },
                "evalOperation": {
                    "type": "string",
                    "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "evalOperation",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEval resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration where evaluation mode will take place (or is currently taking place).\n"
                    },
                    "currentRuleset": {
                        "type": "string",
                        "description": "Versioning information for the Kona Rule Set currently in use in production\n"
                    },
                    "evalMode": {
                        "type": "string",
                        "description": ". Set to **ASE_AUTO** to have your Kona Rule Set rules automatically updated during the evaluation period; set to **ASE_MANUAL** if you want to manually update your evaluation rules. Note that this option is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n"
                    },
                    "evalOperation": {
                        "type": "string",
                        "description": ". Evaluation mode operation. Allowed values are:\n- **START**. Starts evaluation mode. By default, evaluation mode runs for four weeks.\n- **STOP**, Pauses evaluation mode without upgrading the Kona Rule Set on your production network.\n- **RESTART**. Resumes an evaluation trial that was paused by using the **STOP** command.\n- **UPDATE**. Upgrades the Kona Rule Set rules in the evaluation ruleset to their latest versions.\n- **COMPLETE**. Concludes the evaluation period (even if the four-week trial mode is not over) and automatically upgrades the Kona Rule Set on your production network to the same rule set you just finished evaluating.\n"
                    },
                    "evalStatus": {
                        "type": "string",
                        "description": "Whether an evaluation is currently in progress\n"
                    },
                    "evaluatingRuleset": {
                        "type": "string",
                        "description": "Versioning information for the Kona Rule Set being evaluated\n"
                    },
                    "expirationDate": {
                        "type": "string",
                        "description": "Date when the evaluation period ends\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalGroup:AppSecEvalGroup": {
            "description": "**Scopes**: Evaluation attack group\n\nModifies the action and the conditions and exceptions for an evaluation mode attack group.\n\nNote that this resource is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information about ASE, please contact your Akamai representative.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalAttackGroup = new akamai.AppSecEvalGroup(\"evalAttackGroup\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    attackGroup: \"SQL\",\n    attackGroupAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_attack_group = akamai.AppSecEvalGroup(\"evalAttackGroup\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    attack_group=\"SQL\",\n    attack_group_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalAttackGroup = new Akamai.AppSecEvalGroup(\"evalAttackGroup\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        AttackGroup = \"SQL\",\n        AttackGroupAction = \"deny\",\n        ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalGroup(ctx, \"evalAttackGroup\", \u0026akamai.AppSecEvalGroupArgs{\n\t\t\tConfigId:           *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tAttackGroup:        pulumi.String(\"SQL\"),\n\t\t\tAttackGroupAction:  pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalGroup;\nimport com.pulumi.akamai.AppSecEvalGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalAttackGroup = new AppSecEvalGroup(\"evalAttackGroup\", AppSecEvalGroupArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .attackGroup(\"SQL\")\n            .attackGroupAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  evalAttackGroup:\n    type: akamai:AppSecEvalGroup\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      attackGroup: SQL\n      attackGroupAction: deny\n      conditionException:\n        fn::readFile: ${path.module}/condition_exception.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique identifier of the evaluation attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the attack group.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "attackGroup": {
                    "type": "string",
                    "description": ". Unique identifier of the evaluation attack group being modified.\n"
                },
                "attackGroupAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing properties and property values for the attack group.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "attackGroup",
                "attackGroupAction",
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalGroup resources.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique identifier of the evaluation attack group being modified.\n"
                    },
                    "attackGroupAction": {
                        "type": "string",
                        "description": ". Action to be taken any time the attack group is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing properties and property values for the attack group.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration where evaluation is taking place.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalPenaltyBox:AppSecEvalPenaltyBox": {
            "description": "**Scopes**: Security policy\n\n __ASE_Beta__.:\nModifies the penalty box settings for a security policy in evaluation mode - evaluation penalty box.\nWhen the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**:  [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/put-policy-eval_penalty-box)\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalPenaltyBox = new akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    penaltyBoxProtection: true,\n    penaltyBoxAction: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_penalty_box = akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    penalty_box_protection=True,\n    penalty_box_action=\"deny\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalPenaltyBox = new Akamai.AppSecEvalPenaltyBox(\"evalPenaltyBox\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        PenaltyBoxProtection = true,\n        PenaltyBoxAction = \"deny\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalPenaltyBox(ctx, \"evalPenaltyBox\", \u0026akamai.AppSecEvalPenaltyBoxArgs{\n\t\t\tConfigId:             *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:     pulumi.String(\"gms1_134637\"),\n\t\t\tPenaltyBoxProtection: pulumi.Bool(true),\n\t\t\tPenaltyBoxAction:     pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalPenaltyBox;\nimport com.pulumi.akamai.AppSecEvalPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalPenaltyBox = new AppSecEvalPenaltyBox(\"evalPenaltyBox\", AppSecEvalPenaltyBoxArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .penaltyBoxProtection(true)\n            .penaltyBoxAction(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  evalPenaltyBox:\n    type: akamai:AppSecEvalPenaltyBox\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      penaltyBoxProtection: true\n      penaltyBoxAction: deny\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalPenaltyBox resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.\n"
                    },
                    "penaltyBoxAction": {
                        "type": "string",
                        "description": ". Action taken any time evaluation penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "penaltyBoxProtection": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecEvalRule:AppSecEvalRule": {
            "description": "**Scopes**: Evaluation rule\n\nCreates or modifies an evaluation rule's action, conditions, and exceptions.\nEvaluation rules are Kona Rule Set rules used when running a security configuration in evaluation mode.\nChanges to these rules do not affect the rules used on your production network.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-policy-eval-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalRule = new akamai.AppSecEvalRule(\"evalRule\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n    ruleAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_rule = akamai.AppSecEvalRule(\"evalRule\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316,\n    rule_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalRule = new Akamai.AppSecEvalRule(\"evalRule\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        RuleId = 60029316,\n        RuleAction = \"deny\",\n        ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecEvalRule(ctx, \"evalRule\", \u0026akamai.AppSecEvalRuleArgs{\n\t\t\tConfigId:           *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tRuleId:             pulumi.Int(60029316),\n\t\t\tRuleAction:         pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecEvalRule;\nimport com.pulumi.akamai.AppSecEvalRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var evalRule = new AppSecEvalRule(\"evalRule\", AppSecEvalRuleArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(60029316)\n            .ruleAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  evalRule:\n    type: akamai:AppSecEvalRule\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      ruleId: 6.0029316e+07\n      ruleAction: deny\n      conditionException:\n        fn::readFile: ${path.module}/condition_exception.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the evaluation rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "required": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the evaluation rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecEvalRule resources.\n",
                "properties": {
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the conditions and exceptions to be applied to the evaluation rule.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration in evaluation mode.\n"
                    },
                    "ruleAction": {
                        "type": "string",
                        "description": ". Action to be taken any time the evaluation rule is triggered, Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the evaluation rule being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation process.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecIPGeo:AppSecIPGeo": {
            "description": "**Scopes**: Security policy\n\nModifies the method used for firewall blocking, and manages the network lists used for IP/Geo firewall blocking.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-ip-geo-firewall)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ipGeoBlock = new akamai.AppSecIPGeo(\"ipGeoBlock\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    mode: \"block\",\n    geoNetworkLists: [\"06038_GEO_TEST\"],\n    ipNetworkLists: [\"56921_TEST\"],\n    exceptionIpNetworkLists: [\"07126_EXCEPTION_TEST\"],\n});\n// USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\nconst ipGeoAllow = new akamai.AppSecIPGeo(\"ipGeoAllow\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1-090334\",\n    mode: \"allow\",\n    exceptionIpNetworkLists: [\"07126_EXCEPTION_TEST\"],\n});\nexport const ipGeoModeBlock = ipGeoBlock.mode;\nexport const blockGeoNetworkLists = ipGeoBlock.geoNetworkLists;\nexport const blockIpNetworkLists = ipGeoBlock.ipNetworkLists;\nexport const blockExceptionIpNetworkLists = ipGeoBlock.exceptionIpNetworkLists;\nexport const ipGeoModeAllow = ipGeoAllow.mode;\nexport const allowExceptionIpNetworkLists = ipGeoAllow.exceptionIpNetworkLists;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nip_geo_block = akamai.AppSecIPGeo(\"ipGeoBlock\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    mode=\"block\",\n    geo_network_lists=[\"06038_GEO_TEST\"],\n    ip_network_lists=[\"56921_TEST\"],\n    exception_ip_network_lists=[\"07126_EXCEPTION_TEST\"])\n# USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\nip_geo_allow = akamai.AppSecIPGeo(\"ipGeoAllow\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1-090334\",\n    mode=\"allow\",\n    exception_ip_network_lists=[\"07126_EXCEPTION_TEST\"])\npulumi.export(\"ipGeoModeBlock\", ip_geo_block.mode)\npulumi.export(\"blockGeoNetworkLists\", ip_geo_block.geo_network_lists)\npulumi.export(\"blockIpNetworkLists\", ip_geo_block.ip_network_lists)\npulumi.export(\"blockExceptionIpNetworkLists\", ip_geo_block.exception_ip_network_lists)\npulumi.export(\"ipGeoModeAllow\", ip_geo_allow.mode)\npulumi.export(\"allowExceptionIpNetworkLists\", ip_geo_allow.exception_ip_network_lists)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ipGeoBlock = new Akamai.AppSecIPGeo(\"ipGeoBlock\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Mode = \"block\",\n        GeoNetworkLists = new[]\n        {\n            \"06038_GEO_TEST\",\n        },\n        IpNetworkLists = new[]\n        {\n            \"56921_TEST\",\n        },\n        ExceptionIpNetworkLists = new[]\n        {\n            \"07126_EXCEPTION_TEST\",\n        },\n    });\n\n    // USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\n    var ipGeoAllow = new Akamai.AppSecIPGeo(\"ipGeoAllow\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1-090334\",\n        Mode = \"allow\",\n        ExceptionIpNetworkLists = new[]\n        {\n            \"07126_EXCEPTION_TEST\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ipGeoModeBlock\"] = ipGeoBlock.Mode,\n        [\"blockGeoNetworkLists\"] = ipGeoBlock.GeoNetworkLists,\n        [\"blockIpNetworkLists\"] = ipGeoBlock.IpNetworkLists,\n        [\"blockExceptionIpNetworkLists\"] = ipGeoBlock.ExceptionIpNetworkLists,\n        [\"ipGeoModeAllow\"] = ipGeoAllow.Mode,\n        [\"allowExceptionIpNetworkLists\"] = ipGeoAllow.ExceptionIpNetworkLists,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeoBlock, err := akamai.NewAppSecIPGeo(ctx, \"ipGeoBlock\", \u0026akamai.AppSecIPGeoArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tMode:             pulumi.String(\"block\"),\n\t\t\tGeoNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"06038_GEO_TEST\"),\n\t\t\t},\n\t\t\tIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"56921_TEST\"),\n\t\t\t},\n\t\t\tExceptionIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"07126_EXCEPTION_TEST\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeoAllow, err := akamai.NewAppSecIPGeo(ctx, \"ipGeoAllow\", \u0026akamai.AppSecIPGeoArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1-090334\"),\n\t\t\tMode:             pulumi.String(\"allow\"),\n\t\t\tExceptionIpNetworkLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"07126_EXCEPTION_TEST\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ipGeoModeBlock\", ipGeoBlock.Mode)\n\t\tctx.Export(\"blockGeoNetworkLists\", ipGeoBlock.GeoNetworkLists)\n\t\tctx.Export(\"blockIpNetworkLists\", ipGeoBlock.IpNetworkLists)\n\t\tctx.Export(\"blockExceptionIpNetworkLists\", ipGeoBlock.ExceptionIpNetworkLists)\n\t\tctx.Export(\"ipGeoModeAllow\", ipGeoAllow.Mode)\n\t\tctx.Export(\"allowExceptionIpNetworkLists\", ipGeoAllow.ExceptionIpNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecIPGeo;\nimport com.pulumi.akamai.AppSecIPGeoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ipGeoBlock = new AppSecIPGeo(\"ipGeoBlock\", AppSecIPGeoArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .mode(\"block\")\n            .geoNetworkLists(\"06038_GEO_TEST\")\n            .ipNetworkLists(\"56921_TEST\")\n            .exceptionIpNetworkLists(\"07126_EXCEPTION_TEST\")\n            .build());\n\n        var ipGeoAllow = new AppSecIPGeo(\"ipGeoAllow\", AppSecIPGeoArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1-090334\")\n            .mode(\"allow\")\n            .exceptionIpNetworkLists(\"07126_EXCEPTION_TEST\")\n            .build());\n\n        ctx.export(\"ipGeoModeBlock\", ipGeoBlock.mode());\n        ctx.export(\"blockGeoNetworkLists\", ipGeoBlock.geoNetworkLists());\n        ctx.export(\"blockIpNetworkLists\", ipGeoBlock.ipNetworkLists());\n        ctx.export(\"blockExceptionIpNetworkLists\", ipGeoBlock.exceptionIpNetworkLists());\n        ctx.export(\"ipGeoModeAllow\", ipGeoAllow.mode());\n        ctx.export(\"allowExceptionIpNetworkLists\", ipGeoAllow.exceptionIpNetworkLists());\n    }\n}\n```\n```yaml\nresources:\n  ipGeoBlock: # USE CASE: User wants to update the IP/Geo firewall mode and update the exception list.\n    type: akamai:AppSecIPGeo\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      mode: block\n      geoNetworkLists:\n        - 06038_GEO_TEST\n      ipNetworkLists:\n        - 56921_TEST\n      exceptionIpNetworkLists:\n        - 07126_EXCEPTION_TEST\n  ipGeoAllow:\n    type: akamai:AppSecIPGeo\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1-090334\n      mode: allow\n      exceptionIpNetworkLists:\n        - 07126_EXCEPTION_TEST\nvariables:\n  configuration: # USE CASE: User wants to update the IP/Geo firewall mode, and update the IP, geographic, and exception lists.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  ipGeoModeBlock: ${ipGeoBlock.mode}\n  blockGeoNetworkLists: ${ipGeoBlock.geoNetworkLists}\n  blockIpNetworkLists: ${ipGeoBlock.ipNetworkLists}\n  blockExceptionIpNetworkLists: ${ipGeoBlock.exceptionIpNetworkLists}\n  ipGeoModeAllow: ${ipGeoAllow.mode}\n  allowExceptionIpNetworkLists: ${ipGeoAllow.exceptionIpNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                },
                "exceptionIpNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                },
                "geoNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "ipNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                }
            },
            "required": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                },
                "exceptionIpNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                },
                "geoNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "ipNetworkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecIPGeo resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo lists being modified.\n"
                    },
                    "exceptionIpNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of network lists that are always allowed to pass through the firewall, regardless of the value of any other setting.\n"
                    },
                    "geoNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of geographic network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                    },
                    "ipNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of IP network lists that, depending on the value of the `mode` argument, will be blocked or allowed through the firewall.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Set to **block** to prevent the specified network lists from being allowed through the firewall: all other entities will be allowed to pass through the firewall. Set to **allow** to allow the specified network lists to pass through the firewall; all other entities will be prevented from passing through the firewall.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo lists being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecIPGeoProtection:AppSecIPGeoProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables IP/Geo protection for the specified configuration and security policy. When enabled, this allows your firewall to allow (or to block) clients based on their IP address or their geographic location.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecIPGeoProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecIPGeoProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecIPGeoProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecIPGeoProtection(ctx, \"protection\", \u0026akamai.AppSecIPGeoProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecIPGeoProtection;\nimport com.pulumi.akamai.AppSecIPGeoProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecIPGeoProtection(\"protection\", AppSecIPGeoProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecIPGeoProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecIPGeoProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMalwarePolicy:AppSecMalwarePolicy": {
            "description": "**Scopes**: Security configuration; malware protection\n\nCreates, modifies, or deletes malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst malwarePolicy = new akamai.AppSecMalwarePolicy(\"malwarePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    malwarePolicy: fs.readFileSync(`${path.module}/malware_policy.json`),\n});\nexport const malwarePolicyId = malwarePolicy.malwarePolicyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmalware_policy = akamai.AppSecMalwarePolicy(\"malwarePolicy\",\n    config_id=configuration.config_id,\n    malware_policy=(lambda path: open(path).read())(f\"{path['module']}/malware_policy.json\"))\npulumi.export(\"malwarePolicyId\", malware_policy.malware_policy_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var malwarePolicy = new Akamai.AppSecMalwarePolicy(\"malwarePolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MalwarePolicy = File.ReadAllText($\"{path.Module}/malware_policy.json\"),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"malwarePolicyId\"] = malwarePolicy.MalwarePolicyId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmalwarePolicy, err := akamai.NewAppSecMalwarePolicy(ctx, \"malwarePolicy\", \u0026akamai.AppSecMalwarePolicyArgs{\n\t\t\tConfigId:      *pulumi.Int(configuration.ConfigId),\n\t\t\tMalwarePolicy: readFileOrPanic(fmt.Sprintf(\"%v/malware_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"malwarePolicyId\", malwarePolicy.MalwarePolicyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMalwarePolicy;\nimport com.pulumi.akamai.AppSecMalwarePolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var malwarePolicy = new AppSecMalwarePolicy(\"malwarePolicy\", AppSecMalwarePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .malwarePolicy(Files.readString(Paths.get(String.format(\"%s/malware_policy.json\", path.module()))))\n            .build());\n\n        ctx.export(\"malwarePolicyId\", malwarePolicy.malwarePolicyId());\n    }\n}\n```\n```yaml\nresources:\n  malwarePolicy:\n    type: akamai:AppSecMalwarePolicy\n    properties:\n      configId: ${configuration.configId}\n      malwarePolicy:\n        fn::readFile: ${path.module}/malware_policy.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  malwarePolicyId: ${malwarePolicy.malwarePolicyId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following option can be used to determine the information returned, and how that returned information is formatted:\n\n- `malware_policy_id`. Unique identifier of the modified or newly-created malware policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy being modified.\n"
                },
                "malwarePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.\n"
                },
                "malwarePolicyId": {
                    "type": "integer",
                    "description": "Unique identifier of the malware policy\n"
                }
            },
            "required": [
                "configId",
                "malwarePolicy",
                "malwarePolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy being modified.\n"
                },
                "malwarePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "malwarePolicy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMalwarePolicy resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware policy being modified.\n"
                    },
                    "malwarePolicy": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.\n"
                    },
                    "malwarePolicyId": {
                        "type": "integer",
                        "description": "Unique identifier of the malware policy\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMalwarePolicyAction:AppSecMalwarePolicyAction": {
            "description": "**Scopes**: Malware protection\n\nCreates, modifies, or deletes the actions associated with a malware policy.\nBy default, malware policies take no action when triggered.\nNote that you must set separate actions for requests that are scanned according to the specified malware policy and those that are unscanned.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecMalwarePolicy = new akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    malwarePolicy: fs.readFileSync(`${path.module}/malware_policy.json`),\n});\nconst appsecMalwarePolicyAction = new akamai.AppSecMalwarePolicyAction(\"appsecMalwarePolicyAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    malwarePolicyId: appsecMalwarePolicy.malwarePolicyId,\n    action: \"deny\",\n    unscannedAction: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_malware_policy = akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\",\n    config_id=configuration.config_id,\n    malware_policy=(lambda path: open(path).read())(f\"{path['module']}/malware_policy.json\"))\nappsec_malware_policy_action = akamai.AppSecMalwarePolicyAction(\"appsecMalwarePolicyAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    malware_policy_id=appsec_malware_policy.malware_policy_id,\n    action=\"deny\",\n    unscanned_action=\"deny\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecMalwarePolicy = new Akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MalwarePolicy = File.ReadAllText($\"{path.Module}/malware_policy.json\"),\n    });\n\n    var appsecMalwarePolicyAction = new Akamai.AppSecMalwarePolicyAction(\"appsecMalwarePolicyAction\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        MalwarePolicyId = appsecMalwarePolicy.MalwarePolicyId,\n        Action = \"deny\",\n        UnscannedAction = \"deny\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappsecMalwarePolicy, err := akamai.NewAppSecMalwarePolicy(ctx, \"appsecMalwarePolicy\", \u0026akamai.AppSecMalwarePolicyArgs{\n\t\t\tConfigId:      *pulumi.Int(configuration.ConfigId),\n\t\t\tMalwarePolicy: readFileOrPanic(fmt.Sprintf(\"%v/malware_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMalwarePolicyAction(ctx, \"appsecMalwarePolicyAction\", \u0026akamai.AppSecMalwarePolicyActionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tMalwarePolicyId:  appsecMalwarePolicy.MalwarePolicyId,\n\t\t\tAction:           pulumi.String(\"deny\"),\n\t\t\tUnscannedAction:  pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMalwarePolicy;\nimport com.pulumi.akamai.AppSecMalwarePolicyArgs;\nimport com.pulumi.akamai.AppSecMalwarePolicyAction;\nimport com.pulumi.akamai.AppSecMalwarePolicyActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecMalwarePolicy = new AppSecMalwarePolicy(\"appsecMalwarePolicy\", AppSecMalwarePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .malwarePolicy(Files.readString(Paths.get(String.format(\"%s/malware_policy.json\", path.module()))))\n            .build());\n\n        var appsecMalwarePolicyAction = new AppSecMalwarePolicyAction(\"appsecMalwarePolicyAction\", AppSecMalwarePolicyActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .malwarePolicyId(appsecMalwarePolicy.malwarePolicyId())\n            .action(\"deny\")\n            .unscannedAction(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecMalwarePolicy:\n    type: akamai:AppSecMalwarePolicy\n    properties:\n      configId: ${configuration.configId}\n      malwarePolicy:\n        fn::readFile: ${path.module}/malware_policy.json\n  appsecMalwarePolicyAction:\n    type: akamai:AppSecMalwarePolicyAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      malwarePolicyId: ${appsecMalwarePolicy.malwarePolicyId}\n      action: deny\n      unscannedAction: deny\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": ". Action to be taken for requests scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                },
                "malwarePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the malware policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                },
                "unscannedAction": {
                    "type": "string",
                    "description": ". Action to be taken for requests not scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                }
            },
            "required": [
                "action",
                "configId",
                "malwarePolicyId",
                "securityPolicyId",
                "unscannedAction"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": ". Action to be taken for requests scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                },
                "malwarePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the malware policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                },
                "unscannedAction": {
                    "type": "string",
                    "description": ". Action to be taken for requests not scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                }
            },
            "requiredInputs": [
                "action",
                "configId",
                "malwarePolicyId",
                "securityPolicyId",
                "unscannedAction"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMalwarePolicyAction resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": ". Action to be taken for requests scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                    },
                    "malwarePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the malware policy whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                    },
                    "unscannedAction": {
                        "type": "string",
                        "description": ". Action to be taken for requests not scanned according to the given malware policy. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMalwarePolicyActions:AppSecMalwarePolicyActions": {
            "description": "**Scopes**: Malware protection\n\nCreates, modifies, or deletes the actions associated with one or more policies within a given security policy.\nBy default, malware policies take no action when triggered.\nNote that you must set separate actions for requests that are scanned according to the specified malware policy and those that are unscanned.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecMalwarePolicy = new akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    malwarePolicy: fs.readFileSync(`${path.module}/malware_policy.json`),\n});\nconst appsecMalwarePolicyActions = new akamai.AppSecMalwarePolicyActions(\"appsecMalwarePolicyActions\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    malwarePolicyActions: fs.readFileSync(`${path.module}/malware_policy_actions.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_malware_policy = akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\",\n    config_id=configuration.config_id,\n    malware_policy=(lambda path: open(path).read())(f\"{path['module']}/malware_policy.json\"))\nappsec_malware_policy_actions = akamai.AppSecMalwarePolicyActions(\"appsecMalwarePolicyActions\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    malware_policy_actions=(lambda path: open(path).read())(f\"{path['module']}/malware_policy_actions.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecMalwarePolicy = new Akamai.AppSecMalwarePolicy(\"appsecMalwarePolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MalwarePolicy = File.ReadAllText($\"{path.Module}/malware_policy.json\"),\n    });\n\n    var appsecMalwarePolicyActions = new Akamai.AppSecMalwarePolicyActions(\"appsecMalwarePolicyActions\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        MalwarePolicyActions = File.ReadAllText($\"{path.Module}/malware_policy_actions.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMalwarePolicy(ctx, \"appsecMalwarePolicy\", \u0026akamai.AppSecMalwarePolicyArgs{\n\t\t\tConfigId:      *pulumi.Int(configuration.ConfigId),\n\t\t\tMalwarePolicy: readFileOrPanic(fmt.Sprintf(\"%v/malware_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMalwarePolicyActions(ctx, \"appsecMalwarePolicyActions\", \u0026akamai.AppSecMalwarePolicyActionsArgs{\n\t\t\tConfigId:             *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:     pulumi.String(\"gms1_134637\"),\n\t\t\tMalwarePolicyActions: readFileOrPanic(fmt.Sprintf(\"%v/malware_policy_actions.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMalwarePolicy;\nimport com.pulumi.akamai.AppSecMalwarePolicyArgs;\nimport com.pulumi.akamai.AppSecMalwarePolicyActions;\nimport com.pulumi.akamai.AppSecMalwarePolicyActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecMalwarePolicy = new AppSecMalwarePolicy(\"appsecMalwarePolicy\", AppSecMalwarePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .malwarePolicy(Files.readString(Paths.get(String.format(\"%s/malware_policy.json\", path.module()))))\n            .build());\n\n        var appsecMalwarePolicyActions = new AppSecMalwarePolicyActions(\"appsecMalwarePolicyActions\", AppSecMalwarePolicyActionsArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .malwarePolicyActions(Files.readString(Paths.get(String.format(\"%s/malware_policy_actions.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecMalwarePolicy:\n    type: akamai:AppSecMalwarePolicy\n    properties:\n      configId: ${configuration.configId}\n      malwarePolicy:\n        fn::readFile: ${path.module}/malware_policy.json\n  appsecMalwarePolicyActions:\n    type: akamai:AppSecMalwarePolicyActions\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      malwarePolicyActions:\n        fn::readFile: ${path.module}/malware_policy_actions.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                },
                "malwarePolicyActions": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                }
            },
            "required": [
                "configId",
                "malwarePolicyActions",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                },
                "malwarePolicyActions": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "malwarePolicyActions",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMalwarePolicyActions resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware policy action being modified.\n"
                    },
                    "malwarePolicyActions": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the malware policy whose action is being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMalwareProtection:AppSecMalwareProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables malware protection for a security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecMalwareProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecMalwareProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecMalwareProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMalwareProtection(ctx, \"protection\", \u0026akamai.AppSecMalwareProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMalwareProtection;\nimport com.pulumi.akamai.AppSecMalwareProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecMalwareProtection(\"protection\", AppSecMalwareProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecMalwareProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following option can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings for the security policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable malware protection; set to **false** to disable malware protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the malware protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable malware protection; set to **false** to disable malware protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the malware protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMalwareProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable malware protection; set to **false** to disable malware protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the malware protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMatchTarget:AppSecMatchTarget": {
            "description": "**Scopes**: Security configuration\n\nCreates a match target associated with a security configuration. Match targets determine which security policy should apply to an API, hostname or path.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets](https://techdocs.akamai.com/application-security/reference/post-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTarget = new akamai.AppSecMatchTarget(\"matchTarget\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    matchTarget: fs.readFileSync(`${path.module}/match_targets.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_target = akamai.AppSecMatchTarget(\"matchTarget\",\n    config_id=configuration.config_id,\n    match_target=(lambda path: open(path).read())(f\"{path['module']}/match_targets.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var matchTarget = new Akamai.AppSecMatchTarget(\"matchTarget\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MatchTarget = File.ReadAllText($\"{path.Module}/match_targets.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMatchTarget(ctx, \"matchTarget\", \u0026akamai.AppSecMatchTargetArgs{\n\t\t\tConfigId:    *pulumi.Int(configuration.ConfigId),\n\t\t\tMatchTarget: readFileOrPanic(fmt.Sprintf(\"%v/match_targets.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMatchTarget;\nimport com.pulumi.akamai.AppSecMatchTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var matchTarget = new AppSecMatchTarget(\"matchTarget\", AppSecMatchTargetArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTarget(Files.readString(Paths.get(String.format(\"%s/match_targets.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  matchTarget:\n    type: akamai:AppSecMatchTarget\n    properties:\n      configId: ${configuration.configId}\n      matchTarget:\n        fn::readFile: ${path.module}/match_targets.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nIn addition to the arguments above, the following attribute is exported:\n\n- `match_target_id`. ID of the match target.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                },
                "matchTarget": {
                    "type": "string",
                    "description": ". Path to a JSON file containing one or more match target definitions.\n"
                },
                "matchTargetId": {
                    "type": "integer",
                    "description": "Unique identifier of the match target\n"
                }
            },
            "required": [
                "configId",
                "matchTarget",
                "matchTargetId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                },
                "matchTarget": {
                    "type": "string",
                    "description": ". Path to a JSON file containing one or more match target definitions.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "matchTarget"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMatchTarget resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match target being modified.\n"
                    },
                    "matchTarget": {
                        "type": "string",
                        "description": ". Path to a JSON file containing one or more match target definitions.\n"
                    },
                    "matchTargetId": {
                        "type": "integer",
                        "description": "Unique identifier of the match target\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecMatchTargetSequence:AppSecMatchTargetSequence": {
            "description": "**Scopes**: Security configuration\n\nSpecifies the order in which match targets are applied within a security configuration. As a general rule, you should process broader and more-general match targets first, gradually working your way down to more granular and highly-specific targets.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-match-targets-sequence)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargetSequence = new akamai.AppSecMatchTargetSequence(\"matchTargetSequence\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    matchTargetSequence: fs.readFileSync(`${path.module}/match_targets_sequence.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_target_sequence = akamai.AppSecMatchTargetSequence(\"matchTargetSequence\",\n    config_id=configuration.config_id,\n    match_target_sequence=(lambda path: open(path).read())(f\"{path['module']}/match_targets_sequence.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var matchTargetSequence = new Akamai.AppSecMatchTargetSequence(\"matchTargetSequence\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MatchTargetSequence = File.ReadAllText($\"{path.Module}/match_targets_sequence.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecMatchTargetSequence(ctx, \"matchTargetSequence\", \u0026akamai.AppSecMatchTargetSequenceArgs{\n\t\t\tConfigId:            *pulumi.Int(configuration.ConfigId),\n\t\t\tMatchTargetSequence: readFileOrPanic(fmt.Sprintf(\"%v/match_targets_sequence.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecMatchTargetSequence;\nimport com.pulumi.akamai.AppSecMatchTargetSequenceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var matchTargetSequence = new AppSecMatchTargetSequence(\"matchTargetSequence\", AppSecMatchTargetSequenceArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTargetSequence(Files.readString(Paths.get(String.format(\"%s/match_targets_sequence.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  matchTargetSequence:\n    type: akamai:AppSecMatchTargetSequence\n    properties:\n      configId: ${configuration.configId}\n      matchTargetSequence:\n        fn::readFile: ${path.module}/match_targets_sequence.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                },
                "matchTargetSequence": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://techdocs.akamai.com/application-security/reference/put-match-targets-sequence) section of the Application Security API documentation.\n"
                }
            },
            "required": [
                "configId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                },
                "matchTargetSequence": {
                    "type": "string",
                    "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://techdocs.akamai.com/application-security/reference/put-match-targets-sequence) section of the Application Security API documentation.\n"
                }
            },
            "requiredInputs": [
                "configId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecMatchTargetSequence resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match target sequence being modified.\n"
                    },
                    "matchTargetSequence": {
                        "type": "string",
                        "description": ". Path to a JSON file containing the processing sequence for all the match targets defined for the security configuration. You can find a sample match target sequence JSON file in the [Modify match target order](https://techdocs.akamai.com/application-security/reference/put-match-targets-sequence) section of the Application Security API documentation.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecPenaltyBox:AppSecPenaltyBox": {
            "description": "**Scopes**: Security policy\n\nModifies the penalty box settings for a security policy.\nWhen the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-policy-penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst penaltyBox = new akamai.AppSecPenaltyBox(\"penaltyBox\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    penaltyBoxProtection: true,\n    penaltyBoxAction: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npenalty_box = akamai.AppSecPenaltyBox(\"penaltyBox\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    penalty_box_protection=True,\n    penalty_box_action=\"deny\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var penaltyBox = new Akamai.AppSecPenaltyBox(\"penaltyBox\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        PenaltyBoxProtection = true,\n        PenaltyBoxAction = \"deny\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecPenaltyBox(ctx, \"penaltyBox\", \u0026akamai.AppSecPenaltyBoxArgs{\n\t\t\tConfigId:             *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:     pulumi.String(\"gms1_134637\"),\n\t\t\tPenaltyBoxProtection: pulumi.Bool(true),\n\t\t\tPenaltyBoxAction:     pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecPenaltyBox;\nimport com.pulumi.akamai.AppSecPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var penaltyBox = new AppSecPenaltyBox(\"penaltyBox\", AppSecPenaltyBoxArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .penaltyBoxProtection(true)\n            .penaltyBoxAction(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  penaltyBox:\n    type: akamai:AppSecPenaltyBox\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      penaltyBoxProtection: true\n      penaltyBoxAction: deny\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                },
                "penaltyBoxAction": {
                    "type": "string",
                    "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "penaltyBoxProtection": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "penaltyBoxAction",
                "penaltyBoxProtection",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecPenaltyBox resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the penalty box settings being modified.\n"
                    },
                    "penaltyBoxAction": {
                        "type": "string",
                        "description": ". Action taken any time penalty box protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "penaltyBoxProtection": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the penalty box settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRatePolicy:AppSecRatePolicy": {
            "description": "**Scopes**: Security configuration; rate policy\n\nCreates, modifies, or deletes rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive.\nIn turn, this helps you prevent your website from being overwhelmed by a dramatic and unexpected surge in traffic.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/post-rate-policies)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicy = new akamai.AppSecRatePolicy(\"ratePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    ratePolicy: fs.readFileSync(`${path.module}/rate_policy.json`),\n});\nexport const ratePolicyId = ratePolicy.ratePolicyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policy = akamai.AppSecRatePolicy(\"ratePolicy\",\n    config_id=configuration.config_id,\n    rate_policy=(lambda path: open(path).read())(f\"{path['module']}/rate_policy.json\"))\npulumi.export(\"ratePolicyId\", rate_policy.rate_policy_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ratePolicy = new Akamai.AppSecRatePolicy(\"ratePolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        RatePolicy = File.ReadAllText($\"{path.Module}/rate_policy.json\"),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ratePolicyId\"] = ratePolicy.RatePolicyId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicy, err := akamai.NewAppSecRatePolicy(ctx, \"ratePolicy\", \u0026akamai.AppSecRatePolicyArgs{\n\t\t\tConfigId:   *pulumi.Int(configuration.ConfigId),\n\t\t\tRatePolicy: readFileOrPanic(fmt.Sprintf(\"%v/rate_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyId\", ratePolicy.RatePolicyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRatePolicy;\nimport com.pulumi.akamai.AppSecRatePolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ratePolicy = new AppSecRatePolicy(\"ratePolicy\", AppSecRatePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicy(Files.readString(Paths.get(String.format(\"%s/rate_policy.json\", path.module()))))\n            .build());\n\n        ctx.export(\"ratePolicyId\", ratePolicy.ratePolicyId());\n    }\n}\n```\n```yaml\nresources:\n  ratePolicy:\n    type: akamai:AppSecRatePolicy\n    properties:\n      configId: ${configuration.configId}\n      ratePolicy:\n        fn::readFile: ${path.module}/rate_policy.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  ratePolicyId: ${ratePolicy.ratePolicyId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `rate_policy_id`. ID of the modified or newly-created rate policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                },
                "ratePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a rate policy definition.\n"
                },
                "ratePolicyId": {
                    "type": "integer",
                    "description": "Unique identifier of the rate policy\n"
                }
            },
            "required": [
                "configId",
                "ratePolicy",
                "ratePolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                },
                "ratePolicy": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a rate policy definition.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ratePolicy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRatePolicy resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policy being modified.\n"
                    },
                    "ratePolicy": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a rate policy definition.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": "Unique identifier of the rate policy\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRatePolicyAction:AppSecRatePolicyAction": {
            "description": "**Scopes**: Rate policy\n\nCreates, modifies, or deletes the actions associated with a rate policy.\nBy default, rate policies take no action when triggered.\nNote that you must set separate actions for requests originating from an IPv4 IP address and for requests originating from an IPv6 address.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies/{ratePolicyId}](https://techdocs.akamai.com/application-security/reference/put-rate-policy-action)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecRatePolicy = new akamai.AppSecRatePolicy(\"appsecRatePolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    ratePolicy: fs.readFileSync(`${path.module}/rate_policy.json`),\n});\nconst appsecRatePolicyAction = new akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ratePolicyId: appsecRatePolicy.ratePolicyId,\n    ipv4Action: \"deny\",\n    ipv6Action: \"deny\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_rate_policy = akamai.AppSecRatePolicy(\"appsecRatePolicy\",\n    config_id=configuration.config_id,\n    rate_policy=(lambda path: open(path).read())(f\"{path['module']}/rate_policy.json\"))\nappsec_rate_policy_action = akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rate_policy_id=appsec_rate_policy.rate_policy_id,\n    ipv4_action=\"deny\",\n    ipv6_action=\"deny\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecRatePolicy = new Akamai.AppSecRatePolicy(\"appsecRatePolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        RatePolicy = File.ReadAllText($\"{path.Module}/rate_policy.json\"),\n    });\n\n    var appsecRatePolicyAction = new Akamai.AppSecRatePolicyAction(\"appsecRatePolicyAction\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        RatePolicyId = appsecRatePolicy.RatePolicyId,\n        Ipv4Action = \"deny\",\n        Ipv6Action = \"deny\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappsecRatePolicy, err := akamai.NewAppSecRatePolicy(ctx, \"appsecRatePolicy\", \u0026akamai.AppSecRatePolicyArgs{\n\t\t\tConfigId:   *pulumi.Int(configuration.ConfigId),\n\t\t\tRatePolicy: readFileOrPanic(fmt.Sprintf(\"%v/rate_policy.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRatePolicyAction(ctx, \"appsecRatePolicyAction\", \u0026akamai.AppSecRatePolicyActionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tRatePolicyId:     appsecRatePolicy.RatePolicyId,\n\t\t\tIpv4Action:       pulumi.String(\"deny\"),\n\t\t\tIpv6Action:       pulumi.String(\"deny\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRatePolicy;\nimport com.pulumi.akamai.AppSecRatePolicyArgs;\nimport com.pulumi.akamai.AppSecRatePolicyAction;\nimport com.pulumi.akamai.AppSecRatePolicyActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecRatePolicy = new AppSecRatePolicy(\"appsecRatePolicy\", AppSecRatePolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicy(Files.readString(Paths.get(String.format(\"%s/rate_policy.json\", path.module()))))\n            .build());\n\n        var appsecRatePolicyAction = new AppSecRatePolicyAction(\"appsecRatePolicyAction\", AppSecRatePolicyActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ratePolicyId(appsecRatePolicy.ratePolicyId())\n            .ipv4Action(\"deny\")\n            .ipv6Action(\"deny\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecRatePolicy:\n    type: akamai:AppSecRatePolicy\n    properties:\n      configId: ${configuration.configId}\n      ratePolicy:\n        fn::readFile: ${path.module}/rate_policy.json\n  appsecRatePolicyAction:\n    type: akamai:AppSecRatePolicyAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      ratePolicyId: ${appsecRatePolicy.ratePolicyId}\n      ipv4Action: deny\n      ipv6Action: deny\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                },
                "ipv4Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ipv6Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                },
                "ratePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                }
            },
            "required": [
                "configId",
                "ipv4Action",
                "ipv6Action",
                "ratePolicyId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                },
                "ipv4Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "ipv6Action": {
                    "type": "string",
                    "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                },
                "ratePolicyId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ipv4Action",
                "ipv6Action",
                "ratePolicyId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRatePolicyAction resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policy action being modified.\n"
                    },
                    "ipv4Action": {
                        "type": "string",
                        "description": ". Rate policy action for requests coming from an IPv4 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "ipv6Action": {
                        "type": "string",
                        "description": ". Rate policy action for requests coming from an IPv6 IP address. Allowed actions are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom{custom_deny_id}**. Take the action specified by the custom deny.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate policy whose action is being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRateProtection:AppSecRateProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables rate protection for a security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecRateProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecRateProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecRateProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRateProtection(ctx, \"protection\", \u0026akamai.AppSecRateProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRateProtection;\nimport com.pulumi.akamai.AppSecRateProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecRateProtection(\"protection\", AppSecRateProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecRateProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRateProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable rate protection; set to **false** to disable rate protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfile:AppSecReputationProfile": {
            "description": "**Scopes**: Security policy\n\nCreates or modifies a reputation profile.\nReputation profiles grade the security risk of an IP address based on previous activities associated with that address.\nDepending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/put-reputation-profile)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfile = new akamai.AppSecReputationProfile(\"reputationProfile\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    reputationProfile: fs.readFileSync(`${path.module}/reputation_profile.json`),\n});\nexport const reputationProfileId = reputationProfile.reputationProfileId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profile = akamai.AppSecReputationProfile(\"reputationProfile\",\n    config_id=configuration.config_id,\n    reputation_profile=(lambda path: open(path).read())(f\"{path['module']}/reputation_profile.json\"))\npulumi.export(\"reputationProfileId\", reputation_profile.reputation_profile_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var reputationProfile = new Akamai.AppSecReputationProfile(\"reputationProfile\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        ReputationProfile = File.ReadAllText($\"{path.Module}/reputation_profile.json\"),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"reputationProfileId\"] = reputationProfile.ReputationProfileId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfile, err := akamai.NewAppSecReputationProfile(ctx, \"reputationProfile\", \u0026akamai.AppSecReputationProfileArgs{\n\t\t\tConfigId:          *pulumi.Int(configuration.ConfigId),\n\t\t\tReputationProfile: readFileOrPanic(fmt.Sprintf(\"%v/reputation_profile.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileId\", reputationProfile.ReputationProfileId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProfile;\nimport com.pulumi.akamai.AppSecReputationProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var reputationProfile = new AppSecReputationProfile(\"reputationProfile\", AppSecReputationProfileArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .reputationProfile(Files.readString(Paths.get(String.format(\"%s/reputation_profile.json\", path.module()))))\n            .build());\n\n        ctx.export(\"reputationProfileId\", reputationProfile.reputationProfileId());\n    }\n}\n```\n```yaml\nresources:\n  reputationProfile:\n    type: akamai:AppSecReputationProfile\n    properties:\n      configId: ${configuration.configId}\n      reputationProfile:\n        fn::readFile: ${path.module}/reputation_profile.json\nvariables:\n  configuration: # USE CASE: User wants to create a reputation profile for a given security configuration by using a JSON-formatted definition.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  reputationProfileId: ${reputationProfile.reputationProfileId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `reputation_profile_id`. ID of the newly-created or newly-modified reputation profile.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                },
                "reputationProfile": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a definition of the reputation profile.\n"
                },
                "reputationProfileId": {
                    "type": "integer",
                    "description": "Unique identifier of the reputation profile\n"
                }
            },
            "required": [
                "configId",
                "reputationProfile",
                "reputationProfileId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                },
                "reputationProfile": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a definition of the reputation profile.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "reputationProfile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfile resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile being modified.\n"
                    },
                    "reputationProfile": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a definition of the reputation profile.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": "Unique identifier of the reputation profile\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfileAction:AppSecReputationProfileAction": {
            "description": "**Scopes**: Reputation profile\n\nModifies the action taken when a reputation profile is triggered.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles/{reputationProfileId}](https://techdocs.akamai.com/application-security/reference/put-reputation-profile-action)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecReputationProfileAction = new akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    reputationProfileId: 130713,\n    action: \"alert\",\n});\nexport const reputationProfileId = appsecReputationProfileAction.reputationProfileId;\nexport const reputationProfileAction = appsecReputationProfileAction.action;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsec_reputation_profile_action = akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    reputation_profile_id=130713,\n    action=\"alert\")\npulumi.export(\"reputationProfileId\", appsec_reputation_profile_action.reputation_profile_id)\npulumi.export(\"reputationProfileAction\", appsec_reputation_profile_action.action)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecReputationProfileAction = new Akamai.AppSecReputationProfileAction(\"appsecReputationProfileAction\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ReputationProfileId = 130713,\n        Action = \"alert\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"reputationProfileId\"] = appsecReputationProfileAction.ReputationProfileId,\n        [\"reputationProfileAction\"] = appsecReputationProfileAction.Action,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappsecReputationProfileAction, err := akamai.NewAppSecReputationProfileAction(ctx, \"appsecReputationProfileAction\", \u0026akamai.AppSecReputationProfileActionArgs{\n\t\t\tConfigId:            *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:    pulumi.String(\"gms1_134637\"),\n\t\t\tReputationProfileId: pulumi.Int(130713),\n\t\t\tAction:              pulumi.String(\"alert\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileId\", appsecReputationProfileAction.ReputationProfileId)\n\t\tctx.Export(\"reputationProfileAction\", appsecReputationProfileAction.Action)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProfileAction;\nimport com.pulumi.akamai.AppSecReputationProfileActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecReputationProfileAction = new AppSecReputationProfileAction(\"appsecReputationProfileAction\", AppSecReputationProfileActionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .reputationProfileId(130713)\n            .action(\"alert\")\n            .build());\n\n        ctx.export(\"reputationProfileId\", appsecReputationProfileAction.reputationProfileId());\n        ctx.export(\"reputationProfileAction\", appsecReputationProfileAction.action());\n    }\n}\n```\n```yaml\nresources:\n  appsecReputationProfileAction:\n    type: akamai:AppSecReputationProfileAction\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      reputationProfileId: 130713\n      action: alert\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  reputationProfileId: ${appsecReputationProfileAction.reputationProfileId}\n  reputationProfileAction: ${appsecReputationProfileAction.action}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "action": {
                    "type": "string",
                    "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                },
                "reputationProfileId": {
                    "type": "integer",
                    "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                }
            },
            "required": [
                "action",
                "configId",
                "reputationProfileId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                },
                "reputationProfileId": {
                    "type": "integer",
                    "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                }
            },
            "requiredInputs": [
                "action",
                "configId",
                "reputationProfileId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfileAction resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": ". Action taken any time the reputation profile is triggered. Allows values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile action being modified.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile whose action is being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile action being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProfileAnalysis:AppSecReputationProfileAnalysis": {
            "description": "**Scopes**: Security policy\n\nModifies the reputation analysis settings for a security policy. These settings include the following:\n\n- The `forward_to_http_header` parameter, which indicates whether client reputation details are added to requests forwarded to origin in an HTTP header.\n- The `forward_shared_ip_to_http_header_siem` parameter, which specifies whether a value is added indicating that shared IPs addresses are included in HTTP headers and in SIEM integration events.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/put-reputation-analysis)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .forwardToHttpHeader(true)\n            .build());\n\n        ctx.export(\"reputationAnalysisText\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.outputText()));\n        ctx.export(\"reputationAnalysisJson\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationAnalysis:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfileAnalysis\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        forwardToHttpHeader: true\noutputs:\n  reputationAnalysisText: ${reputationAnalysis.outputText}\n  reputationAnalysisJson: ${reputationAnalysis.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                },
                "forwardSharedIpToHttpHeaderSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                },
                "forwardToHttpHeader": {
                    "type": "boolean",
                    "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "forwardSharedIpToHttpHeaderSiem",
                "forwardToHttpHeader",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                },
                "forwardSharedIpToHttpHeaderSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                },
                "forwardToHttpHeader": {
                    "type": "boolean",
                    "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "forwardSharedIpToHttpHeaderSiem",
                "forwardToHttpHeader",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProfileAnalysis resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings being modified.\n"
                    },
                    "forwardSharedIpToHttpHeaderSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to add a value indicating that shared IPs are included in HTTP header and SIEM integration; set to **false** to omit this value.\n"
                    },
                    "forwardToHttpHeader": {
                        "type": "boolean",
                        "description": ". Set to **true** to add client reputation details to requests forwarded to the origin server in an HTTP header; set to `false` to leave reputation details out of these requests.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecReputationProtection:AppSecReputationProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables reputation protection for a security configuration and security policy.\nReputation profiles grade the security risk of an IP address based on previous activities associated with that address.\nDepending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecReputationProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecReputationProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecReputationProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecReputationProtection(ctx, \"protection\", \u0026akamai.AppSecReputationProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecReputationProtection;\nimport com.pulumi.akamai.AppSecReputationProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecReputationProtection(\"protection\", AppSecReputationProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecReputationProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecReputationProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable reputation protection; set to **false** to disable reputation protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRule:AppSecRule": {
            "description": "**Scopes**: Rule\n\nModifies a Kona Rule Set rule's action, conditions, and exceptions.\n\n**Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-rule-condition-exception)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst rule = new akamai.AppSecRule(\"rule\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n    ruleAction: \"deny\",\n    conditionException: fs.readFileSync(`${path.module}/condition_exception.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrule = akamai.AppSecRule(\"rule\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316,\n    rule_action=\"deny\",\n    condition_exception=(lambda path: open(path).read())(f\"{path['module']}/condition_exception.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var rule = new Akamai.AppSecRule(\"rule\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        RuleId = 60029316,\n        RuleAction = \"deny\",\n        ConditionException = File.ReadAllText($\"{path.Module}/condition_exception.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecRule(ctx, \"rule\", \u0026akamai.AppSecRuleArgs{\n\t\t\tConfigId:           *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:   pulumi.String(\"gms1_134637\"),\n\t\t\tRuleId:             pulumi.Int(60029316),\n\t\t\tRuleAction:         pulumi.String(\"deny\"),\n\t\t\tConditionException: readFileOrPanic(fmt.Sprintf(\"%v/condition_exception.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRule;\nimport com.pulumi.akamai.AppSecRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var rule = new AppSecRule(\"rule\", AppSecRuleArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(60029316)\n            .ruleAction(\"deny\")\n            .conditionException(Files.readString(Paths.get(String.format(\"%s/condition_exception.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule:\n    type: akamai:AppSecRule\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      ruleId: 6.0029316e+07\n      ruleAction: deny\n      conditionException:\n        fn::readFile: ${path.module}/condition_exception.json\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                }
            },
            "required": [
                "configId",
                "ruleAction",
                "ruleId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "conditionException": {
                    "type": "string",
                    "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.\n"
                },
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                },
                "ruleAction": {
                    "type": "string",
                    "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                },
                "ruleId": {
                    "type": "integer",
                    "description": ". Unique identifier of the rule being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "ruleId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRule resources.\n",
                "properties": {
                    "conditionException": {
                        "type": "string",
                        "description": ". Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.\n"
                    },
                    "ruleAction": {
                        "type": "string",
                        "description": "Allowed values are:\n- **alert**. Record the event.\n- **deny**. Block the request.\n- **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.\n- **none**. Take no action. or `none` to take no action.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rule being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Set rule being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecRuleUpgrade:AppSecRuleUpgrade": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ruleUpgrade = new akamai.AppSecRuleUpgrade(\"ruleUpgrade\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n});\nexport const ruleUpgradeCurrentRuleset = ruleUpgrade.currentRuleset;\nexport const ruleUpgradeMode = ruleUpgrade.mode;\nexport const ruleUpgradeEvalStatus = ruleUpgrade.evalStatus;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrule_upgrade = akamai.AppSecRuleUpgrade(\"ruleUpgrade\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ruleUpgradeCurrentRuleset\", rule_upgrade.current_ruleset)\npulumi.export(\"ruleUpgradeMode\", rule_upgrade.mode)\npulumi.export(\"ruleUpgradeEvalStatus\", rule_upgrade.eval_status)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ruleUpgrade = new Akamai.AppSecRuleUpgrade(\"ruleUpgrade\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ruleUpgradeCurrentRuleset\"] = ruleUpgrade.CurrentRuleset,\n        [\"ruleUpgradeMode\"] = ruleUpgrade.Mode,\n        [\"ruleUpgradeEvalStatus\"] = ruleUpgrade.EvalStatus,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\truleUpgrade, err := akamai.NewAppSecRuleUpgrade(ctx, \"ruleUpgrade\", \u0026akamai.AppSecRuleUpgradeArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ruleUpgradeCurrentRuleset\", ruleUpgrade.CurrentRuleset)\n\t\tctx.Export(\"ruleUpgradeMode\", ruleUpgrade.Mode)\n\t\tctx.Export(\"ruleUpgradeEvalStatus\", ruleUpgrade.EvalStatus)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecRuleUpgrade;\nimport com.pulumi.akamai.AppSecRuleUpgradeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var ruleUpgrade = new AppSecRuleUpgrade(\"ruleUpgrade\", AppSecRuleUpgradeArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ruleUpgradeCurrentRuleset\", ruleUpgrade.currentRuleset());\n        ctx.export(\"ruleUpgradeMode\", ruleUpgrade.mode());\n        ctx.export(\"ruleUpgradeEvalStatus\", ruleUpgrade.evalStatus());\n    }\n}\n```\n```yaml\nresources:\n  ruleUpgrade:\n    type: akamai:AppSecRuleUpgrade\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  ruleUpgradeCurrentRuleset: ${ruleUpgrade.currentRuleset}\n  ruleUpgradeMode: ${ruleUpgrade.mode}\n  ruleUpgradeEvalStatus: ${ruleUpgrade.evalStatus}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `current_ruleset`. Versioning information for your current KRS rule set.\n- `mode`. Specifies the current upgrade mode type. Valid values are:\n  - **KRS**. Rulesets must be manually upgraded.\n\n  - **AAG**. Rulesets are automatically upgraded by Akamai.\n\n  - **ASE_MANUAL**. Adaptive Security Engine rulesets must be manually upgraded.\n\n  - **ASE_AUTO**. Adaptive Security Engine rulesets are automatically updated by Akamai.\n\n- `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                },
                "currentRuleset": {
                    "type": "string",
                    "description": "Versioning information for the current KRS rule set\n"
                },
                "evalStatus": {
                    "type": "string",
                    "description": "Whether an evaluation is currently in progress\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n"
                },
                "upgradeMode": {
                    "type": "string",
                    "description": ". (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalStatus",
                "mode",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n"
                },
                "upgradeMode": {
                    "type": "string",
                    "description": ". (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecRuleUpgrade resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the ruleset being upgraded.\n"
                    },
                    "currentRuleset": {
                        "type": "string",
                        "description": "Versioning information for the current KRS rule set\n"
                    },
                    "evalStatus": {
                        "type": "string",
                        "description": "Whether an evaluation is currently in progress\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the ruleset being upgraded.\n"
                    },
                    "upgradeMode": {
                        "type": "string",
                        "description": ". (Optional). Modifies the upgrade type for organizations running the ASE beta. Allowed values are:\n- **ASE_AUTO**. Akamai automatically updates your rulesets.\n- **ASE_MANUAL**. Manually updates your rulesets.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSecurityPolicy:AppSecSecurityPolicy": {
            "description": "**Scopes**: Security configuration\n\nCreates a new security policy. The resource enables you to:\n\n- Create a new, “blank” security policy.\n- Create a new policy preconfigured with the default security policy settings.\n- Clone an existing security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies](https://techdocs.akamai.com/application-security/reference/post-policy)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst securityPolicyCreateAppSecSecurityPolicy = new akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    defaultSettings: true,\n    securityPolicyName: \"Documentation Policy\",\n    securityPolicyPrefix: \"gms1\",\n});\nexport const securityPolicyCreate = securityPolicyCreateAppSecSecurityPolicy.securityPolicyId;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsecurity_policy_create_app_sec_security_policy = akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\",\n    config_id=configuration.config_id,\n    default_settings=True,\n    security_policy_name=\"Documentation Policy\",\n    security_policy_prefix=\"gms1\")\npulumi.export(\"securityPolicyCreate\", security_policy_create_app_sec_security_policy.security_policy_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var securityPolicyCreateAppSecSecurityPolicy = new Akamai.AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        DefaultSettings = true,\n        SecurityPolicyName = \"Documentation Policy\",\n        SecurityPolicyPrefix = \"gms1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"securityPolicyCreate\"] = securityPolicyCreateAppSecSecurityPolicy.SecurityPolicyId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecurityPolicyCreateAppSecSecurityPolicy, err := akamai.NewAppSecSecurityPolicy(ctx, \"securityPolicyCreateAppSecSecurityPolicy\", \u0026akamai.AppSecSecurityPolicyArgs{\n\t\t\tConfigId:             *pulumi.Int(configuration.ConfigId),\n\t\t\tDefaultSettings:      pulumi.Bool(true),\n\t\t\tSecurityPolicyName:   pulumi.String(\"Documentation Policy\"),\n\t\t\tSecurityPolicyPrefix: pulumi.String(\"gms1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"securityPolicyCreate\", securityPolicyCreateAppSecSecurityPolicy.SecurityPolicyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSecurityPolicy;\nimport com.pulumi.akamai.AppSecSecurityPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var securityPolicyCreateAppSecSecurityPolicy = new AppSecSecurityPolicy(\"securityPolicyCreateAppSecSecurityPolicy\", AppSecSecurityPolicyArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .defaultSettings(true)\n            .securityPolicyName(\"Documentation Policy\")\n            .securityPolicyPrefix(\"gms1\")\n            .build());\n\n        ctx.export(\"securityPolicyCreate\", securityPolicyCreateAppSecSecurityPolicy.securityPolicyId());\n    }\n}\n```\n```yaml\nresources:\n  securityPolicyCreateAppSecSecurityPolicy:\n    type: akamai:AppSecSecurityPolicy\n    properties:\n      configId: ${configuration.configId}\n      defaultSettings: true\n      securityPolicyName: Documentation Policy\n      securityPolicyPrefix: gms1\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  securityPolicyCreate: ${securityPolicyCreateAppSecSecurityPolicy.securityPolicyId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `security_policy_id`. ID of the newly-created security policy.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                },
                "createFromSecurityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                },
                "defaultSettings": {
                    "type": "boolean",
                    "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": "Unique identifier of the new security policy\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". Name of the new security policy.\n"
                },
                "securityPolicyPrefix": {
                    "type": "string",
                    "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "securityPolicyName",
                "securityPolicyPrefix"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                },
                "createFromSecurityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                },
                "defaultSettings": {
                    "type": "boolean",
                    "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". Name of the new security policy.\n"
                },
                "securityPolicyPrefix": {
                    "type": "string",
                    "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyName",
                "securityPolicyPrefix"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSecurityPolicy resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration to be associated with the new security policy.\n"
                    },
                    "createFromSecurityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the existing security policy that the new policy will be cloned from.\n"
                    },
                    "defaultSettings": {
                        "type": "boolean",
                        "description": ". Set to **true** to assign default setting values to the new policy; set to **false** to create a “blank” security policy. If not included, the new policy will be created using the default settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "Unique identifier of the new security policy\n"
                    },
                    "securityPolicyName": {
                        "type": "string",
                        "description": ". Name of the new security policy.\n"
                    },
                    "securityPolicyPrefix": {
                        "type": "string",
                        "description": ". Four-character alphanumeric string prefix used in creating the security policy ID.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSecurityPolicyRename:AppSecSecurityPolicyRename": {
            "description": "**Scopes**: Security policy\n\nRenames an existing security policy. Note that you can only change the name of the policy: once issued, the security policy ID can't be modified.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}](https://techdocs.akamai.com/application-security/reference/put-policy)\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy being renamed.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". New name to be given to the security policy.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "securityPolicyName"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy being renamed.\n"
                },
                "securityPolicyName": {
                    "type": "string",
                    "description": ". New name to be given to the security policy.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "securityPolicyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSecurityPolicyRename resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policy being renamed.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy being renamed.\n"
                    },
                    "securityPolicyName": {
                        "type": "string",
                        "description": ". New name to be given to the security policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSelectedHostnames:AppSecSelectedHostnames": {
            "description": "**Scopes**: Security configuration\n\nModifies the list of hostnames protected under by a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/put-selected-hostnames-per-config)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecselectedhostnames = new akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    hostnames: [\"example.com\"],\n    mode: \"APPEND\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsecselectedhostnames = akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\",\n    config_id=configuration.config_id,\n    hostnames=[\"example.com\"],\n    mode=\"APPEND\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecselectedhostnames = new Akamai.AppSecSelectedHostnames(\"appsecselectedhostnames\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Hostnames = new[]\n        {\n            \"example.com\",\n        },\n        Mode = \"APPEND\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSelectedHostnames(ctx, \"appsecselectedhostnames\", \u0026akamai.AppSecSelectedHostnamesArgs{\n\t\t\tConfigId: *pulumi.Int(configuration.ConfigId),\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t},\n\t\t\tMode: pulumi.String(\"APPEND\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSelectedHostnames;\nimport com.pulumi.akamai.AppSecSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecselectedhostnames = new AppSecSelectedHostnames(\"appsecselectedhostnames\", AppSecSelectedHostnamesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostnames(\"example.com\")\n            .mode(\"APPEND\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecselectedhostnames:\n    type: akamai:AppSecSelectedHostnames\n    properties:\n      configId: ${configuration.configId}\n      hostnames:\n        - example.com\n      mode: APPEND\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                }
            },
            "required": [
                "configId",
                "hostnames",
                "mode"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "hostnames",
                "mode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSelectedHostnames resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of hostnames to be added or removed from the protected hosts list.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Indicates how the `hostnames` array is to be applied. Allowed values are:\n- **APPEND**. Hosts listed in the `hostnames` array are added to the current list of selected hostnames.\n- **REPLACE**. Hosts listed in the `hostnames`  array overwrite the current list of selected hostnames: the “old” hostnames are replaced by the specified set of hostnames.\n- **REMOVE**, Hosts listed in the `hostnames` array are removed from the current list of select hostnames.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSiemSettings:AppSecSiemSettings": {
            "description": "**Scopes**: Security configuration\n\nModifies SIEM (Security Information and Event Management) integration settings for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/put-siem)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst siemDefinition = akamai.getAppSecSiemDefinitions({\n    siemDefinitionName: \"SIEM Version 01\",\n});\nconst securityPolicies = configuration.then(configuration =\u003e akamai.getAppSecSecurityPolicy({\n    configId: configuration.configId,\n}));\nconst siem = new akamai.AppSecSiemSettings(\"siem\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    enableSiem: true,\n    enableForAllPolicies: false,\n    enableBotmanSiem: true,\n    siemId: siemDefinition.then(siemDefinition =\u003e siemDefinition.id),\n    securityPolicyIds: securityPolicies.then(securityPolicies =\u003e securityPolicies.securityPolicyIdLists),\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsiem_definition = akamai.get_app_sec_siem_definitions(siem_definition_name=\"SIEM Version 01\")\nsecurity_policies = akamai.get_app_sec_security_policy(config_id=configuration.config_id)\nsiem = akamai.AppSecSiemSettings(\"siem\",\n    config_id=configuration.config_id,\n    enable_siem=True,\n    enable_for_all_policies=False,\n    enable_botman_siem=True,\n    siem_id=siem_definition.id,\n    security_policy_ids=security_policies.security_policy_id_lists)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var siemDefinition = Akamai.GetAppSecSiemDefinitions.Invoke(new()\n    {\n        SiemDefinitionName = \"SIEM Version 01\",\n    });\n\n    var securityPolicies = Akamai.GetAppSecSecurityPolicy.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var siem = new Akamai.AppSecSiemSettings(\"siem\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        EnableSiem = true,\n        EnableForAllPolicies = false,\n        EnableBotmanSiem = true,\n        SiemId = siemDefinition.Apply(getAppSecSiemDefinitionsResult =\u003e getAppSecSiemDefinitionsResult.Id),\n        SecurityPolicyIds = securityPolicies.Apply(getAppSecSecurityPolicyResult =\u003e getAppSecSecurityPolicyResult.SecurityPolicyIdLists),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsiemDefinition, err := akamai.GetAppSecSiemDefinitions(ctx, \u0026akamai.GetAppSecSiemDefinitionsArgs{\n\t\t\tSiemDefinitionName: pulumi.StringRef(\"SIEM Version 01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsecurityPolicies, err := akamai.LookupAppSecSecurityPolicy(ctx, \u0026akamai.LookupAppSecSecurityPolicyArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSiemSettings(ctx, \"siem\", \u0026akamai.AppSecSiemSettingsArgs{\n\t\t\tConfigId:             *pulumi.Int(configuration.ConfigId),\n\t\t\tEnableSiem:           pulumi.Bool(true),\n\t\t\tEnableForAllPolicies: pulumi.Bool(false),\n\t\t\tEnableBotmanSiem:     pulumi.Bool(true),\n\t\t\tSiemId:               *pulumi.String(siemDefinition.Id),\n\t\t\tSecurityPolicyIds:    interface{}(securityPolicies.SecurityPolicyIdLists),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSecurityPolicyArgs;\nimport com.pulumi.akamai.AppSecSiemSettings;\nimport com.pulumi.akamai.AppSecSiemSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()\n            .siemDefinitionName(\"SIEM Version 01\")\n            .build());\n\n        final var securityPolicies = AkamaiFunctions.getAppSecSecurityPolicy(GetAppSecSecurityPolicyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        var siem = new AppSecSiemSettings(\"siem\", AppSecSiemSettingsArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .enableSiem(true)\n            .enableForAllPolicies(false)\n            .enableBotmanSiem(true)\n            .siemId(siemDefinition.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.id()))\n            .securityPolicyIds(securityPolicies.applyValue(getAppSecSecurityPolicyResult -\u003e getAppSecSecurityPolicyResult.securityPolicyIdLists()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  siem:\n    type: akamai:AppSecSiemSettings\n    properties:\n      configId: ${configuration.configId}\n      enableSiem: true\n      enableForAllPolicies: false\n      enableBotmanSiem: true\n      siemId: ${siemDefinition.id}\n      securityPolicyIds: ${securityPolicies.securityPolicyIdLists}\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  siemDefinition:\n    fn::invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments:\n        siemDefinitionName: SIEM Version 01\n  securityPolicies:\n    fn::invoke:\n      Function: akamai:getAppSecSecurityPolicy\n      Arguments:\n        configId: ${configuration.configId}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated SIEM integration settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                },
                "enableBotmanSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                },
                "enableForAllPolicies": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                },
                "enableSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                },
                "securityPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                },
                "siemId": {
                    "type": "integer",
                    "description": ". Unique identifier of the SIEM settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enableBotmanSiem",
                "enableForAllPolicies",
                "enableSiem",
                "siemId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                },
                "enableBotmanSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                },
                "enableForAllPolicies": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                },
                "enableSiem": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                },
                "securityPolicyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                },
                "siemId": {
                    "type": "integer",
                    "description": ". Unique identifier of the SIEM settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enableBotmanSiem",
                "enableForAllPolicies",
                "enableSiem",
                "siemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSiemSettings resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the SIEM settings being modified.\n"
                    },
                    "enableBotmanSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to include Bot Manager events in your SIEM events; set to **false** to exclude Bot Manager events from your SIEM events.\n"
                    },
                    "enableForAllPolicies": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable SIEM on all security policies in the security configuration; set to **false** to only enable SIEM on the security policies specified by the `security_policy_ids` argument.\n"
                    },
                    "enableSiem": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable SIEM; set to **false** to disable SIEM.\n"
                    },
                    "securityPolicyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "JSON array of IDs for the security policies where SIEM integration is to be enabled.\n"
                    },
                    "siemId": {
                        "type": "integer",
                        "description": ". Unique identifier of the SIEM settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSlowPost:AppSecSlowPost": {
            "description": "**Scopes**: Security policy\n\nModifies slow POST protection settings for a security configuration and security policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/put-policy-slow-post)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst slowPost = new akamai.AppSecSlowPost(\"slowPost\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    slowRateAction: \"alert\",\n    slowRateThresholdRate: 10,\n    slowRateThresholdPeriod: 30,\n    durationThresholdTimeout: 20,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nslow_post = akamai.AppSecSlowPost(\"slowPost\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    slow_rate_action=\"alert\",\n    slow_rate_threshold_rate=10,\n    slow_rate_threshold_period=30,\n    duration_threshold_timeout=20)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var slowPost = new Akamai.AppSecSlowPost(\"slowPost\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        SlowRateAction = \"alert\",\n        SlowRateThresholdRate = 10,\n        SlowRateThresholdPeriod = 30,\n        DurationThresholdTimeout = 20,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSlowPost(ctx, \"slowPost\", \u0026akamai.AppSecSlowPostArgs{\n\t\t\tConfigId:                 *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId:         pulumi.String(\"gms1_134637\"),\n\t\t\tSlowRateAction:           pulumi.String(\"alert\"),\n\t\t\tSlowRateThresholdRate:    pulumi.Int(10),\n\t\t\tSlowRateThresholdPeriod:  pulumi.Int(30),\n\t\t\tDurationThresholdTimeout: pulumi.Int(20),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSlowPost;\nimport com.pulumi.akamai.AppSecSlowPostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var slowPost = new AppSecSlowPost(\"slowPost\", AppSecSlowPostArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .slowRateAction(\"alert\")\n            .slowRateThresholdRate(10)\n            .slowRateThresholdPeriod(30)\n            .durationThresholdTimeout(20)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  slowPost:\n    type: akamai:AppSecSlowPost\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      slowRateAction: alert\n      slowRateThresholdRate: 10\n      slowRateThresholdPeriod: 30\n      durationThresholdTimeout: 20\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                },
                "durationThresholdTimeout": {
                    "type": "integer",
                    "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                },
                "slowRateAction": {
                    "type": "string",
                    "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                },
                "slowRateThresholdPeriod": {
                    "type": "integer",
                    "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                },
                "slowRateThresholdRate": {
                    "type": "integer",
                    "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "slowRateAction"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                },
                "durationThresholdTimeout": {
                    "type": "integer",
                    "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                },
                "slowRateAction": {
                    "type": "string",
                    "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                },
                "slowRateThresholdPeriod": {
                    "type": "integer",
                    "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                },
                "slowRateThresholdRate": {
                    "type": "integer",
                    "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "slowRateAction"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSlowPost resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST settings being modified.\n"
                    },
                    "durationThresholdTimeout": {
                        "type": "integer",
                        "description": ". Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in to avoid triggering the specified action.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST settings being modified.\n"
                    },
                    "slowRateAction": {
                        "type": "string",
                        "description": ". Action to be taken if slow POST protection is triggered. Allowed values are:\n- **alert**. Record the event.\n- **abort**. Block the request.\n"
                    },
                    "slowRateThresholdPeriod": {
                        "type": "integer",
                        "description": ". Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n"
                    },
                    "slowRateThresholdRate": {
                        "type": "integer",
                        "description": ". Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecSlowPostProtection:AppSecSlowPostProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables slow POST protection for a security configuration and security policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecSlowPostProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecSlowPostProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecSlowPostProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecSlowPostProtection(ctx, \"protection\", \u0026akamai.AppSecSlowPostProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecSlowPostProtection;\nimport com.pulumi.akamai.AppSecSlowPostProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecSlowPostProtection(\"protection\", AppSecSlowPostProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecSlowPostProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecSlowPostProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable slow POST protection; set to **false** to disable slow POST protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecThreatIntel:AppSecThreatIntel": {
            "description": "**Scopes**: Security policy\n\nEnables or disables threat intelligence for a security policy. This resource is only available to organizations running the Adaptive Security Engine (ASE) beta Please contact your Akamai representative for more information.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/put-rules-threat-intel)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst threatIntel = new akamai.AppSecThreatIntel(\"threatIntel\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    threatIntel: \"on\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nthreat_intel = akamai.AppSecThreatIntel(\"threatIntel\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    threat_intel=\"on\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var threatIntel = new Akamai.AppSecThreatIntel(\"threatIntel\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ThreatIntel = \"on\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecThreatIntel(ctx, \"threatIntel\", \u0026akamai.AppSecThreatIntelArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tThreatIntel:      pulumi.String(\"on\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecThreatIntel;\nimport com.pulumi.akamai.AppSecThreatIntelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var threatIntel = new AppSecThreatIntel(\"threatIntel\", AppSecThreatIntelArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .threatIntel(\"on\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  threatIntel:\n    type: akamai:AppSecThreatIntel\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      threatIntel: on\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                },
                "threatIntel": {
                    "type": "string",
                    "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId",
                "threatIntel"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                },
                "threatIntel": {
                    "type": "string",
                    "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId",
                "threatIntel"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecThreatIntel resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the threat intelligence protection settings being modified.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the threat intelligence protection settings being modified.\n"
                    },
                    "threatIntel": {
                        "type": "string",
                        "description": ". Set to `on` to enable threat intelligence protection; set to **off** to disable threat intelligence protection.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecVersionNodes:AppSecVersionNodes": {
            "description": "**Scopes**: Security configuration\n\nUpdates the version notes for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/put-version-notes)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst versionNotesAppSecVersionNodes = new akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    versionNotes: \"This version enables reputation profiles.\",\n});\nexport const versionNotes = versionNotesAppSecVersionNodes.outputText;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nversion_notes_app_sec_version_nodes = akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\",\n    config_id=configuration.config_id,\n    version_notes=\"This version enables reputation profiles.\")\npulumi.export(\"versionNotes\", version_notes_app_sec_version_nodes.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var versionNotesAppSecVersionNodes = new Akamai.AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        VersionNotes = \"This version enables reputation profiles.\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"versionNotes\"] = versionNotesAppSecVersionNodes.OutputText,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversionNotesAppSecVersionNodes, err := akamai.NewAppSecVersionNodes(ctx, \"versionNotesAppSecVersionNodes\", \u0026akamai.AppSecVersionNodesArgs{\n\t\t\tConfigId:     *pulumi.Int(configuration.ConfigId),\n\t\t\tVersionNotes: pulumi.String(\"This version enables reputation profiles.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"versionNotes\", versionNotesAppSecVersionNodes.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecVersionNodes;\nimport com.pulumi.akamai.AppSecVersionNodesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var versionNotesAppSecVersionNodes = new AppSecVersionNodes(\"versionNotesAppSecVersionNodes\", AppSecVersionNodesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .versionNotes(\"This version enables reputation profiles.\")\n            .build());\n\n        ctx.export(\"versionNotes\", versionNotesAppSecVersionNodes.outputText());\n    }\n}\n```\n```yaml\nresources:\n  versionNotesAppSecVersionNodes:\n    type: akamai:AppSecVersionNodes\n    properties:\n      configId: ${configuration.configId}\n      versionNotes: This version enables reputation profiles.\nvariables:\n  configuration: # USE CASE: User wants to update the version notes for the latest version of a security configuration.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  versionNotes: ${versionNotesAppSecVersionNodes.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the updated version notes.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "versionNotes": {
                    "type": "string",
                    "description": ". Brief description of the security configuration version.\n"
                }
            },
            "required": [
                "configId",
                "outputText",
                "versionNotes"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                },
                "versionNotes": {
                    "type": "string",
                    "description": ". Brief description of the security configuration version.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "versionNotes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecVersionNodes resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration whose version notes are being modified.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "versionNotes": {
                        "type": "string",
                        "description": ". Brief description of the security configuration version.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWafMode:AppSecWafMode": {
            "description": "**Scopes**: Security policy\n\nModifies the way your Kona Rule Set rules are updated.\nUse **KRS** mode to update the rule sets manually or **AAG** to have those rule sets automatically updated.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/put-policy-mode)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wafMode = new akamai.AppSecWafMode(\"wafMode\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    mode: \"KRS\",\n});\nexport const wafModeMode = wafMode.mode;\nexport const wafModeCurrentRuleset = wafMode.currentRuleset;\nexport const wafModeEvalStatus = wafMode.evalStatus;\nexport const wafModeEvalRuleset = wafMode.evalRuleset;\nexport const wafModeEvalExpirationDate = wafMode.evalExpirationDate;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwaf_mode = akamai.AppSecWafMode(\"wafMode\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    mode=\"KRS\")\npulumi.export(\"wafModeMode\", waf_mode.mode)\npulumi.export(\"wafModeCurrentRuleset\", waf_mode.current_ruleset)\npulumi.export(\"wafModeEvalStatus\", waf_mode.eval_status)\npulumi.export(\"wafModeEvalRuleset\", waf_mode.eval_ruleset)\npulumi.export(\"wafModeEvalExpirationDate\", waf_mode.eval_expiration_date)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var wafMode = new Akamai.AppSecWafMode(\"wafMode\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Mode = \"KRS\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"wafModeMode\"] = wafMode.Mode,\n        [\"wafModeCurrentRuleset\"] = wafMode.CurrentRuleset,\n        [\"wafModeEvalStatus\"] = wafMode.EvalStatus,\n        [\"wafModeEvalRuleset\"] = wafMode.EvalRuleset,\n        [\"wafModeEvalExpirationDate\"] = wafMode.EvalExpirationDate,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twafMode, err := akamai.NewAppSecWafMode(ctx, \"wafMode\", \u0026akamai.AppSecWafModeArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tMode:             pulumi.String(\"KRS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafModeMode\", wafMode.Mode)\n\t\tctx.Export(\"wafModeCurrentRuleset\", wafMode.CurrentRuleset)\n\t\tctx.Export(\"wafModeEvalStatus\", wafMode.EvalStatus)\n\t\tctx.Export(\"wafModeEvalRuleset\", wafMode.EvalRuleset)\n\t\tctx.Export(\"wafModeEvalExpirationDate\", wafMode.EvalExpirationDate)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWafMode;\nimport com.pulumi.akamai.AppSecWafModeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var wafMode = new AppSecWafMode(\"wafMode\", AppSecWafModeArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .mode(\"KRS\")\n            .build());\n\n        ctx.export(\"wafModeMode\", wafMode.mode());\n        ctx.export(\"wafModeCurrentRuleset\", wafMode.currentRuleset());\n        ctx.export(\"wafModeEvalStatus\", wafMode.evalStatus());\n        ctx.export(\"wafModeEvalRuleset\", wafMode.evalRuleset());\n        ctx.export(\"wafModeEvalExpirationDate\", wafMode.evalExpirationDate());\n    }\n}\n```\n```yaml\nresources:\n  wafMode:\n    type: akamai:AppSecWafMode\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      mode: KRS\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\noutputs:\n  wafModeMode: ${wafMode.mode}\n  wafModeCurrentRuleset: ${wafMode.currentRuleset}\n  wafModeEvalStatus: ${wafMode.evalStatus}\n  wafModeEvalRuleset: ${wafMode.evalRuleset}\n  wafModeEvalExpirationDate: ${wafMode.evalExpirationDate}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `current_ruleset` – Versioning information for the current Kona Rule Set.\n- `eval_ruleset`. Versioning information for the Kona Rule Set being evaluated (if applicable).\n- `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.\n- `eval_expiration_date`. Date on which the evaluation period ends (if applicable).\n- `output_text`. Tabular report showing the current rule set, WAF mode and evaluation status.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                },
                "currentRuleset": {
                    "type": "string",
                    "description": "Versioning information for the current Kona Rule Set\n"
                },
                "evalExpirationDate": {
                    "type": "string",
                    "description": "Date on which the evaluation period ends, if applicable\n"
                },
                "evalRuleset": {
                    "type": "string",
                    "description": "Versioning information for the Kona Rule Set being evaluated, if applicable\n"
                },
                "evalStatus": {
                    "type": "string",
                    "description": "Whether an evaluation is currently in progress\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "currentRuleset",
                "evalExpirationDate",
                "evalRuleset",
                "evalStatus",
                "mode",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                },
                "mode": {
                    "type": "string",
                    "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "mode",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWafMode resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the WAF mode settings being modified.\n"
                    },
                    "currentRuleset": {
                        "type": "string",
                        "description": "Versioning information for the current Kona Rule Set\n"
                    },
                    "evalExpirationDate": {
                        "type": "string",
                        "description": "Date on which the evaluation period ends, if applicable\n"
                    },
                    "evalRuleset": {
                        "type": "string",
                        "description": "Versioning information for the Kona Rule Set being evaluated, if applicable\n"
                    },
                    "evalStatus": {
                        "type": "string",
                        "description": "Whether an evaluation is currently in progress\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": ". Specifies how Kona Rule Set rules are upgraded. Allowed values are:\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the WAF mode settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWafProtection:AppSecWafProtection": {
            "description": "**Scopes**: Security policy\n\nEnables or disables Web Application Firewall (WAF) protection for a security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protection = new akamai.AppSecWafProtection(\"protection\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotection = akamai.AppSecWafProtection(\"protection\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protection = new Akamai.AppSecWafProtection(\"protection\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecWafProtection(ctx, \"protection\", \u0026akamai.AppSecWafProtectionArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWafProtection;\nimport com.pulumi.akamai.AppSecWafProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var protection = new AppSecWafProtection(\"protection\", AppSecWafProtectionArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  protection:\n    type: akamai:AppSecWafProtection\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      enabled: true\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the current protection settings.\n",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                },
                "outputText": {
                    "type": "string",
                    "description": "Text representation\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                }
            },
            "required": [
                "configId",
                "enabled",
                "outputText",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "enabled",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWafProtection resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the WAF protection settings being modified.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": ". Set to **true** to enable WAF protection; set to **false** to disable WAF protection.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "Text representation\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the WAF protection settings being modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/appSecWapSelectedHostnames:AppSecWapSelectedHostnames": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst appsecwapSelectedhostnames = new akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", {\n    configId: configuration.then(configuration =\u003e configuration.configId),\n    securityPolicyId: \"gms1_134637\",\n    protectedHosts: [\"documentation.akamai.com\"],\n    evaluatedHosts: [\"training.akamai.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nappsecwap_selectedhostnames = akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\",\n    config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    protected_hosts=[\"documentation.akamai.com\"],\n    evaluated_hosts=[\"training.akamai.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var appsecwapSelectedhostnames = new Akamai.AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ProtectedHosts = new[]\n        {\n            \"documentation.akamai.com\",\n        },\n        EvaluatedHosts = new[]\n        {\n            \"training.akamai.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewAppSecWapSelectedHostnames(ctx, \"appsecwapSelectedhostnames\", \u0026akamai.AppSecWapSelectedHostnamesArgs{\n\t\t\tConfigId:         *pulumi.Int(configuration.ConfigId),\n\t\t\tSecurityPolicyId: pulumi.String(\"gms1_134637\"),\n\t\t\tProtectedHosts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"documentation.akamai.com\"),\n\t\t\t},\n\t\t\tEvaluatedHosts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"training.akamai.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.AppSecWapSelectedHostnames;\nimport com.pulumi.akamai.AppSecWapSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        var appsecwapSelectedhostnames = new AppSecWapSelectedHostnames(\"appsecwapSelectedhostnames\", AppSecWapSelectedHostnamesArgs.builder()        \n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .protectedHosts(\"documentation.akamai.com\")\n            .evaluatedHosts(\"training.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  appsecwapSelectedhostnames:\n    type: akamai:AppSecWapSelectedHostnames\n    properties:\n      configId: ${configuration.configId}\n      securityPolicyId: gms1_134637\n      protectedHosts:\n        - documentation.akamai.com\n      evaluatedHosts:\n        - training.akamai.com\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                },
                "evaluatedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to be evaluated\n"
                },
                "protectedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to be protected\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                }
            },
            "required": [
                "configId",
                "securityPolicyId"
            ],
            "inputProperties": {
                "configId": {
                    "type": "integer",
                    "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                },
                "evaluatedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to be evaluated\n"
                },
                "protectedHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of hostnames to be protected\n"
                },
                "securityPolicyId": {
                    "type": "string",
                    "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                }
            },
            "requiredInputs": [
                "configId",
                "securityPolicyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AppSecWapSelectedHostnames resources.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames being protected or evaluated.\n"
                    },
                    "evaluatedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of hostnames to be evaluated\n"
                    },
                    "protectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of hostnames to be protected\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsApplicationLoadBalancer:CloudletsApplicationLoadBalancer": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancer` resource to create the Application Load Balancer Cloudlet configuration. The Application Load Balancer Cloudlet provides intelligent, scalable traffic management across physical, virtual, and cloud-hosted data centers without requiring the origin to send load feedback. This Cloudlet can automatically detect load conditions and route traffic to the optimal data source while maintaining custom routing policies and consistent visitor session behavior for your visitors.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsApplicationLoadBalancer(\"example\", {\n    balancingType: \"WEIGHTED\",\n    dataCenters: [{\n        city: \"Boston\",\n        cloudServerHostHeaderOverride: false,\n        cloudService: true,\n        continent: \"NA\",\n        country: \"US\",\n        hostname: \"example-hostname\",\n        latitude: 102.78108,\n        livenessHosts: [\"example\"],\n        longitude: -116.07064,\n        originId: \"alb_test_1\",\n        percent: 100,\n        stateOrProvince: \"MA\",\n    }],\n    description: \"application_load_balancer description\",\n    livenessSettings: {\n        additionalHeaders: {\n            additionalHeaders: \"123\",\n        },\n        hostHeader: \"header\",\n        interval: 10,\n        path: \"/status\",\n        port: 1234,\n        protocol: \"HTTP\",\n        requestString: \"test_request_string\",\n        responseString: \"test_response_string\",\n        timeout: 60,\n    },\n    originId: \"alb_test_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsApplicationLoadBalancer(\"example\",\n    balancing_type=\"WEIGHTED\",\n    data_centers=[akamai.CloudletsApplicationLoadBalancerDataCenterArgs(\n        city=\"Boston\",\n        cloud_server_host_header_override=False,\n        cloud_service=True,\n        continent=\"NA\",\n        country=\"US\",\n        hostname=\"example-hostname\",\n        latitude=102.78108,\n        liveness_hosts=[\"example\"],\n        longitude=-116.07064,\n        origin_id=\"alb_test_1\",\n        percent=100,\n        state_or_province=\"MA\",\n    )],\n    description=\"application_load_balancer description\",\n    liveness_settings=akamai.CloudletsApplicationLoadBalancerLivenessSettingsArgs(\n        additional_headers={\n            \"additionalHeaders\": \"123\",\n        },\n        host_header=\"header\",\n        interval=10,\n        path=\"/status\",\n        port=1234,\n        protocol=\"HTTP\",\n        request_string=\"test_request_string\",\n        response_string=\"test_response_string\",\n        timeout=60,\n    ),\n    origin_id=\"alb_test_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CloudletsApplicationLoadBalancer(\"example\", new()\n    {\n        BalancingType = \"WEIGHTED\",\n        DataCenters = new[]\n        {\n            new Akamai.Inputs.CloudletsApplicationLoadBalancerDataCenterArgs\n            {\n                City = \"Boston\",\n                CloudServerHostHeaderOverride = false,\n                CloudService = true,\n                Continent = \"NA\",\n                Country = \"US\",\n                Hostname = \"example-hostname\",\n                Latitude = 102.78108,\n                LivenessHosts = new[]\n                {\n                    \"example\",\n                },\n                Longitude = -116.07064,\n                OriginId = \"alb_test_1\",\n                Percent = 100,\n                StateOrProvince = \"MA\",\n            },\n        },\n        Description = \"application_load_balancer description\",\n        LivenessSettings = new Akamai.Inputs.CloudletsApplicationLoadBalancerLivenessSettingsArgs\n        {\n            AdditionalHeaders = \n            {\n                { \"additionalHeaders\", \"123\" },\n            },\n            HostHeader = \"header\",\n            Interval = 10,\n            Path = \"/status\",\n            Port = 1234,\n            Protocol = \"HTTP\",\n            RequestString = \"test_request_string\",\n            ResponseString = \"test_response_string\",\n            Timeout = 60,\n        },\n        OriginId = \"alb_test_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsApplicationLoadBalancer(ctx, \"example\", \u0026akamai.CloudletsApplicationLoadBalancerArgs{\n\t\t\tBalancingType: pulumi.String(\"WEIGHTED\"),\n\t\t\tDataCenters: akamai.CloudletsApplicationLoadBalancerDataCenterArray{\n\t\t\t\t\u0026akamai.CloudletsApplicationLoadBalancerDataCenterArgs{\n\t\t\t\t\tCity:                          pulumi.String(\"Boston\"),\n\t\t\t\t\tCloudServerHostHeaderOverride: pulumi.Bool(false),\n\t\t\t\t\tCloudService:                  pulumi.Bool(true),\n\t\t\t\t\tContinent:                     pulumi.String(\"NA\"),\n\t\t\t\t\tCountry:                       pulumi.String(\"US\"),\n\t\t\t\t\tHostname:                      pulumi.String(\"example-hostname\"),\n\t\t\t\t\tLatitude:                      pulumi.Float64(102.78108),\n\t\t\t\t\tLivenessHosts: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"example\"),\n\t\t\t\t\t},\n\t\t\t\t\tLongitude:       -116.07064,\n\t\t\t\t\tOriginId:        pulumi.String(\"alb_test_1\"),\n\t\t\t\t\tPercent:         pulumi.Float64(100),\n\t\t\t\t\tStateOrProvince: pulumi.String(\"MA\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"application_load_balancer description\"),\n\t\t\tLivenessSettings: \u0026akamai.CloudletsApplicationLoadBalancerLivenessSettingsArgs{\n\t\t\t\tAdditionalHeaders: pulumi.StringMap{\n\t\t\t\t\t\"additionalHeaders\": pulumi.String(\"123\"),\n\t\t\t\t},\n\t\t\t\tHostHeader:     pulumi.String(\"header\"),\n\t\t\t\tInterval:       pulumi.Int(10),\n\t\t\t\tPath:           pulumi.String(\"/status\"),\n\t\t\t\tPort:           pulumi.Int(1234),\n\t\t\t\tProtocol:       pulumi.String(\"HTTP\"),\n\t\t\t\tRequestString:  pulumi.String(\"test_request_string\"),\n\t\t\t\tResponseString: pulumi.String(\"test_response_string\"),\n\t\t\t\tTimeout:        pulumi.Float64(60),\n\t\t\t},\n\t\t\tOriginId: pulumi.String(\"alb_test_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic usagehcl resource \"akamai_cloudlets_application_load_balancer\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai Application Load Balancer configuration using an origin ID. For example\n\n```sh\n $ pulumi import akamai:index/cloudletsApplicationLoadBalancer:CloudletsApplicationLoadBalancer example alb_test_1\n```\n\n ",
            "properties": {
                "balancingType": {
                    "type": "string",
                    "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                },
                "dataCenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                    },
                    "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the load balancing configuration.\n"
                },
                "livenessSettings": {
                    "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                    "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version number of the load balancing configuration.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "A list of warnings that occurred during the activation of the load balancing configuration.\n"
                }
            },
            "required": [
                "dataCenters",
                "originId",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "balancingType": {
                    "type": "string",
                    "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                },
                "dataCenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                    },
                    "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the load balancing configuration.\n"
                },
                "livenessSettings": {
                    "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                    "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataCenters",
                "originId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsApplicationLoadBalancer resources.\n",
                "properties": {
                    "balancingType": {
                        "type": "string",
                        "description": "The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n"
                    },
                    "dataCenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerDataCenter:CloudletsApplicationLoadBalancerDataCenter"
                        },
                        "description": "Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the load balancing configuration.\n"
                    },
                    "livenessSettings": {
                        "$ref": "#/types/akamai:index/CloudletsApplicationLoadBalancerLivenessSettings:CloudletsApplicationLoadBalancerLivenessSettings",
                        "description": "Specifies the health of each load balanced data center defined in the data center list.\n"
                    },
                    "originId": {
                        "type": "string",
                        "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version number of the load balancing configuration.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "A list of warnings that occurred during the activation of the load balancing configuration.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsApplicationLoadBalancerActivation:CloudletsApplicationLoadBalancerActivation": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancerActivation` resource to activate the Application Load Balancer Cloudlet configuration. An activation deploys the configuration version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsApplicationLoadBalancerActivation(\"example\", {\n    originId: \"alb_test_1\",\n    network: \"staging\",\n    version: 1,\n});\nexport const status = example.status;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsApplicationLoadBalancerActivation(\"example\",\n    origin_id=\"alb_test_1\",\n    network=\"staging\",\n    version=1)\npulumi.export(\"status\", example.status)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CloudletsApplicationLoadBalancerActivation(\"example\", new()\n    {\n        OriginId = \"alb_test_1\",\n        Network = \"staging\",\n        Version = 1,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"status\"] = example.Status,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.NewCloudletsApplicationLoadBalancerActivation(ctx, \"example\", \u0026akamai.CloudletsApplicationLoadBalancerActivationArgs{\n\t\t\tOriginId: pulumi.String(\"alb_test_1\"),\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"status\", example.Status)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsApplicationLoadBalancerActivation;\nimport com.pulumi.akamai.CloudletsApplicationLoadBalancerActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsApplicationLoadBalancerActivation(\"example\", CloudletsApplicationLoadBalancerActivationArgs.builder()        \n            .originId(\"alb_test_1\")\n            .network(\"staging\")\n            .version(1)\n            .build());\n\n        ctx.export(\"status\", example.status());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsApplicationLoadBalancerActivation\n    properties:\n      originId: alb_test_1\n      network: staging\n      version: 1\noutputs:\n  status: ${example.status}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The activation status for this load balancing configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                }
            },
            "required": [
                "network",
                "originId",
                "status",
                "version"
            ],
            "inputProperties": {
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                },
                "originId": {
                    "type": "string",
                    "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "integer",
                    "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "network",
                "originId",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsApplicationLoadBalancerActivation resources.\n",
                "properties": {
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.\n"
                    },
                    "originId": {
                        "type": "string",
                        "description": "The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The activation status for this load balancing configuration.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The Application Load Balancer Cloudlet configuration version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsPolicy:CloudletsPolicy": {
            "description": "Use the `akamai.CloudletsPolicy` resource to create and version a policy. For each Cloudlet instance on your contract, there can be any number of policies. A single policy is associated with a single property configuration. Within a policy version you define the rules that determine when the Cloudlet executes. You may want to create a new version of a policy to support a different business requirement, or to test new functionality.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsPolicy(\"example\", {\n    cloudletCode: \"ER\",\n    description: \"policy description\",\n    groupId: \"grp_123\",\n    matchRules: `  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": false\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"path\",\n        \"matchValue\": \"/example/website.html\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": false,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"copy_scheme_hostname\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"/website.html\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsPolicy(\"example\",\n    cloudlet_code=\"ER\",\n    description=\"policy description\",\n    group_id=\"grp_123\",\n    match_rules=\"\"\"  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": false\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"path\",\n        \"matchValue\": \"/example/website.html\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": false,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"copy_scheme_hostname\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"/website.html\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CloudletsPolicy(\"example\", new()\n    {\n        CloudletCode = \"ER\",\n        Description = \"policy description\",\n        GroupId = \"grp_123\",\n        MatchRules = @\"  [\n  {\n    \"\"name\"\": \"\"rule1\"\",\n    \"\"type\"\": \"\"erMatchRule\"\",\n    \"\"useRelativeUrl\"\": \"\"none\"\",\n    \"\"statusCode\"\": 301,\n    \"\"redirectURL\"\": \"\"https://www.example.com\"\",\n    \"\"matchURL\"\": \"\"example.com\"\",\n    \"\"useIncomingQueryString\"\": false,\n    \"\"useIncomingSchemeAndHost\"\": false\n  },\n  {\n    \"\"name\"\": \"\"rule2\"\",\n    \"\"type\"\": \"\"erMatchRule\"\",\n    \"\"matches\"\": [\n      {\n        \"\"matchType\"\": \"\"path\"\",\n        \"\"matchValue\"\": \"\"/example/website.html\"\",\n        \"\"matchOperator\"\": \"\"equals\"\",\n        \"\"caseSensitive\"\": false,\n        \"\"negate\"\": false\n      }\n    ],\n    \"\"useRelativeUrl\"\": \"\"copy_scheme_hostname\"\",\n    \"\"statusCode\"\": 301,\n    \"\"redirectURL\"\": \"\"/website.html\"\",\n    \"\"useIncomingQueryString\"\": false,\n    \"\"useIncomingSchemeAndHost\"\": true\n  }\n]\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsPolicy(ctx, \"example\", \u0026akamai.CloudletsPolicyArgs{\n\t\t\tCloudletCode: pulumi.String(\"ER\"),\n\t\t\tDescription:  pulumi.String(\"policy description\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tMatchRules: pulumi.String(fmt.Sprintf(`  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": false\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"path\",\n        \"matchValue\": \"/example/website.html\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": false,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"copy_scheme_hostname\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"/website.html\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n`)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicy;\nimport com.pulumi.akamai.CloudletsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsPolicy(\"example\", CloudletsPolicyArgs.builder()        \n            .cloudletCode(\"ER\")\n            .description(\"policy description\")\n            .groupId(\"grp_123\")\n            .matchRules(\"\"\"\n  [\n  {\n    \"name\": \"rule1\",\n    \"type\": \"erMatchRule\",\n    \"useRelativeUrl\": \"none\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"https://www.example.com\",\n    \"matchURL\": \"example.com\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": false\n  },\n  {\n    \"name\": \"rule2\",\n    \"type\": \"erMatchRule\",\n    \"matches\": [\n      {\n        \"matchType\": \"path\",\n        \"matchValue\": \"/example/website.html\",\n        \"matchOperator\": \"equals\",\n        \"caseSensitive\": false,\n        \"negate\": false\n      }\n    ],\n    \"useRelativeUrl\": \"copy_scheme_hostname\",\n    \"statusCode\": 301,\n    \"redirectURL\": \"/website.html\",\n    \"useIncomingQueryString\": false,\n    \"useIncomingSchemeAndHost\": true\n  }\n]\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsPolicy\n    properties:\n      cloudletCode: ER\n      description: policy description\n      groupId: grp_123\n      matchRules: |2\n          [\n          {\n            \"name\": \"rule1\",\n            \"type\": \"erMatchRule\",\n            \"useRelativeUrl\": \"none\",\n            \"statusCode\": 301,\n            \"redirectURL\": \"https://www.example.com\",\n            \"matchURL\": \"example.com\",\n            \"useIncomingQueryString\": false,\n            \"useIncomingSchemeAndHost\": false\n          },\n          {\n            \"name\": \"rule2\",\n            \"type\": \"erMatchRule\",\n            \"matches\": [\n              {\n                \"matchType\": \"path\",\n                \"matchValue\": \"/example/website.html\",\n                \"matchOperator\": \"equals\",\n                \"caseSensitive\": false,\n                \"negate\": false\n              }\n            ],\n            \"useRelativeUrl\": \"copy_scheme_hostname\",\n            \"statusCode\": 301,\n            \"redirectURL\": \"/website.html\",\n            \"useIncomingQueryString\": false,\n            \"useIncomingSchemeAndHost\": true\n          }\n        ]\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic usagehcl resource \"akamai_cloudlets_policy\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai Cloudlets policy using a policy name. For example\n\n```sh\n $ pulumi import akamai:index/cloudletsPolicy:CloudletsPolicy example policy1\n```\n\n ",
            "properties": {
                "cloudletCode": {
                    "type": "string",
                    "description": "The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.\n"
                },
                "cloudletId": {
                    "type": "integer",
                    "description": "A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this specific policy.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                },
                "matchRuleFormat": {
                    "type": "string",
                    "description": "The version of the Cloudlet-specific `match_rules`.\n"
                },
                "matchRules": {
                    "type": "string",
                    "description": "A JSON structure that defines the rules for this policy\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the policy.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version number of the policy.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "A JSON-encoded list of warnings.\n"
                }
            },
            "required": [
                "cloudletCode",
                "cloudletId",
                "groupId",
                "name",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "cloudletCode": {
                    "type": "string",
                    "description": "The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this specific policy.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                },
                "matchRuleFormat": {
                    "type": "string",
                    "description": "The version of the Cloudlet-specific `match_rules`.\n"
                },
                "matchRules": {
                    "type": "string",
                    "description": "A JSON structure that defines the rules for this policy\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique name of the policy.\n"
                }
            },
            "requiredInputs": [
                "cloudletCode",
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsPolicy resources.\n",
                "properties": {
                    "cloudletCode": {
                        "type": "string",
                        "description": "The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.\n"
                    },
                    "cloudletId": {
                        "type": "integer",
                        "description": "A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this specific policy.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Defines the group association for the policy. You must have edit privileges for the group.\n"
                    },
                    "matchRuleFormat": {
                        "type": "string",
                        "description": "The version of the Cloudlet-specific `match_rules`.\n"
                    },
                    "matchRules": {
                        "type": "string",
                        "description": "A JSON structure that defines the rules for this policy\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The unique name of the policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version number of the policy.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "A JSON-encoded list of warnings.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cloudletsPolicyActivation:CloudletsPolicyActivation": {
            "description": "Use the `akamai.CloudletsPolicyActivation` resource to activate a specific version of a Cloudlet policy. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CloudletsPolicyActivation(\"example\", {\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n        \"Property_3\",\n    ],\n    network: \"staging\",\n    policyId: 1234,\n    version: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CloudletsPolicyActivation(\"example\",\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n        \"Property_3\",\n    ],\n    network=\"staging\",\n    policy_id=1234,\n    version=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CloudletsPolicyActivation(\"example\", new()\n    {\n        AssociatedProperties = new[]\n        {\n            \"Property_1\",\n            \"Property_2\",\n            \"Property_3\",\n        },\n        Network = \"staging\",\n        PolicyId = 1234,\n        Version = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCloudletsPolicyActivation(ctx, \"example\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t\tpulumi.String(\"Property_3\"),\n\t\t\t},\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tPolicyId: pulumi.Int(1234),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicyActivation;\nimport com.pulumi.akamai.CloudletsPolicyActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CloudletsPolicyActivation(\"example\", CloudletsPolicyActivationArgs.builder()        \n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\",\n                \"Property_3\")\n            .network(\"staging\")\n            .policyId(1234)\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      associatedProperties:\n        - Property_1\n        - Property_2\n        - Property_3\n      network: staging\n      policyId: 1234\n      version: 1\n```\nIf you're handling two `akamai.CloudletsPolicyActivation` resources in the same configuration file with the same `policy_id`, but different `network` arguments (for example, `production` and `staging`), you need to add `depends_on` to the production resource. See the example:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst stag = new akamai.CloudletsPolicyActivation(\"stag\", {\n    policyId: 1234567,\n    network: \"staging\",\n    version: 1,\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n    ],\n});\nconst prod = new akamai.CloudletsPolicyActivation(\"prod\", {\n    policyId: 1234567,\n    network: \"production\",\n    version: 1,\n    associatedProperties: [\n        \"Property_1\",\n        \"Property_2\",\n    ],\n}, {\n    dependsOn: [stag],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nstag = akamai.CloudletsPolicyActivation(\"stag\",\n    policy_id=1234567,\n    network=\"staging\",\n    version=1,\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n    ])\nprod = akamai.CloudletsPolicyActivation(\"prod\",\n    policy_id=1234567,\n    network=\"production\",\n    version=1,\n    associated_properties=[\n        \"Property_1\",\n        \"Property_2\",\n    ],\n    opts=pulumi.ResourceOptions(depends_on=[stag]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var stag = new Akamai.CloudletsPolicyActivation(\"stag\", new()\n    {\n        PolicyId = 1234567,\n        Network = \"staging\",\n        Version = 1,\n        AssociatedProperties = new[]\n        {\n            \"Property_1\",\n            \"Property_2\",\n        },\n    });\n\n    var prod = new Akamai.CloudletsPolicyActivation(\"prod\", new()\n    {\n        PolicyId = 1234567,\n        Network = \"production\",\n        Version = 1,\n        AssociatedProperties = new[]\n        {\n            \"Property_1\",\n            \"Property_2\",\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            stag,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstag, err := akamai.NewCloudletsPolicyActivation(ctx, \"stag\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tPolicyId: pulumi.Int(1234567),\n\t\t\tNetwork:  pulumi.String(\"staging\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCloudletsPolicyActivation(ctx, \"prod\", \u0026akamai.CloudletsPolicyActivationArgs{\n\t\t\tPolicyId: pulumi.Int(1234567),\n\t\t\tNetwork:  pulumi.String(\"production\"),\n\t\t\tVersion:  pulumi.Int(1),\n\t\t\tAssociatedProperties: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"Property_1\"),\n\t\t\t\tpulumi.String(\"Property_2\"),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tstag,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CloudletsPolicyActivation;\nimport com.pulumi.akamai.CloudletsPolicyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var stag = new CloudletsPolicyActivation(\"stag\", CloudletsPolicyActivationArgs.builder()        \n            .policyId(1234567)\n            .network(\"staging\")\n            .version(1)\n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\")\n            .build());\n\n        var prod = new CloudletsPolicyActivation(\"prod\", CloudletsPolicyActivationArgs.builder()        \n            .policyId(1234567)\n            .network(\"production\")\n            .version(1)\n            .associatedProperties(            \n                \"Property_1\",\n                \"Property_2\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(stag)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  stag:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      policyId: 1.234567e+06\n      network: staging\n      version: 1\n      associatedProperties:\n        - Property_1\n        - Property_2\n  prod:\n    type: akamai:CloudletsPolicyActivation\n    properties:\n      policyId: 1.234567e+06\n      network: production\n      version: 1\n      associatedProperties:\n        - Property_1\n        - Property_2\n    options:\n      dependson:\n        - ${stag}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "associatedProperties": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                },
                "policyId": {
                    "type": "integer",
                    "description": "An identifier for the Cloudlet policy you want to activate.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The activation status for this Cloudlet policy.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The Cloudlet policy version you want to activate.\n"
                }
            },
            "required": [
                "associatedProperties",
                "network",
                "policyId",
                "status",
                "version"
            ],
            "inputProperties": {
                "associatedProperties": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                },
                "policyId": {
                    "type": "integer",
                    "description": "An identifier for the Cloudlet policy you want to activate.\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "integer",
                    "description": "The Cloudlet policy version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "associatedProperties",
                "network",
                "policyId",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudletsPolicyActivation resources.\n",
                "properties": {
                    "associatedProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of property identifiers related to this Cloudlet policy. You can't activate a Cloudlet policy if it doesn't have any properties associated with it.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on. For the Staging network, specify either `staging`, `stag`, or `s`. For the Production network, specify either `production`, `prod`, or `p`. All values are case insensitive.\n"
                    },
                    "policyId": {
                        "type": "integer",
                        "description": "An identifier for the Cloudlet policy you want to activate.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The activation status for this Cloudlet policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The Cloudlet policy version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpCode:CpCode": {
            "description": "The `akamai.CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.\n\nYou can create additional CP codes to support more detailed billing and reporting functions.\n\nBy default, the Akamai Provider uses your existing CP code instead of creating a new one.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst cpCode = new akamai.CpCode(\"cpCode\", {\n    contractId: akamai_contract.contract.id,\n    groupId: akamai_group.group.id,\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncp_code = akamai.CpCode(\"cpCode\",\n    contract_id=akamai_contract[\"contract\"][\"id\"],\n    group_id=akamai_group[\"group\"][\"id\"],\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cpCode = new Akamai.CpCode(\"cpCode\", new()\n    {\n        ContractId = akamai_contract.Contract.Id,\n        GroupId = akamai_group.Group.Id,\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpCode(ctx, \"cpCode\", \u0026akamai.CpCodeArgs{\n\t\t\tContractId: pulumi.Any(akamai_contract.Contract.Id),\n\t\t\tGroupId:    pulumi.Any(akamai_group.Group.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cpCode = new CpCode(\"cpCode\", CpCodeArgs.builder()        \n            .contractId(akamai_contract.contract().id())\n            .groupId(akamai_group.group().id())\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cpCode:\n    type: akamai:CpCode\n    properties:\n      contractId: ${akamai_contract.contract.id}\n      groupId: ${akamai_group.group.id}\n      productId: prd_Object_Delivery\n```\n\nHere's a real-life example that includes other data sources as dependencies:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst groupName = \"example group name\";\nconst cpcodeName = \"My CP Code\";\nconst exampleContract = akamai.getContract({\n    groupName: groupName,\n});\nconst exampleGroup = exampleContract.then(exampleContract =\u003e akamai.getGroup({\n    name: groupName,\n    contractId: exampleContract.id,\n}));\nconst exampleCp = new akamai.CpCode(\"exampleCp\", {\n    groupId: exampleGroup.then(exampleGroup =\u003e exampleGroup.id),\n    contractId: exampleContract.then(exampleContract =\u003e exampleContract.id),\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ngroup_name = \"example group name\"\ncpcode_name = \"My CP Code\"\nexample_contract = akamai.get_contract(group_name=group_name)\nexample_group = akamai.get_group(name=group_name,\n    contract_id=example_contract.id)\nexample_cp = akamai.CpCode(\"exampleCp\",\n    group_id=example_group.id,\n    contract_id=example_contract.id,\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var groupName = \"example group name\";\n\n    var cpcodeName = \"My CP Code\";\n\n    var exampleContract = Akamai.GetContract.Invoke(new()\n    {\n        GroupName = groupName,\n    });\n\n    var exampleGroup = Akamai.GetGroup.Invoke(new()\n    {\n        Name = groupName,\n        ContractId = exampleContract.Apply(getContractResult =\u003e getContractResult.Id),\n    });\n\n    var exampleCp = new Akamai.CpCode(\"exampleCp\", new()\n    {\n        GroupId = exampleGroup.Apply(getGroupResult =\u003e getGroupResult.Id),\n        ContractId = exampleContract.Apply(getContractResult =\u003e getContractResult.Id),\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroupName := \"example group name\"\n\t\t_ := \"My CP Code\"\n\t\texampleContract, err := akamai.GetContract(ctx, \u0026akamai.GetContractArgs{\n\t\t\tGroupName: pulumi.StringRef(groupName),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleGroup, err := akamai.GetGroup(ctx, \u0026akamai.GetGroupArgs{\n\t\t\tName:       pulumi.StringRef(groupName),\n\t\t\tContractId: pulumi.StringRef(exampleContract.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCpCode(ctx, \"exampleCp\", \u0026akamai.CpCodeArgs{\n\t\t\tGroupId:    *pulumi.String(exampleGroup.Id),\n\t\t\tContractId: *pulumi.String(exampleContract.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetContractArgs;\nimport com.pulumi.akamai.inputs.GetGroupArgs;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var groupName = \"example group name\";\n\n        final var cpcodeName = \"My CP Code\";\n\n        final var exampleContract = AkamaiFunctions.getContract(GetContractArgs.builder()\n            .groupName(groupName)\n            .build());\n\n        final var exampleGroup = AkamaiFunctions.getGroup(GetGroupArgs.builder()\n            .name(groupName)\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .build());\n\n        var exampleCp = new CpCode(\"exampleCp\", CpCodeArgs.builder()        \n            .groupId(exampleGroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCp:\n    type: akamai:CpCode\n    properties:\n      groupId: ${exampleGroup.id}\n      contractId: ${exampleContract.id}\n      productId: prd_Object_Delivery\nvariables:\n  groupName: example group name\n  cpcodeName: My CP Code\n  exampleGroup:\n    fn::invoke:\n      Function: akamai:getGroup\n      Arguments:\n        name: ${groupName}\n        contractId: ${exampleContract.id}\n  exampleContract:\n    fn::invoke:\n      Function: akamai:getContract\n      Arguments:\n        groupName: ${groupName}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `id` - The ID of the CP code.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cp_code\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example\n\n```sh\n $ pulumi import akamai:index/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "name",
                "product",
                "productId"
            ],
            "inputProperties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpCode resources.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/cpCode:CpCode"
                }
            ]
        },
        "akamai:index/cpsDvEnrollment:CpsDvEnrollment": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CpsDvEnrollment(\"example\", {\n    contractId: \"ctr_1-AB123\",\n    acknowledgePreVerificationWarnings: true,\n    commonName: \"cps-test.example.net\",\n    sans: [\n        \"san1.cps-test.example.net\",\n        \"san2.cps-test.example.net\",\n    ],\n    secureNetwork: \"enhanced-tls\",\n    sniOnly: true,\n    adminContact: {\n        firstName: \"x1\",\n        lastName: \"x2\",\n        phone: \"123123123\",\n        email: \"x1x2@example.net\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Akamai\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    techContact: {\n        firstName: \"x3\",\n        lastName: \"x4\",\n        phone: \"123123123\",\n        email: \"x3x4@akamai.com\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Akamai\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    certificateChainType: \"default\",\n    csr: {\n        countryCode: \"US\",\n        city: \"Cambridge\",\n        organization: \"Akamai\",\n        organizationalUnit: \"Dev\",\n        state: \"MA\",\n    },\n    networkConfiguration: {\n        disallowedTlsVersions: [\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        cloneDnsNames: false,\n        geography: \"core\",\n        ocspStapling: \"on\",\n        preferredCiphers: \"ak-akamai-default\",\n        mustHaveCiphers: \"ak-akamai-default\",\n        quicEnabled: false,\n    },\n    signatureAlgorithm: \"SHA-256\",\n    organization: {\n        name: \"Akamai\",\n        phone: \"123123123\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        postalCode: \"02142\",\n        region: \"MA\",\n    },\n});\nexport const dnsChallenges = example.dnsChallenges;\nexport const httpChallenges = example.httpChallenges;\nexport const enrollmentId = example.id;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CpsDvEnrollment(\"example\",\n    contract_id=\"ctr_1-AB123\",\n    acknowledge_pre_verification_warnings=True,\n    common_name=\"cps-test.example.net\",\n    sans=[\n        \"san1.cps-test.example.net\",\n        \"san2.cps-test.example.net\",\n    ],\n    secure_network=\"enhanced-tls\",\n    sni_only=True,\n    admin_contact=akamai.CpsDvEnrollmentAdminContactArgs(\n        first_name=\"x1\",\n        last_name=\"x2\",\n        phone=\"123123123\",\n        email=\"x1x2@example.net\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Akamai\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    tech_contact=akamai.CpsDvEnrollmentTechContactArgs(\n        first_name=\"x3\",\n        last_name=\"x4\",\n        phone=\"123123123\",\n        email=\"x3x4@akamai.com\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Akamai\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    certificate_chain_type=\"default\",\n    csr=akamai.CpsDvEnrollmentCsrArgs(\n        country_code=\"US\",\n        city=\"Cambridge\",\n        organization=\"Akamai\",\n        organizational_unit=\"Dev\",\n        state=\"MA\",\n    ),\n    network_configuration=akamai.CpsDvEnrollmentNetworkConfigurationArgs(\n        disallowed_tls_versions=[\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        clone_dns_names=False,\n        geography=\"core\",\n        ocsp_stapling=\"on\",\n        preferred_ciphers=\"ak-akamai-default\",\n        must_have_ciphers=\"ak-akamai-default\",\n        quic_enabled=False,\n    ),\n    signature_algorithm=\"SHA-256\",\n    organization=akamai.CpsDvEnrollmentOrganizationArgs(\n        name=\"Akamai\",\n        phone=\"123123123\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        postal_code=\"02142\",\n        region=\"MA\",\n    ))\npulumi.export(\"dnsChallenges\", example.dns_challenges)\npulumi.export(\"httpChallenges\", example.http_challenges)\npulumi.export(\"enrollmentId\", example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CpsDvEnrollment(\"example\", new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        AcknowledgePreVerificationWarnings = true,\n        CommonName = \"cps-test.example.net\",\n        Sans = new[]\n        {\n            \"san1.cps-test.example.net\",\n            \"san2.cps-test.example.net\",\n        },\n        SecureNetwork = \"enhanced-tls\",\n        SniOnly = true,\n        AdminContact = new Akamai.Inputs.CpsDvEnrollmentAdminContactArgs\n        {\n            FirstName = \"x1\",\n            LastName = \"x2\",\n            Phone = \"123123123\",\n            Email = \"x1x2@example.net\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            Organization = \"Akamai\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n            Title = \"Administrator\",\n        },\n        TechContact = new Akamai.Inputs.CpsDvEnrollmentTechContactArgs\n        {\n            FirstName = \"x3\",\n            LastName = \"x4\",\n            Phone = \"123123123\",\n            Email = \"x3x4@akamai.com\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            Organization = \"Akamai\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n            Title = \"Administrator\",\n        },\n        CertificateChainType = \"default\",\n        Csr = new Akamai.Inputs.CpsDvEnrollmentCsrArgs\n        {\n            CountryCode = \"US\",\n            City = \"Cambridge\",\n            Organization = \"Akamai\",\n            OrganizationalUnit = \"Dev\",\n            State = \"MA\",\n        },\n        NetworkConfiguration = new Akamai.Inputs.CpsDvEnrollmentNetworkConfigurationArgs\n        {\n            DisallowedTlsVersions = new[]\n            {\n                \"TLSv1\",\n                \"TLSv1_1\",\n            },\n            CloneDnsNames = false,\n            Geography = \"core\",\n            OcspStapling = \"on\",\n            PreferredCiphers = \"ak-akamai-default\",\n            MustHaveCiphers = \"ak-akamai-default\",\n            QuicEnabled = false,\n        },\n        SignatureAlgorithm = \"SHA-256\",\n        Organization = new Akamai.Inputs.CpsDvEnrollmentOrganizationArgs\n        {\n            Name = \"Akamai\",\n            Phone = \"123123123\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dnsChallenges\"] = example.DnsChallenges,\n        [\"httpChallenges\"] = example.HttpChallenges,\n        [\"enrollmentId\"] = example.Id,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.NewCpsDvEnrollment(ctx, \"example\", \u0026akamai.CpsDvEnrollmentArgs{\n\t\t\tContractId:                         pulumi.String(\"ctr_1-AB123\"),\n\t\t\tAcknowledgePreVerificationWarnings: pulumi.Bool(true),\n\t\t\tCommonName:                         pulumi.String(\"cps-test.example.net\"),\n\t\t\tSans: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"san1.cps-test.example.net\"),\n\t\t\t\tpulumi.String(\"san2.cps-test.example.net\"),\n\t\t\t},\n\t\t\tSecureNetwork: pulumi.String(\"enhanced-tls\"),\n\t\t\tSniOnly:       pulumi.Bool(true),\n\t\t\tAdminContact: \u0026akamai.CpsDvEnrollmentAdminContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"x1\"),\n\t\t\t\tLastName:       pulumi.String(\"x2\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tEmail:          pulumi.String(\"x1x2@example.net\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Akamai\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tTechContact: \u0026akamai.CpsDvEnrollmentTechContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"x3\"),\n\t\t\t\tLastName:       pulumi.String(\"x4\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tEmail:          pulumi.String(\"x3x4@akamai.com\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Akamai\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tCertificateChainType: pulumi.String(\"default\"),\n\t\t\tCsr: \u0026akamai.CpsDvEnrollmentCsrArgs{\n\t\t\t\tCountryCode:        pulumi.String(\"US\"),\n\t\t\t\tCity:               pulumi.String(\"Cambridge\"),\n\t\t\t\tOrganization:       pulumi.String(\"Akamai\"),\n\t\t\t\tOrganizationalUnit: pulumi.String(\"Dev\"),\n\t\t\t\tState:              pulumi.String(\"MA\"),\n\t\t\t},\n\t\t\tNetworkConfiguration: \u0026akamai.CpsDvEnrollmentNetworkConfigurationArgs{\n\t\t\t\tDisallowedTlsVersions: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"TLSv1\"),\n\t\t\t\t\tpulumi.String(\"TLSv1_1\"),\n\t\t\t\t},\n\t\t\t\tCloneDnsNames:    pulumi.Bool(false),\n\t\t\t\tGeography:        pulumi.String(\"core\"),\n\t\t\t\tOcspStapling:     pulumi.String(\"on\"),\n\t\t\t\tPreferredCiphers: pulumi.String(\"ak-akamai-default\"),\n\t\t\t\tMustHaveCiphers:  pulumi.String(\"ak-akamai-default\"),\n\t\t\t\tQuicEnabled:      pulumi.Bool(false),\n\t\t\t},\n\t\t\tSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t\tOrganization: \u0026akamai.CpsDvEnrollmentOrganizationArgs{\n\t\t\t\tName:           pulumi.String(\"Akamai\"),\n\t\t\t\tPhone:          pulumi.String(\"123123123\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dnsChallenges\", example.DnsChallenges)\n\t\tctx.Export(\"httpChallenges\", example.HttpChallenges)\n\t\tctx.Export(\"enrollmentId\", example.ID())\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsDvEnrollment;\nimport com.pulumi.akamai.CpsDvEnrollmentArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentAdminContactArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentTechContactArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentCsrArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentNetworkConfigurationArgs;\nimport com.pulumi.akamai.inputs.CpsDvEnrollmentOrganizationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CpsDvEnrollment(\"example\", CpsDvEnrollmentArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .acknowledgePreVerificationWarnings(true)\n            .commonName(\"cps-test.example.net\")\n            .sans(            \n                \"san1.cps-test.example.net\",\n                \"san2.cps-test.example.net\")\n            .secureNetwork(\"enhanced-tls\")\n            .sniOnly(true)\n            .adminContact(CpsDvEnrollmentAdminContactArgs.builder()\n                .firstName(\"x1\")\n                .lastName(\"x2\")\n                .phone(\"123123123\")\n                .email(\"x1x2@example.net\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Akamai\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .techContact(CpsDvEnrollmentTechContactArgs.builder()\n                .firstName(\"x3\")\n                .lastName(\"x4\")\n                .phone(\"123123123\")\n                .email(\"x3x4@akamai.com\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Akamai\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .certificateChainType(\"default\")\n            .csr(CpsDvEnrollmentCsrArgs.builder()\n                .countryCode(\"US\")\n                .city(\"Cambridge\")\n                .organization(\"Akamai\")\n                .organizationalUnit(\"Dev\")\n                .state(\"MA\")\n                .build())\n            .networkConfiguration(CpsDvEnrollmentNetworkConfigurationArgs.builder()\n                .disallowedTlsVersions(                \n                    \"TLSv1\",\n                    \"TLSv1_1\")\n                .cloneDnsNames(false)\n                .geography(\"core\")\n                .ocspStapling(\"on\")\n                .preferredCiphers(\"ak-akamai-default\")\n                .mustHaveCiphers(\"ak-akamai-default\")\n                .quicEnabled(false)\n                .build())\n            .signatureAlgorithm(\"SHA-256\")\n            .organization(CpsDvEnrollmentOrganizationArgs.builder()\n                .name(\"Akamai\")\n                .phone(\"123123123\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .build())\n            .build());\n\n        ctx.export(\"dnsChallenges\", example.dnsChallenges());\n        ctx.export(\"httpChallenges\", example.httpChallenges());\n        ctx.export(\"enrollmentId\", example.id());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CpsDvEnrollment\n    properties:\n      contractId: ctr_1-AB123\n      acknowledgePreVerificationWarnings: true\n      commonName: cps-test.example.net\n      sans:\n        - san1.cps-test.example.net\n        - san2.cps-test.example.net\n      secureNetwork: enhanced-tls\n      sniOnly: true\n      adminContact:\n        firstName: x1\n        lastName: x2\n        phone: '123123123'\n        email: x1x2@example.net\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Akamai\n        postalCode: '02142'\n        region: MA\n        title: Administrator\n      techContact:\n        firstName: x3\n        lastName: x4\n        phone: '123123123'\n        email: x3x4@akamai.com\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Akamai\n        postalCode: '02142'\n        region: MA\n        title: Administrator\n      certificateChainType: default\n      csr:\n        countryCode: US\n        city: Cambridge\n        organization: Akamai\n        organizationalUnit: Dev\n        state: MA\n      networkConfiguration:\n        disallowedTlsVersions:\n          - TLSv1\n          - TLSv1_1\n        cloneDnsNames: false\n        geography: core\n        ocspStapling: on\n        preferredCiphers: ak-akamai-default\n        mustHaveCiphers: ak-akamai-default\n        quicEnabled: false\n      signatureAlgorithm: SHA-256\n      organization:\n        name: Akamai\n        phone: '123123123'\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        postalCode: '02142'\n        region: MA\noutputs:\n  dnsChallenges: ${example.dnsChallenges}\n  httpChallenges: ${example.httpChallenges}\n  enrollmentId: ${example.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThe resource returns these attributes:\n\n* `registration_authority` - (Required) This value populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.\n* `certificate_type` - (Required) This value populates automatically with the `san` certificate type and is preserved in the `state` file.\n* `validation_type` - (Required) This value populates automatically with the `dv` validation type and is preserved in the `state` file.\n* `id` - The unique identifier for this enrollment.\n* `dns_challenges` - The validation challenge for the domains listed in the certificate. To successfully perform the validation, only one challenge for each domain must be complete, either `dns_challenges` or `http_challenges`.\n\n    Returns these additional attributes:\n\n      * `domain` - The domain to validate.\n      * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.\n      * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.\n* `http_challenges` - The validation challenge for the domains listed in the certificate. To successfully perform the validation, only one challenge for each domain must be complete, either `dns_challenges` or `http_challenges`.\n\n    Returns these additional attributes:\n\n      * `domain` - The domain to validate.\n      * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.\n      * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cps_dv_enrollment\" \"example\" { (resource arguments) } You can import your Akamai DV enrollment using a comma-delimited string of the enrollment ID and\n\n contract ID, optionally with the `ctr_` prefix. You have to enter the IDs in this order`enrollment_id,contract_id` For example\n\n```sh\n $ pulumi import akamai:index/cpsDvEnrollment:CpsDvEnrollment example 12345,1-AB123\n```\n\n ",
            "properties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "allowDuplicateCommonName": {
                    "type": "boolean",
                    "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "certificateType": {
                    "type": "string",
                    "description": "Certificate type of enrollment\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n"
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "dnsChallenges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge"
                    },
                    "description": "DNS challenge information\n"
                },
                "enableMultiStackedCertificates": {
                    "type": "boolean",
                    "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n",
                    "deprecationMessage": "Deprecated, don't use; always false"
                },
                "httpChallenges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge"
                    },
                    "description": "HTTP challenge information\n"
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "registrationAuthority": {
                    "type": "string",
                    "description": "The registration authority or certificate authority (CA) used to obtain a certificate\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n"
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                },
                "validationType": {
                    "type": "string",
                    "description": "Enrolment validation type\n"
                }
            },
            "required": [
                "adminContact",
                "certificateType",
                "commonName",
                "contractId",
                "csr",
                "dnsChallenges",
                "httpChallenges",
                "networkConfiguration",
                "organization",
                "registrationAuthority",
                "secureNetwork",
                "signatureAlgorithm",
                "sniOnly",
                "techContact",
                "validationType"
            ],
            "inputProperties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "allowDuplicateCommonName": {
                    "type": "boolean",
                    "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                    "willReplaceOnChanges": true
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "enableMultiStackedCertificates": {
                    "type": "boolean",
                    "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n",
                    "deprecationMessage": "Deprecated, don't use; always false"
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                    "willReplaceOnChanges": true
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                    "willReplaceOnChanges": true
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                }
            },
            "requiredInputs": [
                "adminContact",
                "commonName",
                "contractId",
                "csr",
                "networkConfiguration",
                "organization",
                "secureNetwork",
                "signatureAlgorithm",
                "sniOnly",
                "techContact"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsDvEnrollment resources.\n",
                "properties": {
                    "acknowledgePreVerificationWarnings": {
                        "type": "boolean",
                        "description": "Whether you want to automatically acknowledge the validation warnings of the current job state and proceed with the execution of a change.\n"
                    },
                    "adminContact": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentAdminContact:CpsDvEnrollmentAdminContact",
                        "description": "Contact information for the certificate administrator at your company.\n"
                    },
                    "allowDuplicateCommonName": {
                        "type": "boolean",
                        "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                    },
                    "certificateChainType": {
                        "type": "string",
                        "description": "Certificate trust chain type.\n"
                    },
                    "certificateType": {
                        "type": "string",
                        "description": "Certificate type of enrollment\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentCsr:CpsDvEnrollmentCsr",
                        "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                    },
                    "dnsChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CpsDvEnrollmentDnsChallenge:CpsDvEnrollmentDnsChallenge"
                        },
                        "description": "DNS challenge information\n"
                    },
                    "enableMultiStackedCertificates": {
                        "type": "boolean",
                        "description": "Whether to enable an ECDSA certificate in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties. If you are pinning the certificates, you need to pin both the RSA and the ECDSA certificate.\n",
                        "deprecationMessage": "Deprecated, don't use; always false"
                    },
                    "httpChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/CpsDvEnrollmentHttpChallenge:CpsDvEnrollmentHttpChallenge"
                        },
                        "description": "HTTP challenge information\n"
                    },
                    "networkConfiguration": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentNetworkConfiguration:CpsDvEnrollmentNetworkConfiguration",
                        "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                    },
                    "organization": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentOrganization:CpsDvEnrollmentOrganization",
                        "description": "Your organization information.\n"
                    },
                    "registrationAuthority": {
                        "type": "string",
                        "description": "The registration authority or certificate authority (CA) used to obtain a certificate\n"
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                    },
                    "secureNetwork": {
                        "type": "string",
                        "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                        "willReplaceOnChanges": true
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "The Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n"
                    },
                    "sniOnly": {
                        "type": "boolean",
                        "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "techContact": {
                        "$ref": "#/types/akamai:index/CpsDvEnrollmentTechContact:CpsDvEnrollmentTechContact",
                        "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                    },
                    "validationType": {
                        "type": "string",
                        "description": "Enrolment validation type\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpsDvValidation:CpsDvValidation": {
            "description": "Once you complete the Let's Encrypt challenges, optionally use the `akamai.CpsDvValidation` resource to send the acknowledgement to CPS and inform it that tokens are ready for validation. You can also wait for CPS to check for the tokens, which it does on a regular schedule. Next, CPS automatically deploys the certificate on Staging, and eventually on the Production network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.CpsDvValidation(\"example\", {\n    enrollmentId: akamai_cps_dv_enrollment.example.id,\n    sans: akamai_cps_dv_enrollment.example.sans,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.CpsDvValidation(\"example\",\n    enrollment_id=akamai_cps_dv_enrollment[\"example\"][\"id\"],\n    sans=akamai_cps_dv_enrollment[\"example\"][\"sans\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.CpsDvValidation(\"example\", new()\n    {\n        EnrollmentId = akamai_cps_dv_enrollment.Example.Id,\n        Sans = akamai_cps_dv_enrollment.Example.Sans,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpsDvValidation(ctx, \"example\", \u0026akamai.CpsDvValidationArgs{\n\t\t\tEnrollmentId: pulumi.Any(akamai_cps_dv_enrollment.Example.Id),\n\t\t\tSans:         pulumi.Any(akamai_cps_dv_enrollment.Example.Sans),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsDvValidation;\nimport com.pulumi.akamai.CpsDvValidationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new CpsDvValidation(\"example\", CpsDvValidationArgs.builder()        \n            .enrollmentId(akamai_cps_dv_enrollment.example().id())\n            .sans(akamai_cps_dv_enrollment.example().sans())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:CpsDvValidation\n    properties:\n      enrollmentId: ${akamai_cps_dv_enrollment.example.id}\n      sans: ${akamai_cps_dv_enrollment.example.sans}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `status` - The status of certificate validation.\n",
            "properties": {
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the DV certificate enrollment.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of validation\n"
                }
            },
            "required": [
                "enrollmentId",
                "status"
            ],
            "inputProperties": {
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the DV certificate enrollment.\n",
                    "willReplaceOnChanges": true
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enrollmentId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsDvValidation resources.\n",
                "properties": {
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier for the DV certificate enrollment.\n",
                        "willReplaceOnChanges": true
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of validation\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpsThirdPartyEnrollment:CpsThirdPartyEnrollment": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst enrollment = new akamai.CpsThirdPartyEnrollment(\"enrollment\", {\n    contractId: \"C-0N7RAC7\",\n    commonName: \"*.example.com\",\n    secureNetwork: \"enhanced-tls\",\n    sniOnly: true,\n    autoApproveWarnings: [\n        \"DNS_NAME_LONGER_THEN_255_CHARS\",\n        \"CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\",\n        \"TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\",\n    ],\n    signatureAlgorithm: \"SHA-256\",\n    adminContact: {\n        firstName: \"Mario\",\n        lastName: \"Rossi\",\n        phone: \"+1-311-555-2368\",\n        email: \"mrossi@example.com\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Example Corp.\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    techContact: {\n        firstName: \"Juan\",\n        lastName: \"Perez\",\n        phone: \"+1-311-555-2369\",\n        email: \"jperez@example.com\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        organization: \"Example Corp.\",\n        postalCode: \"02142\",\n        region: \"MA\",\n        title: \"Administrator\",\n    },\n    csr: {\n        countryCode: \"US\",\n        city: \"Cambridge\",\n        organization: \"Example Corp.\",\n        organizationalUnit: \"Corp IT\",\n        state: \"MA\",\n    },\n    networkConfiguration: {\n        disallowedTlsVersions: [\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        cloneDnsNames: false,\n        geography: \"core\",\n        ocspStapling: \"on\",\n        preferredCiphers: \"ak-akamai-default\",\n        mustHaveCiphers: \"ak-akamai-default\",\n        quicEnabled: false,\n    },\n    organization: {\n        name: \"Example Corp.\",\n        phone: \"+1-311-555-2370\",\n        addressLineOne: \"150 Broadway\",\n        city: \"Cambridge\",\n        countryCode: \"US\",\n        postalCode: \"02142\",\n        region: \"MA\",\n    },\n});\nexport const enrollmentId = enrollment.id;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nenrollment = akamai.CpsThirdPartyEnrollment(\"enrollment\",\n    contract_id=\"C-0N7RAC7\",\n    common_name=\"*.example.com\",\n    secure_network=\"enhanced-tls\",\n    sni_only=True,\n    auto_approve_warnings=[\n        \"DNS_NAME_LONGER_THEN_255_CHARS\",\n        \"CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\",\n        \"TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\",\n    ],\n    signature_algorithm=\"SHA-256\",\n    admin_contact=akamai.CpsThirdPartyEnrollmentAdminContactArgs(\n        first_name=\"Mario\",\n        last_name=\"Rossi\",\n        phone=\"+1-311-555-2368\",\n        email=\"mrossi@example.com\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Example Corp.\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    tech_contact=akamai.CpsThirdPartyEnrollmentTechContactArgs(\n        first_name=\"Juan\",\n        last_name=\"Perez\",\n        phone=\"+1-311-555-2369\",\n        email=\"jperez@example.com\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        organization=\"Example Corp.\",\n        postal_code=\"02142\",\n        region=\"MA\",\n        title=\"Administrator\",\n    ),\n    csr=akamai.CpsThirdPartyEnrollmentCsrArgs(\n        country_code=\"US\",\n        city=\"Cambridge\",\n        organization=\"Example Corp.\",\n        organizational_unit=\"Corp IT\",\n        state=\"MA\",\n    ),\n    network_configuration=akamai.CpsThirdPartyEnrollmentNetworkConfigurationArgs(\n        disallowed_tls_versions=[\n            \"TLSv1\",\n            \"TLSv1_1\",\n        ],\n        clone_dns_names=False,\n        geography=\"core\",\n        ocsp_stapling=\"on\",\n        preferred_ciphers=\"ak-akamai-default\",\n        must_have_ciphers=\"ak-akamai-default\",\n        quic_enabled=False,\n    ),\n    organization=akamai.CpsThirdPartyEnrollmentOrganizationArgs(\n        name=\"Example Corp.\",\n        phone=\"+1-311-555-2370\",\n        address_line_one=\"150 Broadway\",\n        city=\"Cambridge\",\n        country_code=\"US\",\n        postal_code=\"02142\",\n        region=\"MA\",\n    ))\npulumi.export(\"enrollmentId\", enrollment.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var enrollment = new Akamai.CpsThirdPartyEnrollment(\"enrollment\", new()\n    {\n        ContractId = \"C-0N7RAC7\",\n        CommonName = \"*.example.com\",\n        SecureNetwork = \"enhanced-tls\",\n        SniOnly = true,\n        AutoApproveWarnings = new[]\n        {\n            \"DNS_NAME_LONGER_THEN_255_CHARS\",\n            \"CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\",\n            \"TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\",\n        },\n        SignatureAlgorithm = \"SHA-256\",\n        AdminContact = new Akamai.Inputs.CpsThirdPartyEnrollmentAdminContactArgs\n        {\n            FirstName = \"Mario\",\n            LastName = \"Rossi\",\n            Phone = \"+1-311-555-2368\",\n            Email = \"mrossi@example.com\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            Organization = \"Example Corp.\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n            Title = \"Administrator\",\n        },\n        TechContact = new Akamai.Inputs.CpsThirdPartyEnrollmentTechContactArgs\n        {\n            FirstName = \"Juan\",\n            LastName = \"Perez\",\n            Phone = \"+1-311-555-2369\",\n            Email = \"jperez@example.com\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            Organization = \"Example Corp.\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n            Title = \"Administrator\",\n        },\n        Csr = new Akamai.Inputs.CpsThirdPartyEnrollmentCsrArgs\n        {\n            CountryCode = \"US\",\n            City = \"Cambridge\",\n            Organization = \"Example Corp.\",\n            OrganizationalUnit = \"Corp IT\",\n            State = \"MA\",\n        },\n        NetworkConfiguration = new Akamai.Inputs.CpsThirdPartyEnrollmentNetworkConfigurationArgs\n        {\n            DisallowedTlsVersions = new[]\n            {\n                \"TLSv1\",\n                \"TLSv1_1\",\n            },\n            CloneDnsNames = false,\n            Geography = \"core\",\n            OcspStapling = \"on\",\n            PreferredCiphers = \"ak-akamai-default\",\n            MustHaveCiphers = \"ak-akamai-default\",\n            QuicEnabled = false,\n        },\n        Organization = new Akamai.Inputs.CpsThirdPartyEnrollmentOrganizationArgs\n        {\n            Name = \"Example Corp.\",\n            Phone = \"+1-311-555-2370\",\n            AddressLineOne = \"150 Broadway\",\n            City = \"Cambridge\",\n            CountryCode = \"US\",\n            PostalCode = \"02142\",\n            Region = \"MA\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"enrollmentId\"] = enrollment.Id,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tenrollment, err := akamai.NewCpsThirdPartyEnrollment(ctx, \"enrollment\", \u0026akamai.CpsThirdPartyEnrollmentArgs{\n\t\t\tContractId:    pulumi.String(\"C-0N7RAC7\"),\n\t\t\tCommonName:    pulumi.String(\"*.example.com\"),\n\t\t\tSecureNetwork: pulumi.String(\"enhanced-tls\"),\n\t\t\tSniOnly:       pulumi.Bool(true),\n\t\t\tAutoApproveWarnings: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DNS_NAME_LONGER_THEN_255_CHARS\"),\n\t\t\t\tpulumi.String(\"CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\"),\n\t\t\t\tpulumi.String(\"TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\"),\n\t\t\t},\n\t\t\tSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t\tAdminContact: \u0026akamai.CpsThirdPartyEnrollmentAdminContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"Mario\"),\n\t\t\t\tLastName:       pulumi.String(\"Rossi\"),\n\t\t\t\tPhone:          pulumi.String(\"+1-311-555-2368\"),\n\t\t\t\tEmail:          pulumi.String(\"mrossi@example.com\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Example Corp.\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tTechContact: \u0026akamai.CpsThirdPartyEnrollmentTechContactArgs{\n\t\t\t\tFirstName:      pulumi.String(\"Juan\"),\n\t\t\t\tLastName:       pulumi.String(\"Perez\"),\n\t\t\t\tPhone:          pulumi.String(\"+1-311-555-2369\"),\n\t\t\t\tEmail:          pulumi.String(\"jperez@example.com\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tOrganization:   pulumi.String(\"Example Corp.\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t\tTitle:          pulumi.String(\"Administrator\"),\n\t\t\t},\n\t\t\tCsr: \u0026akamai.CpsThirdPartyEnrollmentCsrArgs{\n\t\t\t\tCountryCode:        pulumi.String(\"US\"),\n\t\t\t\tCity:               pulumi.String(\"Cambridge\"),\n\t\t\t\tOrganization:       pulumi.String(\"Example Corp.\"),\n\t\t\t\tOrganizationalUnit: pulumi.String(\"Corp IT\"),\n\t\t\t\tState:              pulumi.String(\"MA\"),\n\t\t\t},\n\t\t\tNetworkConfiguration: \u0026akamai.CpsThirdPartyEnrollmentNetworkConfigurationArgs{\n\t\t\t\tDisallowedTlsVersions: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"TLSv1\"),\n\t\t\t\t\tpulumi.String(\"TLSv1_1\"),\n\t\t\t\t},\n\t\t\t\tCloneDnsNames:    pulumi.Bool(false),\n\t\t\t\tGeography:        pulumi.String(\"core\"),\n\t\t\t\tOcspStapling:     pulumi.String(\"on\"),\n\t\t\t\tPreferredCiphers: pulumi.String(\"ak-akamai-default\"),\n\t\t\t\tMustHaveCiphers:  pulumi.String(\"ak-akamai-default\"),\n\t\t\t\tQuicEnabled:      pulumi.Bool(false),\n\t\t\t},\n\t\t\tOrganization: \u0026akamai.CpsThirdPartyEnrollmentOrganizationArgs{\n\t\t\t\tName:           pulumi.String(\"Example Corp.\"),\n\t\t\t\tPhone:          pulumi.String(\"+1-311-555-2370\"),\n\t\t\t\tAddressLineOne: pulumi.String(\"150 Broadway\"),\n\t\t\t\tCity:           pulumi.String(\"Cambridge\"),\n\t\t\t\tCountryCode:    pulumi.String(\"US\"),\n\t\t\t\tPostalCode:     pulumi.String(\"02142\"),\n\t\t\t\tRegion:         pulumi.String(\"MA\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"enrollmentId\", enrollment.ID())\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsThirdPartyEnrollment;\nimport com.pulumi.akamai.CpsThirdPartyEnrollmentArgs;\nimport com.pulumi.akamai.inputs.CpsThirdPartyEnrollmentAdminContactArgs;\nimport com.pulumi.akamai.inputs.CpsThirdPartyEnrollmentTechContactArgs;\nimport com.pulumi.akamai.inputs.CpsThirdPartyEnrollmentCsrArgs;\nimport com.pulumi.akamai.inputs.CpsThirdPartyEnrollmentNetworkConfigurationArgs;\nimport com.pulumi.akamai.inputs.CpsThirdPartyEnrollmentOrganizationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var enrollment = new CpsThirdPartyEnrollment(\"enrollment\", CpsThirdPartyEnrollmentArgs.builder()        \n            .contractId(\"C-0N7RAC7\")\n            .commonName(\"*.example.com\")\n            .secureNetwork(\"enhanced-tls\")\n            .sniOnly(true)\n            .autoApproveWarnings(            \n                \"DNS_NAME_LONGER_THEN_255_CHARS\",\n                \"CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\",\n                \"TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\")\n            .signatureAlgorithm(\"SHA-256\")\n            .adminContact(CpsThirdPartyEnrollmentAdminContactArgs.builder()\n                .firstName(\"Mario\")\n                .lastName(\"Rossi\")\n                .phone(\"+1-311-555-2368\")\n                .email(\"mrossi@example.com\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Example Corp.\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .techContact(CpsThirdPartyEnrollmentTechContactArgs.builder()\n                .firstName(\"Juan\")\n                .lastName(\"Perez\")\n                .phone(\"+1-311-555-2369\")\n                .email(\"jperez@example.com\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .organization(\"Example Corp.\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .title(\"Administrator\")\n                .build())\n            .csr(CpsThirdPartyEnrollmentCsrArgs.builder()\n                .countryCode(\"US\")\n                .city(\"Cambridge\")\n                .organization(\"Example Corp.\")\n                .organizationalUnit(\"Corp IT\")\n                .state(\"MA\")\n                .build())\n            .networkConfiguration(CpsThirdPartyEnrollmentNetworkConfigurationArgs.builder()\n                .disallowedTlsVersions(                \n                    \"TLSv1\",\n                    \"TLSv1_1\")\n                .cloneDnsNames(false)\n                .geography(\"core\")\n                .ocspStapling(\"on\")\n                .preferredCiphers(\"ak-akamai-default\")\n                .mustHaveCiphers(\"ak-akamai-default\")\n                .quicEnabled(false)\n                .build())\n            .organization(CpsThirdPartyEnrollmentOrganizationArgs.builder()\n                .name(\"Example Corp.\")\n                .phone(\"+1-311-555-2370\")\n                .addressLineOne(\"150 Broadway\")\n                .city(\"Cambridge\")\n                .countryCode(\"US\")\n                .postalCode(\"02142\")\n                .region(\"MA\")\n                .build())\n            .build());\n\n        ctx.export(\"enrollmentId\", enrollment.id());\n    }\n}\n```\n```yaml\nresources:\n  enrollment:\n    type: akamai:CpsThirdPartyEnrollment\n    properties:\n      contractId: C-0N7RAC7\n      commonName: '*.example.com'\n      secureNetwork: enhanced-tls\n      sniOnly: true\n      autoApproveWarnings:\n        - DNS_NAME_LONGER_THEN_255_CHARS\n        - CERTIFICATE_EXPIRATION_DATE_BEYOND_MAX_DAYS\n        - TRUST_CHAIN_EMPTY_AND_CERTIFICATE_SIGNED_BY_NON_STANDARD_ROOT\n      signatureAlgorithm: SHA-256\n      adminContact:\n        firstName: Mario\n        lastName: Rossi\n        phone: +1-311-555-2368\n        email: mrossi@example.com\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Example Corp.\n        postalCode: '02142'\n        region: MA\n        title: Administrator\n      techContact:\n        firstName: Juan\n        lastName: Perez\n        phone: +1-311-555-2369\n        email: jperez@example.com\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        organization: Example Corp.\n        postalCode: '02142'\n        region: MA\n        title: Administrator\n      csr:\n        countryCode: US\n        city: Cambridge\n        organization: Example Corp.\n        organizationalUnit: Corp IT\n        state: MA\n      networkConfiguration:\n        disallowedTlsVersions:\n          - TLSv1\n          - TLSv1_1\n        cloneDnsNames: false\n        geography: core\n        ocspStapling: on\n        preferredCiphers: ak-akamai-default\n        mustHaveCiphers: ak-akamai-default\n        quicEnabled: false\n      organization:\n        name: Example Corp.\n        phone: +1-311-555-2370\n        addressLineOne: 150 Broadway\n        city: Cambridge\n        countryCode: US\n        postalCode: '02142'\n        region: MA\noutputs:\n  enrollmentId: ${enrollment.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThe resource returns this attribute:\n\n* `id` - The unique identifier for this enrollment.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cps_third_party_enrollment\" \"example\" { (resource arguments) } You can import your Akamai third-party enrollment using a comma-delimited string of the enrollment ID and\n\n contract ID, optionally with the `ctr_` prefix. You have to enter the IDs in this order`enrollment_id,contract_id` For example\n\n```sh\n $ pulumi import akamai:index/cpsThirdPartyEnrollment:CpsThirdPartyEnrollment example 12345,1-AB123\n```\n\n ",
            "properties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings related to the current job state and proceed with the change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentAdminContact:CpsThirdPartyEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "allowDuplicateCommonName": {
                    "type": "boolean",
                    "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                },
                "autoApproveWarnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "changeManagement": {
                    "type": "boolean",
                    "description": "Boolean. Set to `true` to have CPS deploy first to staging for testing purposes. To deploy the certificate to production, use the `acknowledge_change_management` argument in the `akamai.CpsUploadCertificate` resource. \u003cbr\u003e If you don't use this option, CPS will automatically deploy the certificate to both networks.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n"
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentCsr:CpsThirdPartyEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "excludeSans": {
                    "type": "boolean",
                    "description": "If set to `true`, then the SANs in the enrollment don't appear in the CSR that you send to your CA.\n"
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentNetworkConfiguration:CpsThirdPartyEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentOrganization:CpsThirdPartyEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The SHA function. Changing this value may require running terraform destroy, terraform apply\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n"
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentTechContact:CpsThirdPartyEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                }
            },
            "required": [
                "adminContact",
                "commonName",
                "contractId",
                "csr",
                "networkConfiguration",
                "organization",
                "secureNetwork",
                "sniOnly",
                "techContact"
            ],
            "inputProperties": {
                "acknowledgePreVerificationWarnings": {
                    "type": "boolean",
                    "description": "Whether you want to automatically acknowledge the validation warnings related to the current job state and proceed with the change.\n"
                },
                "adminContact": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentAdminContact:CpsThirdPartyEnrollmentAdminContact",
                    "description": "Contact information for the certificate administrator at your company.\n"
                },
                "allowDuplicateCommonName": {
                    "type": "boolean",
                    "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                },
                "autoApproveWarnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                },
                "certificateChainType": {
                    "type": "string",
                    "description": "Certificate trust chain type.\n"
                },
                "changeManagement": {
                    "type": "boolean",
                    "description": "Boolean. Set to `true` to have CPS deploy first to staging for testing purposes. To deploy the certificate to production, use the `acknowledge_change_management` argument in the `akamai.CpsUploadCertificate` resource. \u003cbr\u003e If you don't use this option, CPS will automatically deploy the certificate to both networks.\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                    "willReplaceOnChanges": true
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "csr": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentCsr:CpsThirdPartyEnrollmentCsr",
                    "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                },
                "excludeSans": {
                    "type": "boolean",
                    "description": "If set to `true`, then the SANs in the enrollment don't appear in the CSR that you send to your CA.\n"
                },
                "networkConfiguration": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentNetworkConfiguration:CpsThirdPartyEnrollmentNetworkConfiguration",
                    "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                },
                "organization": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentOrganization:CpsThirdPartyEnrollmentOrganization",
                    "description": "Your organization information.\n"
                },
                "sans": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                },
                "secureNetwork": {
                    "type": "string",
                    "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                    "willReplaceOnChanges": true
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The SHA function. Changing this value may require running terraform destroy, terraform apply\n"
                },
                "sniOnly": {
                    "type": "boolean",
                    "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                    "willReplaceOnChanges": true
                },
                "techContact": {
                    "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentTechContact:CpsThirdPartyEnrollmentTechContact",
                    "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                }
            },
            "requiredInputs": [
                "adminContact",
                "commonName",
                "contractId",
                "csr",
                "networkConfiguration",
                "organization",
                "secureNetwork",
                "sniOnly",
                "techContact"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsThirdPartyEnrollment resources.\n",
                "properties": {
                    "acknowledgePreVerificationWarnings": {
                        "type": "boolean",
                        "description": "Whether you want to automatically acknowledge the validation warnings related to the current job state and proceed with the change.\n"
                    },
                    "adminContact": {
                        "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentAdminContact:CpsThirdPartyEnrollmentAdminContact",
                        "description": "Contact information for the certificate administrator at your company.\n"
                    },
                    "allowDuplicateCommonName": {
                        "type": "boolean",
                        "description": "(Optional) Boolean. Set to `true` if you want to reuse a common name that's part of an existing enrollment.\n"
                    },
                    "autoApproveWarnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                    },
                    "certificateChainType": {
                        "type": "string",
                        "description": "Certificate trust chain type.\n"
                    },
                    "changeManagement": {
                        "type": "boolean",
                        "description": "Boolean. Set to `true` to have CPS deploy first to staging for testing purposes. To deploy the certificate to production, use the `acknowledge_change_management` argument in the `akamai.CpsUploadCertificate` resource. \u003cbr\u003e If you don't use this option, CPS will automatically deploy the certificate to both networks.\n"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "(Required) The fully qualified domain name (FQDN) for which you plan to use your certificate. The domain name you specify here must be owned or have legal rights to use the domain by the company you specify as `organization`. The company that owns the domain name must be a legally incorporated entity and be active and in good standing.\n",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's ID, optionally with the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "csr": {
                        "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentCsr:CpsThirdPartyEnrollmentCsr",
                        "description": "When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n"
                    },
                    "excludeSans": {
                        "type": "boolean",
                        "description": "If set to `true`, then the SANs in the enrollment don't appear in the CSR that you send to your CA.\n"
                    },
                    "networkConfiguration": {
                        "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentNetworkConfiguration:CpsThirdPartyEnrollmentNetworkConfiguration",
                        "description": "The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n"
                    },
                    "organization": {
                        "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentOrganization:CpsThirdPartyEnrollmentOrganization",
                        "description": "Your organization information.\n"
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Additional common names to create a Subject Alternative Names (SAN) list.\n"
                    },
                    "secureNetwork": {
                        "type": "string",
                        "description": "The type of deployment network you want to use. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n",
                        "willReplaceOnChanges": true
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "The SHA function. Changing this value may require running terraform destroy, terraform apply\n"
                    },
                    "sniOnly": {
                        "type": "boolean",
                        "description": "Whether you want to enable SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname. You should avoid multiple certificates with overlapping SAN names when using SNI-only. You can't change this setting once an enrollment is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "techContact": {
                        "$ref": "#/types/akamai:index/CpsThirdPartyEnrollmentTechContact:CpsThirdPartyEnrollmentTechContact",
                        "description": "The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/cpsUploadCertificate:CpsUploadCertificate": {
            "description": "Use the `akamai.CpsUploadCertificate` resource to upload a third-party certificate and any other files that your CA sent you into CPS. The certificate and trust chain that your CA gives you must be in PEM format before you can use it in CPS. A PEM certificate is a base64 encoded ASCII file and contains `----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` statements. \n\nIf your CA provides you with a certificate that is not in PEM format, you can convert it to PEM format using an SSL converter.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst uploadCert = new akamai.CpsUploadCertificate(\"uploadCert\", {\n    enrollmentId: 12345,\n    certificateEcdsaPem: example_cert_ecdsa.pem,\n    trustChainEcdsaPem: example_trust_chain_ecdsa.pem,\n    acknowledgePostVerificationWarnings: true,\n    acknowledgeChangeManagement: true,\n    waitForDeployment: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nupload_cert = akamai.CpsUploadCertificate(\"uploadCert\",\n    enrollment_id=12345,\n    certificate_ecdsa_pem=example_cert_ecdsa[\"pem\"],\n    trust_chain_ecdsa_pem=example_trust_chain_ecdsa[\"pem\"],\n    acknowledge_post_verification_warnings=True,\n    acknowledge_change_management=True,\n    wait_for_deployment=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var uploadCert = new Akamai.CpsUploadCertificate(\"uploadCert\", new()\n    {\n        EnrollmentId = 12345,\n        CertificateEcdsaPem = example_cert_ecdsa.Pem,\n        TrustChainEcdsaPem = example_trust_chain_ecdsa.Pem,\n        AcknowledgePostVerificationWarnings = true,\n        AcknowledgeChangeManagement = true,\n        WaitForDeployment = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpsUploadCertificate(ctx, \"uploadCert\", \u0026akamai.CpsUploadCertificateArgs{\n\t\t\tEnrollmentId:                        pulumi.Int(12345),\n\t\t\tCertificateEcdsaPem:                 pulumi.Any(example_cert_ecdsa.Pem),\n\t\t\tTrustChainEcdsaPem:                  pulumi.Any(example_trust_chain_ecdsa.Pem),\n\t\t\tAcknowledgePostVerificationWarnings: pulumi.Bool(true),\n\t\t\tAcknowledgeChangeManagement:         pulumi.Bool(true),\n\t\t\tWaitForDeployment:                   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpsUploadCertificate;\nimport com.pulumi.akamai.CpsUploadCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var uploadCert = new CpsUploadCertificate(\"uploadCert\", CpsUploadCertificateArgs.builder()        \n            .enrollmentId(12345)\n            .certificateEcdsaPem(example_cert_ecdsa.pem())\n            .trustChainEcdsaPem(example_trust_chain_ecdsa.pem())\n            .acknowledgePostVerificationWarnings(true)\n            .acknowledgeChangeManagement(true)\n            .waitForDeployment(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  uploadCert:\n    type: akamai:CpsUploadCertificate\n    properties:\n      enrollmentId: 12345\n      certificateEcdsaPem: ${example_cert_ecdsa.pem}\n      trustChainEcdsaPem: ${example_trust_chain_ecdsa.pem}\n      acknowledgePostVerificationWarnings: true\n      acknowledgeChangeManagement: true\n      waitForDeployment: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acknowledgeChangeManagement": {
                    "type": "boolean",
                    "description": "Boolean. Use only if `change_management` is set to `true` in the `akamai.CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.\n"
                },
                "acknowledgePostVerificationWarnings": {
                    "type": "boolean",
                    "description": "Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.\n"
                },
                "autoApproveWarnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                },
                "certificateEcdsaPem": {
                    "type": "string",
                    "description": "The ECDSA certificate in PEM format you want to upload.\n"
                },
                "certificateRsaPem": {
                    "type": "string",
                    "description": "The RSA certificate in PEM format you want to upload.\n"
                },
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the certificate enrollment.\n* certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.\n"
                },
                "trustChainEcdsaPem": {
                    "type": "string",
                    "description": "The trust chain in PEM format for the ECDSA certificate you want to upload.\n"
                },
                "trustChainRsaPem": {
                    "type": "string",
                    "description": "The trust chain in PEM format for the RSA certificate you want to upload.\n"
                },
                "unacknowledgedWarnings": {
                    "type": "boolean",
                    "description": "Used to distinguish whether there are unacknowledged warnings for a certificate\n"
                },
                "waitForDeployment": {
                    "type": "boolean",
                    "description": "Boolean. Enter `true` to wait for certificate to be deployed.\n"
                }
            },
            "required": [
                "enrollmentId",
                "unacknowledgedWarnings"
            ],
            "inputProperties": {
                "acknowledgeChangeManagement": {
                    "type": "boolean",
                    "description": "Boolean. Use only if `change_management` is set to `true` in the `akamai.CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.\n"
                },
                "acknowledgePostVerificationWarnings": {
                    "type": "boolean",
                    "description": "Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.\n"
                },
                "autoApproveWarnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                },
                "certificateEcdsaPem": {
                    "type": "string",
                    "description": "The ECDSA certificate in PEM format you want to upload.\n"
                },
                "certificateRsaPem": {
                    "type": "string",
                    "description": "The RSA certificate in PEM format you want to upload.\n"
                },
                "enrollmentId": {
                    "type": "integer",
                    "description": "Unique identifier for the certificate enrollment.\n* certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.\n",
                    "willReplaceOnChanges": true
                },
                "trustChainEcdsaPem": {
                    "type": "string",
                    "description": "The trust chain in PEM format for the ECDSA certificate you want to upload.\n"
                },
                "trustChainRsaPem": {
                    "type": "string",
                    "description": "The trust chain in PEM format for the RSA certificate you want to upload.\n"
                },
                "waitForDeployment": {
                    "type": "boolean",
                    "description": "Boolean. Enter `true` to wait for certificate to be deployed.\n"
                }
            },
            "requiredInputs": [
                "enrollmentId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpsUploadCertificate resources.\n",
                "properties": {
                    "acknowledgeChangeManagement": {
                        "type": "boolean",
                        "description": "Boolean. Use only if `change_management` is set to `true` in the `akamai.CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.\n"
                    },
                    "acknowledgePostVerificationWarnings": {
                        "type": "boolean",
                        "description": "Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.\n"
                    },
                    "autoApproveWarnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the `akamai.getCpsWarnings` data source.\n"
                    },
                    "certificateEcdsaPem": {
                        "type": "string",
                        "description": "The ECDSA certificate in PEM format you want to upload.\n"
                    },
                    "certificateRsaPem": {
                        "type": "string",
                        "description": "The RSA certificate in PEM format you want to upload.\n"
                    },
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier for the certificate enrollment.\n* certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.\n",
                        "willReplaceOnChanges": true
                    },
                    "trustChainEcdsaPem": {
                        "type": "string",
                        "description": "The trust chain in PEM format for the ECDSA certificate you want to upload.\n"
                    },
                    "trustChainRsaPem": {
                        "type": "string",
                        "description": "The trust chain in PEM format for the RSA certificate you want to upload.\n"
                    },
                    "unacknowledgedWarnings": {
                        "type": "boolean",
                        "description": "Used to distinguish whether there are unacknowledged warnings for a certificate\n"
                    },
                    "waitForDeployment": {
                        "type": "boolean",
                        "description": "Boolean. Enter `true` to wait for certificate to be deployed.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/datastream:Datastream": {
            "description": "\n\n\n## Import\n\nBasic usagehcl resource \"akamai_datastream\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai DataStream configuration using a stream version ID. For example\n\n```sh\n $ pulumi import akamai:index/datastream:Datastream example 1234\n```\n\n ~\u003e **IMPORTANT:** For security reasons, this command doesn't import any secrets you specify for your connector. To make sure the state file includes complete data, use this resource to manually add the arguments marked **Secret** above. ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                },
                "azureConnector": {
                    "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                    "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                },
                "config": {
                    "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                    "description": "Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "Identifies the contract that has access to the product.\n"
                },
                "createdBy": {
                    "type": "string",
                    "description": "The username who created the stream\n"
                },
                "createdDate": {
                    "type": "string",
                    "description": "The date and time when the stream was created\n"
                },
                "datadogConnector": {
                    "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                    "description": "Specify details about the Datadog connector in a stream, including:\n"
                },
                "datasetFieldsIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                },
                "elasticsearchConnector": {
                    "$ref": "#/types/akamai:index/DatastreamElasticsearchConnector:DatastreamElasticsearchConnector",
                    "description": "Specify details about the Elasticsearch connector you can use in a stream, including:\n"
                },
                "emailIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                },
                "gcsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                    "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Identifies the group that has access to the product and this stream configuration.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the user group for which the stream was created\n"
                },
                "httpsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                    "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                },
                "logglyConnector": {
                    "$ref": "#/types/akamai:index/DatastreamLogglyConnector:DatastreamLogglyConnector",
                    "description": "Specify details about the Loggly connector you can use in a stream, including:\n"
                },
                "modifiedBy": {
                    "type": "string",
                    "description": "The username who modified the stream\n"
                },
                "modifiedDate": {
                    "type": "string",
                    "description": "The date and time when the stream was modified\n"
                },
                "newRelicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamNewRelicConnector:DatastreamNewRelicConnector",
                    "description": "Specify details about the New Relic connector you can use in a stream, including:\n"
                },
                "oracleConnector": {
                    "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                    "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                },
                "papiJson": {
                    "type": "string",
                    "description": "The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior\n"
                },
                "productId": {
                    "type": "string",
                    "description": "The ID of the product for which the stream was created\n"
                },
                "productName": {
                    "type": "string",
                    "description": "The name of the product for which the stream was created\n"
                },
                "propertyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                },
                "s3Connector": {
                    "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                    "description": "Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                },
                "splunkConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                    "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream.\n"
                },
                "streamType": {
                    "type": "string",
                    "description": "The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                },
                "streamVersionId": {
                    "type": "integer",
                    "description": "Identifies the configuration version of the stream\n"
                },
                "sumologicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                    "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                }
            },
            "required": [
                "active",
                "config",
                "contractId",
                "createdBy",
                "createdDate",
                "datasetFieldsIds",
                "groupId",
                "groupName",
                "modifiedBy",
                "modifiedDate",
                "papiJson",
                "productId",
                "productName",
                "propertyIds",
                "streamName",
                "streamType",
                "streamVersionId",
                "templateName"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                },
                "azureConnector": {
                    "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                    "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                },
                "config": {
                    "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                    "description": "Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "Identifies the contract that has access to the product.\n"
                },
                "datadogConnector": {
                    "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                    "description": "Specify details about the Datadog connector in a stream, including:\n"
                },
                "datasetFieldsIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                },
                "elasticsearchConnector": {
                    "$ref": "#/types/akamai:index/DatastreamElasticsearchConnector:DatastreamElasticsearchConnector",
                    "description": "Specify details about the Elasticsearch connector you can use in a stream, including:\n"
                },
                "emailIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                },
                "gcsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                    "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "Identifies the group that has access to the product and this stream configuration.\n"
                },
                "httpsConnector": {
                    "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                    "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                },
                "logglyConnector": {
                    "$ref": "#/types/akamai:index/DatastreamLogglyConnector:DatastreamLogglyConnector",
                    "description": "Specify details about the Loggly connector you can use in a stream, including:\n"
                },
                "newRelicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamNewRelicConnector:DatastreamNewRelicConnector",
                    "description": "Specify details about the New Relic connector you can use in a stream, including:\n"
                },
                "oracleConnector": {
                    "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                    "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                },
                "propertyIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                },
                "s3Connector": {
                    "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                    "description": "Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                },
                "splunkConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                    "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream.\n"
                },
                "streamType": {
                    "type": "string",
                    "description": "The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                },
                "sumologicConnector": {
                    "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                    "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                }
            },
            "requiredInputs": [
                "active",
                "config",
                "contractId",
                "datasetFieldsIds",
                "groupId",
                "propertyIds",
                "streamName",
                "streamType",
                "templateName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datastream resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.\n"
                    },
                    "azureConnector": {
                        "$ref": "#/types/akamai:index/DatastreamAzureConnector:DatastreamAzureConnector",
                        "description": "Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:\n"
                    },
                    "config": {
                        "$ref": "#/types/akamai:index/DatastreamConfig:DatastreamConfig",
                        "description": "Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:\n"
                    },
                    "contractId": {
                        "type": "string",
                        "description": "Identifies the contract that has access to the product.\n"
                    },
                    "createdBy": {
                        "type": "string",
                        "description": "The username who created the stream\n"
                    },
                    "createdDate": {
                        "type": "string",
                        "description": "The date and time when the stream was created\n"
                    },
                    "datadogConnector": {
                        "$ref": "#/types/akamai:index/DatastreamDatadogConnector:DatastreamDatadogConnector",
                        "description": "Specify details about the Datadog connector in a stream, including:\n"
                    },
                    "datasetFieldsIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).\n"
                    },
                    "elasticsearchConnector": {
                        "$ref": "#/types/akamai:index/DatastreamElasticsearchConnector:DatastreamElasticsearchConnector",
                        "description": "Specify details about the Elasticsearch connector you can use in a stream, including:\n"
                    },
                    "emailIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses you want to notify about activations and deactivations of the stream.\n"
                    },
                    "gcsConnector": {
                        "$ref": "#/types/akamai:index/DatastreamGcsConnector:DatastreamGcsConnector",
                        "description": "Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_\u003ctimestamp\u003e.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "Identifies the group that has access to the product and this stream configuration.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the user group for which the stream was created\n"
                    },
                    "httpsConnector": {
                        "$ref": "#/types/akamai:index/DatastreamHttpsConnector:DatastreamHttpsConnector",
                        "description": "Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:\n"
                    },
                    "logglyConnector": {
                        "$ref": "#/types/akamai:index/DatastreamLogglyConnector:DatastreamLogglyConnector",
                        "description": "Specify details about the Loggly connector you can use in a stream, including:\n"
                    },
                    "modifiedBy": {
                        "type": "string",
                        "description": "The username who modified the stream\n"
                    },
                    "modifiedDate": {
                        "type": "string",
                        "description": "The date and time when the stream was modified\n"
                    },
                    "newRelicConnector": {
                        "$ref": "#/types/akamai:index/DatastreamNewRelicConnector:DatastreamNewRelicConnector",
                        "description": "Specify details about the New Relic connector you can use in a stream, including:\n"
                    },
                    "oracleConnector": {
                        "$ref": "#/types/akamai:index/DatastreamOracleConnector:DatastreamOracleConnector",
                        "description": "Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_\u003ctimestamp\u003e.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that you’re trying to send logs to.\n"
                    },
                    "papiJson": {
                        "type": "string",
                        "description": "The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior\n"
                    },
                    "productId": {
                        "type": "string",
                        "description": "The ID of the product for which the stream was created\n"
                    },
                    "productName": {
                        "type": "string",
                        "description": "The name of the product for which the stream was created\n"
                    },
                    "propertyIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.\n"
                    },
                    "s3Connector": {
                        "$ref": "#/types/akamai:index/DatastreamS3Connector:DatastreamS3Connector",
                        "description": "Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that you’re trying to send logs to. The argument includes these sub-arguments:\n"
                    },
                    "splunkConnector": {
                        "$ref": "#/types/akamai:index/DatastreamSplunkConnector:DatastreamSplunkConnector",
                        "description": "Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:\n"
                    },
                    "streamName": {
                        "type": "string",
                        "description": "The name of the stream.\n"
                    },
                    "streamType": {
                        "type": "string",
                        "description": "The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.\n"
                    },
                    "streamVersionId": {
                        "type": "integer",
                        "description": "Identifies the configuration version of the stream\n"
                    },
                    "sumologicConnector": {
                        "$ref": "#/types/akamai:index/DatastreamSumologicConnector:DatastreamSumologicConnector",
                        "description": "Specify details about the Sumo Logic connector in a stream, including:\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/dnsRecord:DnsRecord": {
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "answerType": {
                    "type": "string"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "dnsName": {
                    "type": "string"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordSha": {
                    "type": "string"
                },
                "recordtype": {
                    "type": "string"
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "serial": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string"
                }
            },
            "required": [
                "answerType",
                "dnsName",
                "name",
                "recordSha",
                "recordtype",
                "serial",
                "ttl",
                "zone"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "integer"
                },
                "certificate": {
                    "type": "string"
                },
                "digest": {
                    "type": "string"
                },
                "digestType": {
                    "type": "integer"
                },
                "emailAddress": {
                    "type": "string"
                },
                "expiration": {
                    "type": "string"
                },
                "expiry": {
                    "type": "integer"
                },
                "fingerprint": {
                    "type": "string"
                },
                "fingerprintType": {
                    "type": "integer"
                },
                "flags": {
                    "type": "integer"
                },
                "flagsnaptr": {
                    "type": "string"
                },
                "hardware": {
                    "type": "string"
                },
                "inception": {
                    "type": "string"
                },
                "iterations": {
                    "type": "integer"
                },
                "key": {
                    "type": "string"
                },
                "keytag": {
                    "type": "integer"
                },
                "labels": {
                    "type": "integer"
                },
                "mailbox": {
                    "type": "string"
                },
                "matchType": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "nameServer": {
                    "type": "string"
                },
                "nextHashedOwnerName": {
                    "type": "string"
                },
                "nxdomainTtl": {
                    "type": "integer"
                },
                "order": {
                    "type": "integer"
                },
                "originalTtl": {
                    "type": "integer"
                },
                "port": {
                    "type": "integer"
                },
                "preference": {
                    "type": "integer"
                },
                "priority": {
                    "type": "integer"
                },
                "priorityIncrement": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "integer"
                },
                "recordtype": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "refresh": {
                    "type": "integer"
                },
                "regexp": {
                    "type": "string"
                },
                "replacement": {
                    "type": "string"
                },
                "retry": {
                    "type": "integer"
                },
                "salt": {
                    "type": "string"
                },
                "selector": {
                    "type": "integer"
                },
                "service": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                },
                "signer": {
                    "type": "string"
                },
                "software": {
                    "type": "string"
                },
                "subtype": {
                    "type": "integer"
                },
                "svcParams": {
                    "type": "string"
                },
                "svcPriority": {
                    "type": "integer"
                },
                "targetName": {
                    "type": "string"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ttl": {
                    "type": "integer"
                },
                "txt": {
                    "type": "string"
                },
                "typeBitmaps": {
                    "type": "string"
                },
                "typeCovered": {
                    "type": "string"
                },
                "typeMnemonic": {
                    "type": "string"
                },
                "typeValue": {
                    "type": "integer"
                },
                "usage": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "recordtype",
                "ttl",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsRecord resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "algorithm": {
                        "type": "integer"
                    },
                    "answerType": {
                        "type": "string"
                    },
                    "certificate": {
                        "type": "string"
                    },
                    "digest": {
                        "type": "string"
                    },
                    "digestType": {
                        "type": "integer"
                    },
                    "dnsName": {
                        "type": "string"
                    },
                    "emailAddress": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string"
                    },
                    "expiry": {
                        "type": "integer"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "fingerprintType": {
                        "type": "integer"
                    },
                    "flags": {
                        "type": "integer"
                    },
                    "flagsnaptr": {
                        "type": "string"
                    },
                    "hardware": {
                        "type": "string"
                    },
                    "inception": {
                        "type": "string"
                    },
                    "iterations": {
                        "type": "integer"
                    },
                    "key": {
                        "type": "string"
                    },
                    "keytag": {
                        "type": "integer"
                    },
                    "labels": {
                        "type": "integer"
                    },
                    "mailbox": {
                        "type": "string"
                    },
                    "matchType": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "nameServer": {
                        "type": "string"
                    },
                    "nextHashedOwnerName": {
                        "type": "string"
                    },
                    "nxdomainTtl": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "integer"
                    },
                    "originalTtl": {
                        "type": "integer"
                    },
                    "port": {
                        "type": "integer"
                    },
                    "preference": {
                        "type": "integer"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "priorityIncrement": {
                        "type": "integer"
                    },
                    "protocol": {
                        "type": "integer"
                    },
                    "recordSha": {
                        "type": "string"
                    },
                    "recordtype": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "refresh": {
                        "type": "integer"
                    },
                    "regexp": {
                        "type": "string"
                    },
                    "replacement": {
                        "type": "string"
                    },
                    "retry": {
                        "type": "integer"
                    },
                    "salt": {
                        "type": "string"
                    },
                    "selector": {
                        "type": "integer"
                    },
                    "serial": {
                        "type": "integer"
                    },
                    "service": {
                        "type": "string"
                    },
                    "signature": {
                        "type": "string"
                    },
                    "signer": {
                        "type": "string"
                    },
                    "software": {
                        "type": "string"
                    },
                    "subtype": {
                        "type": "integer"
                    },
                    "svcParams": {
                        "type": "string"
                    },
                    "svcPriority": {
                        "type": "integer"
                    },
                    "targetName": {
                        "type": "string"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ttl": {
                        "type": "integer"
                    },
                    "txt": {
                        "type": "string"
                    },
                    "typeBitmaps": {
                        "type": "string"
                    },
                    "typeCovered": {
                        "type": "string"
                    },
                    "typeMnemonic": {
                        "type": "string"
                    },
                    "typeValue": {
                        "type": "integer"
                    },
                    "usage": {
                        "type": "integer"
                    },
                    "weight": {
                        "type": "integer"
                    },
                    "zone": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:edgedns/dnsRecord:DnsRecord"
                }
            ]
        },
        "akamai:index/dnsZone:DnsZone": {
            "properties": {
                "activationState": {
                    "type": "string"
                },
                "aliasCount": {
                    "type": "integer"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n"
                },
                "versionId": {
                    "type": "string"
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "required": [
                "activationState",
                "aliasCount",
                "contract",
                "type",
                "versionId",
                "zone"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "A descriptive comment.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "The contract ID.\n"
                },
                "endCustomerId": {
                    "type": "string",
                    "description": "A free form identifier for the zone.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The currently selected group ID.\n"
                },
                "masters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                },
                "signAndServe": {
                    "type": "boolean",
                    "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                },
                "signAndServeAlgorithm": {
                    "type": "string",
                    "description": "The algorithm used by Sign and Serve.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The name of the zone whose configuration this zone will copy.\n"
                },
                "tsigKey": {
                    "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                    "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                    "willReplaceOnChanges": true
                },
                "zone": {
                    "type": "string",
                    "description": "The domain zone, encapsulating any nested subdomains.\n"
                }
            },
            "requiredInputs": [
                "contract",
                "type",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsZone resources.\n",
                "properties": {
                    "activationState": {
                        "type": "string"
                    },
                    "aliasCount": {
                        "type": "integer"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive comment.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    },
                    "endCustomerId": {
                        "type": "string",
                        "description": "A free form identifier for the zone.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The currently selected group ID.\n"
                    },
                    "masters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The names or IP addresses of the nameservers that the zone data should be retrieved from.\n"
                    },
                    "signAndServe": {
                        "type": "boolean",
                        "description": "Whether DNSSEC Sign and Serve is enabled.\n"
                    },
                    "signAndServeAlgorithm": {
                        "type": "string",
                        "description": "The algorithm used by Sign and Serve.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The name of the zone whose configuration this zone will copy.\n"
                    },
                    "tsigKey": {
                        "$ref": "#/types/akamai:index/DnsZoneTsigKey:DnsZoneTsigKey",
                        "description": "The TSIG Key used in secure zone transfers. If used, requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Whether the zone is `primary`, `secondary`, or `alias`.\n",
                        "willReplaceOnChanges": true
                    },
                    "versionId": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The domain zone, encapsulating any nested subdomains.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:edgedns/dnsZone:DnsZone"
                }
            ]
        },
        "akamai:index/edgeHostName:EdgeHostName": {
            "description": "The `akamai.EdgeHostName` resource lets you configure a secure edge hostname. Your\nedge hostname determines how requests for your site, app, or content are mapped to\nAkamai edge servers.\n\nAn edge hostname is the CNAME target you use when directing your end user traffic to\nAkamai. Each hostname assigned to a property has a corresponding edge hostname.\n\nAkamai supports three types of edge hostnames, depending on the level of security\nyou need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When\nentering the `edge_hostname` attribute, you need to include a specific domain suffix\nfor your edge hostname type:\n\n| Edge hostname type | Domain suffix |\n|------|-------|\n| Enhanced TLS | edgekey.net |\n| Standard TLS | edgesuite.net |\n| Shared Cert | akamaized.net |\n\nFor example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See  [Create a new edge hostname](https://techdocs.akamai.com/property-mgr/reference/post-edgehostnames) in the Property Manager API (PAPI) for more information. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst provider_demo = new akamai.EdgeHostName(\"provider-demo\", {\n    contractId: \"ctr_1-AB123\",\n    edgeHostname: \"www.example.org.edgesuite.net\",\n    groupId: \"grp_123\",\n    ipBehavior: \"IPV4\",\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nprovider_demo = akamai.EdgeHostName(\"provider-demo\",\n    contract_id=\"ctr_1-AB123\",\n    edge_hostname=\"www.example.org.edgesuite.net\",\n    group_id=\"grp_123\",\n    ip_behavior=\"IPV4\",\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var provider_demo = new Akamai.EdgeHostName(\"provider-demo\", new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        EdgeHostname = \"www.example.org.edgesuite.net\",\n        GroupId = \"grp_123\",\n        IpBehavior = \"IPV4\",\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeHostName(ctx, \"provider-demo\", \u0026akamai.EdgeHostNameArgs{\n\t\t\tContractId:   pulumi.String(\"ctr_1-AB123\"),\n\t\t\tEdgeHostname: pulumi.String(\"www.example.org.edgesuite.net\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tIpBehavior:   pulumi.String(\"IPV4\"),\n\t\t\tProductId:    pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeHostName;\nimport com.pulumi.akamai.EdgeHostNameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var provider_demo = new EdgeHostName(\"provider-demo\", EdgeHostNameArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .edgeHostname(\"www.example.org.edgesuite.net\")\n            .groupId(\"grp_123\")\n            .ipBehavior(\"IPV4\")\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  provider-demo:\n    type: akamai:EdgeHostName\n    properties:\n      contractId: ctr_1-AB123\n      edgeHostname: www.example.org.edgesuite.net\n      groupId: grp_123\n      ipBehavior: IPV4\n      productId: prd_Object_Delivery\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE` for version 6, or `IPV6_COMPLIANCE` for both.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_edge_hostname\" \"example\" {\n\n # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:\n\n`edge_hostname, contract_id, group_id` For example\n\n```sh\n $ pulumi import akamai:index/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n"
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n"
                }
            },
            "required": [
                "contract",
                "contractId",
                "edgeHostname",
                "group",
                "groupId",
                "ipBehavior",
                "product",
                "productId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                    "willReplaceOnChanges": true
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeHostname",
                "ipBehavior"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeHostName resources.\n",
                "properties": {
                    "certificate": {
                        "type": "integer",
                        "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                        "willReplaceOnChanges": true
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "edgeHostname": {
                        "type": "string",
                        "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "ipBehavior": {
                        "type": "string",
                        "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    },
                    "statusUpdateEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                    },
                    "useCases": {
                        "type": "string",
                        "description": "A JSON encoded list of use cases.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/edgeHostName:EdgeHostName"
                }
            ]
        },
        "akamai:index/edgeKv:EdgeKv": {
            "description": "The `akamai.EdgeKv` resource lets you control EdgeKV database functions outside EdgeWorkers JavaScript code. Refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/welcome-to-edgekv) for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst testStaging = new akamai.EdgeKv(\"testStaging\", {\n    geoLocation: \"US\",\n    groupId: 4284,\n    initialDatas: [{\n        group: \"translations\",\n        key: \"lang\",\n        value: \"English\",\n    }],\n    namespaceName: \"Marketing\",\n    network: \"staging\",\n    retentionInSeconds: 15724800,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest_staging = akamai.EdgeKv(\"testStaging\",\n    geo_location=\"US\",\n    group_id=4284,\n    initial_datas=[akamai.EdgeKvInitialDataArgs(\n        group=\"translations\",\n        key=\"lang\",\n        value=\"English\",\n    )],\n    namespace_name=\"Marketing\",\n    network=\"staging\",\n    retention_in_seconds=15724800)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testStaging = new Akamai.EdgeKv(\"testStaging\", new()\n    {\n        GeoLocation = \"US\",\n        GroupId = 4284,\n        InitialDatas = new[]\n        {\n            new Akamai.Inputs.EdgeKvInitialDataArgs\n            {\n                Group = \"translations\",\n                Key = \"lang\",\n                Value = \"English\",\n            },\n        },\n        NamespaceName = \"Marketing\",\n        Network = \"staging\",\n        RetentionInSeconds = 15724800,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeKv(ctx, \"testStaging\", \u0026akamai.EdgeKvArgs{\n\t\t\tGeoLocation: pulumi.String(\"US\"),\n\t\t\tGroupId:     pulumi.Int(4284),\n\t\t\tInitialDatas: akamai.EdgeKvInitialDataArray{\n\t\t\t\t\u0026akamai.EdgeKvInitialDataArgs{\n\t\t\t\t\tGroup: pulumi.String(\"translations\"),\n\t\t\t\t\tKey:   pulumi.String(\"lang\"),\n\t\t\t\t\tValue: pulumi.String(\"English\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tNamespaceName:      pulumi.String(\"Marketing\"),\n\t\t\tNetwork:            pulumi.String(\"staging\"),\n\t\t\tRetentionInSeconds: pulumi.Int(15724800),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeKv;\nimport com.pulumi.akamai.EdgeKvArgs;\nimport com.pulumi.akamai.inputs.EdgeKvInitialDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testStaging = new EdgeKv(\"testStaging\", EdgeKvArgs.builder()        \n            .geoLocation(\"US\")\n            .groupId(4284)\n            .initialDatas(EdgeKvInitialDataArgs.builder()\n                .group(\"translations\")\n                .key(\"lang\")\n                .value(\"English\")\n                .build())\n            .namespaceName(\"Marketing\")\n            .network(\"staging\")\n            .retentionInSeconds(15724800)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testStaging:\n    type: akamai:EdgeKv\n    properties:\n      geoLocation: US\n      groupId: 4284\n      initialDatas:\n        - group: translations\n          key: lang\n          value: English\n      namespaceName: Marketing\n      network: staging\n      retentionInSeconds: 1.57248e+07\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThere are no supported arguments for this resource.\n",
            "properties": {
                "geoLocation": {
                    "type": "string",
                    "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "(Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n"
                },
                "initialDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                    },
                    "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                },
                "namespaceName": {
                    "type": "string",
                    "description": "(Required) The name of the namespace.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "retentionInSeconds": {
                    "type": "integer",
                    "description": "(Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                }
            },
            "required": [
                "groupId",
                "namespaceName",
                "network",
                "retentionInSeconds"
            ],
            "inputProperties": {
                "geoLocation": {
                    "type": "string",
                    "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "integer",
                    "description": "(Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n",
                    "willReplaceOnChanges": true
                },
                "initialDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                    },
                    "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                },
                "namespaceName": {
                    "type": "string",
                    "description": "(Required) The name of the namespace.\n",
                    "willReplaceOnChanges": true
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInSeconds": {
                    "type": "integer",
                    "description": "(Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "namespaceName",
                "network",
                "retentionInSeconds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeKv resources.\n",
                "properties": {
                    "geoLocation": {
                        "type": "string",
                        "description": "Storage location for data when creating a namespace on the production network. This can help optimize performance by storing data where most or all of your users are located. The value defaults to `US` on the `STAGING` and `PRODUCTION` networks. For a list of supported geoLocations on the `PRODUCTION` network refer to the [EdgeKV documentation](https://techdocs.akamai.com/edgekv/docs/edgekv-data-model#namespace).\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "(Required) The `group ID` for the EdgeKV namespace. This numeric value will be required in the next EdgeKV API version.\n",
                        "willReplaceOnChanges": true
                    },
                    "initialDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/EdgeKvInitialData:EdgeKvInitialData"
                        },
                        "description": "List of key-value pairs called items to initialize the namespace. These items are valid only for database creation, updates are ignored.\n"
                    },
                    "namespaceName": {
                        "type": "string",
                        "description": "(Required) The name of the namespace.\n",
                        "willReplaceOnChanges": true
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the EdgeKV database on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n",
                        "willReplaceOnChanges": true
                    },
                    "retentionInSeconds": {
                        "type": "integer",
                        "description": "(Required) Retention period for data in this namespace, or 0 for indefinite. An update of this value will just affect new EdgeKV items.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/edgeWorker:EdgeWorker": {
            "description": "The `akamai.EdgeWorker` resource lets you deploy custom code on thousands of edge servers and apply logic that creates powerful web experiences.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst ew = new akamai.EdgeWorker(\"ew\", {\n    groupId: 72297,\n    resourceTierId: 100,\n    localBundle: _var.bundle_path,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\new = akamai.EdgeWorker(\"ew\",\n    group_id=72297,\n    resource_tier_id=100,\n    local_bundle=var[\"bundle_path\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ew = new Akamai.EdgeWorker(\"ew\", new()\n    {\n        GroupId = 72297,\n        ResourceTierId = 100,\n        LocalBundle = @var.Bundle_path,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeWorker(ctx, \"ew\", \u0026akamai.EdgeWorkerArgs{\n\t\t\tGroupId:        pulumi.Int(72297),\n\t\t\tResourceTierId: pulumi.Int(100),\n\t\t\tLocalBundle:    pulumi.Any(_var.Bundle_path),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeWorker;\nimport com.pulumi.akamai.EdgeWorkerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ew = new EdgeWorker(\"ew\", EdgeWorkerArgs.builder()        \n            .groupId(72297)\n            .resourceTierId(100)\n            .localBundle(var_.bundle_path())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ew:\n    type: akamai:EdgeWorker\n    properties:\n      groupId: 72297\n      resourceTierId: 100\n      localBundle: ${var.bundle_path}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `edgeworker_id` - Unique identifier for an EdgeWorker ID.\n* `local_bundle_hash` - A SHA-256 hash digest of the EdgeWorkers code bundle.\n* `version` - Unique identifier for a specific EdgeWorker version.\n* `warnings` - List of validation warnings.\n",
            "properties": {
                "edgeworkerId": {
                    "type": "integer",
                    "description": "The unique identifier of the EdgeWorker\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "(Required) Identifies a group to assign to the EdgeWorker ID.\n"
                },
                "localBundle": {
                    "type": "string",
                    "description": "(Optional) The path to the EdgeWorkers code bundle.\n"
                },
                "localBundleHash": {
                    "type": "string",
                    "description": "The local bundle hash for the EdgeWorker\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) The name of the EdgeWorker ID.\n"
                },
                "resourceTierId": {
                    "type": "integer",
                    "description": "(Required) Unique identifier of the resource tier.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The bundle version\n"
                },
                "warnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of warnings returned by EdgeWorker validation\n"
                }
            },
            "required": [
                "edgeworkerId",
                "groupId",
                "localBundleHash",
                "name",
                "resourceTierId",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "integer",
                    "description": "(Required) Identifies a group to assign to the EdgeWorker ID.\n"
                },
                "localBundle": {
                    "type": "string",
                    "description": "(Optional) The path to the EdgeWorkers code bundle.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) The name of the EdgeWorker ID.\n"
                },
                "resourceTierId": {
                    "type": "integer",
                    "description": "(Required) Unique identifier of the resource tier.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId",
                "resourceTierId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeWorker resources.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "The unique identifier of the EdgeWorker\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "(Required) Identifies a group to assign to the EdgeWorker ID.\n"
                    },
                    "localBundle": {
                        "type": "string",
                        "description": "(Optional) The path to the EdgeWorkers code bundle.\n"
                    },
                    "localBundleHash": {
                        "type": "string",
                        "description": "The local bundle hash for the EdgeWorker\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "(Required) The name of the EdgeWorker ID.\n"
                    },
                    "resourceTierId": {
                        "type": "integer",
                        "description": "(Required) Unique identifier of the resource tier.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The bundle version\n"
                    },
                    "warnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of warnings returned by EdgeWorker validation\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/edgeWorkersActivation:EdgeWorkersActivation": {
            "description": "Use the `akamai.EdgeWorkersActivation` resource to activate a specific EdgeWorker version. An activation deploys the version to either the Akamai staging or production network.\n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst test = new akamai.EdgeWorkersActivation(\"test\", {\n    edgeworkerId: 1234,\n    network: \"STAGING\",\n    version: \"test1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest = akamai.EdgeWorkersActivation(\"test\",\n    edgeworker_id=1234,\n    network=\"STAGING\",\n    version=\"test1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Akamai.EdgeWorkersActivation(\"test\", new()\n    {\n        EdgeworkerId = 1234,\n        Network = \"STAGING\",\n        Version = \"test1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeWorkersActivation(ctx, \"test\", \u0026akamai.EdgeWorkersActivationArgs{\n\t\t\tEdgeworkerId: pulumi.Int(1234),\n\t\t\tNetwork:      pulumi.String(\"STAGING\"),\n\t\t\tVersion:      pulumi.String(\"test1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeWorkersActivation;\nimport com.pulumi.akamai.EdgeWorkersActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EdgeWorkersActivation(\"test\", EdgeWorkersActivationArgs.builder()        \n            .edgeworkerId(1234)\n            .network(\"STAGING\")\n            .version(\"test1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: akamai:EdgeWorkersActivation\n    properties:\n      edgeworkerId: 1234\n      network: STAGING\n      version: test1\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "integer",
                    "description": "(Required) Unique identifier of the activation.\n"
                },
                "edgeworkerId": {
                    "type": "integer",
                    "description": "A unique identifier for the EdgeWorker ID you want to activate.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The EdgeWorker version you want to activate.\n"
                }
            },
            "required": [
                "activationId",
                "edgeworkerId",
                "network",
                "version"
            ],
            "inputProperties": {
                "edgeworkerId": {
                    "type": "integer",
                    "description": "A unique identifier for the EdgeWorker ID you want to activate.\n",
                    "willReplaceOnChanges": true
                },
                "network": {
                    "type": "string",
                    "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The EdgeWorker version you want to activate.\n"
                }
            },
            "requiredInputs": [
                "edgeworkerId",
                "network",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeWorkersActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "integer",
                        "description": "(Required) Unique identifier of the activation.\n"
                    },
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "A unique identifier for the EdgeWorker ID you want to activate.\n",
                        "willReplaceOnChanges": true
                    },
                    "network": {
                        "type": "string",
                        "description": "The network you want to activate the policy version on. For the Staging network, specify either `STAGING`, `STAG`, or `S`. For the Production network, specify either `PRODUCTION`, `PROD`, or `P`. All values are case insensitive.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The EdgeWorker version you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/gtmAsmap:GtmAsmap": {
            "description": "Use the `akamai.GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.\n\nYou can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoAsmap = new akamai.GtmAsmap(\"demoAsmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other AS numbers\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_asmap = akamai.GtmAsmap(\"demoAsmap\",\n    default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other AS numbers\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoAsmap = new Akamai.GtmAsmap(\"demoAsmap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmAsmapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Other AS numbers\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmAsmap(ctx, \"demoAsmap\", \u0026akamai.GtmAsmapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmAsmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other AS numbers\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmAsmap;\nimport com.pulumi.akamai.GtmAsmapArgs;\nimport com.pulumi.akamai.inputs.GtmAsmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoAsmap = new GtmAsmap(\"demoAsmap\", GtmAsmapArgs.builder()        \n            .defaultDatacenter(GtmAsmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other AS numbers\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoAsmap:\n    type: akamai:GtmAsmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other AS numbers\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmAsmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmAsmapAssignment:GtmAsmapAssignment"
                        },
                        "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmAsmapDefaultDatacenter:GtmAsmapDefaultDatacenter",
                        "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM Domain name for the AS map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmASmap:GtmASmap"
                }
            ]
        },
        "akamai:index/gtmCidrmap:GtmCidrmap": {
            "description": "Use the `akamai.GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).\n\n CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoCidrmap = new akamai.GtmCidrmap(\"demoCidrmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other CIDR Blocks\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_cidrmap = akamai.GtmCidrmap(\"demoCidrmap\",\n    default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other CIDR Blocks\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoCidrmap = new Akamai.GtmCidrmap(\"demoCidrmap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmCidrmapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Other CIDR Blocks\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmCidrmap(ctx, \"demoCidrmap\", \u0026akamai.GtmCidrmapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmCidrmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other CIDR Blocks\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmCidrmap;\nimport com.pulumi.akamai.GtmCidrmapArgs;\nimport com.pulumi.akamai.inputs.GtmCidrmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoCidrmap = new GtmCidrmap(\"demoCidrmap\", GtmCidrmapArgs.builder()        \n            .defaultDatacenter(GtmCidrmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other CIDR Blocks\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoCidrmap:\n    type: akamai:GtmCidrmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other CIDR Blocks\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the CIDR Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the CIDR Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmCidrmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmCidrmapAssignment:GtmCidrmapAssignment"
                        },
                        "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                        "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the CIDR Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmCidrmap:GtmCidrmap"
                }
            ]
        },
        "akamai:index/gtmDatacenter:GtmDatacenter": {
            "description": "Use the `akamai.GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.\n\nGTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoDatacenter = new akamai.GtmDatacenter(\"demoDatacenter\", {\n    domain: \"demo_domain.akadns.net\",\n    nickname: \"demo_datacenter\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_datacenter = akamai.GtmDatacenter(\"demoDatacenter\",\n    domain=\"demo_domain.akadns.net\",\n    nickname=\"demo_datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoDatacenter = new Akamai.GtmDatacenter(\"demoDatacenter\", new()\n    {\n        Domain = \"demo_domain.akadns.net\",\n        Nickname = \"demo_datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDatacenter(ctx, \"demoDatacenter\", \u0026akamai.GtmDatacenterArgs{\n\t\t\tDomain:   pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tNickname: pulumi.String(\"demo_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDatacenter;\nimport com.pulumi.akamai.GtmDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoDatacenter = new GtmDatacenter(\"demoDatacenter\", GtmDatacenterArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .nickname(\"demo_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoDatacenter:\n    type: akamai:GtmDatacenter\n    properties:\n      domain: demo_domain.akadns.net\n      nickname: demo_datacenter\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "scorePenalty": {
                    "type": "integer"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "virtual": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "datacenterId",
                "domain",
                "pingInterval",
                "pingPacketSize",
                "scorePenalty",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "virtual"
            ],
            "inputProperties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDatacenter resources.\n",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The name of the city where the data center is located.\n"
                    },
                    "cloneOf": {
                        "type": "integer",
                        "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                    },
                    "cloudServerHostHeaderOverride": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                    },
                    "cloudServerTargeting": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                    },
                    "continent": {
                        "type": "string",
                        "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                    },
                    "datacenterId": {
                        "type": "integer",
                        "description": "A unique identifier for an existing data center in the domain.\n"
                    },
                    "defaultLoadObject": {
                        "$ref": "#/types/akamai:index/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                        "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM domain name for the data center.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                    },
                    "nickname": {
                        "type": "string",
                        "description": "A descriptive label for the data center.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "scorePenalty": {
                        "type": "integer"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "stateOrProvince": {
                        "type": "string",
                        "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                    },
                    "virtual": {
                        "type": "boolean",
                        "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmDatacenter:GtmDatacenter"
                }
            ]
        },
        "akamai:index/gtmDomain:GtmDomain": {
            "description": "Use the `akamai.GtmDomain` resource to create, configure, and import a GTM Domain, which is a basic building block of a traffic management configuration.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demodomain = new akamai.GtmDomain(\"demodomain\", {\n    comment: \"some comment\",\n    contract: \"XXX\",\n    group: \"100\",\n    type: \"basic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemodomain = akamai.GtmDomain(\"demodomain\",\n    comment=\"some comment\",\n    contract=\"XXX\",\n    group=\"100\",\n    type=\"basic\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demodomain = new Akamai.GtmDomain(\"demodomain\", new()\n    {\n        Comment = \"some comment\",\n        Contract = \"XXX\",\n        Group = \"100\",\n        Type = \"basic\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDomain(ctx, \"demodomain\", \u0026akamai.GtmDomainArgs{\n\t\t\tComment:  pulumi.String(\"some comment\"),\n\t\t\tContract: pulumi.String(\"XXX\"),\n\t\t\tGroup:    pulumi.String(\"100\"),\n\t\t\tType:     pulumi.String(\"basic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDomain;\nimport com.pulumi.akamai.GtmDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demodomain = new GtmDomain(\"demodomain\", GtmDomainArgs.builder()        \n            .comment(\"some comment\")\n            .contract(\"XXX\")\n            .group(100)\n            .type(\"basic\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demodomain:\n    type: akamai:GtmDomain\n    properties:\n      comment: some comment\n      contract: XXX\n      group: 100\n      type: basic\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultHealthMax": {
                    "type": "number"
                },
                "defaultHealthMultiplier": {
                    "type": "number"
                },
                "defaultHealthThreshold": {
                    "type": "number"
                },
                "defaultMaxUnreachablePenalty": {
                    "type": "integer"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "defaultUnreachableThreshold": {
                    "type": "number"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "mapUpdateInterval": {
                    "type": "integer"
                },
                "maxProperties": {
                    "type": "integer"
                },
                "maxResources": {
                    "type": "integer"
                },
                "maxTestTimeout": {
                    "type": "number"
                },
                "maxTtl": {
                    "type": "integer"
                },
                "minPingableRegionFraction": {
                    "type": "number"
                },
                "minTestInterval": {
                    "type": "integer"
                },
                "minTtl": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "roundRobinPrefix": {
                    "type": "string"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultHealthMax",
                "defaultHealthMultiplier",
                "defaultHealthThreshold",
                "defaultMaxUnreachablePenalty",
                "defaultUnreachableThreshold",
                "mapUpdateInterval",
                "maxProperties",
                "maxResources",
                "maxTestTimeout",
                "maxTtl",
                "minPingableRegionFraction",
                "minTestInterval",
                "minTtl",
                "name",
                "pingInterval",
                "pingPacketSize",
                "roundRobinPrefix",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "type"
            ],
            "inputProperties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDomain resources.\n",
                "properties": {
                    "cnameCoalescingEnabled": {
                        "type": "boolean",
                        "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "If creating a domain, the contract ID.\n"
                    },
                    "defaultErrorPenalty": {
                        "type": "integer",
                        "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                    },
                    "defaultHealthMax": {
                        "type": "number"
                    },
                    "defaultHealthMultiplier": {
                        "type": "number"
                    },
                    "defaultHealthThreshold": {
                        "type": "number"
                    },
                    "defaultMaxUnreachablePenalty": {
                        "type": "integer"
                    },
                    "defaultSslClientCertificate": {
                        "type": "string",
                        "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                    },
                    "defaultSslClientPrivateKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                    },
                    "defaultTimeoutPenalty": {
                        "type": "integer",
                        "description": "Specifies the timeout penalty score. Default is `25`.\n"
                    },
                    "defaultUnreachableThreshold": {
                        "type": "number"
                    },
                    "emailNotificationLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses to notify when a change is made to the domain.\n"
                    },
                    "endUserMappingEnabled": {
                        "type": "boolean",
                        "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "If creating a domain, the currently selected group ID.\n"
                    },
                    "loadFeedback": {
                        "type": "boolean",
                        "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                    },
                    "mapUpdateInterval": {
                        "type": "integer"
                    },
                    "maxProperties": {
                        "type": "integer"
                    },
                    "maxResources": {
                        "type": "integer"
                    },
                    "maxTestTimeout": {
                        "type": "number"
                    },
                    "maxTtl": {
                        "type": "integer"
                    },
                    "minPingableRegionFraction": {
                        "type": "number"
                    },
                    "minTestInterval": {
                        "type": "integer"
                    },
                    "minTtl": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS name for a collection of GTM Properties.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "roundRobinPrefix": {
                        "type": "string"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmDomain:GtmDomain"
                }
            ]
        },
        "akamai:index/gtmGeomap:GtmGeomap": {
            "description": "Use the `akamai.GtmGeomap` resource to create, configure, and import a GTM Geographic map. Geographic mapping lets you configure a property that returns a CNAME based on the geographic location of the request.\n\nYou can reuse maps for multiple properties or create new ones. To configure a property for geographic mapping, you need to define at least one geographic map for your domain. Each map needs at least two definitions. For example, you can have one definition that maps a set of countries to a specific data center, and a second definition that routes all other traffic.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoGeomap = new akamai.GtmGeomap(\"demoGeomap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Others\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_geomap = akamai.GtmGeomap(\"demoGeomap\",\n    default_datacenter=akamai.GtmGeomapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Others\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoGeomap = new Akamai.GtmGeomap(\"demoGeomap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmGeomapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Others\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmGeomap(ctx, \"demoGeomap\", \u0026akamai.GtmGeomapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmGeomapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Others\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmGeomap;\nimport com.pulumi.akamai.GtmGeomapArgs;\nimport com.pulumi.akamai.inputs.GtmGeomapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoGeomap = new GtmGeomap(\"demoGeomap\", GtmGeomapArgs.builder()        \n            .defaultDatacenter(GtmGeomapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Others\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoGeomap:\n    type: akamai:GtmGeomap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Others\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmGeomap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmGeomapAssignment:GtmGeomapAssignment"
                        },
                        "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:index/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                        "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the Geographic Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the Geographic map.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmGeomap:GtmGeomap"
                }
            ]
        },
        "akamai:index/gtmProperty:GtmProperty": {
            "description": "Use the `akamai.GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoProperty = new akamai.GtmProperty(\"demoProperty\", {\n    domain: \"demo_domain.akadns.net\",\n    handoutLimit: 5,\n    handoutMode: \"normal\",\n    scoreAggregationType: \"median\",\n    trafficTargets: [{\n        datacenterId: 3131,\n    }],\n    type: \"weighted-round-robin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_property = akamai.GtmProperty(\"demoProperty\",\n    domain=\"demo_domain.akadns.net\",\n    handout_limit=5,\n    handout_mode=\"normal\",\n    score_aggregation_type=\"median\",\n    traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(\n        datacenter_id=3131,\n    )],\n    type=\"weighted-round-robin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoProperty = new Akamai.GtmProperty(\"demoProperty\", new()\n    {\n        Domain = \"demo_domain.akadns.net\",\n        HandoutLimit = 5,\n        HandoutMode = \"normal\",\n        ScoreAggregationType = \"median\",\n        TrafficTargets = new[]\n        {\n            new Akamai.Inputs.GtmPropertyTrafficTargetArgs\n            {\n                DatacenterId = 3131,\n            },\n        },\n        Type = \"weighted-round-robin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmProperty(ctx, \"demoProperty\", \u0026akamai.GtmPropertyArgs{\n\t\t\tDomain:               pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tHandoutLimit:         pulumi.Int(5),\n\t\t\tHandoutMode:          pulumi.String(\"normal\"),\n\t\t\tScoreAggregationType: pulumi.String(\"median\"),\n\t\t\tTrafficTargets: akamai.GtmPropertyTrafficTargetArray{\n\t\t\t\t\u0026akamai.GtmPropertyTrafficTargetArgs{\n\t\t\t\t\tDatacenterId: pulumi.Int(3131),\n\t\t\t\t},\n\t\t\t},\n\t\t\tType: pulumi.String(\"weighted-round-robin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmProperty;\nimport com.pulumi.akamai.GtmPropertyArgs;\nimport com.pulumi.akamai.inputs.GtmPropertyTrafficTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoProperty = new GtmProperty(\"demoProperty\", GtmPropertyArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .handoutLimit(5)\n            .handoutMode(\"normal\")\n            .scoreAggregationType(\"median\")\n            .trafficTargets(GtmPropertyTrafficTargetArgs.builder()\n                .datacenterId(3131)\n                .build())\n            .type(\"weighted-round-robin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoProperty:\n    type: akamai:GtmProperty\n    properties:\n      domain: demo_domain.akadns.net\n      handoutLimit: 5\n      handoutMode: normal\n      scoreAggregationType: median\n      trafficTargets:\n        - datacenterId: 3131\n      type: weighted-round-robin\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                },
                "weightedHashBitsForIpv4": {
                    "type": "integer"
                },
                "weightedHashBitsForIpv6": {
                    "type": "integer"
                }
            },
            "required": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "name",
                "scoreAggregationType",
                "type",
                "weightedHashBitsForIpv4",
                "weightedHashBitsForIpv6"
            ],
            "inputProperties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "scoreAggregationType",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmProperty resources.\n",
                "properties": {
                    "backupCname": {
                        "type": "string",
                        "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                    },
                    "backupIp": {
                        "type": "string",
                        "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                    },
                    "balanceByDownloadScore": {
                        "type": "boolean",
                        "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Indicates the fully qualified name aliased to a particular property.\n"
                    },
                    "comments": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this Property.\n"
                    },
                    "dynamicTtl": {
                        "type": "integer",
                        "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                    },
                    "failbackDelay": {
                        "type": "integer",
                        "description": "Specifies the failback delay in seconds.\n"
                    },
                    "failoverDelay": {
                        "type": "integer",
                        "description": "Specifies the failover delay in seconds.\n"
                    },
                    "ghostDemandReporting": {
                        "type": "boolean",
                        "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                    },
                    "handoutLimit": {
                        "type": "integer",
                        "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                    },
                    "handoutMode": {
                        "type": "string",
                        "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                    },
                    "healthMax": {
                        "type": "number",
                        "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                    },
                    "healthMultiplier": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "healthThreshold": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "ipv6": {
                        "type": "boolean",
                        "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                    },
                    "livenessTests": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                        },
                        "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                    },
                    "mapName": {
                        "type": "string",
                        "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                    },
                    "maxUnreachablePenalty": {
                        "type": "integer",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                    },
                    "minLiveFraction": {
                        "type": "number",
                        "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of HTTP header.\n"
                    },
                    "scoreAggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                    },
                    "staticRrSets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                        },
                        "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                    },
                    "staticTtl": {
                        "type": "integer"
                    },
                    "stickinessBonusConstant": {
                        "type": "integer",
                        "description": "Specifies a constant used to configure data center affinity.\n"
                    },
                    "stickinessBonusPercentage": {
                        "type": "integer",
                        "description": "Specifies a percentage used to configure data center affinity.\n"
                    },
                    "trafficTargets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                        },
                        "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The record type.\n"
                    },
                    "unreachableThreshold": {
                        "type": "number",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                    },
                    "useComputedTargets": {
                        "type": "boolean",
                        "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    },
                    "weightedHashBitsForIpv4": {
                        "type": "integer"
                    },
                    "weightedHashBitsForIpv6": {
                        "type": "integer"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmProperty:GtmProperty"
                }
            ]
        },
        "akamai:index/gtmResource:GtmResource": {
            "description": "The `akamai.GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:\n`existing_resource_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoResource = new akamai.GtmResource(\"demoResource\", {\n    aggregationType: \"latest\",\n    domain: \"demo_domain.akadns.net\",\n    type: \"XML load object via HTTP\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_resource = akamai.GtmResource(\"demoResource\",\n    aggregation_type=\"latest\",\n    domain=\"demo_domain.akadns.net\",\n    type=\"XML load object via HTTP\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoResource = new Akamai.GtmResource(\"demoResource\", new()\n    {\n        AggregationType = \"latest\",\n        Domain = \"demo_domain.akadns.net\",\n        Type = \"XML load object via HTTP\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmResource(ctx, \"demoResource\", \u0026akamai.GtmResourceArgs{\n\t\t\tAggregationType: pulumi.String(\"latest\"),\n\t\t\tDomain:          pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tType:            pulumi.String(\"XML load object via HTTP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmResource;\nimport com.pulumi.akamai.GtmResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoResource = new GtmResource(\"demoResource\", GtmResourceArgs.builder()        \n            .aggregationType(\"latest\")\n            .domain(\"demo_domain.akadns.net\")\n            .type(\"XML load object via HTTP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoResource:\n    type: akamai:GtmResource\n    properties:\n      aggregationType: latest\n      domain: demo_domain.akadns.net\n      type: XML load object via HTTP\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "aggregationType",
                "domain",
                "name",
                "type"
            ],
            "inputProperties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "aggregationType",
                "domain",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmResource resources.\n",
                "properties": {
                    "aggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                    },
                    "constrainedProperty": {
                        "type": "string",
                        "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                    },
                    "decayRate": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A descriptive note to help you track what the resource constrains.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this property.\n"
                    },
                    "hostHeader": {
                        "type": "string",
                        "description": "Optionally specifies the host header used when fetching the load object.\n"
                    },
                    "leaderString": {
                        "type": "string",
                        "description": "Specifies the text that comes before the `load_object`.\n"
                    },
                    "leastSquaresDecay": {
                        "type": "number",
                        "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number"
                    },
                    "maxUMultiplicativeIncrement": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the GTM resource.\n"
                    },
                    "resourceInstances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/GtmResourceResourceInstance:GtmResourceResourceInstance"
                        },
                        "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                    },
                    "upperBound": {
                        "type": "integer",
                        "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:trafficmanagement/gtmResource:GtmResource"
                }
            ]
        },
        "akamai:index/iamBlockedUserProperties:IamBlockedUserProperties": {
            "description": "Use the `akamai.IamBlockedUserProperties` resource to remove or grant access to properties. Administrators can block a user's access to any property, overriding any available role already assigned to that user.\n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamBlockedUserProperties(\"example\", {\n    blockedProperties: [\n        1,\n        2,\n        3,\n        4,\n        5,\n    ],\n    groupId: 12345,\n    identityId: \"A-B-123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamBlockedUserProperties(\"example\",\n    blocked_properties=[\n        1,\n        2,\n        3,\n        4,\n        5,\n    ],\n    group_id=12345,\n    identity_id=\"A-B-123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.IamBlockedUserProperties(\"example\", new()\n    {\n        BlockedProperties = new[]\n        {\n            1,\n            2,\n            3,\n            4,\n            5,\n        },\n        GroupId = 12345,\n        IdentityId = \"A-B-123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamBlockedUserProperties(ctx, \"example\", \u0026akamai.IamBlockedUserPropertiesArgs{\n\t\t\tBlockedProperties: pulumi.IntArray{\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(2),\n\t\t\t\tpulumi.Int(3),\n\t\t\t\tpulumi.Int(4),\n\t\t\t\tpulumi.Int(5),\n\t\t\t},\n\t\t\tGroupId:    pulumi.Int(12345),\n\t\t\tIdentityId: pulumi.String(\"A-B-123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamBlockedUserProperties;\nimport com.pulumi.akamai.IamBlockedUserPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamBlockedUserProperties(\"example\", IamBlockedUserPropertiesArgs.builder()        \n            .blockedProperties(            \n                1,\n                2,\n                3,\n                4,\n                5)\n            .groupId(12345)\n            .identityId(\"A-B-123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamBlockedUserProperties\n    properties:\n      blockedProperties:\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n      groupId: 12345\n      identityId: A-B-123456\n```\n\n## Attributes reference\n\nThis resource doesn't return any attributes.\n",
            "properties": {
                "blockedProperties": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "A unique identifier for a group. Each identifier must be an integer.\n"
                },
                "identityId": {
                    "type": "string",
                    "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                }
            },
            "required": [
                "blockedProperties",
                "groupId",
                "identityId"
            ],
            "inputProperties": {
                "blockedProperties": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "A unique identifier for a group. Each identifier must be an integer.\n",
                    "willReplaceOnChanges": true
                },
                "identityId": {
                    "type": "string",
                    "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                }
            },
            "requiredInputs": [
                "blockedProperties",
                "groupId",
                "identityId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamBlockedUserProperties resources.\n",
                "properties": {
                    "blockedProperties": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of properties to block for a user. The property IDs must be an integer.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "A unique identifier for a group. Each identifier must be an integer.\n",
                        "willReplaceOnChanges": true
                    },
                    "identityId": {
                        "type": "string",
                        "description": "A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamGroup:IamGroup": {
            "description": "Use the `akamai.IamGroup` resource to list details about groups. Groups are organizational containers for the objects you use.  Groups can contain other groups, primary objects like properties, and secondary objects like edge hostnames or content provider (CP) codes.\n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamGroup(\"example\", {parentGroupId: 12345});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamGroup(\"example\", parent_group_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.IamGroup(\"example\", new()\n    {\n        ParentGroupId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamGroup(ctx, \"example\", \u0026akamai.IamGroupArgs{\n\t\t\tParentGroupId: pulumi.Int(12345),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamGroup;\nimport com.pulumi.akamai.IamGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamGroup(\"example\", IamGroupArgs.builder()        \n            .parentGroupId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamGroup\n    properties:\n      parentGroupId: 12345\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `sub_groups` - Sub-groups that are related to this group. Each identifier must be an integer.\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Human readable name for a group.\n"
                },
                "parentGroupId": {
                    "type": "integer",
                    "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                },
                "subGroups": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Subgroups IDs\n"
                }
            },
            "required": [
                "name",
                "parentGroupId",
                "subGroups"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Human readable name for a group.\n"
                },
                "parentGroupId": {
                    "type": "integer",
                    "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                }
            },
            "requiredInputs": [
                "parentGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamGroup resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Human readable name for a group.\n"
                    },
                    "parentGroupId": {
                        "type": "integer",
                        "description": "A unique identifier for the parent group. Each identifier must be an integer.\n"
                    },
                    "subGroups": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Subgroups IDs\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamRole:IamRole": {
            "description": "Use the `akamai.IamRole` resource to list and create roles for users. Roles are lists of permissions that are explicitly tied to both a user and a group. Users need roles to act on objects in a group.\n\n## Basic usage\n\nThis example returns information on available roles:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.IamRole(\"example\", {\n    description: \"This role will allow you to view\",\n    grantedRoles: 2051,\n    type: \"custom\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.IamRole(\"example\",\n    description=\"This role will allow you to view\",\n    granted_roles=2051,\n    type=\"custom\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.IamRole(\"example\", new()\n    {\n        Description = \"This role will allow you to view\",\n        GrantedRoles = 2051,\n        Type = \"custom\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamRole(ctx, \"example\", \u0026akamai.IamRoleArgs{\n\t\t\tDescription:  pulumi.String(\"This role will allow you to view\"),\n\t\t\tGrantedRoles: pulumi.IntArray(2051),\n\t\t\tType:         pulumi.String(\"custom\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamRole;\nimport com.pulumi.akamai.IamRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IamRole(\"example\", IamRoleArgs.builder()        \n            .description(\"This role will allow you to view\")\n            .grantedRoles(2051)\n            .type(\"custom\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:IamRole\n    properties:\n      description: This role will allow you to view\n      grantedRoles: 2051\n      type: custom\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `type` - The type indicates whether the role is `standard`, provided by Akamai, or `custom` for the account.\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description for a role.\n"
                },
                "grantedRoles": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name you supply for a role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                }
            },
            "required": [
                "description",
                "grantedRoles",
                "name",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description for a role.\n"
                },
                "grantedRoles": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name you supply for a role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                }
            },
            "requiredInputs": [
                "description",
                "grantedRoles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamRole resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description for a role.\n"
                    },
                    "grantedRoles": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name you supply for a role.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/iamUser:IamUser": {
            "description": "The `akamai.IamUser` resource represents a user on the Akamai platform.\n\n## Basic usage\n\nThis example shows how to set up a user:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst exampleUser = new akamai.IamUser(\"exampleUser\", {\n    authGrantsJson: \"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n    country: \"Grenada\",\n    email: \"jperez@example.com\",\n    enableTfa: false,\n    firstName: \"Juan\",\n    lastName: \"Perez\",\n    phone: \"+1 206-555-0100\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample_user = akamai.IamUser(\"exampleUser\",\n    auth_grants_json=\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n    country=\"Grenada\",\n    email=\"jperez@example.com\",\n    enable_tfa=False,\n    first_name=\"Juan\",\n    last_name=\"Perez\",\n    phone=\"+1 206-555-0100\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleUser = new Akamai.IamUser(\"exampleUser\", new()\n    {\n        AuthGrantsJson = \"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\",\n        Country = \"Grenada\",\n        Email = \"jperez@example.com\",\n        EnableTfa = false,\n        FirstName = \"Juan\",\n        LastName = \"Perez\",\n        Phone = \"+1 206-555-0100\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewIamUser(ctx, \"exampleUser\", \u0026akamai.IamUserArgs{\n\t\t\tAuthGrantsJson: pulumi.String(\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\"),\n\t\t\tCountry:        pulumi.String(\"Grenada\"),\n\t\t\tEmail:          pulumi.String(\"jperez@example.com\"),\n\t\t\tEnableTfa:      pulumi.Bool(false),\n\t\t\tFirstName:      pulumi.String(\"Juan\"),\n\t\t\tLastName:       pulumi.String(\"Perez\"),\n\t\t\tPhone:          pulumi.String(\"+1 206-555-0100\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.IamUser;\nimport com.pulumi.akamai.IamUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleUser = new IamUser(\"exampleUser\", IamUserArgs.builder()        \n            .authGrantsJson(\"[{\\\"groupId\\\":18451,\\\"roleId\\\":14},{\\\"groupId\\\":18453,\\\"roleId\\\":13}]\")\n            .country(\"Grenada\")\n            .email(\"jperez@example.com\")\n            .enableTfa(false)\n            .firstName(\"Juan\")\n            .lastName(\"Perez\")\n            .phone(\"+1 206-555-0100\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUser:\n    type: akamai:IamUser\n    properties:\n      authGrantsJson: '[{\"groupId\":18451,\"roleId\":14},{\"groupId\":18453,\"roleId\":13}]'\n      country: Grenada\n      email: jperez@example.com\n      enableTfa: false\n      firstName: Juan\n      lastName: Perez\n      phone: +1 206-555-0100\n```\n\n## Attributes reference\n\nThis resource returns these attributes:\n\n* `session_timeout` - The number of seconds it takes for the user's session to time out if there hasn't been any activity.\n* `user_name` - A user's `loginId`. Typically, a user's email address.\n* `is_locked` - The user's lock status.\n* `last_login` - ISO 8601 timestamp indicating when the user last logged in.\n* `password_expired_after` - The date a user's password expires.\n* `tfa_configured` - Indicates whether two-factor authentication is configured.\n* `email_update_pending` - Indicates whether email update is pending.\n* `lock` - (Optional) Flag to block as user account.\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The user's street address.\n"
                },
                "authGrantsJson": {
                    "type": "string",
                    "description": "A user's per-group role assignments, in JSON form.\n"
                },
                "city": {
                    "type": "string",
                    "description": "The user's city.\n"
                },
                "contactType": {
                    "type": "string",
                    "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                },
                "country": {
                    "type": "string",
                    "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email address.\n"
                },
                "emailUpdatePending": {
                    "type": "boolean",
                    "description": "Indicates whether email update is pending\n"
                },
                "enableTfa": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is allowed.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "isLocked": {
                    "type": "boolean",
                    "description": "The user's lock status.\n",
                    "deprecationMessage": "The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead"
                },
                "jobTitle": {
                    "type": "string",
                    "description": "The user's position at your company\n"
                },
                "lastLogin": {
                    "type": "string",
                    "description": "ISO 8601 timestamp indicating when the user last logged in\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "lock": {
                    "type": "boolean",
                    "description": "Flag to block a user account\n"
                },
                "mobilePhone": {
                    "type": "string",
                    "description": "The user's mobile phone number.\n"
                },
                "passwordExpiredAfter": {
                    "type": "string",
                    "description": "The date a user's password expires\n"
                },
                "phone": {
                    "type": "string",
                    "description": "The user's main phone number.\n"
                },
                "preferredLanguage": {
                    "type": "string",
                    "description": "The value can be any that are available from the view-languages operation\n"
                },
                "secondaryEmail": {
                    "type": "string",
                    "description": "The user's secondary email address.\n"
                },
                "sessionTimeout": {
                    "type": "integer",
                    "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                },
                "state": {
                    "type": "string",
                    "description": "The user's state.\n"
                },
                "tfaConfigured": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is configured\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                },
                "userName": {
                    "type": "string",
                    "description": "A user's `loginId`. Typically, a user's email address\n"
                },
                "zipCode": {
                    "type": "string",
                    "description": "The user's five-digit ZIP code.\n"
                }
            },
            "required": [
                "address",
                "authGrantsJson",
                "contactType",
                "country",
                "email",
                "emailUpdatePending",
                "enableTfa",
                "firstName",
                "isLocked",
                "lastLogin",
                "lastName",
                "passwordExpiredAfter",
                "phone",
                "preferredLanguage",
                "sessionTimeout",
                "tfaConfigured",
                "timeZone",
                "userName"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The user's street address.\n"
                },
                "authGrantsJson": {
                    "type": "string",
                    "description": "A user's per-group role assignments, in JSON form.\n"
                },
                "city": {
                    "type": "string",
                    "description": "The user's city.\n"
                },
                "contactType": {
                    "type": "string",
                    "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                },
                "country": {
                    "type": "string",
                    "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email address.\n"
                },
                "enableTfa": {
                    "type": "boolean",
                    "description": "Indicates whether two-factor authentication is allowed.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "jobTitle": {
                    "type": "string",
                    "description": "The user's position at your company\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "lock": {
                    "type": "boolean",
                    "description": "Flag to block a user account\n"
                },
                "mobilePhone": {
                    "type": "string",
                    "description": "The user's mobile phone number.\n"
                },
                "phone": {
                    "type": "string",
                    "description": "The user's main phone number.\n"
                },
                "preferredLanguage": {
                    "type": "string",
                    "description": "The value can be any that are available from the view-languages operation\n"
                },
                "secondaryEmail": {
                    "type": "string",
                    "description": "The user's secondary email address.\n"
                },
                "sessionTimeout": {
                    "type": "integer",
                    "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                },
                "state": {
                    "type": "string",
                    "description": "The user's state.\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                },
                "zipCode": {
                    "type": "string",
                    "description": "The user's five-digit ZIP code.\n"
                }
            },
            "requiredInputs": [
                "authGrantsJson",
                "country",
                "email",
                "enableTfa",
                "firstName",
                "lastName",
                "phone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IamUser resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The user's street address.\n"
                    },
                    "authGrantsJson": {
                        "type": "string",
                        "description": "A user's per-group role assignments, in JSON form.\n"
                    },
                    "city": {
                        "type": "string",
                        "description": "The user's city.\n"
                    },
                    "contactType": {
                        "type": "string",
                        "description": "To help characterize the user, the value can be any that are available from the view-contact-types operation.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "As part of the user's location, the value can be any that are available from the view-supported-countries operation.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The user's email address.\n"
                    },
                    "emailUpdatePending": {
                        "type": "boolean",
                        "description": "Indicates whether email update is pending\n"
                    },
                    "enableTfa": {
                        "type": "boolean",
                        "description": "Indicates whether two-factor authentication is allowed.\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The user's first name.\n"
                    },
                    "isLocked": {
                        "type": "boolean",
                        "description": "The user's lock status.\n",
                        "deprecationMessage": "The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead"
                    },
                    "jobTitle": {
                        "type": "string",
                        "description": "The user's position at your company\n"
                    },
                    "lastLogin": {
                        "type": "string",
                        "description": "ISO 8601 timestamp indicating when the user last logged in\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "The user's last name.\n"
                    },
                    "lock": {
                        "type": "boolean",
                        "description": "Flag to block a user account\n"
                    },
                    "mobilePhone": {
                        "type": "string",
                        "description": "The user's mobile phone number.\n"
                    },
                    "passwordExpiredAfter": {
                        "type": "string",
                        "description": "The date a user's password expires\n"
                    },
                    "phone": {
                        "type": "string",
                        "description": "The user's main phone number.\n"
                    },
                    "preferredLanguage": {
                        "type": "string",
                        "description": "The value can be any that are available from the view-languages operation\n"
                    },
                    "secondaryEmail": {
                        "type": "string",
                        "description": "The user's secondary email address.\n"
                    },
                    "sessionTimeout": {
                        "type": "integer",
                        "description": "The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The user's state.\n"
                    },
                    "tfaConfigured": {
                        "type": "boolean",
                        "description": "Indicates whether two-factor authentication is configured\n"
                    },
                    "timeZone": {
                        "type": "string",
                        "description": "The user's time zone. The value can be any that are available from the view-time-zones operation\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "A user's `loginId`. Typically, a user's email address\n"
                    },
                    "zipCode": {
                        "type": "string",
                        "description": "The user's five-digit ZIP code.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkList:NetworkList": {
            "description": "Use the `akamai.NetworkList` resource to create a network list, or to modify an existing list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkList = new akamai.NetworkList(\"networkList\", {\n    type: \"IP\",\n    description: \"network list description\",\n    lists: _var.list,\n    mode: \"APPEND\",\n    contractId: \"ABC-123\",\n    groupId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_list = akamai.NetworkList(\"networkList\",\n    type=\"IP\",\n    description=\"network list description\",\n    lists=var[\"list\"],\n    mode=\"APPEND\",\n    contract_id=\"ABC-123\",\n    group_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkList = new Akamai.NetworkList(\"networkList\", new()\n    {\n        Type = \"IP\",\n        Description = \"network list description\",\n        Lists = @var.List,\n        Mode = \"APPEND\",\n        ContractId = \"ABC-123\",\n        GroupId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewNetworkList(ctx, \"networkList\", \u0026akamai.NetworkListArgs{\n\t\t\tType:        pulumi.String(\"IP\"),\n\t\t\tDescription: pulumi.String(\"network list description\"),\n\t\t\tLists:       pulumi.Any(_var.List),\n\t\t\tMode:        pulumi.String(\"APPEND\"),\n\t\t\tContractId:  pulumi.String(\"ABC-123\"),\n\t\t\tGroupId:     pulumi.Int(12345),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.NetworkList;\nimport com.pulumi.akamai.NetworkListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var networkList = new NetworkList(\"networkList\", NetworkListArgs.builder()        \n            .type(\"IP\")\n            .description(\"network list description\")\n            .lists(var_.list())\n            .mode(\"APPEND\")\n            .contractId(\"ABC-123\")\n            .groupId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  networkList:\n    type: akamai:NetworkList\n    properties:\n      type: IP\n      description: network list description\n      lists: ${var.list}\n      mode: APPEND\n      contractId: ABC-123\n      groupId: 12345\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "contractId": {
                    "type": "string",
                    "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list.\n"
                },
                "syncPoint": {
                    "type": "integer",
                    "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                },
                "uniqueid": {
                    "type": "string",
                    "description": "unique ID\n"
                }
            },
            "required": [
                "description",
                "mode",
                "name",
                "networkListId",
                "syncPoint",
                "type",
                "uniqueid"
            ],
            "inputProperties": {
                "contractId": {
                    "type": "string",
                    "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                }
            },
            "requiredInputs": [
                "description",
                "mode",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkList resources.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "The contract ID of the network list. If supplied, group_id must also be supplied. The\ncontract_id value of an existing network list may not be modified.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description to be assigned to the network list.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The group ID of the network list. If supplied, contract_id must also be supplied. The\ngroup_id value of an existing network list may not be modified.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses or locations to be included in the list, added to an existing list, or\nremoved from an existing list.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "A string specifying the interpretation of the `list` parameter. Must be one of the following:\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to be assigned to the network list.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of the network list.\n"
                    },
                    "syncPoint": {
                        "type": "integer",
                        "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the network list; must be either \"IP\" or \"GEO\".\n"
                    },
                    "uniqueid": {
                        "type": "string",
                        "description": "unique ID\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListActivations:NetworkListActivations": {
            "description": "Use the `akamai.NetworkListActivations` resource to activate a network list in either the STAGING or PRODUCTION\nenvironment.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListIp = new akamai.NetworkList(\"networkListIp\", {\n    type: \"IP\",\n    description: \"IP network list\",\n    lists: _var.ip_list,\n    mode: \"REPLACE\",\n});\nconst activation = new akamai.NetworkListActivations(\"activation\", {\n    networkListId: resource.akamai_networklist_network_list.network_list_ip.network_list_id,\n    network: \"STAGING\",\n    syncPoint: resource.akamai_networklist_network_list.network_list_ip.sync_point,\n    notes: \"TEST Notes\",\n    notificationEmails: [\"user@example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_list_ip = akamai.NetworkList(\"networkListIp\",\n    type=\"IP\",\n    description=\"IP network list\",\n    lists=var[\"ip_list\"],\n    mode=\"REPLACE\")\nactivation = akamai.NetworkListActivations(\"activation\",\n    network_list_id=resource[\"akamai_networklist_network_list\"][\"network_list_ip\"][\"network_list_id\"],\n    network=\"STAGING\",\n    sync_point=resource[\"akamai_networklist_network_list\"][\"network_list_ip\"][\"sync_point\"],\n    notes=\"TEST Notes\",\n    notification_emails=[\"user@example.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkListIp = new Akamai.NetworkList(\"networkListIp\", new()\n    {\n        Type = \"IP\",\n        Description = \"IP network list\",\n        Lists = @var.Ip_list,\n        Mode = \"REPLACE\",\n    });\n\n    var activation = new Akamai.NetworkListActivations(\"activation\", new()\n    {\n        NetworkListId = resource.Akamai_networklist_network_list.Network_list_ip.Network_list_id,\n        Network = \"STAGING\",\n        SyncPoint = resource.Akamai_networklist_network_list.Network_list_ip.Sync_point,\n        Notes = \"TEST Notes\",\n        NotificationEmails = new[]\n        {\n            \"user@example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewNetworkList(ctx, \"networkListIp\", \u0026akamai.NetworkListArgs{\n\t\t\tType:        pulumi.String(\"IP\"),\n\t\t\tDescription: pulumi.String(\"IP network list\"),\n\t\t\tLists:       pulumi.Any(_var.Ip_list),\n\t\t\tMode:        pulumi.String(\"REPLACE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewNetworkListActivations(ctx, \"activation\", \u0026akamai.NetworkListActivationsArgs{\n\t\t\tNetworkListId: pulumi.Any(resource.Akamai_networklist_network_list.Network_list_ip.Network_list_id),\n\t\t\tNetwork:       pulumi.String(\"STAGING\"),\n\t\t\tSyncPoint:     pulumi.Any(resource.Akamai_networklist_network_list.Network_list_ip.Sync_point),\n\t\t\tNotes:         pulumi.String(\"TEST Notes\"),\n\t\t\tNotificationEmails: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user@example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.NetworkList;\nimport com.pulumi.akamai.NetworkListArgs;\nimport com.pulumi.akamai.NetworkListActivations;\nimport com.pulumi.akamai.NetworkListActivationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var networkListIp = new NetworkList(\"networkListIp\", NetworkListArgs.builder()        \n            .type(\"IP\")\n            .description(\"IP network list\")\n            .lists(var_.ip_list())\n            .mode(\"REPLACE\")\n            .build());\n\n        var activation = new NetworkListActivations(\"activation\", NetworkListActivationsArgs.builder()        \n            .networkListId(resource.akamai_networklist_network_list().network_list_ip().network_list_id())\n            .network(\"STAGING\")\n            .syncPoint(resource.akamai_networklist_network_list().network_list_ip().sync_point())\n            .notes(\"TEST Notes\")\n            .notificationEmails(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  networkListIp:\n    type: akamai:NetworkList\n    properties:\n      type: IP\n      description: IP network list\n      lists: ${var.ip_list}\n      mode: REPLACE\n  activation:\n    type: akamai:NetworkListActivations\n    properties:\n      networkListId: ${resource.akamai_networklist_network_list.network_list_ip.network_list_id}\n      network: STAGING\n      syncPoint: ${resource.akamai_networklist_network_list.network_list_ip.sync_point}\n      notes: TEST Notes\n      notificationEmails:\n        - user@example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activate": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"activate\" has been deprecated."
                },
                "network": {
                    "type": "string",
                    "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list to be activated\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A comment describing the activation.\n"
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network\nlist was not activated.\n"
                },
                "syncPoint": {
                    "type": "integer",
                    "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                }
            },
            "required": [
                "networkListId",
                "notificationEmails",
                "status",
                "syncPoint"
            ],
            "inputProperties": {
                "activate": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"activate\" has been deprecated."
                },
                "network": {
                    "type": "string",
                    "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The ID of the network list to be activated\n",
                    "willReplaceOnChanges": true
                },
                "notes": {
                    "type": "string",
                    "description": "A comment describing the activation.\n"
                },
                "notificationEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                },
                "syncPoint": {
                    "type": "integer",
                    "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                }
            },
            "requiredInputs": [
                "networkListId",
                "notificationEmails",
                "syncPoint"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListActivations resources.\n",
                "properties": {
                    "activate": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"activate\" has been deprecated."
                    },
                    "network": {
                        "type": "string",
                        "description": "The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to\n`STAGING`.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of the network list to be activated\n",
                        "willReplaceOnChanges": true
                    },
                    "notes": {
                        "type": "string",
                        "description": "A comment describing the activation.\n"
                    },
                    "notificationEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A bracketed, comma-separated list of email addresses that will be notified when the\noperation is complete.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network\nlist was not activated.\n"
                    },
                    "syncPoint": {
                        "type": "integer",
                        "description": "An integer that identifies the current version of the network list; this value is incremented each time\nthe list is modified.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListDescription:NetworkListDescription": {
            "description": "Use the `akamai.NetworkListDescription` resource to update the name or description of an existing network list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListDescription = new akamai.NetworkListDescription(\"networkListDescription\", {\n    networkListId: _var.network_list_id,\n    description: \"Test network list updated description\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_list_description = akamai.NetworkListDescription(\"networkListDescription\",\n    network_list_id=var[\"network_list_id\"],\n    description=\"Test network list updated description\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkListDescription = new Akamai.NetworkListDescription(\"networkListDescription\", new()\n    {\n        NetworkListId = @var.Network_list_id,\n        Description = \"Test network list updated description\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewNetworkListDescription(ctx, \"networkListDescription\", \u0026akamai.NetworkListDescriptionArgs{\n\t\t\tNetworkListId: pulumi.Any(_var.Network_list_id),\n\t\t\tDescription:   pulumi.String(\"Test network list updated description\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.NetworkListDescription;\nimport com.pulumi.akamai.NetworkListDescriptionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var networkListDescription = new NetworkListDescription(\"networkListDescription\", NetworkListDescriptionArgs.builder()        \n            .networkListId(var_.network_list_id())\n            .description(\"Test network list updated description\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  networkListDescription:\n    type: akamai:NetworkListDescription\n    properties:\n      networkListId: ${var.network_list_id}\n      description: Test network list updated description\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The unique ID of the network list to use.\n"
                }
            },
            "required": [
                "description",
                "name",
                "networkListId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description to be assigned to the network list.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name to be assigned to the network list.\n"
                },
                "networkListId": {
                    "type": "string",
                    "description": "The unique ID of the network list to use.\n"
                }
            },
            "requiredInputs": [
                "description",
                "networkListId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListDescription resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description to be assigned to the network list.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name to be assigned to the network list.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The unique ID of the network list to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/networkListSubscription:NetworkListSubscription": {
            "description": "Use the `akamai.NetworkListSubscription` resource to specify a set of email addresses to be notified of changes to any\nof a set of network lists.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkListsFilter = akamai.getNetworkLists({\n    name: _var.network_list,\n});\nconst subscribe = new akamai.NetworkListSubscription(\"subscribe\", {\n    networkLists: networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.lists),\n    recipients: [\"user@example.com\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_lists_filter = akamai.get_network_lists(name=var[\"network_list\"])\nsubscribe = akamai.NetworkListSubscription(\"subscribe\",\n    network_lists=network_lists_filter.lists,\n    recipients=[\"user@example.com\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkListsFilter = Akamai.GetNetworkLists.Invoke(new()\n    {\n        Name = @var.Network_list,\n    });\n\n    var subscribe = new Akamai.NetworkListSubscription(\"subscribe\", new()\n    {\n        NetworkLists = networkListsFilter.Apply(getNetworkListsResult =\u003e getNetworkListsResult.Lists),\n        Recipients = new[]\n        {\n            \"user@example.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkListsFilter, err := akamai.GetNetworkLists(ctx, \u0026akamai.GetNetworkListsArgs{\n\t\t\tName: pulumi.StringRef(_var.Network_list),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewNetworkListSubscription(ctx, \"subscribe\", \u0026akamai.NetworkListSubscriptionArgs{\n\t\t\tNetworkLists: interface{}(networkListsFilter.Lists),\n\t\t\tRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user@example.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetNetworkListsArgs;\nimport com.pulumi.akamai.NetworkListSubscription;\nimport com.pulumi.akamai.NetworkListSubscriptionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()\n            .name(var_.network_list())\n            .build());\n\n        var subscribe = new NetworkListSubscription(\"subscribe\", NetworkListSubscriptionArgs.builder()        \n            .networkLists(networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()))\n            .recipients(\"user@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  subscribe:\n    type: akamai:NetworkListSubscription\n    properties:\n      networkLists: ${networkListsFilter.lists}\n      recipients:\n        - user@example.com\nvariables:\n  networkListsFilter:\n    fn::invoke:\n      Function: akamai:getNetworkLists\n      Arguments:\n        name: ${var.network_list}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "networkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                }
            },
            "required": [
                "networkLists",
                "recipients"
            ],
            "inputProperties": {
                "networkLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                }
            },
            "requiredInputs": [
                "networkLists",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkListSubscription resources.\n",
                "properties": {
                    "networkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list containing one or more IDs of the network lists to which the indicated email\naddresses should be subscribed.\n"
                    },
                    "recipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A bracketed, comma-separated list of email addresses that will be notified of changes to any\nof the specified network lists.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/property:Property": {
            "description": "The `akamai.Property` resource represents an Akamai property configuration.\nThis resource lets you to create, update, and activate properties on the\nAkamai platform.\n\nAkamai's edge network caches your web assets near to servers that request them.\nA property provides the main way to control how edge servers respond to various\nkinds of requests for those assets. Properties apply rules to a set of hostnames,\nand you can only apply one property at a time to any given hostname. Each property\nis assigned to a product, which determines which behaviors you can use. Each\nproperty's default rule needs a valid content provider (CP) code assigned to bill\nand report for the service.\n\n\u003e **Note** In version 0.10 and earlier of this resource, it also controlled content provider (CP) codes, origin settings, rules, and hostname associations. Starting with version 1.0.0, this logic is broken out into individual resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: [\n        {\n            cnameFrom: \"example.com\",\n            cnameTo: \"example.com.edgekey.net\",\n            certProvisioningType: \"DEFAULT\",\n        },\n        {\n            cnameFrom: \"www.example.com\",\n            cnameTo: \"example.com.edgesuite.net\",\n            certProvisioningType: \"CPS_MANAGED\",\n        },\n    ],\n    ruleFormat: \"v2020-03-04\",\n    rules: data.akamai_property_rules_template.example.json,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames=[\n        akamai.PropertyHostnameArgs(\n            cname_from=\"example.com\",\n            cname_to=\"example.com.edgekey.net\",\n            cert_provisioning_type=\"DEFAULT\",\n        ),\n        akamai.PropertyHostnameArgs(\n            cname_from=\"www.example.com\",\n            cname_to=\"example.com.edgesuite.net\",\n            cert_provisioning_type=\"CPS_MANAGED\",\n        ),\n    ],\n    rule_format=\"v2020-03-04\",\n    rules=data[\"akamai_property_rules_template\"][\"example\"][\"json\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.Property(\"example\", new()\n    {\n        ProductId = \"prd_SPM\",\n        ContractId = @var.Contractid,\n        GroupId = @var.Groupid,\n        Hostnames = new[]\n        {\n            new Akamai.Inputs.PropertyHostnameArgs\n            {\n                CnameFrom = \"example.com\",\n                CnameTo = \"example.com.edgekey.net\",\n                CertProvisioningType = \"DEFAULT\",\n            },\n            new Akamai.Inputs.PropertyHostnameArgs\n            {\n                CnameFrom = \"www.example.com\",\n                CnameTo = \"example.com.edgesuite.net\",\n                CertProvisioningType = \"CPS_MANAGED\",\n            },\n        },\n        RuleFormat = \"v2020-03-04\",\n        Rules = data.Akamai_property_rules_template.Example.Json,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: akamai.PropertyHostnameArray{\n\t\t\t\t\u0026akamai.PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgekey.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"DEFAULT\"),\n\t\t\t\t},\n\t\t\t\t\u0026akamai.PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"www.example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgesuite.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"CPS_MANAGED\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      pulumi.Any(data.Akamai_property_rules_template.Example.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.inputs.PropertyHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(            \n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"example.com\")\n                    .cnameTo(\"example.com.edgekey.net\")\n                    .certProvisioningType(\"DEFAULT\")\n                    .build(),\n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"www.example.com\")\n                    .cnameTo(\"example.com.edgesuite.net\")\n                    .certProvisioningType(\"CPS_MANAGED\")\n                    .build())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(data.akamai_property_rules_template().example().json())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        - cnameFrom: example.com\n          cnameTo: example.com.edgekey.net\n          certProvisioningType: DEFAULT\n        - cnameFrom: www.example.com\n          cnameTo: example.com.edgesuite.net\n          certProvisioningType: CPS_MANAGED\n      ruleFormat: v2020-03-04\n      rules: ${data.akamai_property_rules_template.example.json}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic Usagehcl resource \"akamai_property\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import the latest Akamai property version by using either the `property_id` or a comma-delimited string of the property, contract, and group IDs. You'll need to enter the string of IDs if the property belongs to multiple groups or contracts. If using the string of IDs, you need to enter them in this order`property_id,contract_id,group_id` To import a specific property version, pass additional parameters, either* `LATEST` to import the latest version of the property, regardless of whether it's active or not. This works the same as providing just the `property_id` or a string of the property, contract, and group IDs, which is the default behavior. * `PRODUCTION`, `PROD`, or `P` to import the latest version activated on the production environment. * `STAGING`, `STAGE`, `STAG`, or `S` to import the latest version activated on the staging environment. * Version number or version number with the `ver_` prefix to import a specific property version. For example `3` and `ver_3` correspond to the same version number. Here are some examples for the latest property version\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123\n```\n\n Here are some examples for the latest active property version on the production network\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,P\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123,PROD\n```\n\n Here are some examples for the specific property version\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,3\n```\n\n Or\n\n```sh\n $ pulumi import akamai:index/property:Property example prp_123,ctr_1-AB123,grp_123,ver_3\n```\n\n ",
            "properties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "productionVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai production network.\n"
                },
                "readVersion": {
                    "type": "integer",
                    "description": "Required property's version to be read\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleError:PropertyRuleError"
                    },
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "stagingVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai staging network.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "latestVersion",
                "name",
                "product",
                "productId",
                "productionVersion",
                "readVersion",
                "ruleErrors",
                "ruleFormat",
                "ruleWarnings",
                "rules",
                "stagingVersion"
            ],
            "inputProperties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n",
                    "willReplaceOnChanges": true
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Property resources.\n",
                "properties": {
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "The setting \"contact\" has been deprecated."
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "cpCode": {
                        "type": "string",
                        "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyHostname:PropertyHostname"
                        },
                        "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                    },
                    "isSecure": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The property name.\n",
                        "willReplaceOnChanges": true
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyOrigin:PropertyOrigin"
                        },
                        "deprecationMessage": "The setting \"origin\" has been deprecated."
                    },
                    "product": {
                        "type": "string",
                        "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string",
                        "description": "Product ID to be assigned to the Property\n"
                    },
                    "productionVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai production network.\n"
                    },
                    "readVersion": {
                        "type": "integer",
                        "description": "Required property's version to be read\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyRuleError:PropertyRuleError"
                        },
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    },
                    "ruleFormat": {
                        "type": "string",
                        "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyRuleWarning:PropertyRuleWarning"
                        },
                        "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "rules": {
                        "type": "string",
                        "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                    },
                    "stagingVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai staging network.\n"
                    },
                    "variables": {
                        "type": "string",
                        "deprecationMessage": "The setting \"variables\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/property:Property"
                }
            ]
        },
        "akamai:index/propertyActivation:PropertyActivation": {
            "description": "The `akamai.PropertyActivation` resource lets you activate a property version. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.  \n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst email = \"user@example.org\";\nconst ruleFormat = \"v2020-03-04\";\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: {\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    ruleFormat: ruleFormat,\n    rules: fs.readFileSync(`${path.module}/main.json`),\n});\nconst exampleStaging = new akamai.PropertyActivation(\"exampleStaging\", {\n    propertyId: example.id,\n    contacts: [email],\n    version: example.latestVersion,\n    note: \"Sample activation\",\n});\nconst exampleProd = new akamai.PropertyActivation(\"exampleProd\", {\n    propertyId: example.id,\n    network: \"PRODUCTION\",\n    version: 3,\n    contacts: [email],\n}, {\n    dependsOn: [exampleStaging],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nemail = \"user@example.org\"\nrule_format = \"v2020-03-04\"\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames={\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    rule_format=rule_format,\n    rules=(lambda path: open(path).read())(f\"{path['module']}/main.json\"))\nexample_staging = akamai.PropertyActivation(\"exampleStaging\",\n    property_id=example.id,\n    contacts=[email],\n    version=example.latest_version,\n    note=\"Sample activation\")\nexample_prod = akamai.PropertyActivation(\"exampleProd\",\n    property_id=example.id,\n    network=\"PRODUCTION\",\n    version=3,\n    contacts=[email],\n    opts=pulumi.ResourceOptions(depends_on=[example_staging]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var email = \"user@example.org\";\n\n    var ruleFormat = \"v2020-03-04\";\n\n    var example = new Akamai.Property(\"example\", new()\n    {\n        ProductId = \"prd_SPM\",\n        ContractId = @var.Contractid,\n        GroupId = @var.Groupid,\n        Hostnames = \n        {\n            { \"example.org\", \"example.org.edgesuite.net\" },\n            { \"www.example.org\", \"example.org.edgesuite.net\" },\n            { \"sub.example.org\", \"sub.example.org.edgesuite.net\" },\n        },\n        RuleFormat = ruleFormat,\n        Rules = File.ReadAllText($\"{path.Module}/main.json\"),\n    });\n\n    var exampleStaging = new Akamai.PropertyActivation(\"exampleStaging\", new()\n    {\n        PropertyId = example.Id,\n        Contacts = new[]\n        {\n            email,\n        },\n        Version = example.LatestVersion,\n        Note = \"Sample activation\",\n    });\n\n    var exampleProd = new Akamai.PropertyActivation(\"exampleProd\", new()\n    {\n        PropertyId = example.Id,\n        Network = \"PRODUCTION\",\n        Version = 3,\n        Contacts = new[]\n        {\n            email,\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            exampleStaging,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\temail := \"user@example.org\"\n\t\truleFormat := \"v2020-03-04\"\n\t\texample, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: akamai.PropertyHostnameArray{\n\t\t\t\tExample.org:     \"example.org.edgesuite.net\",\n\t\t\t\tWww.example.org: \"example.org.edgesuite.net\",\n\t\t\t\tSub.example.org: \"sub.example.org.edgesuite.net\",\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(ruleFormat),\n\t\t\tRules:      readFileOrPanic(fmt.Sprintf(\"%v/main.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleStaging, err := akamai.NewPropertyActivation(ctx, \"exampleStaging\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t\tVersion: example.LatestVersion,\n\t\t\tNote:    pulumi.String(\"Sample activation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewPropertyActivation(ctx, \"exampleProd\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tNetwork:    pulumi.String(\"PRODUCTION\"),\n\t\t\tVersion:    pulumi.Int(3),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleStaging,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.PropertyActivation;\nimport com.pulumi.akamai.PropertyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var email = \"user@example.org\";\n\n        final var ruleFormat = \"v2020-03-04\";\n\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(PropertyHostnameArgs.builder()\n%!v(PANIC=Format method: interface conversion: model.Expression is *model.TemplateExpression, not *model.LiteralValueExpression))\n                .ruleFormat(ruleFormat)\n                .rules(Files.readString(Paths.get(String.format(\"%s/main.json\", path.module()))))\n                .build());\n\n            var exampleStaging = new PropertyActivation(\"exampleStaging\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .contacts(email)\n                .version(example.latestVersion())\n                .note(\"Sample activation\")\n                .build());\n\n            var exampleProd = new PropertyActivation(\"exampleProd\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .network(\"PRODUCTION\")\n                .version(3)\n                .contacts(email)\n                .build(), CustomResourceOptions.builder()\n                    .dependsOn(exampleStaging)\n                    .build());\n\n        }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        example.org: example.org.edgesuite.net\n        www.example.org: example.org.edgesuite.net\n        sub.example.org: sub.example.org.edgesuite.net\n      ruleFormat: ${ruleFormat}\n      # line below here is assumed to be defined but left out for example brevity\n      rules:\n        fn::readFile: ${path.module}/main.json\n  exampleStaging:\n    type: akamai:PropertyActivation\n    properties:\n      propertyId: ${example.id}\n      contacts:\n        - ${email}\n      # NOTE: Specifying a version as shown here will target the latest version created. This latest version will always be activated in staging.\n      version: ${example.latestVersion}\n      # not specifying network will target STAGING\n      note: Sample activation\n  exampleProd:\n    type: akamai:PropertyActivation\n    properties:\n      propertyId: ${example.id}\n      network: PRODUCTION\n      # manually specifying version allows production to lag behind staging until qualified by testing on staging URLs.\n      version: 3\n      contacts:\n        - ${email}\n    options:\n      dependson:\n        - ${exampleStaging}\nvariables:\n  email: user@example.org\n  ruleFormat: v2020-03-04\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "errors": {
                    "type": "string",
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "status": {
                    "type": "string",
                    "description": "The property version's activation status on the selected network.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                }
            },
            "required": [
                "activationId",
                "contacts",
                "errors",
                "property",
                "propertyId",
                "ruleErrors",
                "ruleWarnings",
                "status",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                }
            },
            "requiredInputs": [
                "contacts",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "string",
                        "description": "The ID given to the activation event while it's in progress.\n"
                    },
                    "autoAcknowledgeRuleWarnings": {
                        "type": "boolean",
                        "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                    },
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more email addresses to send activation status changes to.\n"
                    },
                    "errors": {
                        "type": "string",
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "A log message you can assign to the activation request.\n"
                    },
                    "property": {
                        "type": "string",
                        "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"property\" has been deprecated."
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyActivationRuleError:PropertyActivationRuleError"
                        }
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                        },
                        "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "status": {
                        "type": "string",
                        "description": "The property version's activation status on the selected network.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "akamai:properties/propertyActivation:PropertyActivation"
                }
            ]
        },
        "akamai:index/propertyInclude:PropertyInclude": {
            "description": "Use the `akamai.PropertyInclude` resource to create an include and its rule tree.\n\n## Basic usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExample = new akamai.PropertyInclude(\"myExample\", {\n    contractId: \"ctr_1-AB123\",\n    groupId: \"grp_12345\",\n    productId: \"prd_123456\",\n    ruleFormat: \"v2022-10-18\",\n    type: \"MICROSERVICES\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.PropertyInclude(\"myExample\",\n    contract_id=\"ctr_1-AB123\",\n    group_id=\"grp_12345\",\n    product_id=\"prd_123456\",\n    rule_format=\"v2022-10-18\",\n    type=\"MICROSERVICES\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExample = new Akamai.PropertyInclude(\"myExample\", new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        GroupId = \"grp_12345\",\n        ProductId = \"prd_123456\",\n        RuleFormat = \"v2022-10-18\",\n        Type = \"MICROSERVICES\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewPropertyInclude(ctx, \"myExample\", \u0026akamai.PropertyIncludeArgs{\n\t\t\tContractId: pulumi.String(\"ctr_1-AB123\"),\n\t\t\tGroupId:    pulumi.String(\"grp_12345\"),\n\t\t\tProductId:  pulumi.String(\"prd_123456\"),\n\t\t\tRuleFormat: pulumi.String(\"v2022-10-18\"),\n\t\t\tType:       pulumi.String(\"MICROSERVICES\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.PropertyInclude;\nimport com.pulumi.akamai.PropertyIncludeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myExample = new PropertyInclude(\"myExample\", PropertyIncludeArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .groupId(\"grp_12345\")\n            .productId(\"prd_123456\")\n            .ruleFormat(\"v2022-10-18\")\n            .type(\"MICROSERVICES\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myExample:\n    type: akamai:PropertyInclude\n    properties:\n      contractId: ctr_1-AB123\n      groupId: grp_12345\n      productId: prd_123456\n      ruleFormat: v2022-10-18\n      type: MICROSERVICES\n```\n\n## Attributes reference\n\nThis resource returns these attributes:\n\n* `rule_errors` - Rule's validation errors. You need to resolve returned errors, as they block an activation.\n* `rule_warnings` - Rule's validation warnings. You can activate a version that yields less severe warnings.\n* `latest_version` - Returns the most recent version of the include.\n* `staging_version` - The include version currently activated on the staging network.\n* `production_version` - The include version currently activated on the production network.\n",
            "properties": {
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "Specifies the most recent version of the include\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) The descriptive name for the include.\n"
                },
                "productId": {
                    "type": "string",
                    "description": "The product assigned to the include\n"
                },
                "productionVersion": {
                    "type": "string",
                    "description": "The most recent version to be activated to the production network\n"
                },
                "ruleErrors": {
                    "type": "string",
                    "description": "Rule validation errors\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "(Required) Indicates the versioned set of features and criteria. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n"
                },
                "ruleWarnings": {
                    "type": "string",
                    "description": "Rule validation warnings\n"
                },
                "rules": {
                    "type": "string",
                    "description": "(Optional) Include's rules as JSON.\n"
                },
                "stagingVersion": {
                    "type": "string",
                    "description": "The most recent version to be activated to the staging network\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Required) Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n"
                }
            },
            "required": [
                "contractId",
                "groupId",
                "latestVersion",
                "name",
                "productionVersion",
                "ruleErrors",
                "ruleFormat",
                "ruleWarnings",
                "rules",
                "stagingVersion",
                "type"
            ],
            "inputProperties": {
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "(Required) The descriptive name for the include.\n",
                    "willReplaceOnChanges": true
                },
                "productId": {
                    "type": "string",
                    "description": "The product assigned to the include\n",
                    "willReplaceOnChanges": true
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "(Required) Indicates the versioned set of features and criteria. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n"
                },
                "rules": {
                    "type": "string",
                    "description": "(Optional) Include's rules as JSON.\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Required) Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "contractId",
                "groupId",
                "ruleFormat",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyInclude resources.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "Specifies the most recent version of the include\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "(Required) The descriptive name for the include.\n",
                        "willReplaceOnChanges": true
                    },
                    "productId": {
                        "type": "string",
                        "description": "The product assigned to the include\n",
                        "willReplaceOnChanges": true
                    },
                    "productionVersion": {
                        "type": "string",
                        "description": "The most recent version to be activated to the production network\n"
                    },
                    "ruleErrors": {
                        "type": "string",
                        "description": "Rule validation errors\n"
                    },
                    "ruleFormat": {
                        "type": "string",
                        "description": "(Required) Indicates the versioned set of features and criteria. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n"
                    },
                    "ruleWarnings": {
                        "type": "string",
                        "description": "Rule validation warnings\n"
                    },
                    "rules": {
                        "type": "string",
                        "description": "(Optional) Include's rules as JSON.\n"
                    },
                    "stagingVersion": {
                        "type": "string",
                        "description": "The most recent version to be activated to the staging network\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Required) Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "akamai:index/propertyIncludeActivation:PropertyIncludeActivation": {
            "description": "Use the `akamai.PropertyIncludeActivation` resource to activate your include and make available to a property.\n\n## Basic usage\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExample = new akamai.PropertyIncludeActivation(\"myExample\", {\n    contractId: \"C-0N7RAC7\",\n    groupId: \"X112233\",\n    includeId: \"inc_X12345\",\n    network: \"STAGING\",\n    notifyEmails: [\n        \"example@example.com\",\n        \"example2@example.com\",\n    ],\n    version: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.PropertyIncludeActivation(\"myExample\",\n    contract_id=\"C-0N7RAC7\",\n    group_id=\"X112233\",\n    include_id=\"inc_X12345\",\n    network=\"STAGING\",\n    notify_emails=[\n        \"example@example.com\",\n        \"example2@example.com\",\n    ],\n    version=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExample = new Akamai.PropertyIncludeActivation(\"myExample\", new()\n    {\n        ContractId = \"C-0N7RAC7\",\n        GroupId = \"X112233\",\n        IncludeId = \"inc_X12345\",\n        Network = \"STAGING\",\n        NotifyEmails = new[]\n        {\n            \"example@example.com\",\n            \"example2@example.com\",\n        },\n        Version = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewPropertyIncludeActivation(ctx, \"myExample\", \u0026akamai.PropertyIncludeActivationArgs{\n\t\t\tContractId: pulumi.String(\"C-0N7RAC7\"),\n\t\t\tGroupId:    pulumi.String(\"X112233\"),\n\t\t\tIncludeId:  pulumi.String(\"inc_X12345\"),\n\t\t\tNetwork:    pulumi.String(\"STAGING\"),\n\t\t\tNotifyEmails: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example@example.com\"),\n\t\t\t\tpulumi.String(\"example2@example.com\"),\n\t\t\t},\n\t\t\tVersion: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.PropertyIncludeActivation;\nimport com.pulumi.akamai.PropertyIncludeActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myExample = new PropertyIncludeActivation(\"myExample\", PropertyIncludeActivationArgs.builder()        \n            .contractId(\"C-0N7RAC7\")\n            .groupId(\"X112233\")\n            .includeId(\"inc_X12345\")\n            .network(\"STAGING\")\n            .notifyEmails(            \n                \"example@example.com\",\n                \"example2@example.com\")\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myExample:\n    type: akamai:PropertyIncludeActivation\n    properties:\n      contractId: C-0N7RAC7\n      groupId: X112233\n      includeId: inc_X12345\n      network: STAGING\n      notifyEmails:\n        - example@example.com\n        - example2@example.com\n      version: 1\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `validations` - The validation information in JSON format.\n",
            "properties": {
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "(Optional) Automatically acknowledge all rule warnings for activation and continue.\n"
                },
                "complianceRecord": {
                    "$ref": "#/types/akamai:index/PropertyIncludeActivationComplianceRecord:PropertyIncludeActivationComplianceRecord",
                    "description": "Provides an audit record when activating on a production network\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                },
                "includeId": {
                    "type": "string",
                    "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n"
                },
                "network": {
                    "type": "string",
                    "description": "(Required) The network for which the activation will be performed.\n"
                },
                "note": {
                    "type": "string",
                    "description": "(Optional) A log message assigned to the activation request.\n"
                },
                "notifyEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required) The list of email addresses to notify when the activation status changes.\n"
                },
                "validations": {
                    "type": "string",
                    "description": "The validation information in JSON format\n"
                },
                "version": {
                    "type": "integer",
                    "description": "(Required) The version of the include you want to activate.\n"
                }
            },
            "required": [
                "contractId",
                "groupId",
                "includeId",
                "network",
                "notifyEmails",
                "validations",
                "version"
            ],
            "inputProperties": {
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "(Optional) Automatically acknowledge all rule warnings for activation and continue.\n"
                },
                "complianceRecord": {
                    "$ref": "#/types/akamai:index/PropertyIncludeActivationComplianceRecord:PropertyIncludeActivationComplianceRecord",
                    "description": "Provides an audit record when activating on a production network\n"
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "includeId": {
                    "type": "string",
                    "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n",
                    "willReplaceOnChanges": true
                },
                "network": {
                    "type": "string",
                    "description": "(Required) The network for which the activation will be performed.\n",
                    "willReplaceOnChanges": true
                },
                "note": {
                    "type": "string",
                    "description": "(Optional) A log message assigned to the activation request.\n"
                },
                "notifyEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(Required) The list of email addresses to notify when the activation status changes.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "(Required) The version of the include you want to activate.\n"
                }
            },
            "requiredInputs": [
                "contractId",
                "groupId",
                "includeId",
                "network",
                "notifyEmails",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyIncludeActivation resources.\n",
                "properties": {
                    "autoAcknowledgeRuleWarnings": {
                        "type": "boolean",
                        "description": "(Optional) Automatically acknowledge all rule warnings for activation and continue.\n"
                    },
                    "complianceRecord": {
                        "$ref": "#/types/akamai:index/PropertyIncludeActivationComplianceRecord:PropertyIncludeActivationComplianceRecord",
                        "description": "Provides an audit record when activating on a production network\n"
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "includeId": {
                        "type": "string",
                        "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "network": {
                        "type": "string",
                        "description": "(Required) The network for which the activation will be performed.\n",
                        "willReplaceOnChanges": true
                    },
                    "note": {
                        "type": "string",
                        "description": "(Optional) A log message assigned to the activation request.\n"
                    },
                    "notifyEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Required) The list of email addresses to notify when the activation status changes.\n"
                    },
                    "validations": {
                        "type": "string",
                        "description": "The validation information in JSON format\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Required) The version of the include you want to activate.\n"
                    }
                },
                "type": "object"
            }
        },
        "akamai:properties/cpCode:CpCode": {
            "description": "The `akamai.CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.\n\nYou can create additional CP codes to support more detailed billing and reporting functions.\n\nBy default, the Akamai Provider uses your existing CP code instead of creating a new one.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst cpCode = new akamai.CpCode(\"cpCode\", {\n    contractId: akamai_contract.contract.id,\n    groupId: akamai_group.group.id,\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncp_code = akamai.CpCode(\"cpCode\",\n    contract_id=akamai_contract[\"contract\"][\"id\"],\n    group_id=akamai_group[\"group\"][\"id\"],\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cpCode = new Akamai.CpCode(\"cpCode\", new()\n    {\n        ContractId = akamai_contract.Contract.Id,\n        GroupId = akamai_group.Group.Id,\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewCpCode(ctx, \"cpCode\", \u0026akamai.CpCodeArgs{\n\t\t\tContractId: pulumi.Any(akamai_contract.Contract.Id),\n\t\t\tGroupId:    pulumi.Any(akamai_group.Group.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cpCode = new CpCode(\"cpCode\", CpCodeArgs.builder()        \n            .contractId(akamai_contract.contract().id())\n            .groupId(akamai_group.group().id())\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cpCode:\n    type: akamai:CpCode\n    properties:\n      contractId: ${akamai_contract.contract.id}\n      groupId: ${akamai_group.group.id}\n      productId: prd_Object_Delivery\n```\n\nHere's a real-life example that includes other data sources as dependencies:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst groupName = \"example group name\";\nconst cpcodeName = \"My CP Code\";\nconst exampleContract = akamai.getContract({\n    groupName: groupName,\n});\nconst exampleGroup = exampleContract.then(exampleContract =\u003e akamai.getGroup({\n    name: groupName,\n    contractId: exampleContract.id,\n}));\nconst exampleCp = new akamai.CpCode(\"exampleCp\", {\n    groupId: exampleGroup.then(exampleGroup =\u003e exampleGroup.id),\n    contractId: exampleContract.then(exampleContract =\u003e exampleContract.id),\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ngroup_name = \"example group name\"\ncpcode_name = \"My CP Code\"\nexample_contract = akamai.get_contract(group_name=group_name)\nexample_group = akamai.get_group(name=group_name,\n    contract_id=example_contract.id)\nexample_cp = akamai.CpCode(\"exampleCp\",\n    group_id=example_group.id,\n    contract_id=example_contract.id,\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var groupName = \"example group name\";\n\n    var cpcodeName = \"My CP Code\";\n\n    var exampleContract = Akamai.GetContract.Invoke(new()\n    {\n        GroupName = groupName,\n    });\n\n    var exampleGroup = Akamai.GetGroup.Invoke(new()\n    {\n        Name = groupName,\n        ContractId = exampleContract.Apply(getContractResult =\u003e getContractResult.Id),\n    });\n\n    var exampleCp = new Akamai.CpCode(\"exampleCp\", new()\n    {\n        GroupId = exampleGroup.Apply(getGroupResult =\u003e getGroupResult.Id),\n        ContractId = exampleContract.Apply(getContractResult =\u003e getContractResult.Id),\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroupName := \"example group name\"\n\t\t_ := \"My CP Code\"\n\t\texampleContract, err := akamai.GetContract(ctx, \u0026akamai.GetContractArgs{\n\t\t\tGroupName: pulumi.StringRef(groupName),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleGroup, err := akamai.GetGroup(ctx, \u0026akamai.GetGroupArgs{\n\t\t\tName:       pulumi.StringRef(groupName),\n\t\t\tContractId: pulumi.StringRef(exampleContract.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewCpCode(ctx, \"exampleCp\", \u0026akamai.CpCodeArgs{\n\t\t\tGroupId:    *pulumi.String(exampleGroup.Id),\n\t\t\tContractId: *pulumi.String(exampleContract.Id),\n\t\t\tProductId:  pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetContractArgs;\nimport com.pulumi.akamai.inputs.GetGroupArgs;\nimport com.pulumi.akamai.CpCode;\nimport com.pulumi.akamai.CpCodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var groupName = \"example group name\";\n\n        final var cpcodeName = \"My CP Code\";\n\n        final var exampleContract = AkamaiFunctions.getContract(GetContractArgs.builder()\n            .groupName(groupName)\n            .build());\n\n        final var exampleGroup = AkamaiFunctions.getGroup(GetGroupArgs.builder()\n            .name(groupName)\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .build());\n\n        var exampleCp = new CpCode(\"exampleCp\", CpCodeArgs.builder()        \n            .groupId(exampleGroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .contractId(exampleContract.applyValue(getContractResult -\u003e getContractResult.id()))\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCp:\n    type: akamai:CpCode\n    properties:\n      groupId: ${exampleGroup.id}\n      contractId: ${exampleContract.id}\n      productId: prd_Object_Delivery\nvariables:\n  groupName: example group name\n  cpcodeName: My CP Code\n  exampleGroup:\n    fn::invoke:\n      Function: akamai:getGroup\n      Arguments:\n        name: ${groupName}\n        contractId: ${exampleContract.id}\n  exampleContract:\n    fn::invoke:\n      Function: akamai:getContract\n      Arguments:\n        groupName: ${groupName}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `id` - The ID of the CP code.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_cp_code\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example\n\n```sh\n $ pulumi import akamai:properties/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "name",
                "product",
                "productId"
            ],
            "inputProperties": {
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CpCode resources.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "(Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.CpCode has been deprecated in favor of akamai.CpCode"
        },
        "akamai:properties/edgeHostName:EdgeHostName": {
            "description": "The `akamai.EdgeHostName` resource lets you configure a secure edge hostname. Your\nedge hostname determines how requests for your site, app, or content are mapped to\nAkamai edge servers.\n\nAn edge hostname is the CNAME target you use when directing your end user traffic to\nAkamai. Each hostname assigned to a property has a corresponding edge hostname.\n\nAkamai supports three types of edge hostnames, depending on the level of security\nyou need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When\nentering the `edge_hostname` attribute, you need to include a specific domain suffix\nfor your edge hostname type:\n\n| Edge hostname type | Domain suffix |\n|------|-------|\n| Enhanced TLS | edgekey.net |\n| Standard TLS | edgesuite.net |\n| Shared Cert | akamaized.net |\n\nFor example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See  [Create a new edge hostname](https://techdocs.akamai.com/property-mgr/reference/post-edgehostnames) in the Property Manager API (PAPI) for more information. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst provider_demo = new akamai.EdgeHostName(\"provider-demo\", {\n    contractId: \"ctr_1-AB123\",\n    edgeHostname: \"www.example.org.edgesuite.net\",\n    groupId: \"grp_123\",\n    ipBehavior: \"IPV4\",\n    productId: \"prd_Object_Delivery\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nprovider_demo = akamai.EdgeHostName(\"provider-demo\",\n    contract_id=\"ctr_1-AB123\",\n    edge_hostname=\"www.example.org.edgesuite.net\",\n    group_id=\"grp_123\",\n    ip_behavior=\"IPV4\",\n    product_id=\"prd_Object_Delivery\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var provider_demo = new Akamai.EdgeHostName(\"provider-demo\", new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        EdgeHostname = \"www.example.org.edgesuite.net\",\n        GroupId = \"grp_123\",\n        IpBehavior = \"IPV4\",\n        ProductId = \"prd_Object_Delivery\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewEdgeHostName(ctx, \"provider-demo\", \u0026akamai.EdgeHostNameArgs{\n\t\t\tContractId:   pulumi.String(\"ctr_1-AB123\"),\n\t\t\tEdgeHostname: pulumi.String(\"www.example.org.edgesuite.net\"),\n\t\t\tGroupId:      pulumi.String(\"grp_123\"),\n\t\t\tIpBehavior:   pulumi.String(\"IPV4\"),\n\t\t\tProductId:    pulumi.String(\"prd_Object_Delivery\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.EdgeHostName;\nimport com.pulumi.akamai.EdgeHostNameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var provider_demo = new EdgeHostName(\"provider-demo\", EdgeHostNameArgs.builder()        \n            .contractId(\"ctr_1-AB123\")\n            .edgeHostname(\"www.example.org.edgesuite.net\")\n            .groupId(\"grp_123\")\n            .ipBehavior(\"IPV4\")\n            .productId(\"prd_Object_Delivery\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  provider-demo:\n    type: akamai:EdgeHostName\n    properties:\n      contractId: ctr_1-AB123\n      edgeHostname: www.example.org.edgesuite.net\n      groupId: grp_123\n      ipBehavior: IPV4\n      productId: prd_Object_Delivery\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE` for version 6, or `IPV6_COMPLIANCE` for both.\n\n\n## Import\n\nBasic Usagehcl resource \"akamai_edge_hostname\" \"example\" {\n\n # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:\n\n`edge_hostname, contract_id, group_id` For example\n\n```sh\n $ pulumi import akamai:properties/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123\n```\n\n ",
            "properties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n"
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n"
                }
            },
            "required": [
                "contract",
                "contractId",
                "edgeHostname",
                "group",
                "groupId",
                "ipBehavior",
                "product",
                "productId"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "integer",
                    "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                    "willReplaceOnChanges": true
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "edgeHostname": {
                    "type": "string",
                    "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "A group's unique ID, including the `grp_` prefix.\n"
                },
                "ipBehavior": {
                    "type": "string",
                    "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                },
                "product": {
                    "type": "string",
                    "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string"
                },
                "statusUpdateEmails": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                },
                "useCases": {
                    "type": "string",
                    "description": "A JSON encoded list of use cases.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "edgeHostname",
                "ipBehavior"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EdgeHostName resources.\n",
                "properties": {
                    "certificate": {
                        "type": "integer",
                        "description": "Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .\n",
                        "willReplaceOnChanges": true
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "edgeHostname": {
                        "type": "string",
                        "description": "One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "ipBehavior": {
                        "type": "string",
                        "description": "Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "Replaced by `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string"
                    },
                    "statusUpdateEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Email address that should receive updates on the IP behavior update request. Required for update operation.\n"
                    },
                    "useCases": {
                        "type": "string",
                        "description": "A JSON encoded list of use cases.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.EdgeHostName has been deprecated in favor of akamai.EdgeHostName"
        },
        "akamai:properties/property:Property": {
            "description": "The `akamai.Property` resource represents an Akamai property configuration.\nThis resource lets you to create, update, and activate properties on the\nAkamai platform.\n\nAkamai's edge network caches your web assets near to servers that request them.\nA property provides the main way to control how edge servers respond to various\nkinds of requests for those assets. Properties apply rules to a set of hostnames,\nand you can only apply one property at a time to any given hostname. Each property\nis assigned to a product, which determines which behaviors you can use. Each\nproperty's default rule needs a valid content provider (CP) code assigned to bill\nand report for the service.\n\n\u003e **Note** In version 0.10 and earlier of this resource, it also controlled content provider (CP) codes, origin settings, rules, and hostname associations. Starting with version 1.0.0, this logic is broken out into individual resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: [\n        {\n            cnameFrom: \"example.com\",\n            cnameTo: \"example.com.edgekey.net\",\n            certProvisioningType: \"DEFAULT\",\n        },\n        {\n            cnameFrom: \"www.example.com\",\n            cnameTo: \"example.com.edgesuite.net\",\n            certProvisioningType: \"CPS_MANAGED\",\n        },\n    ],\n    ruleFormat: \"v2020-03-04\",\n    rules: data.akamai_property_rules_template.example.json,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames=[\n        akamai.PropertyHostnameArgs(\n            cname_from=\"example.com\",\n            cname_to=\"example.com.edgekey.net\",\n            cert_provisioning_type=\"DEFAULT\",\n        ),\n        akamai.PropertyHostnameArgs(\n            cname_from=\"www.example.com\",\n            cname_to=\"example.com.edgesuite.net\",\n            cert_provisioning_type=\"CPS_MANAGED\",\n        ),\n    ],\n    rule_format=\"v2020-03-04\",\n    rules=data[\"akamai_property_rules_template\"][\"example\"][\"json\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Akamai.Property(\"example\", new()\n    {\n        ProductId = \"prd_SPM\",\n        ContractId = @var.Contractid,\n        GroupId = @var.Groupid,\n        Hostnames = new[]\n        {\n            new Akamai.Inputs.PropertyHostnameArgs\n            {\n                CnameFrom = \"example.com\",\n                CnameTo = \"example.com.edgekey.net\",\n                CertProvisioningType = \"DEFAULT\",\n            },\n            new Akamai.Inputs.PropertyHostnameArgs\n            {\n                CnameFrom = \"www.example.com\",\n                CnameTo = \"example.com.edgesuite.net\",\n                CertProvisioningType = \"CPS_MANAGED\",\n            },\n        },\n        RuleFormat = \"v2020-03-04\",\n        Rules = data.Akamai_property_rules_template.Example.Json,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: akamai.PropertyHostnameArray{\n\t\t\t\t\u0026akamai.PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgekey.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"DEFAULT\"),\n\t\t\t\t},\n\t\t\t\t\u0026akamai.PropertyHostnameArgs{\n\t\t\t\t\tCnameFrom:            pulumi.String(\"www.example.com\"),\n\t\t\t\t\tCnameTo:              pulumi.String(\"example.com.edgesuite.net\"),\n\t\t\t\t\tCertProvisioningType: pulumi.String(\"CPS_MANAGED\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      pulumi.Any(data.Akamai_property_rules_template.Example.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.inputs.PropertyHostnameArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(            \n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"example.com\")\n                    .cnameTo(\"example.com.edgekey.net\")\n                    .certProvisioningType(\"DEFAULT\")\n                    .build(),\n                PropertyHostnameArgs.builder()\n                    .cnameFrom(\"www.example.com\")\n                    .cnameTo(\"example.com.edgesuite.net\")\n                    .certProvisioningType(\"CPS_MANAGED\")\n                    .build())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(data.akamai_property_rules_template().example().json())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        - cnameFrom: example.com\n          cnameTo: example.com.edgekey.net\n          certProvisioningType: DEFAULT\n        - cnameFrom: www.example.com\n          cnameTo: example.com.edgesuite.net\n          certProvisioningType: CPS_MANAGED\n      ruleFormat: v2020-03-04\n      rules: ${data.akamai_property_rules_template.example.json}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBasic Usagehcl resource \"akamai_property\" \"example\" {\n\n\n\n # (resource arguments)\n\n } You can import the latest Akamai property version by using either the `property_id` or a comma-delimited string of the property, contract, and group IDs. You'll need to enter the string of IDs if the property belongs to multiple groups or contracts. If using the string of IDs, you need to enter them in this order`property_id,contract_id,group_id` To import a specific property version, pass additional parameters, either* `LATEST` to import the latest version of the property, regardless of whether it's active or not. This works the same as providing just the `property_id` or a string of the property, contract, and group IDs, which is the default behavior. * `PRODUCTION`, `PROD`, or `P` to import the latest version activated on the production environment. * `STAGING`, `STAGE`, `STAG`, or `S` to import the latest version activated on the staging environment. * Version number or version number with the `ver_` prefix to import a specific property version. For example `3` and `ver_3` correspond to the same version number. Here are some examples for the latest property version\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123\n```\n\n Here are some examples for the latest active property version on the production network\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,P\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123,PROD\n```\n\n Here are some examples for the specific property version\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,3\n```\n\n Or\n\n```sh\n $ pulumi import akamai:properties/property:Property example prp_123,ctr_1-AB123,grp_123,ver_3\n```\n\n ",
            "properties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "latestVersion": {
                    "type": "integer",
                    "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n"
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "productionVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai production network.\n"
                },
                "readVersion": {
                    "type": "integer",
                    "description": "Required property's version to be read\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleError:PropertyRuleError"
                    },
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "stagingVersion": {
                    "type": "integer",
                    "description": "The current version of the property active on the Akamai staging network.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "required": [
                "contract",
                "contractId",
                "group",
                "groupId",
                "latestVersion",
                "name",
                "product",
                "productId",
                "productionVersion",
                "readVersion",
                "ruleErrors",
                "ruleFormat",
                "ruleWarnings",
                "rules",
                "stagingVersion"
            ],
            "inputProperties": {
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "deprecationMessage": "The setting \"contact\" has been deprecated."
                },
                "contract": {
                    "type": "string",
                    "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"contract\" has been deprecated."
                },
                "contractId": {
                    "type": "string",
                    "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                },
                "cpCode": {
                    "type": "string",
                    "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                },
                "group": {
                    "type": "string",
                    "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"group\" has been deprecated."
                },
                "groupId": {
                    "type": "string",
                    "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                    },
                    "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                },
                "name": {
                    "type": "string",
                    "description": "The property name.\n",
                    "willReplaceOnChanges": true
                },
                "origins": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                    },
                    "deprecationMessage": "The setting \"origin\" has been deprecated."
                },
                "product": {
                    "type": "string",
                    "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"product\" has been deprecated."
                },
                "productId": {
                    "type": "string",
                    "description": "Product ID to be assigned to the Property\n"
                },
                "ruleFormat": {
                    "type": "string",
                    "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "rules": {
                    "type": "string",
                    "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                },
                "variables": {
                    "type": "string",
                    "deprecationMessage": "The setting \"variables\" has been deprecated."
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Property resources.\n",
                "properties": {
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "deprecationMessage": "The setting \"contact\" has been deprecated."
                    },
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "cpCode": {
                        "type": "string",
                        "deprecationMessage": "The setting \"cp_code\" has been deprecated."
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyHostname:PropertyHostname"
                        },
                        "description": "A mapping of public hostnames to edge hostnames. See the `akamai.getPropertyHostnames` data source for details on the necessary DNS configuration.\n"
                    },
                    "isSecure": {
                        "type": "boolean",
                        "deprecationMessage": "The setting \"is_secure\" has been deprecated."
                    },
                    "latestVersion": {
                        "type": "integer",
                        "description": "The version of the property you've created or updated rules for. The Akamai Provider always uses the latest version or creates a new version if latest is not editable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The property name.\n",
                        "willReplaceOnChanges": true
                    },
                    "origins": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyOrigin:PropertyOrigin"
                        },
                        "deprecationMessage": "The setting \"origin\" has been deprecated."
                    },
                    "product": {
                        "type": "string",
                        "description": "Optional argument replaced by the now required `product_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"product\" has been deprecated."
                    },
                    "productId": {
                        "type": "string",
                        "description": "Product ID to be assigned to the Property\n"
                    },
                    "productionVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai production network.\n"
                    },
                    "readVersion": {
                        "type": "integer",
                        "description": "Required property's version to be read\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyRuleError:PropertyRuleError"
                        },
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    },
                    "ruleFormat": {
                        "type": "string",
                        "description": "The [rule format](https://techdocs.akamai.com/property-mgr/reference/get-rule-formats) to use. Uses the latest rule format by default.\n"
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyRuleWarning:PropertyRuleWarning"
                        },
                        "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "rules": {
                        "type": "string",
                        "description": "A JSON-encoded rule tree for a given property. For this argument, you need to enter a complete JSON rule tree, unless you set up a series of JSON templates. See the `akamai.getPropertyRules` data source.\n"
                    },
                    "stagingVersion": {
                        "type": "integer",
                        "description": "The current version of the property active on the Akamai staging network.\n"
                    },
                    "variables": {
                        "type": "string",
                        "deprecationMessage": "The setting \"variables\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.Property has been deprecated in favor of akamai.Property"
        },
        "akamai:properties/propertyActivation:PropertyActivation": {
            "description": "The `akamai.PropertyActivation` resource lets you activate a property version. An activation deploys the version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.  \n\nBefore activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\nimport * as fs from \"fs\";\n\nconst email = \"user@example.org\";\nconst ruleFormat = \"v2020-03-04\";\nconst example = new akamai.Property(\"example\", {\n    productId: \"prd_SPM\",\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    hostnames: {\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    ruleFormat: ruleFormat,\n    rules: fs.readFileSync(`${path.module}/main.json`),\n});\nconst exampleStaging = new akamai.PropertyActivation(\"exampleStaging\", {\n    propertyId: example.id,\n    contacts: [email],\n    version: example.latestVersion,\n    note: \"Sample activation\",\n});\nconst exampleProd = new akamai.PropertyActivation(\"exampleProd\", {\n    propertyId: example.id,\n    network: \"PRODUCTION\",\n    version: 3,\n    contacts: [email],\n}, {\n    dependsOn: [exampleStaging],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nemail = \"user@example.org\"\nrule_format = \"v2020-03-04\"\nexample = akamai.Property(\"example\",\n    product_id=\"prd_SPM\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    hostnames={\n        \"example.org\": \"example.org.edgesuite.net\",\n        \"www.example.org\": \"example.org.edgesuite.net\",\n        \"sub.example.org\": \"sub.example.org.edgesuite.net\",\n    },\n    rule_format=rule_format,\n    rules=(lambda path: open(path).read())(f\"{path['module']}/main.json\"))\nexample_staging = akamai.PropertyActivation(\"exampleStaging\",\n    property_id=example.id,\n    contacts=[email],\n    version=example.latest_version,\n    note=\"Sample activation\")\nexample_prod = akamai.PropertyActivation(\"exampleProd\",\n    property_id=example.id,\n    network=\"PRODUCTION\",\n    version=3,\n    contacts=[email],\n    opts=pulumi.ResourceOptions(depends_on=[example_staging]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var email = \"user@example.org\";\n\n    var ruleFormat = \"v2020-03-04\";\n\n    var example = new Akamai.Property(\"example\", new()\n    {\n        ProductId = \"prd_SPM\",\n        ContractId = @var.Contractid,\n        GroupId = @var.Groupid,\n        Hostnames = \n        {\n            { \"example.org\", \"example.org.edgesuite.net\" },\n            { \"www.example.org\", \"example.org.edgesuite.net\" },\n            { \"sub.example.org\", \"sub.example.org.edgesuite.net\" },\n        },\n        RuleFormat = ruleFormat,\n        Rules = File.ReadAllText($\"{path.Module}/main.json\"),\n    });\n\n    var exampleStaging = new Akamai.PropertyActivation(\"exampleStaging\", new()\n    {\n        PropertyId = example.Id,\n        Contacts = new[]\n        {\n            email,\n        },\n        Version = example.LatestVersion,\n        Note = \"Sample activation\",\n    });\n\n    var exampleProd = new Akamai.PropertyActivation(\"exampleProd\", new()\n    {\n        PropertyId = example.Id,\n        Network = \"PRODUCTION\",\n        Version = 3,\n        Contacts = new[]\n        {\n            email,\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            exampleStaging,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\temail := \"user@example.org\"\n\t\truleFormat := \"v2020-03-04\"\n\t\texample, err := akamai.NewProperty(ctx, \"example\", \u0026akamai.PropertyArgs{\n\t\t\tProductId:  pulumi.String(\"prd_SPM\"),\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tHostnames: akamai.PropertyHostnameArray{\n\t\t\t\tExample.org:     \"example.org.edgesuite.net\",\n\t\t\t\tWww.example.org: \"example.org.edgesuite.net\",\n\t\t\t\tSub.example.org: \"sub.example.org.edgesuite.net\",\n\t\t\t},\n\t\t\tRuleFormat: pulumi.String(ruleFormat),\n\t\t\tRules:      readFileOrPanic(fmt.Sprintf(\"%v/main.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleStaging, err := akamai.NewPropertyActivation(ctx, \"exampleStaging\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t\tVersion: example.LatestVersion,\n\t\t\tNote:    pulumi.String(\"Sample activation\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewPropertyActivation(ctx, \"exampleProd\", \u0026akamai.PropertyActivationArgs{\n\t\t\tPropertyId: example.ID(),\n\t\t\tNetwork:    pulumi.String(\"PRODUCTION\"),\n\t\t\tVersion:    pulumi.Int(3),\n\t\t\tContacts: pulumi.StringArray{\n\t\t\t\tpulumi.String(email),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleStaging,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport com.pulumi.akamai.PropertyActivation;\nimport com.pulumi.akamai.PropertyActivationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var email = \"user@example.org\";\n\n        final var ruleFormat = \"v2020-03-04\";\n\n        var example = new Property(\"example\", PropertyArgs.builder()        \n            .productId(\"prd_SPM\")\n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .hostnames(PropertyHostnameArgs.builder()\n%!v(PANIC=Format method: interface conversion: model.Expression is *model.TemplateExpression, not *model.LiteralValueExpression))\n                .ruleFormat(ruleFormat)\n                .rules(Files.readString(Paths.get(String.format(\"%s/main.json\", path.module()))))\n                .build());\n\n            var exampleStaging = new PropertyActivation(\"exampleStaging\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .contacts(email)\n                .version(example.latestVersion())\n                .note(\"Sample activation\")\n                .build());\n\n            var exampleProd = new PropertyActivation(\"exampleProd\", PropertyActivationArgs.builder()            \n                .propertyId(example.id())\n                .network(\"PRODUCTION\")\n                .version(3)\n                .contacts(email)\n                .build(), CustomResourceOptions.builder()\n                    .dependsOn(exampleStaging)\n                    .build());\n\n        }\n}\n```\n```yaml\nresources:\n  example:\n    type: akamai:Property\n    properties:\n      productId: prd_SPM\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      hostnames:\n        example.org: example.org.edgesuite.net\n        www.example.org: example.org.edgesuite.net\n        sub.example.org: sub.example.org.edgesuite.net\n      ruleFormat: ${ruleFormat}\n      # line below here is assumed to be defined but left out for example brevity\n      rules:\n        fn::readFile: ${path.module}/main.json\n  exampleStaging:\n    type: akamai:PropertyActivation\n    properties:\n      propertyId: ${example.id}\n      contacts:\n        - ${email}\n      # NOTE: Specifying a version as shown here will target the latest version created. This latest version will always be activated in staging.\n      version: ${example.latestVersion}\n      # not specifying network will target STAGING\n      note: Sample activation\n  exampleProd:\n    type: akamai:PropertyActivation\n    properties:\n      propertyId: ${example.id}\n      network: PRODUCTION\n      # manually specifying version allows production to lag behind staging until qualified by testing on staging URLs.\n      version: 3\n      contacts:\n        - ${email}\n    options:\n      dependson:\n        - ${exampleStaging}\nvariables:\n  email: user@example.org\n  ruleFormat: v2020-03-04\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "errors": {
                    "type": "string",
                    "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "status": {
                    "type": "string",
                    "description": "The property version's activation status on the selected network.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                },
                "warnings": {
                    "type": "string",
                    "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                }
            },
            "required": [
                "activationId",
                "contacts",
                "errors",
                "property",
                "propertyId",
                "ruleErrors",
                "ruleWarnings",
                "status",
                "version",
                "warnings"
            ],
            "inputProperties": {
                "activationId": {
                    "type": "string",
                    "description": "The ID given to the activation event while it's in progress.\n"
                },
                "autoAcknowledgeRuleWarnings": {
                    "type": "boolean",
                    "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                },
                "contacts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more email addresses to send activation status changes to.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                },
                "note": {
                    "type": "string",
                    "description": "A log message you can assign to the activation request.\n"
                },
                "property": {
                    "type": "string",
                    "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                    "deprecationMessage": "The setting \"property\" has been deprecated."
                },
                "propertyId": {
                    "type": "string",
                    "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                },
                "ruleErrors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                    }
                },
                "ruleWarnings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                    },
                    "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                    "deprecationMessage": "Rule warnings will not be set in state anymore"
                },
                "version": {
                    "type": "integer",
                    "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                }
            },
            "requiredInputs": [
                "contacts",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PropertyActivation resources.\n",
                "properties": {
                    "activationId": {
                        "type": "string",
                        "description": "The ID given to the activation event while it's in progress.\n"
                    },
                    "autoAcknowledgeRuleWarnings": {
                        "type": "boolean",
                        "description": "Whether the activation should proceed despite any warnings. By default set to `true`.\n"
                    },
                    "contacts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more email addresses to send activation status changes to.\n"
                    },
                    "errors": {
                        "type": "string",
                        "description": "The contents of `errors` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Akamai network to activate on, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "A log message you can assign to the activation request.\n"
                    },
                    "property": {
                        "type": "string",
                        "description": "(Deprecated) Replaced by `property_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"property\" has been deprecated."
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "(Required) The property's unique identifier, including the `prp_` prefix.\n"
                    },
                    "ruleErrors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyActivationRuleError:PropertyActivationRuleError"
                        }
                    },
                    "ruleWarnings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:properties/PropertyActivationRuleWarning:PropertyActivationRuleWarning"
                        },
                        "description": "(Deprecated) Rule warnings are no longer maintained in the state file. You can still see the warnings in logs.\n",
                        "deprecationMessage": "Rule warnings will not be set in state anymore"
                    },
                    "status": {
                        "type": "string",
                        "description": "The property version's activation status on the selected network.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The property version to activate. Previously this field was optional. It now depends on the `akamai.Property` resource to identify latest instead of calculating it locally.  This association helps keep the dependency tree properly aligned. To always use the latest version, enter this value `{resource}.{resource identifier}.{field name}`. Using the example code above, the entry would be `akamai_property.example.latest_version` since we want the value of the `latest_version` attribute in the `akamai.Property` resource labeled `example`.\n"
                    },
                    "warnings": {
                        "type": "string",
                        "description": "The contents of `warnings` field returned by the API. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the PAPI documentation.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.properties.PropertyActivation has been deprecated in favor of akamai.PropertyActivation"
        },
        "akamai:trafficmanagement/gtmASmap:GtmASmap": {
            "description": "Use the `akamai.GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.\n\nYou can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoAsmap = new akamai.GtmAsmap(\"demoAsmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other AS numbers\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_asmap = akamai.GtmAsmap(\"demoAsmap\",\n    default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other AS numbers\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoAsmap = new Akamai.GtmAsmap(\"demoAsmap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmAsmapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Other AS numbers\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmAsmap(ctx, \"demoAsmap\", \u0026akamai.GtmAsmapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmAsmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other AS numbers\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmAsmap;\nimport com.pulumi.akamai.GtmAsmapArgs;\nimport com.pulumi.akamai.inputs.GtmAsmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoAsmap = new GtmAsmap(\"demoAsmap\", GtmAsmapArgs.builder()        \n            .defaultDatacenter(GtmAsmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other AS numbers\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoAsmap:\n    type: akamai:GtmAsmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other AS numbers\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                    },
                    "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                    "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM Domain name for the AS map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmASmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmASmapAssignment:GtmASmapAssignment"
                        },
                        "description": "Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmASmapDefaultDatacenter:GtmASmapDefaultDatacenter",
                        "description": "A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM Domain name for the AS map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap"
        },
        "akamai:trafficmanagement/gtmCidrmap:GtmCidrmap": {
            "description": "Use the `akamai.GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).\n\n CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoCidrmap = new akamai.GtmCidrmap(\"demoCidrmap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Other CIDR Blocks\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_cidrmap = akamai.GtmCidrmap(\"demoCidrmap\",\n    default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Other CIDR Blocks\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoCidrmap = new Akamai.GtmCidrmap(\"demoCidrmap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmCidrmapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Other CIDR Blocks\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmCidrmap(ctx, \"demoCidrmap\", \u0026akamai.GtmCidrmapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmCidrmapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Other CIDR Blocks\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmCidrmap;\nimport com.pulumi.akamai.GtmCidrmapArgs;\nimport com.pulumi.akamai.inputs.GtmCidrmapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoCidrmap = new GtmCidrmap(\"demoCidrmap\", GtmCidrmapArgs.builder()        \n            .defaultDatacenter(GtmCidrmapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Other CIDR Blocks\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoCidrmap:\n    type: akamai:GtmCidrmap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Other CIDR Blocks\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the CIDR Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                    },
                    "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                    "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the CIDR Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmCidrmap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapAssignment:GtmCidrmapAssignment"
                        },
                        "description": "Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmCidrmapDefaultDatacenter:GtmCidrmapDefaultDatacenter",
                        "description": "A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the CIDR Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the CIDR map, up to 255 characters.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmCidrmap has been deprecated in favor of akamai.GtmCidrmap"
        },
        "akamai:trafficmanagement/gtmDatacenter:GtmDatacenter": {
            "description": "Use the `akamai.GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.\n\nGTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoDatacenter = new akamai.GtmDatacenter(\"demoDatacenter\", {\n    domain: \"demo_domain.akadns.net\",\n    nickname: \"demo_datacenter\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_datacenter = akamai.GtmDatacenter(\"demoDatacenter\",\n    domain=\"demo_domain.akadns.net\",\n    nickname=\"demo_datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoDatacenter = new Akamai.GtmDatacenter(\"demoDatacenter\", new()\n    {\n        Domain = \"demo_domain.akadns.net\",\n        Nickname = \"demo_datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDatacenter(ctx, \"demoDatacenter\", \u0026akamai.GtmDatacenterArgs{\n\t\t\tDomain:   pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tNickname: pulumi.String(\"demo_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDatacenter;\nimport com.pulumi.akamai.GtmDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoDatacenter = new GtmDatacenter(\"demoDatacenter\", GtmDatacenterArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .nickname(\"demo_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoDatacenter:\n    type: akamai:GtmDatacenter\n    properties:\n      domain: demo_domain.akadns.net\n      nickname: demo_datacenter\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "datacenterId": {
                    "type": "integer",
                    "description": "A unique identifier for an existing data center in the domain.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "scorePenalty": {
                    "type": "integer"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "virtual": {
                    "type": "boolean",
                    "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "datacenterId",
                "domain",
                "pingInterval",
                "pingPacketSize",
                "scorePenalty",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "virtual"
            ],
            "inputProperties": {
                "city": {
                    "type": "string",
                    "description": "The name of the city where the data center is located.\n"
                },
                "cloneOf": {
                    "type": "integer",
                    "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                },
                "cloudServerHostHeaderOverride": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                },
                "cloudServerTargeting": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                },
                "continent": {
                    "type": "string",
                    "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                },
                "country": {
                    "type": "string",
                    "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                },
                "defaultLoadObject": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                    "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The GTM domain name for the data center.\n"
                },
                "latitude": {
                    "type": "number",
                    "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                },
                "longitude": {
                    "type": "number",
                    "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                },
                "nickname": {
                    "type": "string",
                    "description": "A descriptive label for the data center.\n"
                },
                "stateOrProvince": {
                    "type": "string",
                    "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDatacenter resources.\n",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "The name of the city where the data center is located.\n"
                    },
                    "cloneOf": {
                        "type": "integer",
                        "description": "Identifies the data center's `datacenter_id` of which this data center is a clone.\n"
                    },
                    "cloudServerHostHeaderOverride": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.\n"
                    },
                    "cloudServerTargeting": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to balance load between two or more servers in a cloud environment.\n"
                    },
                    "continent": {
                        "type": "string",
                        "description": "A two-letter code that specifies the continent where the data center maps to.\n"
                    },
                    "country": {
                        "type": "string",
                        "description": "A two-letter ISO 3166 country code that specifies the country where the data center maps to.\n"
                    },
                    "datacenterId": {
                        "type": "integer",
                        "description": "A unique identifier for an existing data center in the domain.\n"
                    },
                    "defaultLoadObject": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmDatacenterDefaultLoadObject:GtmDatacenterDefaultLoadObject",
                        "description": "Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The GTM domain name for the data center.\n"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "Specifies the geographical latitude of the data center's position. See also longitude within this object.\n"
                    },
                    "longitude": {
                        "type": "number",
                        "description": "Specifies the geographic longitude of the data center's position. See also latitude within this object.\n"
                    },
                    "nickname": {
                        "type": "string",
                        "description": "A descriptive label for the data center.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "scorePenalty": {
                        "type": "integer"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "stateOrProvince": {
                        "type": "string",
                        "description": "Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.\n"
                    },
                    "virtual": {
                        "type": "boolean",
                        "description": "A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean, that if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmDatacenter has been deprecated in favor of akamai.GtmDatacenter"
        },
        "akamai:trafficmanagement/gtmDomain:GtmDomain": {
            "description": "Use the `akamai.GtmDomain` resource to create, configure, and import a GTM Domain, which is a basic building block of a traffic management configuration.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demodomain = new akamai.GtmDomain(\"demodomain\", {\n    comment: \"some comment\",\n    contract: \"XXX\",\n    group: \"100\",\n    type: \"basic\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemodomain = akamai.GtmDomain(\"demodomain\",\n    comment=\"some comment\",\n    contract=\"XXX\",\n    group=\"100\",\n    type=\"basic\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demodomain = new Akamai.GtmDomain(\"demodomain\", new()\n    {\n        Comment = \"some comment\",\n        Contract = \"XXX\",\n        Group = \"100\",\n        Type = \"basic\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmDomain(ctx, \"demodomain\", \u0026akamai.GtmDomainArgs{\n\t\t\tComment:  pulumi.String(\"some comment\"),\n\t\t\tContract: pulumi.String(\"XXX\"),\n\t\t\tGroup:    pulumi.String(\"100\"),\n\t\t\tType:     pulumi.String(\"basic\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmDomain;\nimport com.pulumi.akamai.GtmDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demodomain = new GtmDomain(\"demodomain\", GtmDomainArgs.builder()        \n            .comment(\"some comment\")\n            .contract(\"XXX\")\n            .group(100)\n            .type(\"basic\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demodomain:\n    type: akamai:GtmDomain\n    properties:\n      comment: some comment\n      contract: XXX\n      group: 100\n      type: basic\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultHealthMax": {
                    "type": "number"
                },
                "defaultHealthMultiplier": {
                    "type": "number"
                },
                "defaultHealthThreshold": {
                    "type": "number"
                },
                "defaultMaxUnreachablePenalty": {
                    "type": "integer"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "defaultUnreachableThreshold": {
                    "type": "number"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "mapUpdateInterval": {
                    "type": "integer"
                },
                "maxProperties": {
                    "type": "integer"
                },
                "maxResources": {
                    "type": "integer"
                },
                "maxTestTimeout": {
                    "type": "number"
                },
                "maxTtl": {
                    "type": "integer"
                },
                "minPingableRegionFraction": {
                    "type": "number"
                },
                "minTestInterval": {
                    "type": "integer"
                },
                "minTtl": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "pingInterval": {
                    "type": "integer"
                },
                "pingPacketSize": {
                    "type": "integer"
                },
                "roundRobinPrefix": {
                    "type": "string"
                },
                "servermonitorLivenessCount": {
                    "type": "integer"
                },
                "servermonitorLoadCount": {
                    "type": "integer"
                },
                "servermonitorPool": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "required": [
                "defaultHealthMax",
                "defaultHealthMultiplier",
                "defaultHealthThreshold",
                "defaultMaxUnreachablePenalty",
                "defaultUnreachableThreshold",
                "mapUpdateInterval",
                "maxProperties",
                "maxResources",
                "maxTestTimeout",
                "maxTtl",
                "minPingableRegionFraction",
                "minTestInterval",
                "minTtl",
                "name",
                "pingInterval",
                "pingPacketSize",
                "roundRobinPrefix",
                "servermonitorLivenessCount",
                "servermonitorLoadCount",
                "servermonitorPool",
                "type"
            ],
            "inputProperties": {
                "cnameCoalescingEnabled": {
                    "type": "boolean",
                    "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "contract": {
                    "type": "string",
                    "description": "If creating a domain, the contract ID.\n"
                },
                "defaultErrorPenalty": {
                    "type": "integer",
                    "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                },
                "defaultSslClientCertificate": {
                    "type": "string",
                    "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                },
                "defaultSslClientPrivateKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                },
                "defaultTimeoutPenalty": {
                    "type": "integer",
                    "description": "Specifies the timeout penalty score. Default is `25`.\n"
                },
                "emailNotificationLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email addresses to notify when a change is made to the domain.\n"
                },
                "endUserMappingEnabled": {
                    "type": "boolean",
                    "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                },
                "group": {
                    "type": "string",
                    "description": "If creating a domain, the currently selected group ID.\n"
                },
                "loadFeedback": {
                    "type": "boolean",
                    "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The DNS name for a collection of GTM Properties.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmDomain resources.\n",
                "properties": {
                    "cnameCoalescingEnabled": {
                        "type": "boolean",
                        "description": "A boolean that if set to `true`, GTM collapses CNAME redirections in DNS answers when it knows the target of the CNAME.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "contract": {
                        "type": "string",
                        "description": "If creating a domain, the contract ID.\n"
                    },
                    "defaultErrorPenalty": {
                        "type": "integer",
                        "description": "Specifies the download penalty score. The default is `75`. If the download encounters an error, the web agent computes a score that is either the download time in seconds or a penalty score.\n"
                    },
                    "defaultHealthMax": {
                        "type": "number"
                    },
                    "defaultHealthMultiplier": {
                        "type": "number"
                    },
                    "defaultHealthThreshold": {
                        "type": "number"
                    },
                    "defaultMaxUnreachablePenalty": {
                        "type": "integer"
                    },
                    "defaultSslClientCertificate": {
                        "type": "string",
                        "description": "Specifies an optional Base64-encoded certificate that corresponds with the private key for TLS-based liveness tests (HTTPS, SMTPS, POPS, and TCPS).\n"
                    },
                    "defaultSslClientPrivateKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded private key that corresponds with the TLS certificate for HTTPS, SMTPS, POPS, and TCPS liveness tests.\n"
                    },
                    "defaultTimeoutPenalty": {
                        "type": "integer",
                        "description": "Specifies the timeout penalty score. Default is `25`.\n"
                    },
                    "defaultUnreachableThreshold": {
                        "type": "number"
                    },
                    "emailNotificationLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email addresses to notify when a change is made to the domain.\n"
                    },
                    "endUserMappingEnabled": {
                        "type": "boolean",
                        "description": "A boolean indicating whether whether the GTM Domain is using end user client subnet mapping.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "If creating a domain, the currently selected group ID.\n"
                    },
                    "loadFeedback": {
                        "type": "boolean",
                        "description": "A boolean indicating whether one or more measurements of load (resources) are defined by you and supplied by each data center in real time to balance load.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percentage of load imbalance factor (LIF) for the domain.\n"
                    },
                    "mapUpdateInterval": {
                        "type": "integer"
                    },
                    "maxProperties": {
                        "type": "integer"
                    },
                    "maxResources": {
                        "type": "integer"
                    },
                    "maxTestTimeout": {
                        "type": "number"
                    },
                    "maxTtl": {
                        "type": "integer"
                    },
                    "minPingableRegionFraction": {
                        "type": "number"
                    },
                    "minTestInterval": {
                        "type": "integer"
                    },
                    "minTtl": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string",
                        "description": "The DNS name for a collection of GTM Properties.\n"
                    },
                    "pingInterval": {
                        "type": "integer"
                    },
                    "pingPacketSize": {
                        "type": "integer"
                    },
                    "roundRobinPrefix": {
                        "type": "string"
                    },
                    "servermonitorLivenessCount": {
                        "type": "integer"
                    },
                    "servermonitorLoadCount": {
                        "type": "integer"
                    },
                    "servermonitorPool": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Th type of GTM domain. Options include `failover-only`, `static`, `weighted`, `basic`, or `full`.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean that, if set to `true`, waits for transaction to complete.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmDomain has been deprecated in favor of akamai.GtmDomain"
        },
        "akamai:trafficmanagement/gtmGeomap:GtmGeomap": {
            "description": "Use the `akamai.GtmGeomap` resource to create, configure, and import a GTM Geographic map. Geographic mapping lets you configure a property that returns a CNAME based on the geographic location of the request.\n\nYou can reuse maps for multiple properties or create new ones. To configure a property for geographic mapping, you need to define at least one geographic map for your domain. Each map needs at least two definitions. For example, you can have one definition that maps a set of countries to a specific data center, and a second definition that routes all other traffic.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoGeomap = new akamai.GtmGeomap(\"demoGeomap\", {\n    defaultDatacenter: {\n        datacenterId: 5400,\n        nickname: \"All Others\",\n    },\n    domain: \"demo_domain.akadns.net\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_geomap = akamai.GtmGeomap(\"demoGeomap\",\n    default_datacenter=akamai.GtmGeomapDefaultDatacenterArgs(\n        datacenter_id=5400,\n        nickname=\"All Others\",\n    ),\n    domain=\"demo_domain.akadns.net\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoGeomap = new Akamai.GtmGeomap(\"demoGeomap\", new()\n    {\n        DefaultDatacenter = new Akamai.Inputs.GtmGeomapDefaultDatacenterArgs\n        {\n            DatacenterId = 5400,\n            Nickname = \"All Others\",\n        },\n        Domain = \"demo_domain.akadns.net\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmGeomap(ctx, \"demoGeomap\", \u0026akamai.GtmGeomapArgs{\n\t\t\tDefaultDatacenter: \u0026akamai.GtmGeomapDefaultDatacenterArgs{\n\t\t\t\tDatacenterId: pulumi.Int(5400),\n\t\t\t\tNickname:     pulumi.String(\"All Others\"),\n\t\t\t},\n\t\t\tDomain: pulumi.String(\"demo_domain.akadns.net\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmGeomap;\nimport com.pulumi.akamai.GtmGeomapArgs;\nimport com.pulumi.akamai.inputs.GtmGeomapDefaultDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoGeomap = new GtmGeomap(\"demoGeomap\", GtmGeomapArgs.builder()        \n            .defaultDatacenter(GtmGeomapDefaultDatacenterArgs.builder()\n                .datacenterId(5400)\n                .nickname(\"All Others\")\n                .build())\n            .domain(\"demo_domain.akadns.net\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoGeomap:\n    type: akamai:GtmGeomap\n    properties:\n      defaultDatacenter:\n        datacenterId: 5400\n        nickname: All Others\n      domain: demo_domain.akadns.net\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "defaultDatacenter",
                "domain",
                "name"
            ],
            "inputProperties": {
                "assignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                    },
                    "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                },
                "defaultDatacenter": {
                    "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                    "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                },
                "domain": {
                    "type": "string",
                    "description": "GTM Domain name for the Geographic Map.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the Geographic map.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "defaultDatacenter",
                "domain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmGeomap resources.\n",
                "properties": {
                    "assignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmGeomapAssignment:GtmGeomapAssignment"
                        },
                        "description": "Contains information about the geographic zone groupings of countries. You can have multiple `assignment` arguments. If used, requires these additional arguments:\n"
                    },
                    "defaultDatacenter": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmGeomapDefaultDatacenter:GtmGeomapDefaultDatacenter",
                        "description": "A placeholder for all other geographic zones. Requires these additional arguments:\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "GTM Domain name for the Geographic Map.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the Geographic map.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmGeomap has been deprecated in favor of akamai.GtmGeomap"
        },
        "akamai:trafficmanagement/gtmProperty:GtmProperty": {
            "description": "Use the `akamai.GtmProperty` resource to create, configure and import a GTM property, a set of IP addresses or CNAMEs that GTM provides in response to DNS queries based on a set of rules.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:`existing_property_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoProperty = new akamai.GtmProperty(\"demoProperty\", {\n    domain: \"demo_domain.akadns.net\",\n    handoutLimit: 5,\n    handoutMode: \"normal\",\n    scoreAggregationType: \"median\",\n    trafficTargets: [{\n        datacenterId: 3131,\n    }],\n    type: \"weighted-round-robin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_property = akamai.GtmProperty(\"demoProperty\",\n    domain=\"demo_domain.akadns.net\",\n    handout_limit=5,\n    handout_mode=\"normal\",\n    score_aggregation_type=\"median\",\n    traffic_targets=[akamai.GtmPropertyTrafficTargetArgs(\n        datacenter_id=3131,\n    )],\n    type=\"weighted-round-robin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoProperty = new Akamai.GtmProperty(\"demoProperty\", new()\n    {\n        Domain = \"demo_domain.akadns.net\",\n        HandoutLimit = 5,\n        HandoutMode = \"normal\",\n        ScoreAggregationType = \"median\",\n        TrafficTargets = new[]\n        {\n            new Akamai.Inputs.GtmPropertyTrafficTargetArgs\n            {\n                DatacenterId = 3131,\n            },\n        },\n        Type = \"weighted-round-robin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmProperty(ctx, \"demoProperty\", \u0026akamai.GtmPropertyArgs{\n\t\t\tDomain:               pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tHandoutLimit:         pulumi.Int(5),\n\t\t\tHandoutMode:          pulumi.String(\"normal\"),\n\t\t\tScoreAggregationType: pulumi.String(\"median\"),\n\t\t\tTrafficTargets: akamai.GtmPropertyTrafficTargetArray{\n\t\t\t\t\u0026akamai.GtmPropertyTrafficTargetArgs{\n\t\t\t\t\tDatacenterId: pulumi.Int(3131),\n\t\t\t\t},\n\t\t\t},\n\t\t\tType: pulumi.String(\"weighted-round-robin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmProperty;\nimport com.pulumi.akamai.GtmPropertyArgs;\nimport com.pulumi.akamai.inputs.GtmPropertyTrafficTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoProperty = new GtmProperty(\"demoProperty\", GtmPropertyArgs.builder()        \n            .domain(\"demo_domain.akadns.net\")\n            .handoutLimit(5)\n            .handoutMode(\"normal\")\n            .scoreAggregationType(\"median\")\n            .trafficTargets(GtmPropertyTrafficTargetArgs.builder()\n                .datacenterId(3131)\n                .build())\n            .type(\"weighted-round-robin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoProperty:\n    type: akamai:GtmProperty\n    properties:\n      domain: demo_domain.akadns.net\n      handoutLimit: 5\n      handoutMode: normal\n      scoreAggregationType: median\n      trafficTargets:\n        - datacenterId: 3131\n      type: weighted-round-robin\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                },
                "weightedHashBitsForIpv4": {
                    "type": "integer"
                },
                "weightedHashBitsForIpv6": {
                    "type": "integer"
                }
            },
            "required": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "name",
                "scoreAggregationType",
                "type",
                "weightedHashBitsForIpv4",
                "weightedHashBitsForIpv6"
            ],
            "inputProperties": {
                "backupCname": {
                    "type": "string",
                    "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                },
                "backupIp": {
                    "type": "string",
                    "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                },
                "balanceByDownloadScore": {
                    "type": "boolean",
                    "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Indicates the fully qualified name aliased to a particular property.\n"
                },
                "comments": {
                    "type": "string",
                    "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this Property.\n"
                },
                "dynamicTtl": {
                    "type": "integer",
                    "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                },
                "failbackDelay": {
                    "type": "integer",
                    "description": "Specifies the failback delay in seconds.\n"
                },
                "failoverDelay": {
                    "type": "integer",
                    "description": "Specifies the failover delay in seconds.\n"
                },
                "ghostDemandReporting": {
                    "type": "boolean",
                    "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                },
                "handoutLimit": {
                    "type": "integer",
                    "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                },
                "handoutMode": {
                    "type": "string",
                    "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                },
                "healthMax": {
                    "type": "number",
                    "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                },
                "healthMultiplier": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "healthThreshold": {
                    "type": "number",
                    "description": "Configures a cutoff value that is computed from the median scores.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                },
                "livenessTests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                    },
                    "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                },
                "loadImbalancePercentage": {
                    "type": "number",
                    "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                },
                "mapName": {
                    "type": "string",
                    "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                },
                "maxUnreachablePenalty": {
                    "type": "integer",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                },
                "minLiveFraction": {
                    "type": "number",
                    "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of HTTP header.\n"
                },
                "scoreAggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                },
                "staticRrSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                    },
                    "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                },
                "staticTtl": {
                    "type": "integer"
                },
                "stickinessBonusConstant": {
                    "type": "integer",
                    "description": "Specifies a constant used to configure data center affinity.\n"
                },
                "stickinessBonusPercentage": {
                    "type": "integer",
                    "description": "Specifies a percentage used to configure data center affinity.\n"
                },
                "trafficTargets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                    },
                    "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "The record type.\n"
                },
                "unreachableThreshold": {
                    "type": "number",
                    "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                },
                "useComputedTargets": {
                    "type": "boolean",
                    "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "handoutLimit",
                "handoutMode",
                "scoreAggregationType",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmProperty resources.\n",
                "properties": {
                    "backupCname": {
                        "type": "string",
                        "description": "Specifies a backup CNAME. If GTM declares that all of the servers configured for your property are down, the backup CNAME is handed out. If a backup CNAME is set, do not set a backup IP.\n"
                    },
                    "backupIp": {
                        "type": "string",
                        "description": "Specifies a backup IP. When GTM declares that all of the targets are down, the backup IP is handed out. If a backup IP is set, do not set a backup CNAME.\n"
                    },
                    "balanceByDownloadScore": {
                        "type": "boolean",
                        "description": "A boolean that indicates whether download score based load balancing is enabled.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Indicates the fully qualified name aliased to a particular property.\n"
                    },
                    "comments": {
                        "type": "string",
                        "description": "A descriptive note about changes to the domain. The maximum is 4000 characters.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this Property.\n"
                    },
                    "dynamicTtl": {
                        "type": "integer",
                        "description": "Indicates the TTL in seconds for records that might change dynamically based on liveness and load balancing such as A and AAAA records, and CNAMEs.\n"
                    },
                    "failbackDelay": {
                        "type": "integer",
                        "description": "Specifies the failback delay in seconds.\n"
                    },
                    "failoverDelay": {
                        "type": "integer",
                        "description": "Specifies the failover delay in seconds.\n"
                    },
                    "ghostDemandReporting": {
                        "type": "boolean",
                        "description": "Use load estimates from Akamai Ghost utilization messages.\n"
                    },
                    "handoutLimit": {
                        "type": "integer",
                        "description": "Indicates the limit for the number of live IPs handed out to a DNS request.\n"
                    },
                    "handoutMode": {
                        "type": "string",
                        "description": "Specifies how IPs are returned when more than one IP is alive and available.\n"
                    },
                    "healthMax": {
                        "type": "number",
                        "description": "Defines the absolute limit beyond which IPs are declared unhealthy.\n"
                    },
                    "healthMultiplier": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "healthThreshold": {
                        "type": "number",
                        "description": "Configures a cutoff value that is computed from the median scores.\n"
                    },
                    "ipv6": {
                        "type": "boolean",
                        "description": "A boolean that indicates the type of IP address handed out by a GTM property.\n"
                    },
                    "livenessTests": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyLivenessTest:GtmPropertyLivenessTest"
                        },
                        "description": "Contains information about the liveness tests, which are run periodically to determine whether your servers respond to requests. You can have multiple `liveness_test` arguments. If used, requires these arguments:\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number",
                        "description": "Indicates the percent of load imbalance factor (LIF) for the property.\n"
                    },
                    "mapName": {
                        "type": "string",
                        "description": "A descriptive label for a GeographicMap or a CidrMap that's required if the property is either geographic or cidrmapping, in which case mapName needs to reference either an existing GeographicMap or CidrMap in the same domain.\n"
                    },
                    "maxUnreachablePenalty": {
                        "type": "integer",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers show an aggregated loss fraction higher than the penalty value.\n"
                    },
                    "minLiveFraction": {
                        "type": "number",
                        "description": "Specifies what fraction of the servers need to respond to requests so GTM considers the data center up and able to receive traffic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of HTTP header.\n"
                    },
                    "scoreAggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM aggregates liveness test scores across different tests, when multiple tests are configured.\n"
                    },
                    "staticRrSets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyStaticRrSet:GtmPropertyStaticRrSet"
                        },
                        "description": "Contains static record sets. You can have multiple `static_rr_set` entries. Requires these arguments:\n"
                    },
                    "staticTtl": {
                        "type": "integer"
                    },
                    "stickinessBonusConstant": {
                        "type": "integer",
                        "description": "Specifies a constant used to configure data center affinity.\n"
                    },
                    "stickinessBonusPercentage": {
                        "type": "integer",
                        "description": "Specifies a percentage used to configure data center affinity.\n"
                    },
                    "trafficTargets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmPropertyTrafficTarget:GtmPropertyTrafficTarget"
                        },
                        "description": "Contains information about where to direct data center traffic. You can have multiple `traffic_target` arguments. If used, includes these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The record type.\n"
                    },
                    "unreachableThreshold": {
                        "type": "number",
                        "description": "For performance domains, this specifies a penalty value that's added to liveness test scores when data centers have an aggregated loss fraction higher than this value.\n"
                    },
                    "useComputedTargets": {
                        "type": "boolean",
                        "description": "For load-feedback domains only, a boolean that indicates whether you want GTM to automatically compute target load.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    },
                    "weightedHashBitsForIpv4": {
                        "type": "integer"
                    },
                    "weightedHashBitsForIpv6": {
                        "type": "integer"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmProperty has been deprecated in favor of akamai.GtmProperty"
        },
        "akamai:trafficmanagement/gtmResource:GtmResource": {
            "description": "The `akamai.GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second.\n\n\u003e **Note** Import requires an ID with this format: `existing_domain_name`:\n`existing_resource_name`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst demoResource = new akamai.GtmResource(\"demoResource\", {\n    aggregationType: \"latest\",\n    domain: \"demo_domain.akadns.net\",\n    type: \"XML load object via HTTP\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ndemo_resource = akamai.GtmResource(\"demoResource\",\n    aggregation_type=\"latest\",\n    domain=\"demo_domain.akadns.net\",\n    type=\"XML load object via HTTP\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoResource = new Akamai.GtmResource(\"demoResource\", new()\n    {\n        AggregationType = \"latest\",\n        Domain = \"demo_domain.akadns.net\",\n        Type = \"XML load object via HTTP\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.NewGtmResource(ctx, \"demoResource\", \u0026akamai.GtmResourceArgs{\n\t\t\tAggregationType: pulumi.String(\"latest\"),\n\t\t\tDomain:          pulumi.String(\"demo_domain.akadns.net\"),\n\t\t\tType:            pulumi.String(\"XML load object via HTTP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.GtmResource;\nimport com.pulumi.akamai.GtmResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoResource = new GtmResource(\"demoResource\", GtmResourceArgs.builder()        \n            .aggregationType(\"latest\")\n            .domain(\"demo_domain.akadns.net\")\n            .type(\"XML load object via HTTP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demoResource:\n    type: akamai:GtmResource\n    properties:\n      aggregationType: latest\n      domain: demo_domain.akadns.net\n      type: XML load object via HTTP\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "required": [
                "aggregationType",
                "domain",
                "name",
                "type"
            ],
            "inputProperties": {
                "aggregationType": {
                    "type": "string",
                    "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                },
                "constrainedProperty": {
                    "type": "string",
                    "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                },
                "decayRate": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A descriptive note to help you track what the resource constrains.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "DNS name for the GTM Domain set that includes this property.\n"
                },
                "hostHeader": {
                    "type": "string",
                    "description": "Optionally specifies the host header used when fetching the load object.\n"
                },
                "leaderString": {
                    "type": "string",
                    "description": "Specifies the text that comes before the `load_object`.\n"
                },
                "leastSquaresDecay": {
                    "type": "number",
                    "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                },
                "loadImbalancePercentage": {
                    "type": "number"
                },
                "maxUMultiplicativeIncrement": {
                    "type": "number",
                    "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive label for the GTM resource.\n"
                },
                "resourceInstances": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                    },
                    "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                },
                "type": {
                    "type": "string",
                    "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                },
                "upperBound": {
                    "type": "integer",
                    "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                },
                "waitOnComplete": {
                    "type": "boolean",
                    "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                }
            },
            "requiredInputs": [
                "aggregationType",
                "domain",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GtmResource resources.\n",
                "properties": {
                    "aggregationType": {
                        "type": "string",
                        "description": "Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.\n"
                    },
                    "constrainedProperty": {
                        "type": "string",
                        "description": "Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.\n"
                    },
                    "decayRate": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A descriptive note to help you track what the resource constrains.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "DNS name for the GTM Domain set that includes this property.\n"
                    },
                    "hostHeader": {
                        "type": "string",
                        "description": "Optionally specifies the host header used when fetching the load object.\n"
                    },
                    "leaderString": {
                        "type": "string",
                        "description": "Specifies the text that comes before the `load_object`.\n"
                    },
                    "leastSquaresDecay": {
                        "type": "number",
                        "description": "For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.\n"
                    },
                    "loadImbalancePercentage": {
                        "type": "number"
                    },
                    "maxUMultiplicativeIncrement": {
                        "type": "number",
                        "description": "For Akamai internal use only. You can omit the value or set it to `null`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive label for the GTM resource.\n"
                    },
                    "resourceInstances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:trafficmanagement/GtmResourceResourceInstance:GtmResourceResourceInstance"
                        },
                        "description": "(multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Indicates the kind of `load_object` format used to determine the load on the resource.\n"
                    },
                    "upperBound": {
                        "type": "integer",
                        "description": "An optional sanity check that specifies the maximum allowed value for any component of the load object.\n"
                    },
                    "waitOnComplete": {
                        "type": "boolean",
                        "description": "A boolean indicating whether to wait for transaction to complete. Set to `true` by default.\n"
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "akamai.trafficmanagement.GtmResource has been deprecated in favor of akamai.GtmResource"
        }
    },
    "functions": {
        "akamai:edgedns/getAuthoritiesSet:getAuthoritiesSet": {
            "description": "Use the `akamai.getAuthoritiesSet` data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getAuthoritiesSet({\n    contract: \"ctr_1-AB123\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_authorities_set(contract=\"ctr_1-AB123\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetAuthoritiesSet.Invoke(new()\n    {\n        Contract = \"ctr_1-AB123\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAuthoritiesSet(ctx, \u0026akamai.GetAuthoritiesSetArgs{\n\t\t\tContract: \"ctr_1-AB123\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()\n            .contract(\"ctr_1-AB123\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getAuthoritiesSet\n      Arguments:\n        contract: ctr_1-AB123\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source supports this attribute:\n\n* `authorities` - A list of authorities.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthoritiesSet.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contract"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthoritiesSet.\n",
                "properties": {
                    "authorities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "contract": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authorities",
                    "contract",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.edgedns.getAuthoritiesSet has been deprecated in favor of akamai.getAuthoritiesSet"
        },
        "akamai:edgedns/getDnsRecordSet:getDnsRecordSet": {
            "inputs": {
                "description": "A collection of arguments for invoking getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "recordType",
                    "zone"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rdatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "rdatas",
                    "recordType",
                    "zone",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.edgedns.getDnsRecordSet has been deprecated in favor of akamai.getDnsRecordSet"
        },
        "akamai:index/getAppSecAdvancedSettingsEvasivePathMatch:getAppSecAdvancedSettingsEvasivePathMatch": {
            "description": "**Scopes**: Security configuration; security policy\n\nUse the `akamai.AppSecAdvancedSettingsEvasivePathMatch` data source to retrieve information about the evasive path match for a configuration. This operation applies at the configuration level, and therefore applies to all policies within a configuration. You may retrieve these settings for a particular policy by specifying the policy using the `security_policy_id` parameter. For more information, see [Get evasive path match setting](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match).\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/get-evasive-path-match)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst evasivePathMatch = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsEvasivePathMatch({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsEvasivePathMatchOutput = evasivePathMatch.then(evasivePathMatch =\u003e evasivePathMatch.outputText);\nexport const advancedSettingsEvasivePathMatchJson = evasivePathMatch.then(evasivePathMatch =\u003e evasivePathMatch.json);\nconst policyOverride = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsEvasivePathMatch({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n}));\nexport const advancedSettingsPolicyEvasivePathMatchOutput = policyOverride.then(policyOverride =\u003e policyOverride.outputText);\nexport const advancedSettingsPolicyEvasivePathMatchJson = policyOverride.then(policyOverride =\u003e policyOverride.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\nevasive_path_match = akamai.get_app_sec_advanced_settings_evasive_path_match(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsEvasivePathMatchOutput\", evasive_path_match.output_text)\npulumi.export(\"advancedSettingsEvasivePathMatchJson\", evasive_path_match.json)\npolicy_override = akamai.get_app_sec_advanced_settings_evasive_path_match(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"])\npulumi.export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policy_override.output_text)\npulumi.export(\"advancedSettingsPolicyEvasivePathMatchJson\", policy_override.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = @var.Security_configuration,\n    });\n\n    var evasivePathMatch = Akamai.GetAppSecAdvancedSettingsEvasivePathMatch.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var policyOverride = Akamai.GetAppSecAdvancedSettingsEvasivePathMatch.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = @var.Security_policy_id,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"advancedSettingsEvasivePathMatchOutput\"] = evasivePathMatch.Apply(getAppSecAdvancedSettingsEvasivePathMatchResult =\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.OutputText),\n        [\"advancedSettingsEvasivePathMatchJson\"] = evasivePathMatch.Apply(getAppSecAdvancedSettingsEvasivePathMatchResult =\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.Json),\n        [\"advancedSettingsPolicyEvasivePathMatchOutput\"] = policyOverride.Apply(getAppSecAdvancedSettingsEvasivePathMatchResult =\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.OutputText),\n        [\"advancedSettingsPolicyEvasivePathMatchJson\"] = policyOverride.Apply(getAppSecAdvancedSettingsEvasivePathMatchResult =\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevasivePathMatch, err := akamai.LookupAppSecAdvancedSettingsEvasivePathMatch(ctx, \u0026akamai.LookupAppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsEvasivePathMatchOutput\", evasivePathMatch.OutputText)\n\t\tctx.Export(\"advancedSettingsEvasivePathMatchJson\", evasivePathMatch.Json)\n\t\tpolicyOverride, err := akamai.LookupAppSecAdvancedSettingsEvasivePathMatch(ctx, \u0026akamai.LookupAppSecAdvancedSettingsEvasivePathMatchArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policyOverride.OutputText)\n\t\tctx.Export(\"advancedSettingsPolicyEvasivePathMatchJson\", policyOverride.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsEvasivePathMatchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        final var evasivePathMatch = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsEvasivePathMatchOutput\", evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));\n        ctx.export(\"advancedSettingsEvasivePathMatchJson\", evasivePathMatch.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.json()));\n        final var policyOverride = AkamaiFunctions.getAppSecAdvancedSettingsEvasivePathMatch(GetAppSecAdvancedSettingsEvasivePathMatchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .build());\n\n        ctx.export(\"advancedSettingsPolicyEvasivePathMatchOutput\", policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.outputText()));\n        ctx.export(\"advancedSettingsPolicyEvasivePathMatchJson\", policyOverride.applyValue(getAppSecAdvancedSettingsEvasivePathMatchResult -\u003e getAppSecAdvancedSettingsEvasivePathMatchResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n  evasivePathMatch:\n    fn::invoke:\n      Function: akamai:getAppSecAdvancedSettingsEvasivePathMatch\n      Arguments:\n        configId: ${configuration.configId}\n  policyOverride:\n    fn::invoke:\n      Function: akamai:getAppSecAdvancedSettingsEvasivePathMatch\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\noutputs:\n  advancedSettingsEvasivePathMatchOutput: ${evasivePathMatch.outputText}\n  advancedSettingsEvasivePathMatchJson: ${evasivePathMatch.json}\n  advancedSettingsPolicyEvasivePathMatchOutput: ${policyOverride.outputText}\n  advancedSettingsPolicyEvasivePathMatchJson: ${policyOverride.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsEvasivePathMatch.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": "The configuration ID.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": "The ID of the security policy to use.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsEvasivePathMatch.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "A JSON-formatted list of information about the evasive path match settings.\n"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "A tabular display showing the evasive path match settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsLogging:getAppSecAdvancedSettingsLogging": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about your HTTP header logging controls. By default, information is returned for all the security policies in the configuration; however, you can return data for a single policy by using the `security_policy_id` parameter. The returned information is described in the [ConfigHeaderLog members](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-logging)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRules = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n}));\nexport const customRulesOutputText = customRules.then(customRules =\u003e customRules.outputText);\nexport const customRulesJson = customRules.then(customRules =\u003e customRules.json);\nexport const customRulesConfigId = customRules.then(customRules =\u003e customRules.configId);\nconst specificCustomRule = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n    customRuleId: 60029316,\n}));\nexport const specificCustomRuleJson = specificCustomRule.then(specificCustomRule =\u003e specificCustomRule.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rules = akamai.get_app_sec_custom_rules(config_id=configuration.config_id)\npulumi.export(\"customRulesOutputText\", custom_rules.output_text)\npulumi.export(\"customRulesJson\", custom_rules.json)\npulumi.export(\"customRulesConfigId\", custom_rules.config_id)\nspecific_custom_rule = akamai.get_app_sec_custom_rules(config_id=configuration.config_id,\n    custom_rule_id=60029316)\npulumi.export(\"specificCustomRuleJson\", specific_custom_rule.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var customRules = Akamai.GetAppSecCustomRules.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var specificCustomRule = Akamai.GetAppSecCustomRules.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        CustomRuleId = 60029316,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customRulesOutputText\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.OutputText),\n        [\"customRulesJson\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.Json),\n        [\"customRulesConfigId\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.ConfigId),\n        [\"specificCustomRuleJson\"] = specificCustomRule.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRules, err := akamai.GetAppSecCustomRules(ctx, \u0026akamai.GetAppSecCustomRulesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRulesOutputText\", customRules.OutputText)\n\t\tctx.Export(\"customRulesJson\", customRules.Json)\n\t\tctx.Export(\"customRulesConfigId\", customRules.ConfigId)\n\t\tspecificCustomRule, err := akamai.GetAppSecCustomRules(ctx, \u0026akamai.GetAppSecCustomRulesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomRuleId: pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"specificCustomRuleJson\", specificCustomRule.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customRulesOutputText\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.outputText()));\n        ctx.export(\"customRulesJson\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n        ctx.export(\"customRulesConfigId\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.configId()));\n        final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customRuleId(\"60029316\")\n            .build());\n\n        ctx.export(\"specificCustomRuleJson\", specificCustomRule.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRules:\n    fn::invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n  specificCustomRule:\n    fn::invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n        customRuleId: '60029316'\noutputs:\n  customRulesOutputText: ${customRules.outputText}\n  customRulesJson: ${customRules.json}\n  customRulesConfigId: ${customRules.configId} # USE CASE: User wants to view a specific custom rule.\n  specificCustomRuleJson: ${specificCustomRule.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the logging settings.\n- `output_text`. Tabular report showing the logging settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsLogging.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the logging settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the logging settings. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsLogging.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsPragmaHeader:getAppSecAdvancedSettingsPragmaHeader": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns pragma header settings information. This HTTP header provides information about such things as: the edge routers used in a transaction; the Akamai IP addresses involved; information about whether a request was cached or not; and so on. By default, pragma headers are removed from all responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/pragma-header](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-pragma-header)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst pragmaHeader = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPragmaHeader({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsPragmaHeaderOutput = pragmaHeader.then(pragmaHeader =\u003e pragmaHeader.outputText);\nexport const advancedSettingsPragmaHeaderJson = pragmaHeader.then(pragmaHeader =\u003e pragmaHeader.json);\nconst policyPragmaHeader = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPragmaHeader({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const advancedSettingsPolicyPragmaHeaderOutput = policyPragmaHeader.then(policyPragmaHeader =\u003e policyPragmaHeader.outputText);\nexport const advancedSettingsPolicyPragmaHeaderJson = policyPragmaHeader.then(policyPragmaHeader =\u003e policyPragmaHeader.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npragma_header = akamai.get_app_sec_advanced_settings_pragma_header(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsPragmaHeaderOutput\", pragma_header.output_text)\npulumi.export(\"advancedSettingsPragmaHeaderJson\", pragma_header.json)\npolicy_pragma_header = akamai.get_app_sec_advanced_settings_pragma_header(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"advancedSettingsPolicyPragmaHeaderOutput\", policy_pragma_header.output_text)\npulumi.export(\"advancedSettingsPolicyPragmaHeaderJson\", policy_pragma_header.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var pragmaHeader = Akamai.GetAppSecAdvancedSettingsPragmaHeader.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var policyPragmaHeader = Akamai.GetAppSecAdvancedSettingsPragmaHeader.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"advancedSettingsPragmaHeaderOutput\"] = pragmaHeader.Apply(getAppSecAdvancedSettingsPragmaHeaderResult =\u003e getAppSecAdvancedSettingsPragmaHeaderResult.OutputText),\n        [\"advancedSettingsPragmaHeaderJson\"] = pragmaHeader.Apply(getAppSecAdvancedSettingsPragmaHeaderResult =\u003e getAppSecAdvancedSettingsPragmaHeaderResult.Json),\n        [\"advancedSettingsPolicyPragmaHeaderOutput\"] = policyPragmaHeader.Apply(getAppSecAdvancedSettingsPragmaHeaderResult =\u003e getAppSecAdvancedSettingsPragmaHeaderResult.OutputText),\n        [\"advancedSettingsPolicyPragmaHeaderJson\"] = policyPragmaHeader.Apply(getAppSecAdvancedSettingsPragmaHeaderResult =\u003e getAppSecAdvancedSettingsPragmaHeaderResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpragmaHeader, err := akamai.LookupAppSecAdvancedSettingsPragmaHeader(ctx, \u0026akamai.LookupAppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPragmaHeaderOutput\", pragmaHeader.OutputText)\n\t\tctx.Export(\"advancedSettingsPragmaHeaderJson\", pragmaHeader.Json)\n\t\tpolicyPragmaHeader, err := akamai.LookupAppSecAdvancedSettingsPragmaHeader(ctx, \u0026akamai.LookupAppSecAdvancedSettingsPragmaHeaderArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(\"gms1_134637\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPolicyPragmaHeaderOutput\", policyPragmaHeader.OutputText)\n\t\tctx.Export(\"advancedSettingsPolicyPragmaHeaderJson\", policyPragmaHeader.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPragmaHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var pragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsPragmaHeaderOutput\", pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));\n        ctx.export(\"advancedSettingsPragmaHeaderJson\", pragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.json()));\n        final var policyPragmaHeader = AkamaiFunctions.getAppSecAdvancedSettingsPragmaHeader(GetAppSecAdvancedSettingsPragmaHeaderArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"advancedSettingsPolicyPragmaHeaderOutput\", policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.outputText()));\n        ctx.export(\"advancedSettingsPolicyPragmaHeaderJson\", policyPragmaHeader.applyValue(getAppSecAdvancedSettingsPragmaHeaderResult -\u003e getAppSecAdvancedSettingsPragmaHeaderResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  pragmaHeader:\n    fn::invoke:\n      Function: akamai:getAppSecAdvancedSettingsPragmaHeader\n      Arguments:\n        configId: ${configuration.configId}\n  policyPragmaHeader:\n    fn::invoke:\n      Function: akamai:getAppSecAdvancedSettingsPragmaHeader\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  advancedSettingsPragmaHeaderOutput: ${pragmaHeader.outputText}\n  advancedSettingsPragmaHeaderJson: ${pragmaHeader.json}\n  advancedSettingsPolicyPragmaHeaderOutput: ${policyPragmaHeader.outputText}\n  advancedSettingsPolicyPragmaHeaderJson: ${policyPragmaHeader.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the pragma header settings.\n- `output_text`. Tabular report showing the pragma header settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsPragmaHeader.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the pragma header settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the pragma header settings. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsPragmaHeader.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAdvancedSettingsPrefetch:getAppSecAdvancedSettingsPrefetch": {
            "description": "**Scopes**: Security configuration\n\nReturns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests — requests originating outside of your firewall or Akamai's edge servers. When prefetch is enabled, requests between your origin servers and Akamai's edge servers can also be inspected by the firewall.\n\n**Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst prefetch = configuration.then(configuration =\u003e akamai.getAppSecAdvancedSettingsPrefetch({\n    configId: configuration.configId,\n}));\nexport const advancedSettingsPrefetchOutput = prefetch.then(prefetch =\u003e prefetch.outputText);\nexport const advancedSettingsPrefetchJson = prefetch.then(prefetch =\u003e prefetch.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprefetch = akamai.get_app_sec_advanced_settings_prefetch(config_id=configuration.config_id)\npulumi.export(\"advancedSettingsPrefetchOutput\", prefetch.output_text)\npulumi.export(\"advancedSettingsPrefetchJson\", prefetch.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var prefetch = Akamai.GetAppSecAdvancedSettingsPrefetch.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"advancedSettingsPrefetchOutput\"] = prefetch.Apply(getAppSecAdvancedSettingsPrefetchResult =\u003e getAppSecAdvancedSettingsPrefetchResult.OutputText),\n        [\"advancedSettingsPrefetchJson\"] = prefetch.Apply(getAppSecAdvancedSettingsPrefetchResult =\u003e getAppSecAdvancedSettingsPrefetchResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefetch, err := akamai.LookupAppSecAdvancedSettingsPrefetch(ctx, \u0026akamai.LookupAppSecAdvancedSettingsPrefetchArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"advancedSettingsPrefetchOutput\", prefetch.OutputText)\n\t\tctx.Export(\"advancedSettingsPrefetchJson\", prefetch.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAdvancedSettingsPrefetchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var prefetch = AkamaiFunctions.getAppSecAdvancedSettingsPrefetch(GetAppSecAdvancedSettingsPrefetchArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"advancedSettingsPrefetchOutput\", prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -\u003e getAppSecAdvancedSettingsPrefetchResult.outputText()));\n        ctx.export(\"advancedSettingsPrefetchJson\", prefetch.applyValue(getAppSecAdvancedSettingsPrefetchResult -\u003e getAppSecAdvancedSettingsPrefetchResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  prefetch: # USE CASE: User wants to display returned data in a table.\n    fn::invoke:\n      Function: akamai:getAppSecAdvancedSettingsPrefetch\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  advancedSettingsPrefetchOutput: ${prefetch.outputText}\n  advancedSettingsPrefetchJson: ${prefetch.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the prefetch request settings.\n- `output_text`. Tabular report showing the prefetch request settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAdvancedSettingsPrefetch.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the prefetch settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAdvancedSettingsPrefetch.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecApiEndpoints:getAppSecApiEndpoints": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about the API endpoints associated with a security policy or configuration. \n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst apiEndpoints = akamai.getAppSecApiEndpoints({\n    apiName: \"Contracts\",\n    configId: 58843,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\napi_endpoints = akamai.get_app_sec_api_endpoints(api_name=\"Contracts\",\n    config_id=58843)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var apiEndpoints = Akamai.GetAppSecApiEndpoints.Invoke(new()\n    {\n        ApiName = \"Contracts\",\n        ConfigId = 58843,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAppSecApiEndpoints(ctx, \u0026akamai.GetAppSecApiEndpointsArgs{\n\t\t\tApiName:  pulumi.StringRef(\"Contracts\"),\n\t\t\tConfigId: 58843,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecApiEndpointsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var apiEndpoints = AkamaiFunctions.getAppSecApiEndpoints(GetAppSecApiEndpointsArgs.builder()\n            .apiName(\"Contracts\")\n            .configId(58843)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  apiEndpoints:\n    fn::invoke:\n      Function: akamai:getAppSecApiEndpoints\n      Arguments:\n        apiName: Contracts\n        configId: 58843\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `id_list`. List of API endpoint IDs.\n- `json`. JSON-formatted list of information about the API endpoints.\n- `output_text`. Tabular report showing the ID and name of the API endpoints.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecApiEndpoints.\n",
                "properties": {
                    "apiName": {
                        "type": "string",
                        "description": ". Name of the API endpoint you want to return information for. If not included, information is returned for all your API endpoints.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API endpoints.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API endpoints. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecApiEndpoints.\n",
                "properties": {
                    "apiName": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "idLists": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        }
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "idLists",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecApiRequestConstraints:getAppSecApiRequestConstraints": {
            "description": "**Scopes**: Security policy; API endpoint\n\nReturns information about API endpoint constraints and actions. \n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-request-constraints](https://techdocs.akamai.com/application-security/reference/get-api-request-constraints)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst apisRequestConstraints = configuration.then(configuration =\u003e akamai.getAppSecApiRequestConstraints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const apisConstraintsText = apisRequestConstraints.then(apisRequestConstraints =\u003e apisRequestConstraints.outputText);\nexport const apisConstraintsJson = apisRequestConstraints.then(apisRequestConstraints =\u003e apisRequestConstraints.json);\nconst apiRequestConstraints = configuration.then(configuration =\u003e akamai.getAppSecApiRequestConstraints({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    apiId: 624913,\n}));\nexport const apiConstraintsText = apiRequestConstraints.then(apiRequestConstraints =\u003e apiRequestConstraints.outputText);\nexport const apiConstraintsJson = apiRequestConstraints.then(apiRequestConstraints =\u003e apiRequestConstraints.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\napis_request_constraints = akamai.get_app_sec_api_request_constraints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"apisConstraintsText\", apis_request_constraints.output_text)\npulumi.export(\"apisConstraintsJson\", apis_request_constraints.json)\napi_request_constraints = akamai.get_app_sec_api_request_constraints(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    api_id=624913)\npulumi.export(\"apiConstraintsText\", api_request_constraints.output_text)\npulumi.export(\"apiConstraintsJson\", api_request_constraints.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var apisRequestConstraints = Akamai.GetAppSecApiRequestConstraints.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    var apiRequestConstraints = Akamai.GetAppSecApiRequestConstraints.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ApiId = 624913,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"apisConstraintsText\"] = apisRequestConstraints.Apply(getAppSecApiRequestConstraintsResult =\u003e getAppSecApiRequestConstraintsResult.OutputText),\n        [\"apisConstraintsJson\"] = apisRequestConstraints.Apply(getAppSecApiRequestConstraintsResult =\u003e getAppSecApiRequestConstraintsResult.Json),\n        [\"apiConstraintsText\"] = apiRequestConstraints.Apply(getAppSecApiRequestConstraintsResult =\u003e getAppSecApiRequestConstraintsResult.OutputText),\n        [\"apiConstraintsJson\"] = apiRequestConstraints.Apply(getAppSecApiRequestConstraintsResult =\u003e getAppSecApiRequestConstraintsResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tapisRequestConstraints, err := akamai.LookupAppSecApiRequestConstraints(ctx, \u0026akamai.LookupAppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"apisConstraintsText\", apisRequestConstraints.OutputText)\n\t\tctx.Export(\"apisConstraintsJson\", apisRequestConstraints.Json)\n\t\tapiRequestConstraints, err := akamai.LookupAppSecApiRequestConstraints(ctx, \u0026akamai.LookupAppSecApiRequestConstraintsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t\tApiId:            pulumi.IntRef(624913),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"apiConstraintsText\", apiRequestConstraints.OutputText)\n\t\tctx.Export(\"apiConstraintsJson\", apiRequestConstraints.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecApiRequestConstraintsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var apisRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"apisConstraintsText\", apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.outputText()));\n        ctx.export(\"apisConstraintsJson\", apisRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.json()));\n        final var apiRequestConstraints = AkamaiFunctions.getAppSecApiRequestConstraints(GetAppSecApiRequestConstraintsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .apiId(624913)\n            .build());\n\n        ctx.export(\"apiConstraintsText\", apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.outputText()));\n        ctx.export(\"apiConstraintsJson\", apiRequestConstraints.applyValue(getAppSecApiRequestConstraintsResult -\u003e getAppSecApiRequestConstraintsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  apisRequestConstraints:\n    fn::invoke:\n      Function: akamai:getAppSecApiRequestConstraints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n  apiRequestConstraints:\n    fn::invoke:\n      Function: akamai:getAppSecApiRequestConstraints\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        apiId: 624913\noutputs:\n  apisConstraintsText: ${apisRequestConstraints.outputText}\n  apisConstraintsJson: ${apisRequestConstraints.json} # USE CASE: User wants to view the action associated with an API request constraint.\n  apiConstraintsText: ${apiRequestConstraints.outputText}\n  apiConstraintsJson: ${apiRequestConstraints.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of information about the APIs, their constraints, and their actions.\n- `output_text`. Tabular report of the APIs, their constraints, and their actions.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecApiRequestConstraints.\n",
                "properties": {
                    "apiId": {
                        "type": "integer",
                        "description": ". Unique identifier of the API endpoint you want to return constraint information for.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the API constraints.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the API constraints.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecApiRequestConstraints.\n",
                "properties": {
                    "apiId": {
                        "type": "integer"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecAttackGroups:getAppSecAttackGroups": {
            "description": "**Scopes**: Security policy; attack group\n\nReturns the action and the condition-exception information for an attack group or set of attack groups. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups](https://techdocs.akamai.com/application-security/reference/get-policy-attack-groups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst attackGroup = configuration.then(configuration =\u003e akamai.getAppSecAttackGroups({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    attackGroup: \"SQL\",\n}));\nexport const attackGroupAction = attackGroup.then(attackGroup =\u003e attackGroup.attackGroupAction);\nexport const conditionException = attackGroup.then(attackGroup =\u003e attackGroup.conditionException);\nexport const json = attackGroup.then(attackGroup =\u003e attackGroup.json);\nexport const outputText = attackGroup.then(attackGroup =\u003e attackGroup.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nattack_group = akamai.get_app_sec_attack_groups(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    attack_group=\"SQL\")\npulumi.export(\"attackGroupAction\", attack_group.attack_group_action)\npulumi.export(\"conditionException\", attack_group.condition_exception)\npulumi.export(\"json\", attack_group.json)\npulumi.export(\"outputText\", attack_group.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var attackGroup = Akamai.GetAppSecAttackGroups.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        AttackGroup = \"SQL\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"attackGroupAction\"] = attackGroup.Apply(getAppSecAttackGroupsResult =\u003e getAppSecAttackGroupsResult.AttackGroupAction),\n        [\"conditionException\"] = attackGroup.Apply(getAppSecAttackGroupsResult =\u003e getAppSecAttackGroupsResult.ConditionException),\n        [\"json\"] = attackGroup.Apply(getAppSecAttackGroupsResult =\u003e getAppSecAttackGroupsResult.Json),\n        [\"outputText\"] = attackGroup.Apply(getAppSecAttackGroupsResult =\u003e getAppSecAttackGroupsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tattackGroup, err := akamai.GetAppSecAttackGroups(ctx, \u0026akamai.GetAppSecAttackGroupsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t\tAttackGroup:      pulumi.StringRef(\"SQL\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"attackGroupAction\", attackGroup.AttackGroupAction)\n\t\tctx.Export(\"conditionException\", attackGroup.ConditionException)\n\t\tctx.Export(\"json\", attackGroup.Json)\n\t\tctx.Export(\"outputText\", attackGroup.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecAttackGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var attackGroup = AkamaiFunctions.getAppSecAttackGroups(GetAppSecAttackGroupsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .attackGroup(\"SQL\")\n            .build());\n\n        ctx.export(\"attackGroupAction\", attackGroup.applyValue(getAppSecAttackGroupsResult -\u003e getAppSecAttackGroupsResult.attackGroupAction()));\n        ctx.export(\"conditionException\", attackGroup.applyValue(getAppSecAttackGroupsResult -\u003e getAppSecAttackGroupsResult.conditionException()));\n        ctx.export(\"json\", attackGroup.applyValue(getAppSecAttackGroupsResult -\u003e getAppSecAttackGroupsResult.json()));\n        ctx.export(\"outputText\", attackGroup.applyValue(getAppSecAttackGroupsResult -\u003e getAppSecAttackGroupsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  attackGroup:\n    fn::invoke:\n      Function: akamai:getAppSecAttackGroups\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        attackGroup: SQL\noutputs:\n  attackGroupAction: ${attackGroup.attackGroupAction}\n  conditionException: ${attackGroup.conditionException}\n  json: ${attackGroup.json}\n  outputText: ${attackGroup.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `attack_group_action`. Action taken anytime the attack group is triggered. This information is returned only when a single attack group is retrieved. Valid values are:\n  - **alert**. The event is recorded.\n  - **deny**. The request is blocked.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. No action is taken.\n- `condition_exception`. Conditions and exceptions assigned to the attack group. This information is returned only when a single attack group is retrieved.\n- `json`. JSON-formatted list of the action and the condition-exception information for the attack group. This information is returned only when a single attack group is retrieved.\n- `output_text`. Tabular report showing the attack group's action as well as Boolean values indicating whether conditions and exceptions have been configured for the group.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecAttackGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group you want to return information for. If not included, information is returned for all your attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the attack group.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the attack group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecAttackGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "attackGroupAction": {
                        "type": "string"
                    },
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attackGroupAction",
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists": {
            "description": "**Scopes**: Security configuration\n\nReturns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking. \n\nNote that this data source is only applicable to WAP (Web Application Protector) configurations.\n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst bypassNetworkLists = configuration.then(configuration =\u003e akamai.getAppSecBypassNetworkLists({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const bypassNetworkListsOutput = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.outputText);\nexport const bypassNetworkListsJson = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.json);\nexport const bypassNetworkListsIdList = bypassNetworkLists.then(bypassNetworkLists =\u003e bypassNetworkLists.bypassNetworkLists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nbypass_network_lists = akamai.get_app_sec_bypass_network_lists(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"bypassNetworkListsOutput\", bypass_network_lists.output_text)\npulumi.export(\"bypassNetworkListsJson\", bypass_network_lists.json)\npulumi.export(\"bypassNetworkListsIdList\", bypass_network_lists.bypass_network_lists)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var bypassNetworkLists = Akamai.GetAppSecBypassNetworkLists.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"bypassNetworkListsOutput\"] = bypassNetworkLists.Apply(getAppSecBypassNetworkListsResult =\u003e getAppSecBypassNetworkListsResult.OutputText),\n        [\"bypassNetworkListsJson\"] = bypassNetworkLists.Apply(getAppSecBypassNetworkListsResult =\u003e getAppSecBypassNetworkListsResult.Json),\n        [\"bypassNetworkListsIdList\"] = bypassNetworkLists.Apply(getAppSecBypassNetworkListsResult =\u003e getAppSecBypassNetworkListsResult.BypassNetworkLists),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbypassNetworkLists, err := akamai.GetAppSecBypassNetworkLists(ctx, \u0026akamai.GetAppSecBypassNetworkListsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"bypassNetworkListsOutput\", bypassNetworkLists.OutputText)\n\t\tctx.Export(\"bypassNetworkListsJson\", bypassNetworkLists.Json)\n\t\tctx.Export(\"bypassNetworkListsIdList\", bypassNetworkLists.BypassNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecBypassNetworkListsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var bypassNetworkLists = AkamaiFunctions.getAppSecBypassNetworkLists(GetAppSecBypassNetworkListsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"bypassNetworkListsOutput\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.outputText()));\n        ctx.export(\"bypassNetworkListsJson\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.json()));\n        ctx.export(\"bypassNetworkListsIdList\", bypassNetworkLists.applyValue(getAppSecBypassNetworkListsResult -\u003e getAppSecBypassNetworkListsResult.bypassNetworkLists()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  bypassNetworkLists: # USE CASE: User wants to display returned data in a table.\n    fn::invoke:\n      Function: akamai:getAppSecBypassNetworkLists\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  bypassNetworkListsOutput: ${bypassNetworkLists.outputText}\n  bypassNetworkListsJson: ${bypassNetworkLists.json}\n  bypassNetworkListsIdList: ${bypassNetworkLists.bypassNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `bypass_network_list`. List of network IDs.\n- `json`. JSON-formatted list of information about the bypass networks.\n- `output_text`. Tabular report showing the bypass network list information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecBypassNetworkLists.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the bypass network lists.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the bypass network lists.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecBypassNetworkLists.\n",
                "properties": {
                    "bypassNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "bypassNetworkLists",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecConfiguration:getAppSecConfiguration": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecConfiguration.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": ". Name of the security configuration you want to return information for. If not included, information is returned for all your security configurations.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "latestVersion": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "productionVersion": {
                        "type": "integer"
                    },
                    "stagingVersion": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "latestVersion",
                    "outputText",
                    "productionVersion",
                    "stagingVersion",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecConfigurationVersion:getAppSecConfigurationVersion": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecConfigurationVersion.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return version information for.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration you want to return information about. If not included, information about all the security configuration's versions is returned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecConfigurationVersion.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "latestVersion": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "productionStatus": {
                        "type": "string"
                    },
                    "stagingStatus": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "latestVersion",
                    "outputText",
                    "productionStatus",
                    "stagingStatus",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecContractsGroups:getAppSecContractsGroups": {
            "description": "**Scopes**: Contract; group\n\nReturns information about the contracts and groups associated with your account. Among other things, this information is required to create a new security configuration and to return a list of the hostnames available for use in a security policy. \n\n**Related API Endpoint**: [/appsec/v1/contracts-groups](https://techdocs.akamai.com/application-security/reference/get-contracts-groups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst contractsGroups = akamai.getAppSecContractsGroups({\n    contractid: \"5-2WA382\",\n    groupid: 12198,\n});\nexport const contractsGroupsList = contractsGroups.then(contractsGroups =\u003e contractsGroups.outputText);\nexport const contractsGroupsJson = contractsGroups.then(contractsGroups =\u003e contractsGroups.json);\nexport const contractGroupsDefaultContractid = contractsGroups.then(contractsGroups =\u003e contractsGroups.defaultContractid);\nexport const contractGroupsDefaultGroupid = contractsGroups.then(contractsGroups =\u003e contractsGroups.defaultGroupid);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncontracts_groups = akamai.get_app_sec_contracts_groups(contractid=\"5-2WA382\",\n    groupid=12198)\npulumi.export(\"contractsGroupsList\", contracts_groups.output_text)\npulumi.export(\"contractsGroupsJson\", contracts_groups.json)\npulumi.export(\"contractGroupsDefaultContractid\", contracts_groups.default_contractid)\npulumi.export(\"contractGroupsDefaultGroupid\", contracts_groups.default_groupid)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var contractsGroups = Akamai.GetAppSecContractsGroups.Invoke(new()\n    {\n        Contractid = \"5-2WA382\",\n        Groupid = 12198,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"contractsGroupsList\"] = contractsGroups.Apply(getAppSecContractsGroupsResult =\u003e getAppSecContractsGroupsResult.OutputText),\n        [\"contractsGroupsJson\"] = contractsGroups.Apply(getAppSecContractsGroupsResult =\u003e getAppSecContractsGroupsResult.Json),\n        [\"contractGroupsDefaultContractid\"] = contractsGroups.Apply(getAppSecContractsGroupsResult =\u003e getAppSecContractsGroupsResult.DefaultContractid),\n        [\"contractGroupsDefaultGroupid\"] = contractsGroups.Apply(getAppSecContractsGroupsResult =\u003e getAppSecContractsGroupsResult.DefaultGroupid),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcontractsGroups, err := akamai.GetAppSecContractsGroups(ctx, \u0026akamai.GetAppSecContractsGroupsArgs{\n\t\t\tContractid: pulumi.StringRef(\"5-2WA382\"),\n\t\t\tGroupid:    pulumi.IntRef(12198),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"contractsGroupsList\", contractsGroups.OutputText)\n\t\tctx.Export(\"contractsGroupsJson\", contractsGroups.Json)\n\t\tctx.Export(\"contractGroupsDefaultContractid\", contractsGroups.DefaultContractid)\n\t\tctx.Export(\"contractGroupsDefaultGroupid\", contractsGroups.DefaultGroupid)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecContractsGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var contractsGroups = AkamaiFunctions.getAppSecContractsGroups(GetAppSecContractsGroupsArgs.builder()\n            .contractid(\"5-2WA382\")\n            .groupid(12198)\n            .build());\n\n        ctx.export(\"contractsGroupsList\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.outputText()));\n        ctx.export(\"contractsGroupsJson\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.json()));\n        ctx.export(\"contractGroupsDefaultContractid\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.defaultContractid()));\n        ctx.export(\"contractGroupsDefaultGroupid\", contractsGroups.applyValue(getAppSecContractsGroupsResult -\u003e getAppSecContractsGroupsResult.defaultGroupid()));\n    }\n}\n```\n```yaml\nvariables:\n  contractsGroups: # USE CASE: User wants to display returned data in a table.\n    fn::invoke:\n      Function: akamai:getAppSecContractsGroups\n      Arguments:\n        contractid: 5-2WA382\n        groupid: 12198\noutputs:\n  contractsGroupsList: ${contractsGroups.outputText}\n  contractsGroupsJson: ${contractsGroups.json} # USE CASE: User wants to return all available contracts and contract groups.\n  contractGroupsDefaultContractid: ${contractsGroups.defaultContractid}\n  contractGroupsDefaultGroupid: ${contractsGroups.defaultGroupid}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of contract and group information.\n- `output_text`. Tabular report of contract and group information.\n- `default_contractid`. Default contract ID for the specified contract and group.\n- `default_groupid`. Default group ID for the specified contract and group.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecContractsGroups.\n",
                "properties": {
                    "contractid": {
                        "type": "string",
                        "description": ". Unique identifier of an Akamai contract. If not included, information is returned for all the Akamai contracts associated with your account.\n"
                    },
                    "groupid": {
                        "type": "integer",
                        "description": ". Unique identifier of a contract group. If not included, information is returned for all the groups associated with your account.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecContractsGroups.\n",
                "properties": {
                    "contractid": {
                        "type": "string"
                    },
                    "defaultContractid": {
                        "type": "string"
                    },
                    "defaultGroupid": {
                        "type": "integer"
                    },
                    "groupid": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "defaultContractid",
                    "defaultGroupid",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomDeny:getAppSecCustomDeny": {
            "description": "**Scopes**: Security configuration; custom deny\n\nReturns information about custom deny actions. Custom denies allow you to craft your own error messages or redirect pages to use when HTTP requests are denied.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customDenyList = configuration.then(configuration =\u003e akamai.getAppSecCustomDeny({\n    configId: configuration.configId,\n}));\nexport const customDenyListOutput = customDenyList.then(customDenyList =\u003e customDenyList.outputText);\nexport const customDenyListJson = customDenyList.then(customDenyList =\u003e customDenyList.json);\nconst customDeny = configuration.then(configuration =\u003e akamai.getAppSecCustomDeny({\n    configId: configuration.configId,\n    customDenyId: \"deny_custom_64386\",\n}));\nexport const customDenyJson = customDeny.then(customDeny =\u003e customDeny.json);\nexport const customDenyOutput = customDeny.then(customDeny =\u003e customDeny.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_deny_list = akamai.get_app_sec_custom_deny(config_id=configuration.config_id)\npulumi.export(\"customDenyListOutput\", custom_deny_list.output_text)\npulumi.export(\"customDenyListJson\", custom_deny_list.json)\ncustom_deny = akamai.get_app_sec_custom_deny(config_id=configuration.config_id,\n    custom_deny_id=\"deny_custom_64386\")\npulumi.export(\"customDenyJson\", custom_deny.json)\npulumi.export(\"customDenyOutput\", custom_deny.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var customDenyList = Akamai.GetAppSecCustomDeny.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var customDeny = Akamai.GetAppSecCustomDeny.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        CustomDenyId = \"deny_custom_64386\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customDenyListOutput\"] = customDenyList.Apply(getAppSecCustomDenyResult =\u003e getAppSecCustomDenyResult.OutputText),\n        [\"customDenyListJson\"] = customDenyList.Apply(getAppSecCustomDenyResult =\u003e getAppSecCustomDenyResult.Json),\n        [\"customDenyJson\"] = customDeny.Apply(getAppSecCustomDenyResult =\u003e getAppSecCustomDenyResult.Json),\n        [\"customDenyOutput\"] = customDeny.Apply(getAppSecCustomDenyResult =\u003e getAppSecCustomDenyResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomDenyList, err := akamai.LookupAppSecCustomDeny(ctx, \u0026akamai.LookupAppSecCustomDenyArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyListOutput\", customDenyList.OutputText)\n\t\tctx.Export(\"customDenyListJson\", customDenyList.Json)\n\t\tcustomDeny, err := akamai.LookupAppSecCustomDeny(ctx, \u0026akamai.LookupAppSecCustomDenyArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomDenyId: pulumi.StringRef(\"deny_custom_64386\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customDenyJson\", customDeny.Json)\n\t\tctx.Export(\"customDenyOutput\", customDeny.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomDenyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customDenyList = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customDenyListOutput\", customDenyList.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.outputText()));\n        ctx.export(\"customDenyListJson\", customDenyList.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.json()));\n        final var customDeny = AkamaiFunctions.getAppSecCustomDeny(GetAppSecCustomDenyArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customDenyId(\"deny_custom_64386\")\n            .build());\n\n        ctx.export(\"customDenyJson\", customDeny.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.json()));\n        ctx.export(\"customDenyOutput\", customDeny.applyValue(getAppSecCustomDenyResult -\u003e getAppSecCustomDenyResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customDenyList: # USE CASE: User wants to display the returned data in a table.\n    fn::invoke:\n      Function: akamai:getAppSecCustomDeny\n      Arguments:\n        configId: ${configuration.configId}\n  customDeny:\n    fn::invoke:\n      Function: akamai:getAppSecCustomDeny\n      Arguments:\n        configId: ${configuration.configId}\n        customDenyId: deny_custom_64386\noutputs:\n  customDenyListOutput: ${customDenyList.outputText}\n  customDenyListJson: ${customDenyList.json} # USE CASE: User wants to view a specific custom deny associated with a security configuration.\n  customDenyJson: ${customDeny.json}\n  customDenyOutput: ${customDeny.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of custom deny information.\n- `output_text`. Tabular report of the custom deny information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomDeny.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom denies.\n"
                    },
                    "customDenyId": {
                        "type": "string",
                        "description": ". Unique identifier of the custom deny you want to return information for. If not included. information is returned for all your custom denies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomDeny.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customDenyId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomRuleActions:getAppSecCustomRuleActions": {
            "description": "**Scopes**: Security policy; custom rule\n\nRetrieve information about the actions defined for your custom rules. Custom rules are rules that you create yourself — these rules aren't part of Akamai's Kona Rule Set.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRuleActionsAppSecCustomRuleActions = configuration.then(configuration =\u003e akamai.getAppSecCustomRuleActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const customRuleActions = customRuleActionsAppSecCustomRuleActions.then(customRuleActionsAppSecCustomRuleActions =\u003e customRuleActionsAppSecCustomRuleActions.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rule_actions_app_sec_custom_rule_actions = akamai.get_app_sec_custom_rule_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"customRuleActions\", custom_rule_actions_app_sec_custom_rule_actions.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var customRuleActionsAppSecCustomRuleActions = Akamai.GetAppSecCustomRuleActions.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customRuleActions\"] = customRuleActionsAppSecCustomRuleActions.Apply(getAppSecCustomRuleActionsResult =\u003e getAppSecCustomRuleActionsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRuleActionsAppSecCustomRuleActions, err := akamai.GetAppSecCustomRuleActions(ctx, \u0026akamai.GetAppSecCustomRuleActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRuleActions\", customRuleActionsAppSecCustomRuleActions.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRuleActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRuleActionsAppSecCustomRuleActions = AkamaiFunctions.getAppSecCustomRuleActions(GetAppSecCustomRuleActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"customRuleActions\", customRuleActionsAppSecCustomRuleActions.applyValue(getAppSecCustomRuleActionsResult -\u003e getAppSecCustomRuleActionsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRuleActionsAppSecCustomRuleActions:\n    fn::invoke:\n      Function: akamai:getAppSecCustomRuleActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  customRuleActions: ${customRuleActionsAppSecCustomRuleActions.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID, name, and action of the custom rules.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomRuleActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rules.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule you want to return information for. If not included, action information is returned for all your custom rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the custom rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomRuleActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customRuleId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecCustomRules:getAppSecCustomRules": {
            "description": "**Scopes**: Security configuration; custom rule\n\nReturns a list of the custom rules defined for a security configuration; you can also use this resource to return information for an individual custom rule. Custom rules are rules you have created yourself and are not part of the Kona Rule Set.\n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-custom-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst customRules = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n}));\nexport const customRulesOutputText = customRules.then(customRules =\u003e customRules.outputText);\nexport const customRulesJson = customRules.then(customRules =\u003e customRules.json);\nexport const customRulesConfigId = customRules.then(customRules =\u003e customRules.configId);\nconst specificCustomRule = configuration.then(configuration =\u003e akamai.getAppSecCustomRules({\n    configId: configuration.configId,\n    customRuleId: 60029316,\n}));\nexport const specificCustomRuleJson = specificCustomRule.then(specificCustomRule =\u003e specificCustomRule.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ncustom_rules = akamai.get_app_sec_custom_rules(config_id=configuration.config_id)\npulumi.export(\"customRulesOutputText\", custom_rules.output_text)\npulumi.export(\"customRulesJson\", custom_rules.json)\npulumi.export(\"customRulesConfigId\", custom_rules.config_id)\nspecific_custom_rule = akamai.get_app_sec_custom_rules(config_id=configuration.config_id,\n    custom_rule_id=60029316)\npulumi.export(\"specificCustomRuleJson\", specific_custom_rule.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var customRules = Akamai.GetAppSecCustomRules.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var specificCustomRule = Akamai.GetAppSecCustomRules.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        CustomRuleId = 60029316,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"customRulesOutputText\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.OutputText),\n        [\"customRulesJson\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.Json),\n        [\"customRulesConfigId\"] = customRules.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.ConfigId),\n        [\"specificCustomRuleJson\"] = specificCustomRule.Apply(getAppSecCustomRulesResult =\u003e getAppSecCustomRulesResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcustomRules, err := akamai.GetAppSecCustomRules(ctx, \u0026akamai.GetAppSecCustomRulesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"customRulesOutputText\", customRules.OutputText)\n\t\tctx.Export(\"customRulesJson\", customRules.Json)\n\t\tctx.Export(\"customRulesConfigId\", customRules.ConfigId)\n\t\tspecificCustomRule, err := akamai.GetAppSecCustomRules(ctx, \u0026akamai.GetAppSecCustomRulesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tCustomRuleId: pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"specificCustomRuleJson\", specificCustomRule.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecCustomRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var customRules = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"customRulesOutputText\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.outputText()));\n        ctx.export(\"customRulesJson\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n        ctx.export(\"customRulesConfigId\", customRules.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.configId()));\n        final var specificCustomRule = AkamaiFunctions.getAppSecCustomRules(GetAppSecCustomRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .customRuleId(\"60029316\")\n            .build());\n\n        ctx.export(\"specificCustomRuleJson\", specificCustomRule.applyValue(getAppSecCustomRulesResult -\u003e getAppSecCustomRulesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  customRules:\n    fn::invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n  specificCustomRule:\n    fn::invoke:\n      Function: akamai:getAppSecCustomRules\n      Arguments:\n        configId: ${configuration.configId}\n        customRuleId: '60029316'\noutputs:\n  customRulesOutputText: ${customRules.outputText}\n  customRulesJson: ${customRules.json}\n  customRulesConfigId: ${customRules.configId} # USE CASE: User wants to view a specific custom rule.\n  specificCustomRuleJson: ${specificCustomRule.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and name of the custom rule information.\n- `json`. JSON-formatted report of the custom rule information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecCustomRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the custom rules.\n"
                    },
                    "customRuleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the custom rule you want to return information for. If not included, information is returned for all your custom rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecCustomRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "customRuleId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEval:getAppSecEval": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEval.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEval.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalGroups:getAppSecEvalGroups": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique identifier of the evaluation attack group you want to return information for. If not included, information is returned for all your evaluation attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation attack group.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation attack group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalGroups.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "attackGroupAction": {
                        "type": "string"
                    },
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attackGroupAction",
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalPenaltyBox:getAppSecEvalPenaltyBox": {
            "description": "**Scopes**: Security policy\n\n __ASE_Beta__.:\nReturns the penalty box settings for a security policy in evaluation mode - evaluation penalty box.\nWhen the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-eval_penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalPenaltyBox = configuration.then(configuration =\u003e akamai.getAppSecEvalPenaltyBox({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const evalPenaltyBoxAction = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.action);\nexport const evalPenaltyBoxEnabled = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.enabled);\nexport const evalPenaltyBoxText = evalPenaltyBox.then(evalPenaltyBox =\u003e evalPenaltyBox.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_penalty_box = akamai.get_app_sec_eval_penalty_box(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"evalPenaltyBoxAction\", eval_penalty_box.action)\npulumi.export(\"evalPenaltyBoxEnabled\", eval_penalty_box.enabled)\npulumi.export(\"evalPenaltyBoxText\", eval_penalty_box.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalPenaltyBox = Akamai.GetAppSecEvalPenaltyBox.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"evalPenaltyBoxAction\"] = evalPenaltyBox.Apply(getAppSecEvalPenaltyBoxResult =\u003e getAppSecEvalPenaltyBoxResult.Action),\n        [\"evalPenaltyBoxEnabled\"] = evalPenaltyBox.Apply(getAppSecEvalPenaltyBoxResult =\u003e getAppSecEvalPenaltyBoxResult.Enabled),\n        [\"evalPenaltyBoxText\"] = evalPenaltyBox.Apply(getAppSecEvalPenaltyBoxResult =\u003e getAppSecEvalPenaltyBoxResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalPenaltyBox, err := akamai.LookupAppSecEvalPenaltyBox(ctx, \u0026akamai.LookupAppSecEvalPenaltyBoxArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalPenaltyBoxAction\", evalPenaltyBox.Action)\n\t\tctx.Export(\"evalPenaltyBoxEnabled\", evalPenaltyBox.Enabled)\n\t\tctx.Export(\"evalPenaltyBoxText\", evalPenaltyBox.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecEvalPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var evalPenaltyBox = AkamaiFunctions.getAppSecEvalPenaltyBox(GetAppSecEvalPenaltyBoxArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"evalPenaltyBoxAction\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.action()));\n        ctx.export(\"evalPenaltyBoxEnabled\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.enabled()));\n        ctx.export(\"evalPenaltyBoxText\", evalPenaltyBox.applyValue(getAppSecEvalPenaltyBoxResult -\u003e getAppSecEvalPenaltyBoxResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  evalPenaltyBox:\n    fn::invoke:\n      Function: akamai:getAppSecEvalPenaltyBox\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  evalPenaltyBoxAction: ${evalPenaltyBox.action}\n  evalPenaltyBoxEnabled: ${evalPenaltyBox.enabled}\n  evalPenaltyBoxText: ${evalPenaltyBox.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the penalty box is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. The request is blocked.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `enabled`. If **true**, evaluation penalty box protection is enabled. If **false**, evaluation penalty box protection is disabled.\n- `output_text`. Tabular report of evaluation penalty box protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalPenaltyBox.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the evaluation penalty box settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation penalty box settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalPenaltyBox.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "enabled",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecEvalRules:getAppSecEvalRules": {
            "description": "**Scopes**: Security policy; evaluation rule\n\nReturns the action and the condition-exception information for a rule or set of rules being used in evaluation mode.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval-rules](https://techdocs.akamai.com/application-security/reference/get-policy-eval-rules)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst evalRule = configuration.then(configuration =\u003e akamai.getAppSecEvalRules({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    ruleId: 60029316,\n}));\nexport const evalRuleAction = evalRule.then(evalRule =\u003e evalRule.evalRuleAction);\nexport const conditionException = evalRule.then(evalRule =\u003e evalRule.conditionException);\nexport const json = evalRule.then(evalRule =\u003e evalRule.json);\nexport const outputText = evalRule.then(evalRule =\u003e evalRule.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\neval_rule = akamai.get_app_sec_eval_rules(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    rule_id=60029316)\npulumi.export(\"evalRuleAction\", eval_rule.eval_rule_action)\npulumi.export(\"conditionException\", eval_rule.condition_exception)\npulumi.export(\"json\", eval_rule.json)\npulumi.export(\"outputText\", eval_rule.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var evalRule = Akamai.GetAppSecEvalRules.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        RuleId = 60029316,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"evalRuleAction\"] = evalRule.Apply(getAppSecEvalRulesResult =\u003e getAppSecEvalRulesResult.EvalRuleAction),\n        [\"conditionException\"] = evalRule.Apply(getAppSecEvalRulesResult =\u003e getAppSecEvalRulesResult.ConditionException),\n        [\"json\"] = evalRule.Apply(getAppSecEvalRulesResult =\u003e getAppSecEvalRulesResult.Json),\n        [\"outputText\"] = evalRule.Apply(getAppSecEvalRulesResult =\u003e getAppSecEvalRulesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevalRule, err := akamai.GetAppSecEvalRules(ctx, \u0026akamai.GetAppSecEvalRulesArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t\tRuleId:           pulumi.IntRef(60029316),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"evalRuleAction\", evalRule.EvalRuleAction)\n\t\tctx.Export(\"conditionException\", evalRule.ConditionException)\n\t\tctx.Export(\"json\", evalRule.Json)\n\t\tctx.Export(\"outputText\", evalRule.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecEvalRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var evalRule = AkamaiFunctions.getAppSecEvalRules(GetAppSecEvalRulesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .ruleId(\"60029316\")\n            .build());\n\n        ctx.export(\"evalRuleAction\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.evalRuleAction()));\n        ctx.export(\"conditionException\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.conditionException()));\n        ctx.export(\"json\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.json()));\n        ctx.export(\"outputText\", evalRule.applyValue(getAppSecEvalRulesResult -\u003e getAppSecEvalRulesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  evalRule:\n    fn::invoke:\n      Function: akamai:getAppSecEvalRules\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        ruleId: '60029316'\noutputs:\n  evalRuleAction: ${evalRule.evalRuleAction}\n  conditionException: ${evalRule.conditionException}\n  json: ${evalRule.json}\n  outputText: ${evalRule.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `eval_rule_action`. Action taken anytime the evaluation rule is triggered. This information is returned only when a single rule is retrieved. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. Reject the request.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `condition_exception`. Conditions and exceptions associated with the rule. This information is returned only when a single rule is retrieved.\n- `json`. JSON-formatted list of the action and the condition-exception information for the rule. This information is returned only when a single rule is retrieved.\n- `output_text`. Tabular report showing the rule action as well as Boolean values indicating whether conditions and exceptions have been configured for the rule.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecEvalRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration running in evaluation mode.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the evaluation rule you want to return information for. If not included, information is returned for all your evaluation rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the evaluation rule.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecEvalRules.\n",
                "properties": {
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "evalRuleAction": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "conditionException",
                    "configId",
                    "evalRuleAction",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecExportConfiguration:getAppSecExportConfiguration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst export = Promise.all([configuration, configuration]).then(([configuration, configuration1]) =\u003e akamai.getAppSecExportConfiguration({\n    configId: configuration.configId,\n    version: configuration1.latestVersion,\n    searches: [\n        \"securityPolicies\",\n        \"selectedHosts\",\n    ],\n}));\nexport const json = _export.then(_export =\u003e _export.json);\nexport const text = _export.then(_export =\u003e _export.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nexport = akamai.get_app_sec_export_configuration(config_id=configuration.config_id,\n    version=configuration.latest_version,\n    searches=[\n        \"securityPolicies\",\n        \"selectedHosts\",\n    ])\npulumi.export(\"json\", export.json)\npulumi.export(\"text\", export.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var export = Akamai.GetAppSecExportConfiguration.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Version = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.LatestVersion),\n        Searches = new[]\n        {\n            \"securityPolicies\",\n            \"selectedHosts\",\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"json\"] = export.Apply(getAppSecExportConfigurationResult =\u003e getAppSecExportConfigurationResult.Json),\n        [\"text\"] = export.Apply(getAppSecExportConfigurationResult =\u003e getAppSecExportConfigurationResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texport, err := akamai.GetAppSecExportConfiguration(ctx, \u0026akamai.GetAppSecExportConfigurationArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tVersion:  configuration.LatestVersion,\n\t\t\tSearches: []string{\n\t\t\t\t\"securityPolicies\",\n\t\t\t\t\"selectedHosts\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"json\", export.Json)\n\t\tctx.Export(\"text\", export.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecExportConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var export = AkamaiFunctions.getAppSecExportConfiguration(GetAppSecExportConfigurationArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .version(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.latestVersion()))\n            .searches(            \n                \"securityPolicies\",\n                \"selectedHosts\")\n            .build());\n\n        ctx.export(\"json\", export.applyValue(getAppSecExportConfigurationResult -\u003e getAppSecExportConfigurationResult.json()));\n        ctx.export(\"text\", export.applyValue(getAppSecExportConfigurationResult -\u003e getAppSecExportConfigurationResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  export:\n    fn::invoke:\n      Function: akamai:getAppSecExportConfiguration\n      Arguments:\n        configId: ${configuration.configId}\n        version: ${configuration.latestVersion}\n        searches:\n          - securityPolicies\n          - selectedHosts\noutputs:\n  json: ${export.json}\n  text: ${export.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.\n- `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecExportConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    },
                    "searches": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ". JSON array of strings specifying the types of information to be retrieved. Note that there are two different ways to return data by using the `search` parameter. To return data in tabular format, use one or more of the following terms:\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": ". Version number of the security configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecExportConfiguration.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "searches": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecFailoverHostnames:getAppSecFailoverHostnames": {
            "description": "**Scopes**: Security configuration\n\nReturns a list of the failover hostnames in a configuration. \n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/failover-hostnames](https://techdocs.akamai.com/application-security/reference/get-failover-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst failoverHostnamesAppSecFailoverHostnames = configuration.then(configuration =\u003e akamai.getAppSecFailoverHostnames({\n    configId: configuration.configId,\n}));\nexport const failoverHostnames = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.hostnames);\nexport const failoverHostnamesOutput = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.outputText);\nexport const failoverHostnamesJson = failoverHostnamesAppSecFailoverHostnames.then(failoverHostnamesAppSecFailoverHostnames =\u003e failoverHostnamesAppSecFailoverHostnames.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nfailover_hostnames_app_sec_failover_hostnames = akamai.get_app_sec_failover_hostnames(config_id=configuration.config_id)\npulumi.export(\"failoverHostnames\", failover_hostnames_app_sec_failover_hostnames.hostnames)\npulumi.export(\"failoverHostnamesOutput\", failover_hostnames_app_sec_failover_hostnames.output_text)\npulumi.export(\"failoverHostnamesJson\", failover_hostnames_app_sec_failover_hostnames.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var failoverHostnamesAppSecFailoverHostnames = Akamai.GetAppSecFailoverHostnames.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"failoverHostnames\"] = failoverHostnamesAppSecFailoverHostnames.Apply(getAppSecFailoverHostnamesResult =\u003e getAppSecFailoverHostnamesResult.Hostnames),\n        [\"failoverHostnamesOutput\"] = failoverHostnamesAppSecFailoverHostnames.Apply(getAppSecFailoverHostnamesResult =\u003e getAppSecFailoverHostnamesResult.OutputText),\n        [\"failoverHostnamesJson\"] = failoverHostnamesAppSecFailoverHostnames.Apply(getAppSecFailoverHostnamesResult =\u003e getAppSecFailoverHostnamesResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfailoverHostnamesAppSecFailoverHostnames, err := akamai.GetAppSecFailoverHostnames(ctx, \u0026akamai.GetAppSecFailoverHostnamesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"failoverHostnames\", failoverHostnamesAppSecFailoverHostnames.Hostnames)\n\t\tctx.Export(\"failoverHostnamesOutput\", failoverHostnamesAppSecFailoverHostnames.OutputText)\n\t\tctx.Export(\"failoverHostnamesJson\", failoverHostnamesAppSecFailoverHostnames.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecFailoverHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var failoverHostnamesAppSecFailoverHostnames = AkamaiFunctions.getAppSecFailoverHostnames(GetAppSecFailoverHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"failoverHostnames\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.hostnames()));\n        ctx.export(\"failoverHostnamesOutput\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.outputText()));\n        ctx.export(\"failoverHostnamesJson\", failoverHostnamesAppSecFailoverHostnames.applyValue(getAppSecFailoverHostnamesResult -\u003e getAppSecFailoverHostnamesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  failoverHostnamesAppSecFailoverHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecFailoverHostnames\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  failoverHostnames: ${failoverHostnamesAppSecFailoverHostnames.hostnames}\n  failoverHostnamesOutput: ${failoverHostnamesAppSecFailoverHostnames.outputText}\n  failoverHostnamesJson: ${failoverHostnamesAppSecFailoverHostnames.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of the failover hostnames.\n- `json`. JSON-formatted list of the failover hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecFailoverHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the failover hosts.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecFailoverHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostnames",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverage:getAppSecHostnameCoverage": {
            "description": "**Scopes**: Individual account\n\nReturns information about the hostnames associated with your account. The returned data includes the hostname's protections, activation status, and other summary information. \n\n**Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst hostnameCoverage = akamai.getAppSecHostnameCoverage({});\nexport const hostnameCoverageListJson = hostnameCoverage.then(hostnameCoverage =\u003e hostnameCoverage.json);\nexport const hostnameCoverageListOutput = hostnameCoverage.then(hostnameCoverage =\u003e hostnameCoverage.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nhostname_coverage = akamai.get_app_sec_hostname_coverage()\npulumi.export(\"hostnameCoverageListJson\", hostname_coverage.json)\npulumi.export(\"hostnameCoverageListOutput\", hostname_coverage.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var hostnameCoverage = Akamai.GetAppSecHostnameCoverage.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"hostnameCoverageListJson\"] = hostnameCoverage.Apply(getAppSecHostnameCoverageResult =\u003e getAppSecHostnameCoverageResult.Json),\n        [\"hostnameCoverageListOutput\"] = hostnameCoverage.Apply(getAppSecHostnameCoverageResult =\u003e getAppSecHostnameCoverageResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thostnameCoverage, err := akamai.GetAppSecHostnameCoverage(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"hostnameCoverageListJson\", hostnameCoverage.Json)\n\t\tctx.Export(\"hostnameCoverageListOutput\", hostnameCoverage.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var hostnameCoverage = AkamaiFunctions.getAppSecHostnameCoverage();\n\n        ctx.export(\"hostnameCoverageListJson\", hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -\u003e getAppSecHostnameCoverageResult.json()));\n        ctx.export(\"hostnameCoverageListOutput\", hostnameCoverage.applyValue(getAppSecHostnameCoverageResult -\u003e getAppSecHostnameCoverageResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  hostnameCoverage:\n    fn::invoke:\n      Function: akamai:getAppSecHostnameCoverage\n      Arguments: {}\noutputs:\n  hostnameCoverageListJson: ${hostnameCoverage.json} # USE CASE: User wants to display the returned data in a table.\n  hostnameCoverageListOutput: ${hostnameCoverage.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the hostname coverage information.\n- `output_text`. Tabular report of the hostname coverage information.\n",
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverage.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverageMatchTargets:getAppSecHostnameCoverageMatchTargets": {
            "description": "**Scopes**: Hostname\n\nReturns information about the API and website match targets used to protect a hostname. \n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/match-targets](https://techdocs.akamai.com/application-security/reference/get-coverage-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargets = configuration.then(configuration =\u003e akamai.getAppSecHostnameCoverageMatchTargets({\n    configId: configuration.configId,\n    hostname: \"documentation.akamai.com\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_targets = akamai.get_app_sec_hostname_coverage_match_targets(config_id=configuration.config_id,\n    hostname=\"documentation.akamai.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var matchTargets = Akamai.GetAppSecHostnameCoverageMatchTargets.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Hostname = \"documentation.akamai.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.GetAppSecHostnameCoverageMatchTargets(ctx, \u0026akamai.GetAppSecHostnameCoverageMatchTargetsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tHostname: \"documentation.akamai.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecHostnameCoverageMatchTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var matchTargets = AkamaiFunctions.getAppSecHostnameCoverageMatchTargets(GetAppSecHostnameCoverageMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostname(\"documentation.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  matchTargets:\n    fn::invoke:\n      Function: akamai:getAppSecHostnameCoverageMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n        hostname: documentation.akamai.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the coverage information.\n- `output_text`. Tabular report of the coverage information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecHostnameCoverageMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". (Required). Unique identifier of the security configuration associated with the hostname.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": ". Name of the host you want to return information for. You can only return information for a single host and hostname at a time.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverageMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecHostnameCoverageOverlapping:getAppSecHostnameCoverageOverlapping": {
            "description": "**Scopes**: Security configuration; hostname\n\nReturns information about any other configuration versions that contain a hostname found in the current configuration version. \n\n**Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst test = configuration.then(configuration =\u003e akamai.getAppSecHostnameCoverageOverlapping({\n    configId: configuration.configId,\n    hostname: \"documentation.akamai.com\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\ntest = akamai.get_app_sec_hostname_coverage_overlapping(config_id=configuration.config_id,\n    hostname=\"documentation.akamai.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var test = Akamai.GetAppSecHostnameCoverageOverlapping.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        Hostname = \"documentation.akamai.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.GetAppSecHostnameCoverageOverlapping(ctx, \u0026akamai.GetAppSecHostnameCoverageOverlappingArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t\tHostname: \"documentation.akamai.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecHostnameCoverageOverlappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var test = AkamaiFunctions.getAppSecHostnameCoverageOverlapping(GetAppSecHostnameCoverageOverlappingArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .hostname(\"documentation.akamai.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  test:\n    fn::invoke:\n      Function: akamai:getAppSecHostnameCoverageOverlapping\n      Arguments:\n        configId: ${configuration.configId}\n        hostname: documentation.akamai.com\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the overlap information.\n- `output_text`. Tabular report of the overlap information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecHostnameCoverageOverlapping.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": ". Name of the host you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecHostnameCoverageOverlapping.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostname",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecIPGeo:getAppSecIPGeo": {
            "description": "**Scopes**: Security configuration; security policy\n\nReturns information about the network lists used in the IP/Geo Firewall settings; also returns the firewall `mode`, which indicates whether devices on the geographic or IP address lists are allowed through the firewall or are blocked by the firewall.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/get-policy-ip-geo-firewall)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ipGeo = configuration.then(configuration =\u003e akamai.getAppSecIPGeo({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const ipGeoMode = ipGeo.then(ipGeo =\u003e ipGeo.mode);\nexport const geoNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.geoNetworkLists);\nexport const ipNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.ipNetworkLists);\nexport const exceptionIpNetworkLists = ipGeo.then(ipGeo =\u003e ipGeo.exceptionIpNetworkLists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nip_geo = akamai.get_app_sec_ip_geo(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ipGeoMode\", ip_geo.mode)\npulumi.export(\"geoNetworkLists\", ip_geo.geo_network_lists)\npulumi.export(\"ipNetworkLists\", ip_geo.ip_network_lists)\npulumi.export(\"exceptionIpNetworkLists\", ip_geo.exception_ip_network_lists)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ipGeo = Akamai.GetAppSecIPGeo.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ipGeoMode\"] = ipGeo.Apply(getAppSecIPGeoResult =\u003e getAppSecIPGeoResult.Mode),\n        [\"geoNetworkLists\"] = ipGeo.Apply(getAppSecIPGeoResult =\u003e getAppSecIPGeoResult.GeoNetworkLists),\n        [\"ipNetworkLists\"] = ipGeo.Apply(getAppSecIPGeoResult =\u003e getAppSecIPGeoResult.IpNetworkLists),\n        [\"exceptionIpNetworkLists\"] = ipGeo.Apply(getAppSecIPGeoResult =\u003e getAppSecIPGeoResult.ExceptionIpNetworkLists),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipGeo, err := akamai.LookupAppSecIPGeo(ctx, \u0026akamai.LookupAppSecIPGeoArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ipGeoMode\", ipGeo.Mode)\n\t\tctx.Export(\"geoNetworkLists\", ipGeo.GeoNetworkLists)\n\t\tctx.Export(\"ipNetworkLists\", ipGeo.IpNetworkLists)\n\t\tctx.Export(\"exceptionIpNetworkLists\", ipGeo.ExceptionIpNetworkLists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecIPGeoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ipGeo = AkamaiFunctions.getAppSecIPGeo(GetAppSecIPGeoArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ipGeoMode\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.mode()));\n        ctx.export(\"geoNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.geoNetworkLists()));\n        ctx.export(\"ipNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.ipNetworkLists()));\n        ctx.export(\"exceptionIpNetworkLists\", ipGeo.applyValue(getAppSecIPGeoResult -\u003e getAppSecIPGeoResult.exceptionIpNetworkLists()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view IP/Geo firewall settings.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ipGeo:\n    fn::invoke:\n      Function: akamai:getAppSecIPGeo\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  ipGeoMode: ${ipGeo.mode}\n  geoNetworkLists: ${ipGeo.geoNetworkLists}\n  ipNetworkLists: ${ipGeo.ipNetworkLists}\n  exceptionIpNetworkLists: ${ipGeo.exceptionIpNetworkLists}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `mode`. Specifies the action taken by the IP/Geo firewall. Valid values are:\n  - **block**. Networks on the IP and geographic network lists are prevented from passing through the firewall.\n  - **allow**.  Networks on the IP and geographic network lists are allowed to pass through the firewall.\n- `geo_network_lists`. Network lists blocked or allowed based on geographic location.\n- `ip_network_lists`. Network lists blocked or allowed based on IP address.\n- `exception_ip_network_lists`. Network lists allowed through the firewall regardless of the values assigned to the `mode`, `geo_network_lists`, and `ip_network_lists` parameters.\n- `output_text`. Tabular report of the IP/Geo firewall settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecIPGeo.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the IP/Geo lists.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the IP/Geo lists. If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecIPGeo.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "exceptionIpNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "geoNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipNetworkLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "mode": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "exceptionIpNetworkLists",
                    "geoNetworkLists",
                    "ipNetworkLists",
                    "mode",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecMalwareContentTypes:getAppSecMalwareContentTypes": {
            "description": "**Scopes**: Security configuration; malware protection\n\nReturns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy's actions are applied.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst malwareContentTypes = configuration.then(configuration =\u003e akamai.getAppSecMalwareContentTypes({\n    configId: configuration.configId,\n}));\nexport const malwareContentTypesOutput = malwareContentTypes.then(malwareContentTypes =\u003e malwareContentTypes.outputText);\nexport const malwareContentTypesJson = malwareContentTypes.then(malwareContentTypes =\u003e malwareContentTypes.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmalware_content_types = akamai.get_app_sec_malware_content_types(config_id=configuration.config_id)\npulumi.export(\"malwareContentTypesOutput\", malware_content_types.output_text)\npulumi.export(\"malwareContentTypesJson\", malware_content_types.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var malwareContentTypes = Akamai.GetAppSecMalwareContentTypes.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"malwareContentTypesOutput\"] = malwareContentTypes.Apply(getAppSecMalwareContentTypesResult =\u003e getAppSecMalwareContentTypesResult.OutputText),\n        [\"malwareContentTypesJson\"] = malwareContentTypes.Apply(getAppSecMalwareContentTypesResult =\u003e getAppSecMalwareContentTypesResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmalwareContentTypes, err := akamai.GetAppSecMalwareContentTypes(ctx, \u0026akamai.GetAppSecMalwareContentTypesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"malwareContentTypesOutput\", malwareContentTypes.OutputText)\n\t\tctx.Export(\"malwareContentTypesJson\", malwareContentTypes.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecMalwareContentTypesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var malwareContentTypes = AkamaiFunctions.getAppSecMalwareContentTypes(GetAppSecMalwareContentTypesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"malwareContentTypesOutput\", malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -\u003e getAppSecMalwareContentTypesResult.outputText()));\n        ctx.export(\"malwareContentTypesJson\", malwareContentTypes.applyValue(getAppSecMalwareContentTypesResult -\u003e getAppSecMalwareContentTypesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  malwareContentTypes:\n    fn::invoke:\n      Function: akamai:getAppSecMalwareContentTypes\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  malwareContentTypesOutput: ${malwareContentTypes.outputText}\n  malwareContentTypesJson: ${malwareContentTypes.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the available content types.\n- `json`. JSON-formatted list of the available content types.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecMalwareContentTypes.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the content types.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecMalwareContentTypes.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecMalwarePolicies:getAppSecMalwarePolicies": {
            "description": "**Scopes**: Security configuration; malware protection\n\nReturns information about your malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst malwarePolicies = configuration.then(configuration =\u003e akamai.getAppSecMalwarePolicies({\n    configId: configuration.configId,\n}));\nexport const malwarePoliciesOutput = malwarePolicies.then(malwarePolicies =\u003e malwarePolicies.outputText);\nexport const malwarePoliciesJson = malwarePolicies.then(malwarePolicies =\u003e malwarePolicies.json);\nconst malwarePolicy = configuration.then(configuration =\u003e akamai.getAppSecMalwarePolicies({\n    configId: configuration.configId,\n    malwarePolicyId: 122149,\n}));\nexport const malwarePolicyJson = malwarePolicy.then(malwarePolicy =\u003e malwarePolicy.json);\nexport const malwarePolicyOutput = malwarePolicy.then(malwarePolicy =\u003e malwarePolicy.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmalware_policies = akamai.get_app_sec_malware_policies(config_id=configuration.config_id)\npulumi.export(\"malwarePoliciesOutput\", malware_policies.output_text)\npulumi.export(\"malwarePoliciesJson\", malware_policies.json)\nmalware_policy = akamai.get_app_sec_malware_policies(config_id=configuration.config_id,\n    malware_policy_id=122149)\npulumi.export(\"malwarePolicyJson\", malware_policy.json)\npulumi.export(\"malwarePolicyOutput\", malware_policy.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var malwarePolicies = Akamai.GetAppSecMalwarePolicies.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var malwarePolicy = Akamai.GetAppSecMalwarePolicies.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MalwarePolicyId = 122149,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"malwarePoliciesOutput\"] = malwarePolicies.Apply(getAppSecMalwarePoliciesResult =\u003e getAppSecMalwarePoliciesResult.OutputText),\n        [\"malwarePoliciesJson\"] = malwarePolicies.Apply(getAppSecMalwarePoliciesResult =\u003e getAppSecMalwarePoliciesResult.Json),\n        [\"malwarePolicyJson\"] = malwarePolicy.Apply(getAppSecMalwarePoliciesResult =\u003e getAppSecMalwarePoliciesResult.Json),\n        [\"malwarePolicyOutput\"] = malwarePolicy.Apply(getAppSecMalwarePoliciesResult =\u003e getAppSecMalwarePoliciesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmalwarePolicies, err := akamai.GetAppSecMalwarePolicies(ctx, \u0026akamai.GetAppSecMalwarePoliciesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"malwarePoliciesOutput\", malwarePolicies.OutputText)\n\t\tctx.Export(\"malwarePoliciesJson\", malwarePolicies.Json)\n\t\tmalwarePolicy, err := akamai.GetAppSecMalwarePolicies(ctx, \u0026akamai.GetAppSecMalwarePoliciesArgs{\n\t\t\tConfigId:        configuration.ConfigId,\n\t\t\tMalwarePolicyId: pulumi.IntRef(122149),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"malwarePolicyJson\", malwarePolicy.Json)\n\t\tctx.Export(\"malwarePolicyOutput\", malwarePolicy.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecMalwarePoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var malwarePolicies = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"malwarePoliciesOutput\", malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -\u003e getAppSecMalwarePoliciesResult.outputText()));\n        ctx.export(\"malwarePoliciesJson\", malwarePolicies.applyValue(getAppSecMalwarePoliciesResult -\u003e getAppSecMalwarePoliciesResult.json()));\n        final var malwarePolicy = AkamaiFunctions.getAppSecMalwarePolicies(GetAppSecMalwarePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .malwarePolicyId(\"122149\")\n            .build());\n\n        ctx.export(\"malwarePolicyJson\", malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -\u003e getAppSecMalwarePoliciesResult.json()));\n        ctx.export(\"malwarePolicyOutput\", malwarePolicy.applyValue(getAppSecMalwarePoliciesResult -\u003e getAppSecMalwarePoliciesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  malwarePolicies:\n    fn::invoke:\n      Function: akamai:getAppSecMalwarePolicies\n      Arguments:\n        configId: ${configuration.configId}\n  malwarePolicy:\n    fn::invoke:\n      Function: akamai:getAppSecMalwarePolicies\n      Arguments:\n        configId: ${configuration.configId}\n        malwarePolicyId: '122149'\noutputs:\n  malwarePoliciesOutput: ${malwarePolicies.outputText}\n  malwarePoliciesJson: ${malwarePolicies.json} # USE CASE: User wants to see a specific malware policy.\n  malwarePolicyJson: ${malwarePolicy.json}\n  malwarePolicyOutput: ${malwarePolicy.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and name of the malware policies.\n- `json`. JSON-formatted list of the malware policy information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecMalwarePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware policies.\n"
                    },
                    "malwarePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the malware policy you want to return information for. If not included, information is returned for all of your malware policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecMalwarePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "malwarePolicyId": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecMalwarePolicyActions:getAppSecMalwarePolicyActions": {
            "description": "**Scopes**: Security policy; malware protection\n\nReturns information about your malware policy actions. Actions specify what happens any time a malware policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst malwarePolicyActionsAppSecMalwarePolicyActions = configuration.then(configuration =\u003e akamai.getAppSecMalwarePolicyActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const malwarePolicyActions = malwarePolicyActionsAppSecMalwarePolicyActions.then(malwarePolicyActionsAppSecMalwarePolicyActions =\u003e malwarePolicyActionsAppSecMalwarePolicyActions.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmalware_policy_actions_app_sec_malware_policy_actions = akamai.get_app_sec_malware_policy_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"malwarePolicyActions\", malware_policy_actions_app_sec_malware_policy_actions.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var malwarePolicyActionsAppSecMalwarePolicyActions = Akamai.GetAppSecMalwarePolicyActions.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"malwarePolicyActions\"] = malwarePolicyActionsAppSecMalwarePolicyActions.Apply(getAppSecMalwarePolicyActionsResult =\u003e getAppSecMalwarePolicyActionsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmalwarePolicyActionsAppSecMalwarePolicyActions, err := akamai.LookupAppSecMalwarePolicyActions(ctx, \u0026akamai.LookupAppSecMalwarePolicyActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"malwarePolicyActions\", malwarePolicyActionsAppSecMalwarePolicyActions.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecMalwarePolicyActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var malwarePolicyActionsAppSecMalwarePolicyActions = AkamaiFunctions.getAppSecMalwarePolicyActions(GetAppSecMalwarePolicyActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"malwarePolicyActions\", malwarePolicyActionsAppSecMalwarePolicyActions.applyValue(getAppSecMalwarePolicyActionsResult -\u003e getAppSecMalwarePolicyActionsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  malwarePolicyActionsAppSecMalwarePolicyActions:\n    fn::invoke:\n      Function: akamai:getAppSecMalwarePolicyActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  malwarePolicyActions: ${malwarePolicyActionsAppSecMalwarePolicyActions.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID, scanned action, and unscanned action of the malware policy or policies.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecMalwarePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the malware policies and malware policy actions.\n"
                    },
                    "malwarePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the malware policy you want to return action information for. If not included, action information is returned for all malware policies associated with the specified security policy.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the malware policies and malware policy actions.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecMalwarePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "malwarePolicyId": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecMatchTargets:getAppSecMatchTargets": {
            "description": "**Scopes**: Security configuration; match target\n\nReturns information about your match targets. Match targets determine which security policy should apply to an API, hostname, or path.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets{?policyId,includeChildObjectName}](https://techdocs.akamai.com/application-security/reference/get-match-targets)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst matchTargetsAppSecMatchTargets = configuration.then(configuration =\u003e akamai.getAppSecMatchTargets({\n    configId: configuration.configId,\n}));\nexport const matchTargets = matchTargetsAppSecMatchTargets.then(matchTargetsAppSecMatchTargets =\u003e matchTargetsAppSecMatchTargets.outputText);\nconst matchTarget = configuration.then(configuration =\u003e akamai.getAppSecMatchTargets({\n    configId: configuration.configId,\n    matchTargetId: 2712938,\n}));\nexport const matchTargetOutput = matchTarget.then(matchTarget =\u003e matchTarget.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nmatch_targets_app_sec_match_targets = akamai.get_app_sec_match_targets(config_id=configuration.config_id)\npulumi.export(\"matchTargets\", match_targets_app_sec_match_targets.output_text)\nmatch_target = akamai.get_app_sec_match_targets(config_id=configuration.config_id,\n    match_target_id=2712938)\npulumi.export(\"matchTargetOutput\", match_target.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var matchTargetsAppSecMatchTargets = Akamai.GetAppSecMatchTargets.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var matchTarget = Akamai.GetAppSecMatchTargets.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        MatchTargetId = 2712938,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"matchTargets\"] = matchTargetsAppSecMatchTargets.Apply(getAppSecMatchTargetsResult =\u003e getAppSecMatchTargetsResult.OutputText),\n        [\"matchTargetOutput\"] = matchTarget.Apply(getAppSecMatchTargetsResult =\u003e getAppSecMatchTargetsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmatchTargetsAppSecMatchTargets, err := akamai.GetAppSecMatchTargets(ctx, \u0026akamai.GetAppSecMatchTargetsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"matchTargets\", matchTargetsAppSecMatchTargets.OutputText)\n\t\tmatchTarget, err := akamai.GetAppSecMatchTargets(ctx, \u0026akamai.GetAppSecMatchTargetsArgs{\n\t\t\tConfigId:      configuration.ConfigId,\n\t\t\tMatchTargetId: pulumi.IntRef(2712938),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"matchTargetOutput\", matchTarget.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecMatchTargetsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var matchTargetsAppSecMatchTargets = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"matchTargets\", matchTargetsAppSecMatchTargets.applyValue(getAppSecMatchTargetsResult -\u003e getAppSecMatchTargetsResult.outputText()));\n        final var matchTarget = AkamaiFunctions.getAppSecMatchTargets(GetAppSecMatchTargetsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .matchTargetId(\"2712938\")\n            .build());\n\n        ctx.export(\"matchTargetOutput\", matchTarget.applyValue(getAppSecMatchTargetsResult -\u003e getAppSecMatchTargetsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  matchTargetsAppSecMatchTargets:\n    fn::invoke:\n      Function: akamai:getAppSecMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n  matchTarget:\n    fn::invoke:\n      Function: akamai:getAppSecMatchTargets\n      Arguments:\n        configId: ${configuration.configId}\n        matchTargetId: '2712938'\noutputs:\n  matchTargets: ${matchTargetsAppSecMatchTargets.outputText} # USE CASE: User wants to view a single match target.\n  matchTargetOutput: ${matchTarget.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and security policy ID of your match targets.\n- `json`. JSON-formatted list of the match target information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the match targets.\n"
                    },
                    "matchTargetId": {
                        "type": "integer",
                        "description": ". Unique identifier of the match target you want to return information for. If not included, information is returned for all your match targets.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecMatchTargets.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchTargetId": {
                        "type": "integer"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecPenaltyBox:getAppSecPenaltyBox": {
            "description": "**Scopes**: Security policy\n\nReturns penalty box settings for the specified security policy.\nWhen the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the “penalty box”.\nThere, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/penalty-box](https://techdocs.akamai.com/application-security/reference/get-policy-penalty-box)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst penaltyBox = configuration.then(configuration =\u003e akamai.getAppSecPenaltyBox({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const penaltyBoxAction = penaltyBox.then(penaltyBox =\u003e penaltyBox.action);\nexport const penaltyBoxEnabled = penaltyBox.then(penaltyBox =\u003e penaltyBox.enabled);\nexport const penaltyBoxText = penaltyBox.then(penaltyBox =\u003e penaltyBox.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\npenalty_box = akamai.get_app_sec_penalty_box(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"penaltyBoxAction\", penalty_box.action)\npulumi.export(\"penaltyBoxEnabled\", penalty_box.enabled)\npulumi.export(\"penaltyBoxText\", penalty_box.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var penaltyBox = Akamai.GetAppSecPenaltyBox.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"penaltyBoxAction\"] = penaltyBox.Apply(getAppSecPenaltyBoxResult =\u003e getAppSecPenaltyBoxResult.Action),\n        [\"penaltyBoxEnabled\"] = penaltyBox.Apply(getAppSecPenaltyBoxResult =\u003e getAppSecPenaltyBoxResult.Enabled),\n        [\"penaltyBoxText\"] = penaltyBox.Apply(getAppSecPenaltyBoxResult =\u003e getAppSecPenaltyBoxResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpenaltyBox, err := akamai.LookupAppSecPenaltyBox(ctx, \u0026akamai.LookupAppSecPenaltyBoxArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"penaltyBoxAction\", penaltyBox.Action)\n\t\tctx.Export(\"penaltyBoxEnabled\", penaltyBox.Enabled)\n\t\tctx.Export(\"penaltyBoxText\", penaltyBox.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecPenaltyBoxArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var penaltyBox = AkamaiFunctions.getAppSecPenaltyBox(GetAppSecPenaltyBoxArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"penaltyBoxAction\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.action()));\n        ctx.export(\"penaltyBoxEnabled\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.enabled()));\n        ctx.export(\"penaltyBoxText\", penaltyBox.applyValue(getAppSecPenaltyBoxResult -\u003e getAppSecPenaltyBoxResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  penaltyBox:\n    fn::invoke:\n      Function: akamai:getAppSecPenaltyBox\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  penaltyBoxAction: ${penaltyBox.action}\n  penaltyBoxEnabled: ${penaltyBox.enabled}\n  penaltyBoxText: ${penaltyBox.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the penalty box is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. The request is blocked.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `enabled`. If **true**, penalty box protection is enabled. If **false**, penalty box protection is disabled.\n- `output_text`. Tabular report of penalty box protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecPenaltyBox.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the penalty box settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the penalty box settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecPenaltyBox.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "enabled",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRatePolicies:getAppSecRatePolicies": {
            "description": "**Scopes**: Security configuration; rate policy\n\nReturns information about your rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive; in turn, this helps you prevent your website from being overwhelmed by a dramatic, and unexpected, surge in traffic.\n\n**Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicies = configuration.then(configuration =\u003e akamai.getAppSecRatePolicies({\n    configId: configuration.configId,\n}));\nexport const ratePoliciesOutput = ratePolicies.then(ratePolicies =\u003e ratePolicies.outputText);\nexport const ratePoliciesJson = ratePolicies.then(ratePolicies =\u003e ratePolicies.json);\nconst ratePolicy = configuration.then(configuration =\u003e akamai.getAppSecRatePolicies({\n    configId: configuration.configId,\n    ratePolicyId: 122149,\n}));\nexport const ratePolicyJson = ratePolicy.then(ratePolicy =\u003e ratePolicy.json);\nexport const ratePolicyOutput = ratePolicy.then(ratePolicy =\u003e ratePolicy.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policies = akamai.get_app_sec_rate_policies(config_id=configuration.config_id)\npulumi.export(\"ratePoliciesOutput\", rate_policies.output_text)\npulumi.export(\"ratePoliciesJson\", rate_policies.json)\nrate_policy = akamai.get_app_sec_rate_policies(config_id=configuration.config_id,\n    rate_policy_id=122149)\npulumi.export(\"ratePolicyJson\", rate_policy.json)\npulumi.export(\"ratePolicyOutput\", rate_policy.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ratePolicies = Akamai.GetAppSecRatePolicies.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var ratePolicy = Akamai.GetAppSecRatePolicies.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        RatePolicyId = 122149,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ratePoliciesOutput\"] = ratePolicies.Apply(getAppSecRatePoliciesResult =\u003e getAppSecRatePoliciesResult.OutputText),\n        [\"ratePoliciesJson\"] = ratePolicies.Apply(getAppSecRatePoliciesResult =\u003e getAppSecRatePoliciesResult.Json),\n        [\"ratePolicyJson\"] = ratePolicy.Apply(getAppSecRatePoliciesResult =\u003e getAppSecRatePoliciesResult.Json),\n        [\"ratePolicyOutput\"] = ratePolicy.Apply(getAppSecRatePoliciesResult =\u003e getAppSecRatePoliciesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicies, err := akamai.GetAppSecRatePolicies(ctx, \u0026akamai.GetAppSecRatePoliciesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePoliciesOutput\", ratePolicies.OutputText)\n\t\tctx.Export(\"ratePoliciesJson\", ratePolicies.Json)\n\t\tratePolicy, err := akamai.GetAppSecRatePolicies(ctx, \u0026akamai.GetAppSecRatePoliciesArgs{\n\t\t\tConfigId:     configuration.ConfigId,\n\t\t\tRatePolicyId: pulumi.IntRef(122149),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyJson\", ratePolicy.Json)\n\t\tctx.Export(\"ratePolicyOutput\", ratePolicy.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRatePoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ratePolicies = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"ratePoliciesOutput\", ratePolicies.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.outputText()));\n        ctx.export(\"ratePoliciesJson\", ratePolicies.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.json()));\n        final var ratePolicy = AkamaiFunctions.getAppSecRatePolicies(GetAppSecRatePoliciesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .ratePolicyId(\"122149\")\n            .build());\n\n        ctx.export(\"ratePolicyJson\", ratePolicy.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.json()));\n        ctx.export(\"ratePolicyOutput\", ratePolicy.applyValue(getAppSecRatePoliciesResult -\u003e getAppSecRatePoliciesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ratePolicies:\n    fn::invoke:\n      Function: akamai:getAppSecRatePolicies\n      Arguments:\n        configId: ${configuration.configId}\n  ratePolicy:\n    fn::invoke:\n      Function: akamai:getAppSecRatePolicies\n      Arguments:\n        configId: ${configuration.configId}\n        ratePolicyId: '122149'\noutputs:\n  ratePoliciesOutput: ${ratePolicies.outputText}\n  ratePoliciesJson: ${ratePolicies.json} # USE CASE: User wants to see a specific rate policy.\n  ratePolicyJson: ${ratePolicy.json}\n  ratePolicyOutput: ${ratePolicy.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID and name of the rate policies.\n- `json`. JSON-formatted list of the rate policy information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRatePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policies.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy you want to return information for. If not included, information is returned for all your rate policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRatePolicies.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ratePolicyId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRatePolicyActions:getAppSecRatePolicyActions": {
            "description": "**Scopes**: Security policy; rate policy\n\nReturns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.\n\n**Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst ratePolicyActionsAppSecRatePolicyActions = configuration.then(configuration =\u003e akamai.getAppSecRatePolicyActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const ratePolicyActions = ratePolicyActionsAppSecRatePolicyActions.then(ratePolicyActionsAppSecRatePolicyActions =\u003e ratePolicyActionsAppSecRatePolicyActions.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nrate_policy_actions_app_sec_rate_policy_actions = akamai.get_app_sec_rate_policy_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"ratePolicyActions\", rate_policy_actions_app_sec_rate_policy_actions.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var ratePolicyActionsAppSecRatePolicyActions = Akamai.GetAppSecRatePolicyActions.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ratePolicyActions\"] = ratePolicyActionsAppSecRatePolicyActions.Apply(getAppSecRatePolicyActionsResult =\u003e getAppSecRatePolicyActionsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tratePolicyActionsAppSecRatePolicyActions, err := akamai.GetAppSecRatePolicyActions(ctx, \u0026akamai.GetAppSecRatePolicyActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"ratePolicyActions\", ratePolicyActionsAppSecRatePolicyActions.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRatePolicyActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var ratePolicyActionsAppSecRatePolicyActions = AkamaiFunctions.getAppSecRatePolicyActions(GetAppSecRatePolicyActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"ratePolicyActions\", ratePolicyActionsAppSecRatePolicyActions.applyValue(getAppSecRatePolicyActionsResult -\u003e getAppSecRatePolicyActionsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  ratePolicyActionsAppSecRatePolicyActions:\n    fn::invoke:\n      Function: akamai:getAppSecRatePolicyActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  ratePolicyActions: ${ratePolicyActionsAppSecRatePolicyActions.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRatePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rate policies and rate policy actions.\n"
                    },
                    "ratePolicyId": {
                        "type": "integer",
                        "description": ". Unique identifier of the rate policy you want to return action information for. If not included, action information is returned for all your rate policies.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rate policies and rate policy actions.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRatePolicyActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ratePolicyId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions": {
            "description": "## akamai.getAppSecReputationProfileActions\n\n**Scopes**: Security policy; reputation profile\n\nReturns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfileActions = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const reputationProfileActionsText = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.outputText);\nexport const reputationProfileActionsJson = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.json);\nconst reputationProfileActions2AppSecReputationProfileActions = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileActions({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n    reputationProfileId: 12345,\n}));\nexport const reputationProfileActions2 = reputationProfileActions.then(reputationProfileActions =\u003e reputationProfileActions.action);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"reputationProfileActionsText\", reputation_profile_actions.output_text)\npulumi.export(\"reputationProfileActionsJson\", reputation_profile_actions.json)\nreputation_profile_actions2_app_sec_reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\",\n    reputation_profile_id=12345)\npulumi.export(\"reputationProfileActions2\", reputation_profile_actions.action)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var reputationProfileActions = Akamai.GetAppSecReputationProfileActions.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    var reputationProfileActions2AppSecReputationProfileActions = Akamai.GetAppSecReputationProfileActions.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n        ReputationProfileId = 12345,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"reputationProfileActionsText\"] = reputationProfileActions.Apply(getAppSecReputationProfileActionsResult =\u003e getAppSecReputationProfileActionsResult.OutputText),\n        [\"reputationProfileActionsJson\"] = reputationProfileActions.Apply(getAppSecReputationProfileActionsResult =\u003e getAppSecReputationProfileActionsResult.Json),\n        [\"reputationProfileActions2\"] = reputationProfileActions.Apply(getAppSecReputationProfileActionsResult =\u003e getAppSecReputationProfileActionsResult.Action),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfileActions, err := akamai.GetAppSecReputationProfileActions(ctx, \u0026akamai.GetAppSecReputationProfileActionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileActionsText\", reputationProfileActions.OutputText)\n\t\tctx.Export(\"reputationProfileActionsJson\", reputationProfileActions.Json)\n\t\t_, err = akamai.GetAppSecReputationProfileActions(ctx, \u0026akamai.GetAppSecReputationProfileActionsArgs{\n\t\t\tConfigId:            configuration.ConfigId,\n\t\t\tSecurityPolicyId:    \"gms1_134637\",\n\t\t\tReputationProfileId: pulumi.IntRef(12345),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileActions2\", reputationProfileActions.Action)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileActionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"reputationProfileActionsText\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.outputText()));\n        ctx.export(\"reputationProfileActionsJson\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.json()));\n        final var reputationProfileActions2AppSecReputationProfileActions = AkamaiFunctions.getAppSecReputationProfileActions(GetAppSecReputationProfileActionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .reputationProfileId(\"12345\")\n            .build());\n\n        ctx.export(\"reputationProfileActions2\", reputationProfileActions.applyValue(getAppSecReputationProfileActionsResult -\u003e getAppSecReputationProfileActionsResult.action()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationProfileActions:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfileActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n  reputationProfileActions2AppSecReputationProfileActions:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfileActions\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\n        reputationProfileId: '12345'\noutputs:\n  reputationProfileActionsText: ${reputationProfileActions.outputText}\n  reputationProfileActionsJson: ${reputationProfileActions.json} # USE CASE: User wants to view the action for a specific reputation profile.\n  reputationProfileActions2: ${reputationProfileActions.action}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `action`. Action taken any time the reputation profile is triggered. Valid values are:\n  - **alert**. Record the event.\n  - **deny**. Block the request.\n  - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.\n  - **none**. Take no action.\n- `json`. JSON-formatted report of the reputation profile action information.\n- `output_text`. Tabular report of the reputation profile action information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfileActions.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profiles.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profiles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfileActions.\n",
                "properties": {
                    "action": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "reputationProfileId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "action",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfileAnalysis:getAppSecReputationProfileAnalysis": {
            "description": "**Scopes**: Security policy\n\nReturns information about the following two reputation analysis settings:\n\n- `forwardToHTTPHeader`. When enabled, client reputation information associated with a request is forwarded to origin servers by using an HTTP header.\n- `forwardSharedIPToHTTPHeaderAndSIEM`. When enabled, both the HTTP header and SIEM integration events include a value indicating that the IP addresses is shared address.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-analysis](https://techdocs.akamai.com/application-security/reference/get-reputation-analysis)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationAnalysis = configuration.then(configuration =\u003e akamai.getAppSecReputationProfileAnalysis({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const reputationAnalysisText = reputationAnalysis.then(reputationAnalysis =\u003e reputationAnalysis.outputText);\nexport const reputationAnalysisJson = reputationAnalysis.then(reputationAnalysis =\u003e reputationAnalysis.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_analysis = akamai.get_app_sec_reputation_profile_analysis(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"reputationAnalysisText\", reputation_analysis.output_text)\npulumi.export(\"reputationAnalysisJson\", reputation_analysis.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var reputationAnalysis = Akamai.GetAppSecReputationProfileAnalysis.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"reputationAnalysisText\"] = reputationAnalysis.Apply(getAppSecReputationProfileAnalysisResult =\u003e getAppSecReputationProfileAnalysisResult.OutputText),\n        [\"reputationAnalysisJson\"] = reputationAnalysis.Apply(getAppSecReputationProfileAnalysisResult =\u003e getAppSecReputationProfileAnalysisResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationAnalysis, err := akamai.LookupAppSecReputationProfileAnalysis(ctx, \u0026akamai.LookupAppSecReputationProfileAnalysisArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationAnalysisText\", reputationAnalysis.OutputText)\n\t\tctx.Export(\"reputationAnalysisJson\", reputationAnalysis.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfileAnalysisArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationAnalysis = AkamaiFunctions.getAppSecReputationProfileAnalysis(GetAppSecReputationProfileAnalysisArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"reputationAnalysisText\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.outputText()));\n        ctx.export(\"reputationAnalysisJson\", reputationAnalysis.applyValue(getAppSecReputationProfileAnalysisResult -\u003e getAppSecReputationProfileAnalysisResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationAnalysis:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfileAnalysis\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  reputationAnalysisText: ${reputationAnalysis.outputText}\n  reputationAnalysisJson: ${reputationAnalysis.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the reputation analysis settings.\n- `output_text`. Tabular report showing the reputation analysis settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfileAnalysis.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profile analysis settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the reputation profile analysis settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfileAnalysis.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecReputationProfiles:getAppSecReputationProfiles": {
            "description": "**Scopes**: Security configuration; reputation profile\n\nReturns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst reputationProfiles = configuration.then(configuration =\u003e akamai.getAppSecReputationProfiles({\n    configId: configuration.configId,\n}));\nexport const reputationProfilesOutput = reputationProfiles.then(reputationProfiles =\u003e reputationProfiles.outputText);\nexport const reputationProfilesJson = reputationProfiles.then(reputationProfiles =\u003e reputationProfiles.json);\nconst reputationProfile = configuration.then(configuration =\u003e akamai.getAppSecReputationProfiles({\n    configId: configuration.configId,\n    reputationProfileId: 12345,\n}));\nexport const reputationProfileJson = reputationProfile.then(reputationProfile =\u003e reputationProfile.json);\nexport const reputationProfileOutput = reputationProfile.then(reputationProfile =\u003e reputationProfile.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nreputation_profiles = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id)\npulumi.export(\"reputationProfilesOutput\", reputation_profiles.output_text)\npulumi.export(\"reputationProfilesJson\", reputation_profiles.json)\nreputation_profile = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id,\n    reputation_profile_id=12345)\npulumi.export(\"reputationProfileJson\", reputation_profile.json)\npulumi.export(\"reputationProfileOutput\", reputation_profile.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var reputationProfiles = Akamai.GetAppSecReputationProfiles.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var reputationProfile = Akamai.GetAppSecReputationProfiles.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        ReputationProfileId = 12345,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"reputationProfilesOutput\"] = reputationProfiles.Apply(getAppSecReputationProfilesResult =\u003e getAppSecReputationProfilesResult.OutputText),\n        [\"reputationProfilesJson\"] = reputationProfiles.Apply(getAppSecReputationProfilesResult =\u003e getAppSecReputationProfilesResult.Json),\n        [\"reputationProfileJson\"] = reputationProfile.Apply(getAppSecReputationProfilesResult =\u003e getAppSecReputationProfilesResult.Json),\n        [\"reputationProfileOutput\"] = reputationProfile.Apply(getAppSecReputationProfilesResult =\u003e getAppSecReputationProfilesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treputationProfiles, err := akamai.GetAppSecReputationProfiles(ctx, \u0026akamai.GetAppSecReputationProfilesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfilesOutput\", reputationProfiles.OutputText)\n\t\tctx.Export(\"reputationProfilesJson\", reputationProfiles.Json)\n\t\treputationProfile, err := akamai.GetAppSecReputationProfiles(ctx, \u0026akamai.GetAppSecReputationProfilesArgs{\n\t\t\tConfigId:            configuration.ConfigId,\n\t\t\tReputationProfileId: pulumi.IntRef(12345),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"reputationProfileJson\", reputationProfile.Json)\n\t\tctx.Export(\"reputationProfileOutput\", reputationProfile.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecReputationProfilesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var reputationProfiles = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"reputationProfilesOutput\", reputationProfiles.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.outputText()));\n        ctx.export(\"reputationProfilesJson\", reputationProfiles.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.json()));\n        final var reputationProfile = AkamaiFunctions.getAppSecReputationProfiles(GetAppSecReputationProfilesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .reputationProfileId(\"12345\")\n            .build());\n\n        ctx.export(\"reputationProfileJson\", reputationProfile.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.json()));\n        ctx.export(\"reputationProfileOutput\", reputationProfile.applyValue(getAppSecReputationProfilesResult -\u003e getAppSecReputationProfilesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view all the reputation profiles associated with a security configuration.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  reputationProfiles:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfiles\n      Arguments:\n        configId: ${configuration.configId}\n  reputationProfile:\n    fn::invoke:\n      Function: akamai:getAppSecReputationProfiles\n      Arguments:\n        configId: ${configuration.configId}\n        reputationProfileId: '12345'\noutputs:\n  reputationProfilesOutput: ${reputationProfiles.outputText}\n  reputationProfilesJson: ${reputationProfiles.json} # USE CASE: User wants to view a specific reputation profile associated with a given configuration\n  reputationProfileJson: ${reputationProfile.json}\n  reputationProfileOutput: ${reputationProfile.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report of the details about the specified reputation profile or profiles.\n- `json`. JSON-formatted report of the details about the specified reputation profile or profiles.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecReputationProfiles.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the reputation profiles.\n"
                    },
                    "reputationProfileId": {
                        "type": "integer",
                        "description": ". Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecReputationProfiles.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "reputationProfileId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRuleUpgradeDetails:getAppSecRuleUpgradeDetails": {
            "description": "**Scopes**: Security policy\n\nReturns information indicating which of your Kona Rule Sets, if any, need to be updated. A value of **false** indicates that no updates are required.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/upgrade-details](https://techdocs.akamai.com/application-security/reference/get-rules-upgrade-details)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst upgradeDetails = configuration.then(configuration =\u003e akamai.getAppSecRuleUpgradeDetails({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const upgradeDetailsText = upgradeDetails.then(upgradeDetails =\u003e upgradeDetails.outputText);\nexport const upgradeDetailsJson = upgradeDetails.then(upgradeDetails =\u003e upgradeDetails.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nupgrade_details = akamai.get_app_sec_rule_upgrade_details(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"upgradeDetailsText\", upgrade_details.output_text)\npulumi.export(\"upgradeDetailsJson\", upgrade_details.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var upgradeDetails = Akamai.GetAppSecRuleUpgradeDetails.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"upgradeDetailsText\"] = upgradeDetails.Apply(getAppSecRuleUpgradeDetailsResult =\u003e getAppSecRuleUpgradeDetailsResult.OutputText),\n        [\"upgradeDetailsJson\"] = upgradeDetails.Apply(getAppSecRuleUpgradeDetailsResult =\u003e getAppSecRuleUpgradeDetailsResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tupgradeDetails, err := akamai.GetAppSecRuleUpgradeDetails(ctx, \u0026akamai.GetAppSecRuleUpgradeDetailsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"upgradeDetailsText\", upgradeDetails.OutputText)\n\t\tctx.Export(\"upgradeDetailsJson\", upgradeDetails.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecRuleUpgradeDetailsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var upgradeDetails = AkamaiFunctions.getAppSecRuleUpgradeDetails(GetAppSecRuleUpgradeDetailsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"upgradeDetailsText\", upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -\u003e getAppSecRuleUpgradeDetailsResult.outputText()));\n        ctx.export(\"upgradeDetailsJson\", upgradeDetails.applyValue(getAppSecRuleUpgradeDetailsResult -\u003e getAppSecRuleUpgradeDetailsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  upgradeDetails:\n    fn::invoke:\n      Function: akamai:getAppSecRuleUpgradeDetails\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  upgradeDetailsText: ${upgradeDetails.outputText}\n  upgradeDetailsJson: ${upgradeDetails.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report showing changes (additions and deletions) to the rules for the specified security policy.\n- `json`. JSON-formatted list of the changes (additions and deletions) to the rules for the specified security policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRuleUpgradeDetails.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Sets.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Sets.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRuleUpgradeDetails.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecRules:getAppSecRules": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecRules.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the rules.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique identifier of the Kona Rule Set rule you want to return information for. If not included, information is returned for all your KRS rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecRules.\n",
                "properties": {
                    "conditionException": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "ruleAction": {
                        "type": "string"
                    },
                    "ruleId": {
                        "type": "integer"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "conditionException",
                    "configId",
                    "json",
                    "outputText",
                    "ruleAction",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSecurityPolicy:getAppSecSecurityPolicy": {
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSecurityPolicy.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policies.\n"
                    },
                    "securityPolicyName": {
                        "type": "string",
                        "description": ". (Optional). Name of the security policy you want to return information for (be sure to reference the policy name and not the policy ID). If not included, information is returned for all your security policies.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSecurityPolicy.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "securityPolicyIdLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "securityPolicyName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "securityPolicyIdLists",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSecurityPolicyProtections:getAppSecSecurityPolicyProtections": {
            "description": "**Scopes**: Security policy\n\nReturns information about the protections in effect for the specified security policy.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/get-policy-protections)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst protections = configuration.then(configuration =\u003e akamai.getAppSecSecurityPolicyProtections({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const protectionsJson = protections.then(protections =\u003e protections.json);\nexport const protectionsApplyApiConstraints = protections.then(protections =\u003e protections.applyApiConstraints);\nexport const protectionsApplyApplicationLayerControls = protections.then(protections =\u003e protections.applyApplicationLayerControls);\nexport const protectionsApplyBotmanControls = protections.then(protections =\u003e protections.applyBotmanControls);\nexport const protectionsApplyMalwareControls = protections.then(protections =\u003e protections.applyMalwareControls);\nexport const protectionsApplyNetworkLayerControls = protections.then(protections =\u003e protections.applyNetworkLayerControls);\nexport const protectionsApplyRateControls = protections.then(protections =\u003e protections.applyRateControls);\nexport const protectionsApplyReputationControls = protections.then(protections =\u003e protections.applyReputationControls);\nexport const protectionsApplySlowPostControls = protections.then(protections =\u003e protections.applySlowPostControls);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nprotections = akamai.get_app_sec_security_policy_protections(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"protectionsJson\", protections.json)\npulumi.export(\"protectionsApplyApiConstraints\", protections.apply_api_constraints)\npulumi.export(\"protectionsApplyApplicationLayerControls\", protections.apply_application_layer_controls)\npulumi.export(\"protectionsApplyBotmanControls\", protections.apply_botman_controls)\npulumi.export(\"protectionsApplyMalwareControls\", protections.apply_malware_controls)\npulumi.export(\"protectionsApplyNetworkLayerControls\", protections.apply_network_layer_controls)\npulumi.export(\"protectionsApplyRateControls\", protections.apply_rate_controls)\npulumi.export(\"protectionsApplyReputationControls\", protections.apply_reputation_controls)\npulumi.export(\"protectionsApplySlowPostControls\", protections.apply_slow_post_controls)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var protections = Akamai.GetAppSecSecurityPolicyProtections.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"protectionsJson\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.Json),\n        [\"protectionsApplyApiConstraints\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyApiConstraints),\n        [\"protectionsApplyApplicationLayerControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyApplicationLayerControls),\n        [\"protectionsApplyBotmanControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyBotmanControls),\n        [\"protectionsApplyMalwareControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyMalwareControls),\n        [\"protectionsApplyNetworkLayerControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyNetworkLayerControls),\n        [\"protectionsApplyRateControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyRateControls),\n        [\"protectionsApplyReputationControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplyReputationControls),\n        [\"protectionsApplySlowPostControls\"] = protections.Apply(getAppSecSecurityPolicyProtectionsResult =\u003e getAppSecSecurityPolicyProtectionsResult.ApplySlowPostControls),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprotections, err := akamai.GetAppSecSecurityPolicyProtections(ctx, \u0026akamai.GetAppSecSecurityPolicyProtectionsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"protectionsJson\", protections.Json)\n\t\tctx.Export(\"protectionsApplyApiConstraints\", protections.ApplyApiConstraints)\n\t\tctx.Export(\"protectionsApplyApplicationLayerControls\", protections.ApplyApplicationLayerControls)\n\t\tctx.Export(\"protectionsApplyBotmanControls\", protections.ApplyBotmanControls)\n\t\tctx.Export(\"protectionsApplyMalwareControls\", protections.ApplyMalwareControls)\n\t\tctx.Export(\"protectionsApplyNetworkLayerControls\", protections.ApplyNetworkLayerControls)\n\t\tctx.Export(\"protectionsApplyRateControls\", protections.ApplyRateControls)\n\t\tctx.Export(\"protectionsApplyReputationControls\", protections.ApplyReputationControls)\n\t\tctx.Export(\"protectionsApplySlowPostControls\", protections.ApplySlowPostControls)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSecurityPolicyProtectionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var protections = AkamaiFunctions.getAppSecSecurityPolicyProtections(GetAppSecSecurityPolicyProtectionsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"protectionsJson\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.json()));\n        ctx.export(\"protectionsApplyApiConstraints\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyApiConstraints()));\n        ctx.export(\"protectionsApplyApplicationLayerControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyApplicationLayerControls()));\n        ctx.export(\"protectionsApplyBotmanControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyBotmanControls()));\n        ctx.export(\"protectionsApplyMalwareControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyMalwareControls()));\n        ctx.export(\"protectionsApplyNetworkLayerControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyNetworkLayerControls()));\n        ctx.export(\"protectionsApplyRateControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyRateControls()));\n        ctx.export(\"protectionsApplyReputationControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applyReputationControls()));\n        ctx.export(\"protectionsApplySlowPostControls\", protections.applyValue(getAppSecSecurityPolicyProtectionsResult -\u003e getAppSecSecurityPolicyProtectionsResult.applySlowPostControls()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  protections:\n    fn::invoke:\n      Function: akamai:getAppSecSecurityPolicyProtections\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  protectionsJson: ${protections.json}\n  protectionsApplyApiConstraints: ${protections.applyApiConstraints}\n  protectionsApplyApplicationLayerControls: ${protections.applyApplicationLayerControls}\n  protectionsApplyBotmanControls: ${protections.applyBotmanControls}\n  protectionsApplyMalwareControls: ${protections.applyMalwareControls}\n  protectionsApplyNetworkLayerControls: ${protections.applyNetworkLayerControls}\n  protectionsApplyRateControls: ${protections.applyRateControls}\n  protectionsApplyReputationControls: ${protections.applyReputationControls}\n  protectionsApplySlowPostControls: ${protections.applySlowPostControls}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `apply_application_layer_controls`. Returns **true** if application layer controls are enabled; returns **false** if they are not.\n- `apply_api_constraints`. Returns **true** if API constraints are enabled; returns **false** if they are not.\n- `apply_botman_controls`. Returns **true** if Bot Manager controls are enabled; returns **false** if they are not.\n- `apply_malware_controls`. Returns **true** if malware controls are enabled; returns **false** if they are not.\n- `apply_network_layer_controls`. Returns **true** if network layer controls are enabled; returns **false** if they are not.\n- `apply_rate_controls`. Returns **true** if rate controls are enabled; returns **false** if they are not.\n- `apply_reputation_controls`. Returns **true** if reputation controls are enabled; returns **false** if they are not.\n- `apply_slow_post_controls`. Returns **true** if slow POST controls are enabled; returns **false** if they are not.\n- `json`. JSON-formatted list showing the status of the protection settings.\n- `output_text`. Tabular report showing the status of the protection settings.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSecurityPolicyProtections.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the security policy protections.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy you want to return protections information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSecurityPolicyProtections.\n",
                "properties": {
                    "applyApiConstraints": {
                        "type": "boolean"
                    },
                    "applyApplicationLayerControls": {
                        "type": "boolean"
                    },
                    "applyBotmanControls": {
                        "type": "boolean"
                    },
                    "applyMalwareControls": {
                        "type": "boolean"
                    },
                    "applyNetworkLayerControls": {
                        "type": "boolean"
                    },
                    "applyRateControls": {
                        "type": "boolean"
                    },
                    "applyReputationControls": {
                        "type": "boolean"
                    },
                    "applySlowPostControls": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "applyApiConstraints",
                    "applyApplicationLayerControls",
                    "applyBotmanControls",
                    "applyMalwareControls",
                    "applyNetworkLayerControls",
                    "applyRateControls",
                    "applyReputationControls",
                    "applySlowPostControls",
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSelectableHostnames:getAppSecSelectableHostnames": {
            "description": "**Scopes**: Security configuration; contract; group\n\nReturns the list of hostnames that can be (but aren't yet) protected by a security configuration. You can specify the set of hostnames to be retrieved either by supplying the name of a security configuration or by supplying an Akamai group ID and contract ID.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selectable-hostnames](https://techdocs.akamai.com/application-security/reference/get-selectable-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst selectableHostnamesAppSecSelectableHostnames = configuration.then(configuration =\u003e akamai.getAppSecSelectableHostnames({\n    configId: configuration.configId,\n}));\nexport const selectableHostnames = selectableHostnamesAppSecSelectableHostnames.then(selectableHostnamesAppSecSelectableHostnames =\u003e selectableHostnamesAppSecSelectableHostnames.hostnames);\nexport const selectableHostnamesJson = selectableHostnamesAppSecSelectableHostnames.then(selectableHostnamesAppSecSelectableHostnames =\u003e selectableHostnamesAppSecSelectableHostnames.hostnamesJson);\nexport const selectableHostnamesOutputText = selectableHostnamesAppSecSelectableHostnames.then(selectableHostnamesAppSecSelectableHostnames =\u003e selectableHostnamesAppSecSelectableHostnames.outputText);\nconst selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = akamai.getAppSecSelectableHostnames({\n    contractId: \"5-2WA382\",\n    groupId: 12198,\n});\nexport const selectableHostnamesForCreateConfiguration = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.then(selectableHostnamesForCreateConfigurationAppSecSelectableHostnames =\u003e selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnames);\nexport const selectableHostnamesForCreateConfigurationJson = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.then(selectableHostnamesForCreateConfigurationAppSecSelectableHostnames =\u003e selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnamesJson);\nexport const selectableHostnamesForCreateConfigurationOutputText = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.then(selectableHostnamesForCreateConfigurationAppSecSelectableHostnames =\u003e selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nselectable_hostnames_app_sec_selectable_hostnames = akamai.get_app_sec_selectable_hostnames(config_id=configuration.config_id)\npulumi.export(\"selectableHostnames\", selectable_hostnames_app_sec_selectable_hostnames.hostnames)\npulumi.export(\"selectableHostnamesJson\", selectable_hostnames_app_sec_selectable_hostnames.hostnames_json)\npulumi.export(\"selectableHostnamesOutputText\", selectable_hostnames_app_sec_selectable_hostnames.output_text)\nselectable_hostnames_for_create_configuration_app_sec_selectable_hostnames = akamai.get_app_sec_selectable_hostnames(contract_id=\"5-2WA382\",\n    group_id=12198)\npulumi.export(\"selectableHostnamesForCreateConfiguration\", selectable_hostnames_for_create_configuration_app_sec_selectable_hostnames.hostnames)\npulumi.export(\"selectableHostnamesForCreateConfigurationJson\", selectable_hostnames_for_create_configuration_app_sec_selectable_hostnames.hostnames_json)\npulumi.export(\"selectableHostnamesForCreateConfigurationOutputText\", selectable_hostnames_for_create_configuration_app_sec_selectable_hostnames.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var selectableHostnamesAppSecSelectableHostnames = Akamai.GetAppSecSelectableHostnames.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = Akamai.GetAppSecSelectableHostnames.Invoke(new()\n    {\n        ContractId = \"5-2WA382\",\n        GroupId = 12198,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"selectableHostnames\"] = selectableHostnamesAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.Hostnames),\n        [\"selectableHostnamesJson\"] = selectableHostnamesAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.HostnamesJson),\n        [\"selectableHostnamesOutputText\"] = selectableHostnamesAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.OutputText),\n        [\"selectableHostnamesForCreateConfiguration\"] = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.Hostnames),\n        [\"selectableHostnamesForCreateConfigurationJson\"] = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.HostnamesJson),\n        [\"selectableHostnamesForCreateConfigurationOutputText\"] = selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.Apply(getAppSecSelectableHostnamesResult =\u003e getAppSecSelectableHostnamesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselectableHostnamesAppSecSelectableHostnames, err := akamai.GetAppSecSelectableHostnames(ctx, \u0026akamai.GetAppSecSelectableHostnamesArgs{\n\t\t\tConfigId: pulumi.IntRef(configuration.ConfigId),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"selectableHostnames\", selectableHostnamesAppSecSelectableHostnames.Hostnames)\n\t\tctx.Export(\"selectableHostnamesJson\", selectableHostnamesAppSecSelectableHostnames.HostnamesJson)\n\t\tctx.Export(\"selectableHostnamesOutputText\", selectableHostnamesAppSecSelectableHostnames.OutputText)\n\t\tselectableHostnamesForCreateConfigurationAppSecSelectableHostnames, err := akamai.GetAppSecSelectableHostnames(ctx, \u0026akamai.GetAppSecSelectableHostnamesArgs{\n\t\t\tContractId: \"5-2WA382\",\n\t\t\tGroupId:    12198,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"selectableHostnamesForCreateConfiguration\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.Hostnames)\n\t\tctx.Export(\"selectableHostnamesForCreateConfigurationJson\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.HostnamesJson)\n\t\tctx.Export(\"selectableHostnamesForCreateConfigurationOutputText\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSelectableHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var selectableHostnamesAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"selectableHostnames\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()));\n        ctx.export(\"selectableHostnamesJson\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectableHostnamesOutputText\", selectableHostnamesAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.outputText()));\n        final var selectableHostnamesForCreateConfigurationAppSecSelectableHostnames = AkamaiFunctions.getAppSecSelectableHostnames(GetAppSecSelectableHostnamesArgs.builder()\n            .contractId(\"5-2WA382\")\n            .groupId(12198)\n            .build());\n\n        ctx.export(\"selectableHostnamesForCreateConfiguration\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnames()));\n        ctx.export(\"selectableHostnamesForCreateConfigurationJson\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectableHostnamesForCreateConfigurationOutputText\", selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.applyValue(getAppSecSelectableHostnamesResult -\u003e getAppSecSelectableHostnamesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  selectableHostnamesAppSecSelectableHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        configId: ${configuration.configId}\n  selectableHostnamesForCreateConfigurationAppSecSelectableHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecSelectableHostnames\n      Arguments:\n        contractId: 5-2WA382\n        groupId: 12198\noutputs:\n  selectableHostnames: ${selectableHostnamesAppSecSelectableHostnames.hostnames} # USE CASE: User wants to view all the unprotected hostnames.\n  selectableHostnamesJson: ${selectableHostnamesAppSecSelectableHostnames.hostnamesJson} # USE CASE: user wants to view the same list of unprotected hostnames, in tabular form\n  selectableHostnamesOutputText: ${selectableHostnamesAppSecSelectableHostnames.outputText} # USE CASE: User wants to view the list of hosts available for the specified contract and contract group before creating a new security configuration.\n  selectableHostnamesForCreateConfiguration: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnames} # USE CASE: User wants to view the available hostnames in JSON format.\n  selectableHostnamesForCreateConfigurationJson: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.hostnamesJson} # USE CASE: User wants to view the available hostnames in a table.\n  selectableHostnamesForCreateConfigurationOutputText: ${selectableHostnamesForCreateConfigurationAppSecSelectableHostnames.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of selectable hostnames.\n- `hostnames_json`. JSON-formatted list of selectable hostnames.\n- `output_text`. Tabular report of the selectable hostnames showing the name and config_id of the security configuration under which the host is protected in production.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSelectableHostnames.\n",
                "properties": {
                    "activeInProduction": {
                        "type": "boolean"
                    },
                    "activeInStaging": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return hostname information for. If not included, information is returned for all your security configurations. Note that argument can't be used with either the `contractid` or the `groupid` arguments.\n"
                    },
                    "contractid": {
                        "type": "string",
                        "description": ". Unique identifier of the Akamai contract you want to return hostname information for. If not included, information is returned for all the Akamai contracts associated with your account. Note that this argument can't be used with the `config_id` argument.\n"
                    },
                    "groupid": {
                        "type": "integer",
                        "description": ". Unique identifier of the contract group you want to return hostname information for. If not included, information is returned for all your contract groups. (Or, if you include the `contractid` argument, all the groups associated with the specified contract.) Note that this argument can't be used with the `config_id` argument.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSelectableHostnames.\n",
                "properties": {
                    "activeInProduction": {
                        "type": "boolean"
                    },
                    "activeInStaging": {
                        "type": "boolean"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "contractid": {
                        "type": "string"
                    },
                    "groupid": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "hostnamesJson": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostnames",
                    "hostnamesJson",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSelectedHostnames:getAppSecSelectedHostnames": {
            "description": "**Scopes**: Security configuration\n\nReturns a list of the hostnames currently protected by the specified security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/selected-hostnames](https://techdocs.akamai.com/application-security/reference/get-selected-hostnames)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst selectedHostnamesAppSecSelectedHostnames = configuration.then(configuration =\u003e akamai.getAppSecSelectedHostnames({\n    configId: configuration.configId,\n}));\nexport const selectedHostnames = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.hostnames);\nexport const selectedHostnamesJson = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.hostnamesJson);\nexport const selectedHostnamesOutputText = selectedHostnamesAppSecSelectedHostnames.then(selectedHostnamesAppSecSelectedHostnames =\u003e selectedHostnamesAppSecSelectedHostnames.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nselected_hostnames_app_sec_selected_hostnames = akamai.get_app_sec_selected_hostnames(config_id=configuration.config_id)\npulumi.export(\"selectedHostnames\", selected_hostnames_app_sec_selected_hostnames.hostnames)\npulumi.export(\"selectedHostnamesJson\", selected_hostnames_app_sec_selected_hostnames.hostnames_json)\npulumi.export(\"selectedHostnamesOutputText\", selected_hostnames_app_sec_selected_hostnames.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var selectedHostnamesAppSecSelectedHostnames = Akamai.GetAppSecSelectedHostnames.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"selectedHostnames\"] = selectedHostnamesAppSecSelectedHostnames.Apply(getAppSecSelectedHostnamesResult =\u003e getAppSecSelectedHostnamesResult.Hostnames),\n        [\"selectedHostnamesJson\"] = selectedHostnamesAppSecSelectedHostnames.Apply(getAppSecSelectedHostnamesResult =\u003e getAppSecSelectedHostnamesResult.HostnamesJson),\n        [\"selectedHostnamesOutputText\"] = selectedHostnamesAppSecSelectedHostnames.Apply(getAppSecSelectedHostnamesResult =\u003e getAppSecSelectedHostnamesResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tselectedHostnamesAppSecSelectedHostnames, err := akamai.LookupAppSecSelectedHostnames(ctx, \u0026akamai.LookupAppSecSelectedHostnamesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"selectedHostnames\", selectedHostnamesAppSecSelectedHostnames.Hostnames)\n\t\tctx.Export(\"selectedHostnamesJson\", selectedHostnamesAppSecSelectedHostnames.HostnamesJson)\n\t\tctx.Export(\"selectedHostnamesOutputText\", selectedHostnamesAppSecSelectedHostnames.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var selectedHostnamesAppSecSelectedHostnames = AkamaiFunctions.getAppSecSelectedHostnames(GetAppSecSelectedHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"selectedHostnames\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.hostnames()));\n        ctx.export(\"selectedHostnamesJson\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.hostnamesJson()));\n        ctx.export(\"selectedHostnamesOutputText\", selectedHostnamesAppSecSelectedHostnames.applyValue(getAppSecSelectedHostnamesResult -\u003e getAppSecSelectedHostnamesResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  selectedHostnamesAppSecSelectedHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecSelectedHostnames\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  selectedHostnames: ${selectedHostnamesAppSecSelectedHostnames.hostnames}\n  selectedHostnamesJson: ${selectedHostnamesAppSecSelectedHostnames.hostnamesJson}\n  selectedHostnamesOutputText: ${selectedHostnamesAppSecSelectedHostnames.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `hostnames`. List of selected hostnames.\n- `hostnames_json`. JSON-formatted list of selected hostnames.\n- `output_text`. Tabular report of the selected hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the protected hosts.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "hostnamesJson": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "hostnames",
                    "hostnamesJson",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSiemDefinitions:getAppSecSiemDefinitions": {
            "description": "**Scopes**: SIEM definition\n\nReturns information about your SIEM (Security Information and Event Management) versions. The returned information is described in the [Get SIEM versions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions) section of the Application Security API.\n\n**Related API Endpoint**: [/appsec/v1/siem-definitions](https://techdocs.akamai.com/application-security/reference/get-siem-definitions)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst siemDefinitions = akamai.getAppSecSiemDefinitions({});\nexport const siemDefinitionsJson = siemDefinitions.then(siemDefinitions =\u003e siemDefinitions.json);\nexport const siemDefinitionsOutput = siemDefinitions.then(siemDefinitions =\u003e siemDefinitions.outputText);\nconst siemDefinition = akamai.getAppSecSiemDefinitions({\n    siemDefinitionName: \"SIEM Version 01\",\n});\nexport const siemDefinitionId = siemDefinition.then(siemDefinition =\u003e siemDefinition.id);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nsiem_definitions = akamai.get_app_sec_siem_definitions()\npulumi.export(\"siemDefinitionsJson\", siem_definitions.json)\npulumi.export(\"siemDefinitionsOutput\", siem_definitions.output_text)\nsiem_definition = akamai.get_app_sec_siem_definitions(siem_definition_name=\"SIEM Version 01\")\npulumi.export(\"siemDefinitionId\", siem_definition.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var siemDefinitions = Akamai.GetAppSecSiemDefinitions.Invoke();\n\n    var siemDefinition = Akamai.GetAppSecSiemDefinitions.Invoke(new()\n    {\n        SiemDefinitionName = \"SIEM Version 01\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"siemDefinitionsJson\"] = siemDefinitions.Apply(getAppSecSiemDefinitionsResult =\u003e getAppSecSiemDefinitionsResult.Json),\n        [\"siemDefinitionsOutput\"] = siemDefinitions.Apply(getAppSecSiemDefinitionsResult =\u003e getAppSecSiemDefinitionsResult.OutputText),\n        [\"siemDefinitionId\"] = siemDefinition.Apply(getAppSecSiemDefinitionsResult =\u003e getAppSecSiemDefinitionsResult.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsiemDefinitions, err := akamai.GetAppSecSiemDefinitions(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemDefinitionsJson\", siemDefinitions.Json)\n\t\tctx.Export(\"siemDefinitionsOutput\", siemDefinitions.OutputText)\n\t\tsiemDefinition, err := akamai.GetAppSecSiemDefinitions(ctx, \u0026akamai.GetAppSecSiemDefinitionsArgs{\n\t\t\tSiemDefinitionName: pulumi.StringRef(\"SIEM Version 01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemDefinitionId\", siemDefinition.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecSiemDefinitionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var siemDefinitions = AkamaiFunctions.getAppSecSiemDefinitions();\n\n        ctx.export(\"siemDefinitionsJson\", siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.json()));\n        ctx.export(\"siemDefinitionsOutput\", siemDefinitions.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.outputText()));\n        final var siemDefinition = AkamaiFunctions.getAppSecSiemDefinitions(GetAppSecSiemDefinitionsArgs.builder()\n            .siemDefinitionName(\"SIEM Version 01\")\n            .build());\n\n        ctx.export(\"siemDefinitionId\", siemDefinition.applyValue(getAppSecSiemDefinitionsResult -\u003e getAppSecSiemDefinitionsResult.id()));\n    }\n}\n```\n```yaml\nvariables:\n  siemDefinitions:\n    fn::invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments: {}\n  siemDefinition:\n    fn::invoke:\n      Function: akamai:getAppSecSiemDefinitions\n      Arguments:\n        siemDefinitionName: SIEM Version 01\noutputs:\n  siemDefinitionsJson: ${siemDefinitions.json}\n  siemDefinitionsOutput: ${siemDefinitions.outputText}\n  siemDefinitionId: ${siemDefinition.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the SIEM version information.\n- `output_text`. Tabular report showing the ID and name of each SIEM version.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSiemDefinitions.\n",
                "properties": {
                    "siemDefinitionName": {
                        "type": "string",
                        "description": ". Name of the SIEM definition you want to return information for. If not included, information is returned for all your SIEM definitions.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSiemDefinitions.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "siemDefinitionName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSiemSettings:getAppSecSiemSettings": {
            "description": "**Scopes**: Security configuration\n\nReturns the SIEM (Security Event and Information Management) settings for a security configuration. \n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst siemSettings = configuration.then(configuration =\u003e akamai.getAppSecSiemSettings({\n    configId: configuration.configId,\n}));\nexport const siemSettingsJson = siemSettings.then(siemSettings =\u003e siemSettings.json);\nexport const siemSettingsOutput = siemSettings.then(siemSettings =\u003e siemSettings.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nsiem_settings = akamai.get_app_sec_siem_settings(config_id=configuration.config_id)\npulumi.export(\"siemSettingsJson\", siem_settings.json)\npulumi.export(\"siemSettingsOutput\", siem_settings.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var siemSettings = Akamai.GetAppSecSiemSettings.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"siemSettingsJson\"] = siemSettings.Apply(getAppSecSiemSettingsResult =\u003e getAppSecSiemSettingsResult.Json),\n        [\"siemSettingsOutput\"] = siemSettings.Apply(getAppSecSiemSettingsResult =\u003e getAppSecSiemSettingsResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsiemSettings, err := akamai.LookupAppSecSiemSettings(ctx, \u0026akamai.LookupAppSecSiemSettingsArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"siemSettingsJson\", siemSettings.Json)\n\t\tctx.Export(\"siemSettingsOutput\", siemSettings.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSiemSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var siemSettings = AkamaiFunctions.getAppSecSiemSettings(GetAppSecSiemSettingsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"siemSettingsJson\", siemSettings.applyValue(getAppSecSiemSettingsResult -\u003e getAppSecSiemSettingsResult.json()));\n        ctx.export(\"siemSettingsOutput\", siemSettings.applyValue(getAppSecSiemSettingsResult -\u003e getAppSecSiemSettingsResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  siemSettings:\n    fn::invoke:\n      Function: akamai:getAppSecSiemSettings\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  siemSettingsJson: ${siemSettings.json}\n  siemSettingsOutput: ${siemSettings.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list of the SIEM setting information.\n- `output_text`. Tabular report showing the SIEM setting information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSiemSettings.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSiemSettings.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecSlowPost:getAppSecSlowPost": {
            "description": "**Scopes**: Security policy\n\nReturns the slow POST protection settings for the specified security configuration and policy. Slow POST protections help defend a site against attacks that try to tie up the site by using extremely slow requests and responses.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/slow-post](https://techdocs.akamai.com/application-security/reference/get-policy-slow-post)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst slowPost = configuration.then(configuration =\u003e akamai.getAppSecSlowPost({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const slowPostOutputText = slowPost.then(slowPost =\u003e slowPost.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nslow_post = akamai.get_app_sec_slow_post(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"slowPostOutputText\", slow_post.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var slowPost = Akamai.GetAppSecSlowPost.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"slowPostOutputText\"] = slowPost.Apply(getAppSecSlowPostResult =\u003e getAppSecSlowPostResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tslowPost, err := akamai.LookupAppSecSlowPost(ctx, \u0026akamai.LookupAppSecSlowPostArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"slowPostOutputText\", slowPost.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecSlowPostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var slowPost = AkamaiFunctions.getAppSecSlowPost(GetAppSecSlowPostArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"slowPostOutputText\", slowPost.applyValue(getAppSecSlowPostResult -\u003e getAppSecSlowPostResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  slowPost:\n    fn::invoke:\n      Function: akamai:getAppSecSlowPost\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  slowPostOutputText: ${slowPost.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `output_text`. Tabular report including the following:\n  - **ACTION**. Action taken any time slow POST protection is triggered. Valid values are:\n    - **alert**. Record the event.\n    - **abort**. Block the request.\n  - **SLOW_RATE_THRESHOLD RATE**. Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered.\n  - **SLOW_RATE_THRESHOLD PERIOD**. Amount of time (in seconds) that the server should allow a request before marking the request as being too slow.\n  - **DURATION_THRESHOLD TIMEOUT**. Maximum amount of time (in seconds) that the first eight kilobytes of the POST body must be received in order to avoid triggering the specified action.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecSlowPost.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the slow POST settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the slow POST settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecSlowPost.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecThreatIntel:getAppSecThreatIntel": {
            "description": "**Scopes**: Security policy\n\nReturns threat intelligence settings for a security policy Note that this data source is only available to organizations running the Adaptive Security Engine (ASE) beta. For more information on ASE, please contact your Akamai representative.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/threat-intel](https://techdocs.akamai.com/application-security/reference/get-rules-threat-intel)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst threatIntelAppSecThreatIntel = configuration.then(configuration =\u003e akamai.getAppSecThreatIntel({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const threatIntel = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.threatIntel);\nexport const json = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.json);\nexport const outputText = threatIntelAppSecThreatIntel.then(threatIntelAppSecThreatIntel =\u003e threatIntelAppSecThreatIntel.outputText);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nthreat_intel_app_sec_threat_intel = akamai.get_app_sec_threat_intel(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"threatIntel\", threat_intel_app_sec_threat_intel.threat_intel)\npulumi.export(\"json\", threat_intel_app_sec_threat_intel.json)\npulumi.export(\"outputText\", threat_intel_app_sec_threat_intel.output_text)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var threatIntelAppSecThreatIntel = Akamai.GetAppSecThreatIntel.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"threatIntel\"] = threatIntelAppSecThreatIntel.Apply(getAppSecThreatIntelResult =\u003e getAppSecThreatIntelResult.ThreatIntel),\n        [\"json\"] = threatIntelAppSecThreatIntel.Apply(getAppSecThreatIntelResult =\u003e getAppSecThreatIntelResult.Json),\n        [\"outputText\"] = threatIntelAppSecThreatIntel.Apply(getAppSecThreatIntelResult =\u003e getAppSecThreatIntelResult.OutputText),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthreatIntelAppSecThreatIntel, err := akamai.LookupAppSecThreatIntel(ctx, \u0026akamai.LookupAppSecThreatIntelArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"threatIntel\", threatIntelAppSecThreatIntel.ThreatIntel)\n\t\tctx.Export(\"json\", threatIntelAppSecThreatIntel.Json)\n\t\tctx.Export(\"outputText\", threatIntelAppSecThreatIntel.OutputText)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecThreatIntelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var threatIntelAppSecThreatIntel = AkamaiFunctions.getAppSecThreatIntel(GetAppSecThreatIntelArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"threatIntel\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.threatIntel()));\n        ctx.export(\"json\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.json()));\n        ctx.export(\"outputText\", threatIntelAppSecThreatIntel.applyValue(getAppSecThreatIntelResult -\u003e getAppSecThreatIntelResult.outputText()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  threatIntelAppSecThreatIntel:\n    fn::invoke:\n      Function: akamai:getAppSecThreatIntel\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  threatIntel: ${threatIntelAppSecThreatIntel.threatIntel}\n  json: ${threatIntelAppSecThreatIntel.json}\n  outputText: ${threatIntelAppSecThreatIntel.outputText}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `threat_intel`. Reports the threat Intelligence setting, either **on** or **off**.\n- `json`. JSON-formatted threat intelligence report.\n- `output_text`. Tabular report of the threat intelligence information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecThreatIntel.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the threat intelligence settings.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the threat intelligence settings.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecThreatIntel.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "threatIntel": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "securityPolicyId",
                    "threatIntel",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecTuningRecommendations:getAppSecTuningRecommendations": {
            "description": "Returns tuning recommendations for the specified attack group or rule (or, if both the `attack_group` and the `rule_id` arguments are not included, returns tuning recommendations for all the attack groups and rules in the specified security policy).\nTuning recommendations help minimize the number of false positives triggered by a security policy. With a false positive, a client request is marked as having violated the security policy restrictions even though it actually did not.\nTuning recommendations are returned as attack group or rule exceptions: if you choose, you can copy the response and use the `akamai.AppSecAttackGroup` resource to add the recommended exception to an attack group or the `akamai.AppSecRule` resource to add the recommended exception to a rule.  \nIf the data source response is empty, that means that there are no further recommendations for tuning your security policy or attack group.\nIf you need, you can manually merge a recommended exception for an attack group or a rule with the exception previously configured.\nYou can find additional information in our [Application Security API v1 documentation](https://techdocs.akamai.com/application-security/reference/get-recommendations).\n\n**Related API endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/recommendation](https://techdocs.akamai.com/application-security/reference/get-recommendations)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: _var.security_configuration,\n});\nconst policyRecommendations = configuration.then(configuration =\u003e akamai.getAppSecTuningRecommendations({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n}));\nexport const policyRecommendationsJson = policyRecommendations.then(policyRecommendations =\u003e policyRecommendations.json);\nconst attackGroupRecommendations = configuration.then(configuration =\u003e akamai.getAppSecTuningRecommendations({\n    configId: configuration.configId,\n    securityPolicyId: _var.security_policy_id,\n    rulesetType: _var.ruleset_type,\n    attackGroup: _var.attack_group,\n}));\nexport const attackGroupRecommendationsJson = attackGroupRecommendations.then(attackGroupRecommendations =\u003e attackGroupRecommendations.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=var[\"security_configuration\"])\npolicy_recommendations = akamai.get_app_sec_tuning_recommendations(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"])\npulumi.export(\"policyRecommendationsJson\", policy_recommendations.json)\nattack_group_recommendations = akamai.get_app_sec_tuning_recommendations(config_id=configuration.config_id,\n    security_policy_id=var[\"security_policy_id\"],\n    ruleset_type=var[\"ruleset_type\"],\n    attack_group=var[\"attack_group\"])\npulumi.export(\"attackGroupRecommendationsJson\", attack_group_recommendations.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = @var.Security_configuration,\n    });\n\n    var policyRecommendations = Akamai.GetAppSecTuningRecommendations.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = @var.Security_policy_id,\n    });\n\n    var attackGroupRecommendations = Akamai.GetAppSecTuningRecommendations.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = @var.Security_policy_id,\n        RulesetType = @var.Ruleset_type,\n        AttackGroup = @var.Attack_group,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"policyRecommendationsJson\"] = policyRecommendations.Apply(getAppSecTuningRecommendationsResult =\u003e getAppSecTuningRecommendationsResult.Json),\n        [\"attackGroupRecommendationsJson\"] = attackGroupRecommendations.Apply(getAppSecTuningRecommendationsResult =\u003e getAppSecTuningRecommendationsResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(_var.Security_configuration),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpolicyRecommendations, err := akamai.GetAppSecTuningRecommendations(ctx, \u0026akamai.GetAppSecTuningRecommendationsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"policyRecommendationsJson\", policyRecommendations.Json)\n\t\tattackGroupRecommendations, err := akamai.GetAppSecTuningRecommendations(ctx, \u0026akamai.GetAppSecTuningRecommendationsArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: pulumi.StringRef(_var.Security_policy_id),\n\t\t\tRulesetType:      pulumi.StringRef(_var.Ruleset_type),\n\t\t\tAttackGroup:      pulumi.StringRef(_var.Attack_group),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"attackGroupRecommendationsJson\", attackGroupRecommendations.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecTuningRecommendationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(var_.security_configuration())\n            .build());\n\n        final var policyRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .build());\n\n        ctx.export(\"policyRecommendationsJson\", policyRecommendations.applyValue(getAppSecTuningRecommendationsResult -\u003e getAppSecTuningRecommendationsResult.json()));\n        final var attackGroupRecommendations = AkamaiFunctions.getAppSecTuningRecommendations(GetAppSecTuningRecommendationsArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(var_.security_policy_id())\n            .rulesetType(var_.ruleset_type())\n            .attackGroup(var_.attack_group())\n            .build());\n\n        ctx.export(\"attackGroupRecommendationsJson\", attackGroupRecommendations.applyValue(getAppSecTuningRecommendationsResult -\u003e getAppSecTuningRecommendationsResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: ${var.security_configuration}\n  policyRecommendations:\n    fn::invoke:\n      Function: akamai:getAppSecTuningRecommendations\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\n  attackGroupRecommendations:\n    fn::invoke:\n      Function: akamai:getAppSecTuningRecommendations\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: ${var.security_policy_id}\n        rulesetType: ${var.ruleset_type}\n        attackGroup: ${var.attack_group}\noutputs:\n  policyRecommendationsJson: ${policyRecommendations.json}\n  attackGroupRecommendationsJson: ${attackGroupRecommendations.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecTuningRecommendations.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string",
                        "description": ". Unique name of the attack group you want tuning recommendations for. If both `attack_group` and `rule_id` not included, recommendations are returned for all attack groups.\n"
                    },
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want tuning recommendations for.\n"
                    },
                    "ruleId": {
                        "type": "integer",
                        "description": ". Unique id of the rule you want tuning recommendations for. If both `attack_group` and `rule_id` not included, recommendations are returned for all attack groups.\n"
                    },
                    "rulesetType": {
                        "type": "string",
                        "description": ". Type of ruleset used by the security configuration you want tuning recommendations for. Supported values are `active` and `evaluation`. Defaults to `active`.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy you want tuning recommendations for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecTuningRecommendations.\n",
                "properties": {
                    "attackGroup": {
                        "type": "string"
                    },
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON-formatted list of the tuning recommendations for the security policy, the attack group or the rule. The exception block format in a recommendation conforms to the exception block format used in `condition_exception` element of `attack_group` or ASE rule resource.\n"
                    },
                    "ruleId": {
                        "type": "integer"
                    },
                    "rulesetType": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecVersionNotes:getAppSecVersionNotes": {
            "description": "**Scopes**: Security configuration\n\nReturns the most recent version notes for a security configuration.\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst versionNotes = configuration.then(configuration =\u003e akamai.getAppSecVersionNotes({\n    configId: configuration.configId,\n}));\nexport const versionNotesText = versionNotes.then(versionNotes =\u003e versionNotes.outputText);\nexport const versionNotesJson = versionNotes.then(versionNotes =\u003e versionNotes.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nversion_notes = akamai.get_app_sec_version_notes(config_id=configuration.config_id)\npulumi.export(\"versionNotesText\", version_notes.output_text)\npulumi.export(\"versionNotesJson\", version_notes.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var versionNotes = Akamai.GetAppSecVersionNotes.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"versionNotesText\"] = versionNotes.Apply(getAppSecVersionNotesResult =\u003e getAppSecVersionNotesResult.OutputText),\n        [\"versionNotesJson\"] = versionNotes.Apply(getAppSecVersionNotesResult =\u003e getAppSecVersionNotesResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversionNotes, err := akamai.GetAppSecVersionNotes(ctx, \u0026akamai.GetAppSecVersionNotesArgs{\n\t\t\tConfigId: configuration.ConfigId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"versionNotesText\", versionNotes.OutputText)\n\t\tctx.Export(\"versionNotesJson\", versionNotes.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecVersionNotesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var versionNotes = AkamaiFunctions.getAppSecVersionNotes(GetAppSecVersionNotesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .build());\n\n        ctx.export(\"versionNotesText\", versionNotes.applyValue(getAppSecVersionNotesResult -\u003e getAppSecVersionNotesResult.outputText()));\n        ctx.export(\"versionNotesJson\", versionNotes.applyValue(getAppSecVersionNotesResult -\u003e getAppSecVersionNotesResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration: # USE CASE: User wants to view the version notes for the most-recent version of a security configuration.\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  versionNotes:\n    fn::invoke:\n      Function: akamai:getAppSecVersionNotes\n      Arguments:\n        configId: ${configuration.configId}\noutputs:\n  versionNotesText: ${versionNotes.outputText}\n  versionNotesJson: ${versionNotes.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `json`. JSON-formatted list showing the version notes.\n- `output_text`. Tabular report showing the version notes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecVersionNotes.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration you want to return information for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecVersionNotes.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "json",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecWafMode:getAppSecWafMode": {
            "description": "**Scopes**: Security policy\n\nReturns information about how the Kona Rule Set rules associated with a security configuration and security policy are updated. The WAF (Web Application Firewall) mode determines whether Kona Rule Sets are automatically updated as part of automated attack groups (`mode = AAG`) or whether you must periodically check for new rules and then manually update those rules yourself (`mode = KRS`).\n\n**Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/get-policy-mode)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wafMode = configuration.then(configuration =\u003e akamai.getAppSecWafMode({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const wafModeMode = wafMode.then(wafMode =\u003e wafMode.mode);\nexport const wafModeCurrentRuleset = wafMode.then(wafMode =\u003e wafMode.currentRuleset);\nexport const wafModeEvalStatus = wafMode.then(wafMode =\u003e wafMode.evalStatus);\nexport const wafModeEvalRuleset = wafMode.then(wafMode =\u003e wafMode.evalRuleset);\nexport const wafModeEvalExpirationDate = wafMode.then(wafMode =\u003e wafMode.evalExpirationDate);\nexport const wafModeText = wafMode.then(wafMode =\u003e wafMode.outputText);\nexport const wafModeJson = wafMode.then(wafMode =\u003e wafMode.json);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwaf_mode = akamai.get_app_sec_waf_mode(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"wafModeMode\", waf_mode.mode)\npulumi.export(\"wafModeCurrentRuleset\", waf_mode.current_ruleset)\npulumi.export(\"wafModeEvalStatus\", waf_mode.eval_status)\npulumi.export(\"wafModeEvalRuleset\", waf_mode.eval_ruleset)\npulumi.export(\"wafModeEvalExpirationDate\", waf_mode.eval_expiration_date)\npulumi.export(\"wafModeText\", waf_mode.output_text)\npulumi.export(\"wafModeJson\", waf_mode.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var wafMode = Akamai.GetAppSecWafMode.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"wafModeMode\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.Mode),\n        [\"wafModeCurrentRuleset\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.CurrentRuleset),\n        [\"wafModeEvalStatus\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.EvalStatus),\n        [\"wafModeEvalRuleset\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.EvalRuleset),\n        [\"wafModeEvalExpirationDate\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.EvalExpirationDate),\n        [\"wafModeText\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.OutputText),\n        [\"wafModeJson\"] = wafMode.Apply(getAppSecWafModeResult =\u003e getAppSecWafModeResult.Json),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twafMode, err := akamai.LookupAppSecWafMode(ctx, \u0026akamai.LookupAppSecWafModeArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"wafModeMode\", wafMode.Mode)\n\t\tctx.Export(\"wafModeCurrentRuleset\", wafMode.CurrentRuleset)\n\t\tctx.Export(\"wafModeEvalStatus\", wafMode.EvalStatus)\n\t\tctx.Export(\"wafModeEvalRuleset\", wafMode.EvalRuleset)\n\t\tctx.Export(\"wafModeEvalExpirationDate\", wafMode.EvalExpirationDate)\n\t\tctx.Export(\"wafModeText\", wafMode.OutputText)\n\t\tctx.Export(\"wafModeJson\", wafMode.Json)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecWafModeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var wafMode = AkamaiFunctions.getAppSecWafMode(GetAppSecWafModeArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"wafModeMode\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.mode()));\n        ctx.export(\"wafModeCurrentRuleset\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.currentRuleset()));\n        ctx.export(\"wafModeEvalStatus\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalStatus()));\n        ctx.export(\"wafModeEvalRuleset\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalRuleset()));\n        ctx.export(\"wafModeEvalExpirationDate\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.evalExpirationDate()));\n        ctx.export(\"wafModeText\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.outputText()));\n        ctx.export(\"wafModeJson\", wafMode.applyValue(getAppSecWafModeResult -\u003e getAppSecWafModeResult.json()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  wafMode:\n    fn::invoke:\n      Function: akamai:getAppSecWafMode\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  wafModeMode: ${wafMode.mode}\n  wafModeCurrentRuleset: ${wafMode.currentRuleset}\n  wafModeEvalStatus: ${wafMode.evalStatus}\n  wafModeEvalRuleset: ${wafMode.evalRuleset}\n  wafModeEvalExpirationDate: ${wafMode.evalExpirationDate}\n  wafModeText: ${wafMode.outputText}\n  wafModeJson: ${wafMode.json}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned, and how that returned information is formatted:\n\n- `mode`. Security policy mode, either **KRS** (update manually) or **AAG** (update automatically), For organizations running the Adaptive Security Engine (ASE) beta, you'll get back **ASE_AUTO** for automatic updates or **ASE_MANUAL** for manual updates. Please contact your Akamai representative to learn more about ASE.\n- `current_ruleset`. Current ruleset version and the ISO 8601 date the version was introduced.\n- `eval_status`. Specifies whether evaluation mode is enabled or disabled.\n- `eval_ruleset`. Evaluation ruleset version and the ISO 8601 date the evaluation began.\n- `eval_expiration_date`. ISO 8601 timestamp indicating when evaluation mode expires. Valid only if `eval_status` is set to **enabled**.\n- `output_text`. Tabular report of the mode information.\n- `json`. JSON-formatted list of the mode information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecWafMode.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the Kona Rule Set rules.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the Kona Rule Set rules.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecWafMode.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "currentRuleset": {
                        "type": "string"
                    },
                    "evalExpirationDate": {
                        "type": "string"
                    },
                    "evalRuleset": {
                        "type": "string"
                    },
                    "evalStatus": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "securityPolicyId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "currentRuleset",
                    "evalExpirationDate",
                    "evalRuleset",
                    "evalStatus",
                    "json",
                    "mode",
                    "outputText",
                    "securityPolicyId",
                    "id"
                ]
            }
        },
        "akamai:index/getAppSecWapSelectedHostnames:getAppSecWapSelectedHostnames": {
            "description": "**Scopes**: Security policy\n\nReturns hostnames currently protected or being evaluated by a configuration and security policy.\nThis resource is available only to organizations running Web Application Protector (WAP).\nNote that the WAP selected hostnames feature is currently in beta.\nPlease contact your Akamai representative for more information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst configuration = akamai.getAppSecConfiguration({\n    name: \"Documentation\",\n});\nconst wapSelectedHostnames = configuration.then(configuration =\u003e akamai.getAppSecWapSelectedHostnames({\n    configId: configuration.configId,\n    securityPolicyId: \"gms1_134637\",\n}));\nexport const protectedHostnames = wapSelectedHostnames.then(wapSelectedHostnames =\u003e wapSelectedHostnames.protectedHosts);\nexport const evaluatedHostnames = wapSelectedHostnames.then(wapSelectedHostnames =\u003e wapSelectedHostnames.evaluatedHosts);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nconfiguration = akamai.get_app_sec_configuration(name=\"Documentation\")\nwap_selected_hostnames = akamai.get_app_sec_wap_selected_hostnames(config_id=configuration.config_id,\n    security_policy_id=\"gms1_134637\")\npulumi.export(\"protectedHostnames\", wap_selected_hostnames.protected_hosts)\npulumi.export(\"evaluatedHostnames\", wap_selected_hostnames.evaluated_hosts)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var configuration = Akamai.GetAppSecConfiguration.Invoke(new()\n    {\n        Name = \"Documentation\",\n    });\n\n    var wapSelectedHostnames = Akamai.GetAppSecWapSelectedHostnames.Invoke(new()\n    {\n        ConfigId = configuration.Apply(getAppSecConfigurationResult =\u003e getAppSecConfigurationResult.ConfigId),\n        SecurityPolicyId = \"gms1_134637\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"protectedHostnames\"] = wapSelectedHostnames.Apply(getAppSecWapSelectedHostnamesResult =\u003e getAppSecWapSelectedHostnamesResult.ProtectedHosts),\n        [\"evaluatedHostnames\"] = wapSelectedHostnames.Apply(getAppSecWapSelectedHostnamesResult =\u003e getAppSecWapSelectedHostnamesResult.EvaluatedHosts),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconfiguration, err := akamai.LookupAppSecConfiguration(ctx, \u0026akamai.LookupAppSecConfigurationArgs{\n\t\t\tName: pulumi.StringRef(\"Documentation\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twapSelectedHostnames, err := akamai.LookupAppSecWapSelectedHostnames(ctx, \u0026akamai.LookupAppSecWapSelectedHostnamesArgs{\n\t\t\tConfigId:         configuration.ConfigId,\n\t\t\tSecurityPolicyId: \"gms1_134637\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"protectedHostnames\", wapSelectedHostnames.ProtectedHosts)\n\t\tctx.Export(\"evaluatedHostnames\", wapSelectedHostnames.EvaluatedHosts)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAppSecConfigurationArgs;\nimport com.pulumi.akamai.inputs.GetAppSecWapSelectedHostnamesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var configuration = AkamaiFunctions.getAppSecConfiguration(GetAppSecConfigurationArgs.builder()\n            .name(\"Documentation\")\n            .build());\n\n        final var wapSelectedHostnames = AkamaiFunctions.getAppSecWapSelectedHostnames(GetAppSecWapSelectedHostnamesArgs.builder()\n            .configId(configuration.applyValue(getAppSecConfigurationResult -\u003e getAppSecConfigurationResult.configId()))\n            .securityPolicyId(\"gms1_134637\")\n            .build());\n\n        ctx.export(\"protectedHostnames\", wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -\u003e getAppSecWapSelectedHostnamesResult.protectedHosts()));\n        ctx.export(\"evaluatedHostnames\", wapSelectedHostnames.applyValue(getAppSecWapSelectedHostnamesResult -\u003e getAppSecWapSelectedHostnamesResult.evaluatedHosts()));\n    }\n}\n```\n```yaml\nvariables:\n  configuration:\n    fn::invoke:\n      Function: akamai:getAppSecConfiguration\n      Arguments:\n        name: Documentation\n  wapSelectedHostnames:\n    fn::invoke:\n      Function: akamai:getAppSecWapSelectedHostnames\n      Arguments:\n        configId: ${configuration.configId}\n        securityPolicyId: gms1_134637\noutputs:\n  protectedHostnames: ${wapSelectedHostnames.protectedHosts}\n  evaluatedHostnames: ${wapSelectedHostnames.evaluatedHosts}\n```\n{{% /example %}}\n{{% /examples %}}\n## Output Options\n\nThe following options can be used to determine the information returned and how that returned information is formatted:\n\n- `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.\n- `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.\n- `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.\n- `output_text`. Tabular reports of the protected and evaluated hostnames.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAppSecWapSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer",
                        "description": ". Unique identifier of the security configuration associated with the hostnames.\n"
                    },
                    "securityPolicyId": {
                        "type": "string",
                        "description": ". Unique identifier of the security policy associated with the hostnames.\n"
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "securityPolicyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAppSecWapSelectedHostnames.\n",
                "properties": {
                    "configId": {
                        "type": "integer"
                    },
                    "evaluatedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchTargets": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string"
                    },
                    "protectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "securityPolicyId": {
                        "type": "string"
                    },
                    "selectedHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "configId",
                    "evaluatedHosts",
                    "json",
                    "matchTargets",
                    "outputText",
                    "protectedHosts",
                    "securityPolicyId",
                    "selectedHosts",
                    "id"
                ]
            }
        },
        "akamai:index/getAuthoritiesSet:getAuthoritiesSet": {
            "description": "Use the `akamai.getAuthoritiesSet` data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getAuthoritiesSet({\n    contract: \"ctr_1-AB123\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_authorities_set(contract=\"ctr_1-AB123\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetAuthoritiesSet.Invoke(new()\n    {\n        Contract = \"ctr_1-AB123\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetAuthoritiesSet(ctx, \u0026akamai.GetAuthoritiesSetArgs{\n\t\t\tContract: \"ctr_1-AB123\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetAuthoritiesSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getAuthoritiesSet(GetAuthoritiesSetArgs.builder()\n            .contract(\"ctr_1-AB123\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getAuthoritiesSet\n      Arguments:\n        contract: ctr_1-AB123\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source supports this attribute:\n\n* `authorities` - A list of authorities.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthoritiesSet.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "The contract ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contract"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthoritiesSet.\n",
                "properties": {
                    "authorities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "contract": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authorities",
                    "contract",
                    "id"
                ]
            }
        },
        "akamai:index/getCPSEnrollment:getCPSEnrollment": {
            "description": "Use the `akamai.getCPSEnrollment` data source to return data for specific enrollment.\n\n## Basic usage\n\nThis example shows how to set up a user:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst testEnrollment = akamai.getCPSEnrollment({\n    enrollmentId: _var.enrollment_id,\n});\nexport const dvOutput = testEnrollment;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest_enrollment = akamai.get_cps_enrollment(enrollment_id=var[\"enrollment_id\"])\npulumi.export(\"dvOutput\", test_enrollment)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testEnrollment = Akamai.GetCPSEnrollment.Invoke(new()\n    {\n        EnrollmentId = @var.Enrollment_id,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dvOutput\"] = testEnrollment.Apply(getCPSEnrollmentResult =\u003e getCPSEnrollmentResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestEnrollment, err := akamai.GetCPSEnrollment(ctx, \u0026akamai.GetCPSEnrollmentArgs{\n\t\t\tEnrollmentId: _var.Enrollment_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dvOutput\", testEnrollment)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCPSEnrollmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testEnrollment = AkamaiFunctions.getCPSEnrollment(GetCPSEnrollmentArgs.builder()\n            .enrollmentId(var_.enrollment_id())\n            .build());\n\n        ctx.export(\"dvOutput\", testEnrollment.applyValue(getCPSEnrollmentResult -\u003e getCPSEnrollmentResult));\n    }\n}\n```\n```yaml\nvariables:\n  testEnrollment:\n    fn::invoke:\n      Function: akamai:getCPSEnrollment\n      Arguments:\n        enrollmentId: ${var.enrollment_id}\noutputs:\n  dvOutput: ${testEnrollment}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n  * `common_name` - The fully qualified domain name (FQDN) used for the certificate.\n  * `sans` - Additional common names in a Subject Alternative Names (SAN) list.\n  * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n  * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.\n  * `admin_contact` - Contact information for the certificate administrator at your company.\n  * `certificate_chain_type` - Certificate trust chain type.\n  * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n    * `country_code` - The country code for the country where your organization is located.\n    * `city` - The city where your organization resides.\n    * `organization` - The name of your company or organization.\n    * `organizational_unit` - Your organizational unit.\n    * `state` - Your state or province.\n  * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.\n  * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n    * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.\n      * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.\n      * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.\n      * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).\n    * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.\n    * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.\n    * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.\n    * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n    * `ocsp_stapling` - If present, its using OCSP stapling for the enrollment, either `on`, `off` or `not-set`. OCSP Stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response.\n    * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n    * `quic_enabled` - If present, uses the QUIC transport layer network protocol.\n  * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n  * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n  * `organization` - The name of the organization in Akamai where your technical contact works.\n    * `name` - The name of the technical contact at Akamai.\n    * `phone` - The phone number of the technical contact at Akamai.\n    * `address_line_one` - The address for the technical contact at Akamai.\n    * `address_line_two` - The address for the technical contact at Akamai.\n    * `city` - The address for the technical contact at Akamai.\n    * `region` - The region for the technical contact at Akamai.\n    * `postal_code` - The postal code for the technical contact at Akamai.\n    * `country_code` - The country code for the technical contact at Akamai.\n  * `contract_id` - A contract's ID, optionally with the `ctr_` prefix.\n  * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.\n  * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.\n  * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.\n  * `dns_challenges` - If present, the validation challenge for the domains listed in the certificate.\n    * `domain` - The domain to validate.\n    * `full_path` - The URL where Akamai publishes `response_body` for Let's Encrypt to validate.\n    * `response_body` - The data Let's Encrypt expects to find served at `full_path` URL.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCPSEnrollment.\n",
                "properties": {
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier for the certificate enrollment.\n"
                    }
                },
                "type": "object",
                "required": [
                    "enrollmentId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCPSEnrollment.\n",
                "properties": {
                    "adminContacts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentAdminContact:getCPSEnrollmentAdminContact"
                        }
                    },
                    "certificateChainType": {
                        "type": "string"
                    },
                    "certificateType": {
                        "type": "string"
                    },
                    "commonName": {
                        "type": "string"
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "csrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentCsr:getCPSEnrollmentCsr"
                        }
                    },
                    "dnsChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentDnsChallenge:getCPSEnrollmentDnsChallenge"
                        }
                    },
                    "enableMultiStackedCertificates": {
                        "type": "boolean"
                    },
                    "enrollmentId": {
                        "type": "integer"
                    },
                    "httpChallenges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentHttpChallenge:getCPSEnrollmentHttpChallenge"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "networkConfigurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentNetworkConfiguration:getCPSEnrollmentNetworkConfiguration"
                        }
                    },
                    "organizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentOrganization:getCPSEnrollmentOrganization"
                        }
                    },
                    "registrationAuthority": {
                        "type": "string"
                    },
                    "sans": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "secureNetwork": {
                        "type": "string"
                    },
                    "signatureAlgorithm": {
                        "type": "string"
                    },
                    "sniOnly": {
                        "type": "boolean"
                    },
                    "techContacts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentTechContact:getCPSEnrollmentTechContact"
                        }
                    },
                    "validationType": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "adminContacts",
                    "certificateChainType",
                    "certificateType",
                    "commonName",
                    "contractId",
                    "csrs",
                    "dnsChallenges",
                    "enableMultiStackedCertificates",
                    "enrollmentId",
                    "httpChallenges",
                    "networkConfigurations",
                    "organizations",
                    "registrationAuthority",
                    "sans",
                    "secureNetwork",
                    "signatureAlgorithm",
                    "sniOnly",
                    "techContacts",
                    "validationType",
                    "id"
                ]
            }
        },
        "akamai:index/getCPSEnrollments:getCPSEnrollments": {
            "description": "Use the `akamai.getCPSEnrollments` data source to return data for all of a specific contract's enrollments.\n\n## Basic usage\n\nThis example shows how to set up a user:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst testEnrollmentsList = akamai.getCPSEnrollments({\n    contractId: _var.contract_id,\n});\nexport const dvOutput = testEnrollmentsList;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest_enrollments_list = akamai.get_cps_enrollments(contract_id=var[\"contract_id\"])\npulumi.export(\"dvOutput\", test_enrollments_list)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testEnrollmentsList = Akamai.GetCPSEnrollments.Invoke(new()\n    {\n        ContractId = @var.Contract_id,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dvOutput\"] = testEnrollmentsList.Apply(getCPSEnrollmentsResult =\u003e getCPSEnrollmentsResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestEnrollmentsList, err := akamai.GetCPSEnrollments(ctx, \u0026akamai.GetCPSEnrollmentsArgs{\n\t\t\tContractId: _var.Contract_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dvOutput\", testEnrollmentsList)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCPSEnrollmentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testEnrollmentsList = AkamaiFunctions.getCPSEnrollments(GetCPSEnrollmentsArgs.builder()\n            .contractId(var_.contract_id())\n            .build());\n\n        ctx.export(\"dvOutput\", testEnrollmentsList.applyValue(getCPSEnrollmentsResult -\u003e getCPSEnrollmentsResult));\n    }\n}\n```\n```yaml\nvariables:\n  testEnrollmentsList:\n    fn::invoke:\n      Function: akamai:getCPSEnrollments\n      Arguments:\n        contractId: ${var.contract_id}\noutputs:\n  dvOutput: ${testEnrollmentsList}\n```\n\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `enrollments`\n  * `enrollment_id`\n  * `common_name` - The fully qualified domain name (FQDN) used for the certificate.\n  * `sans` - Additional common names in a Subject Alternative Names (SAN) list.\n  * `secure_network` - The type of deployment network used. `standard-tls` deploys your certificate to Akamai's standard secure network, but it isn't PCI compliant. `enhanced-tls` deploys your certificate to Akamai's more secure network with PCI compliance capability.\n  * `sni_only` - Whether you enabled SNI-only extension for the enrollment. Server Name Indication (SNI) is an extension of the Transport Layer Security (TLS) networking protocol. It allows a server to present multiple certificates on the same IP address. All modern web browsers support the SNI extension. If you have the same SAN on two or more certificates with the SNI-only option set, Akamai may serve traffic using any certificate which matches the requested SNI hostname.\n  * `admin_contact` - Contact information for the certificate administrator at your company.\n  * `certificate_chain_type` - Certificate trust chain type.\n  * `csr` - When you create an enrollment, you also generate a certificate signing request (CSR) using CPS. CPS signs the CSR with the private key. The CSR contains all the information the CA needs to issue your certificate.\n    * `country_code` - The country code for the country where your organization is located.\n    * `city` - The city where your organization resides.\n    * `organization` - The name of your company or organization.\n    * `organizational_unit` - Your organizational unit.\n    * `state` - Your state or province.\n  * `enable_multi_stacked_certificates` - If present, an ECDSA certificate is enabled in addition to an RSA certificate. CPS automatically performs all certificate operations on both certificates, and uses the best certificate for each client connection to your secure properties.\n  * `network_configuration` - The network information and TLS Metadata you want CPS to use to push the completed certificate to the network.\n    * `client_mutual_authentication` - If present, shows the configuration for client mutual authentication. Specifies the trust chain that is used to verify client certificates and some configuration options.\n      * `send_ca_list_to_client` - If present, the server is enabled to send the certificate authority (CA) list to the client.\n      * `ocsp_enabled` - If present, the Online Certificate Status Protocol (OCSP) stapling is enabled for client certificates.\n      * `set_id` - The identifier of the set of trust chains, created in [Trust Chain Manager](https://techdocs.akamai.com/trust-chain-mgr/docs/welcome-trust-chain-manager).\n    * `disallowed_tls_versions` - The TLS protocol version that is not trusted. CPS uses the TLS protocols that Akamai currently supports as a best practice.\n    * `clone_dns_names` - If present, CPS directs traffic using all the SANs listed in the SANs parameter when the enrollment was created.\n    * `geography` - A list of where you can deploy the certificate. Either `core` to specify worldwide deployment (including China and Russia), `china+core` to specify worldwide deployment and China, or `russia+core` to specify worldwide deployment and Russia.\n    * `must_have_ciphers` - If present, shows ciphers included for enrollment when deployed on the network. The default is `ak-akamai-default` when it is not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n    * `ocsp_stapling` - If present, the enrollment is using OCSP stapling. OCSP stapling improves performance by including a valid OCSP response in every TLS handshake. This option allows the visitors on your site to query the Online Certificate Status Protocol (OCSP) server at regular intervals to obtain a signed time-stamped OCSP response. Possible values are `on`, `off`, or `not-set`.\n    * `preferred_ciphers` - If present, shows the ciphers that you prefer to include for the enrollment while deploying it on the network. The default is `ak-akamai-default` when its not set. For more information on cipher profiles, see [Akamai community](https://community.akamai.com/customers/s/article/SSL-TLS-Cipher-Profiles-for-Akamai-Secure-CDNrxdxm).\n    * `quic_enabled` - If present, uses the QUIC transport layer network protocol.\n  * `signature_algorithm` - If present, shows the Secure Hash Algorithm (SHA) function, either `SHA-1` or `SHA-256`.\n  * `tech_contact` - The technical contact within Akamai. This is the person you work closest with at Akamai and who can verify the certificate request. The CA calls this contact if there are any issues with the certificate and they can't reach the `admin_contact`.\n  * `organization` - The name of the organization in Akamai where your technical contact works.\n    * `name` - The name of the technical contact at Akamai.\n    * `phone` - The phone number of the technical contact at Akamai.\n    * `address_line_one` - The address for the technical contact at Akamai.\n    * `address_line_two` - The address for the technical contact at Akamai.\n    * `city` - The address for the technical contact at Akamai.\n    * `region` - The region for the technical contact at Akamai.\n    * `postal_code` - The postal code for the technical contact at Akamai.\n    * `country_code` - The country code for the technical contact at Akamai.\n  * `certificate_type` - Populates automatically with the `san` certificate type and is preserved in the `state` file.\n  * `validation_type` - Populates automatically with the `dv` validation type and is preserved in the `state` file.\n  * `registration_authority` - Populates automatically with the `lets-encrypt` certificate type and is preserved in the `state` file.\n  * `pending_changes` - If `true`, there are changes currently pending in CPS. To view pending changes, use the `data_akamai_cps_enrollment` data source.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCPSEnrollments.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "A contract's ID, optionally with the `ctr_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCPSEnrollments.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "enrollments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCPSEnrollmentsEnrollment:getCPSEnrollmentsEnrollment"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "enrollments",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApiPrioritizationMatchRule:getCloudletsApiPrioritizationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsApiPrioritizationMatchRule` data source to build a match rule JSON object for the API Prioritization Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the API Prioritization Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApiPrioritizationMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApiPrioritizationMatchRule(GetCloudletsApiPrioritizationMatchRuleArgs.builder()\n            .matchRules(GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs.builder()\n                .disabled(false)\n                .end(1645037845)\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsApiPrioritizationMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(true)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .passThroughPercent(10)\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsApiPrioritizationMatchRule\n      Arguments:\n        matchRules:\n          - disabled: false\n            end: 1.645037845e+09\n            matchUrl: example.com\n            matches:\n              - caseSensitive: true\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - POST\n            name: rule\n            passThroughPercent: 10\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApiPrioritizationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApiPrioritizationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApiPrioritizationMatchRuleMatchRule:getCloudletsApiPrioritizationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancer:getCloudletsApplicationLoadBalancer": {
            "description": "Use the `akamai.CloudletsApplicationLoadBalancer` data source to list details about the Application Load Balancer configuration with a specified policy version, or latest if not specified.\n\n## Basic usage\n\nThis example returns the load balancing configuration details based on the origin ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCloudletsApplicationLoadBalancer({\n    originId: \"alb_test_1\",\n    version: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_application_load_balancer(origin_id=\"alb_test_1\",\n    version=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCloudletsApplicationLoadBalancer.Invoke(new()\n    {\n        OriginId = \"alb_test_1\",\n        Version = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.LookupCloudletsApplicationLoadBalancer(ctx, \u0026akamai.LookupCloudletsApplicationLoadBalancerArgs{\n\t\t\tOriginId: \"alb_test_1\",\n\t\t\tVersion:  pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancer(GetCloudletsApplicationLoadBalancerArgs.builder()\n            .originId(\"alb_test_1\")\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsApplicationLoadBalancer\n      Arguments:\n        originId: alb_test_1\n        version: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `description` - The description of the load balancing configuration.\n* `type` - The type of Conditional Origin. `APPLICATION_LOAD_BALANCER` is the only supported value.\n* `balancing_type` - The type of load balancing being performed, either `WEIGHTED` or `PERFORMANCE`.\n* `created_by` - The name of the user who created this load balancing configuration.\n* `created_date` - The date, in ISO 8601 format, when this load balancing configuration was created.\n* `deleted` - Whether the Conditional Origin version has been deleted. If `false`, you can use this version again.\n* `immutable` - Whether you can edit the load balancing version. The default setting for this member is false. It automatically becomes true when the load balancing version is activated for the first time.\n* `last_modified_by` - The user who last modified the load balancing configuration.\n* `last_modified_date` - The date, in ISO 8601 format, when the initial load balancing configuration was last modified.\n* `warnings` - A list of warnings that occurred during the activation of the load balancing configuration.\n* `data_centers` - Specifies the Conditional Origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an origin type of `CUSTOMER` or `NETSTORAGE` can be used as data centers in an Application Load Balancer configuration.\n  * `city` - The city in which the data center is located.\n  * `cloud_server_host_header_override` - Whether the cloud server host header is overridden.\n  * `cloud_service` - Whether this datacenter is a cloud service.\n  * `continent` - The code of the continent on which the data center is located. See [Continent Codes](https://control.akamai.com/dl/edgescape/continentCodes.csv) for a list of valid codes.\n  * `country` - The country in which the data center is located. See [Country Codes](https://control.akamai.com/dl/edgescape/cc2continent.csv) for a list of valid codes.\n  * `hostname` - The name of the host that can be used as a Conditional Origin. This should match the `hostname` value defined for this datacenter in Property Manager.\n  * `latitude` - The latitude value for the data center. This member supports six decimal places of precision.\n  * `liveness_hosts` - A list of the origin servers used to poll the data centers in an Application Load Balancer configuration. These servers support basic HTTP polling.\n  * `longitude` - The longitude value for the data center. This member supports six decimal places of precision.\n  * `origin_id` - The ID of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.\n  * `percent` - The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.\n  * `state_or_province` - The state, province, or region where the data center is located.\n* `liveness_settings` - Specifies the health of each load balanced data center defined in the data center list.\n  * `host_header` - The Host header for the liveness HTTP request.\n  * `additional_headers` - Maps additional case-insensitive HTTP header names included to the liveness testing requests.\n  * `interval` - The frequency of liveness tests. Defaults to 60 seconds, minimum is 10 seconds.\n  * `path` - The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.\n  * `peer_certificate_verification` - Whether to validate the origin certificate for an HTTPS request.\n  * `port` - The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.\n  * `protocol` - The protocol or scheme for the database, either `HTTP` or `HTTPS`.\n  * `request_string` - The request used for TCP and TCPS tests.\n  * `response_string` - The response used for TCP and TCPS tests.\n  * `status_3xx_failure` - If `true`, marks the liveness test as failed when the request returns a 3xx (redirection) status code.\n  * `status_4xx_failure` - If `true`, marks the liveness test as failed when the request returns a 4xx (client error) status code.\n  * `status_5xx_failure` - If `true`, marks the liveness test as failed when the request returns a 5xx (server error) status code.\n  * `timeout` - The number of seconds the system waits before failing the liveness test.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApplicationLoadBalancer.\n",
                "properties": {
                    "originId": {
                        "type": "string",
                        "description": "(Required) A unique identifier for the Conditional Origin that supports the load balancing configuration. The Conditional Origin type must be set to `APPLICATION_LOAD_BALANCER` in the `origin` behavior. See property rules for more information.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version number of the load balancing configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "originId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApplicationLoadBalancer.\n",
                "properties": {
                    "balancingType": {
                        "type": "string"
                    },
                    "createdBy": {
                        "type": "string"
                    },
                    "createdDate": {
                        "type": "string"
                    },
                    "dataCenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerDataCenter:getCloudletsApplicationLoadBalancerDataCenter"
                        }
                    },
                    "deleted": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "immutable": {
                        "type": "boolean"
                    },
                    "lastModifiedBy": {
                        "type": "string"
                    },
                    "lastModifiedDate": {
                        "type": "string"
                    },
                    "livenessSettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerLivenessSetting:getCloudletsApplicationLoadBalancerLivenessSetting"
                        }
                    },
                    "originId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    },
                    "warnings": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "balancingType",
                    "createdBy",
                    "createdDate",
                    "dataCenters",
                    "deleted",
                    "description",
                    "immutable",
                    "lastModifiedBy",
                    "lastModifiedDate",
                    "livenessSettings",
                    "originId",
                    "type",
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsApplicationLoadBalancerMatchRule:getCloudletsApplicationLoadBalancerMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsApplicationLoadBalancerMatchRule` data source to build a match rule JSON object for the Application Load Balancer Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Application Load Balancer Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsApplicationLoadBalancerMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsApplicationLoadBalancerMatchRule(GetCloudletsApplicationLoadBalancerMatchRuleArgs.builder()\n            .matchRules(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .forwardSettings(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleForwardSettingArgs.builder()\n                    .originId(\"alb_test_1\")\n                    .build())\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsApplicationLoadBalancerMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsApplicationLoadBalancerMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            forwardSettings:\n              - originId: alb_test_1\n            matchUrl: example.com\n            matches:\n              - caseSensitive: false\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - GET\n            name: rule\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsApplicationLoadBalancerMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsApplicationLoadBalancerMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsApplicationLoadBalancerMatchRuleMatchRule:getCloudletsApplicationLoadBalancerMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsAudienceSegmentationMatchRule:getCloudletsAudienceSegmentationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsAudienceSegmentationMatchRule` data source to build a match rule JSON object for the Audience Segmentation Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Audience Segmentation Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsAudienceSegmentationMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsAudienceSegmentationMatchRule(GetCloudletsAudienceSegmentationMatchRuleArgs.builder()\n            .matchRules(GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs.builder()\n                .forwardSettings(GetCloudletsAudienceSegmentationMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"123\")\n                    .pathAndQs(\"/test\")\n                    .useIncomingQueryString(true)\n                    .build())\n                .matches(GetCloudletsAudienceSegmentationMatchRuleMatchRuleMatchArgs.builder()\n                    .matchOperator(\"contains\")\n                    .matchType(\"header\")\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsAudienceSegmentationMatchRule\n      Arguments:\n        matchRules:\n          - forwardSettings:\n              originId: '123'\n              pathAndQs: /test\n              useIncomingQueryString: true\n            matches:\n              - matchOperator: contains\n                matchType: header\n                objectMatchValue:\n                  - name: cookie\n                    options:\n                      value:\n                        - abcd\n                    type: object\n            name: rule\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsAudienceSegmentationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsAudienceSegmentationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsAudienceSegmentationMatchRuleMatchRule:getCloudletsAudienceSegmentationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsEdgeRedirectorMatchRule:getCloudletsEdgeRedirectorMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsEdgeRedirectorMatchRule` data source to build a match rule JSON object for the Edge Redirector Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Edge Redirector Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsEdgeRedirectorMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsEdgeRedirectorMatchRule(GetCloudletsEdgeRedirectorMatchRuleArgs.builder()\n            .matchRules(GetCloudletsEdgeRedirectorMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .matchUrl(\"example.com\")\n                .matches(GetCloudletsEdgeRedirectorMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .matchOperator(\"equals\")\n                    .matchType(\"method\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .redirectUrl(\"https://www.example.com\")\n                .start(1644865045)\n                .statusCode(301)\n                .useIncomingQueryString(false)\n                .useRelativeUrl(\"none\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsEdgeRedirectorMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            matchUrl: example.com\n            matches:\n              - caseSensitive: false\n                matchOperator: equals\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - type: simple\n                    value:\n                      - GET\n            name: rule\n            redirectUrl: https://www.example.com\n            start: 1.644865045e+09\n            statusCode: 301\n            useIncomingQueryString: false\n            useRelativeUrl: none\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsEdgeRedirectorMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsEdgeRedirectorMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsEdgeRedirectorMatchRuleMatchRule:getCloudletsEdgeRedirectorMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsForwardRewriteMatchRule:getCloudletsForwardRewriteMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsForwardRewriteMatchRule` data source to build a match rule JSON object for the Forward Rewrite Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Forward Rewrite Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCloudletsForwardRewriteMatchRule({\n    matchRules: [{\n        forwardSettings: {\n            originId: \"1234\",\n            pathAndQs: \"/path\",\n            useIncomingQueryString: true,\n        },\n        matches: [{\n            caseSensitive: false,\n            checkIps: \"CONNECTING_IP XFF_HEADERS\",\n            matchOperator: \"equals\",\n            matchType: \"clientip\",\n            matchValue: \"192.0.2.0\",\n            negate: false,\n        }],\n        name: \"rule\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_forward_rewrite_match_rule(match_rules=[akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleArgs(\n    forward_settings=akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs(\n        origin_id=\"1234\",\n        path_and_qs=\"/path\",\n        use_incoming_query_string=True,\n    ),\n    matches=[akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs(\n        case_sensitive=False,\n        check_ips=\"CONNECTING_IP XFF_HEADERS\",\n        match_operator=\"equals\",\n        match_type=\"clientip\",\n        match_value=\"192.0.2.0\",\n        negate=False,\n    )],\n    name=\"rule\",\n)])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCloudletsForwardRewriteMatchRule.Invoke(new()\n    {\n        MatchRules = new[]\n        {\n            new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleInputArgs\n            {\n                ForwardSettings = new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsInputArgs\n                {\n                    OriginId = \"1234\",\n                    PathAndQs = \"/path\",\n                    UseIncomingQueryString = true,\n                },\n                Matches = new[]\n                {\n                    new Akamai.Inputs.GetCloudletsForwardRewriteMatchRuleMatchRuleMatchInputArgs\n                    {\n                        CaseSensitive = false,\n                        CheckIps = \"CONNECTING_IP XFF_HEADERS\",\n                        MatchOperator = \"equals\",\n                        MatchType = \"clientip\",\n                        MatchValue = \"192.0.2.0\",\n                        Negate = false,\n                    },\n                },\n                Name = \"rule\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCloudletsForwardRewriteMatchRule(ctx, \u0026akamai.GetCloudletsForwardRewriteMatchRuleArgs{\n\t\t\tMatchRules: []akamai.GetCloudletsForwardRewriteMatchRuleMatchRule{\n\t\t\t\t{\n\t\t\t\t\tForwardSettings: {\n\t\t\t\t\t\tOriginId:               pulumi.StringRef(\"1234\"),\n\t\t\t\t\t\tPathAndQs:              pulumi.StringRef(\"/path\"),\n\t\t\t\t\t\tUseIncomingQueryString: pulumi.BoolRef(true),\n\t\t\t\t\t},\n\t\t\t\t\tMatches: []akamai.GetCloudletsForwardRewriteMatchRuleMatchRuleMatch{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCaseSensitive: pulumi.BoolRef(false),\n\t\t\t\t\t\t\tCheckIps:      pulumi.StringRef(\"CONNECTING_IP XFF_HEADERS\"),\n\t\t\t\t\t\t\tMatchOperator: pulumi.StringRef(\"equals\"),\n\t\t\t\t\t\t\tMatchType:     pulumi.StringRef(\"clientip\"),\n\t\t\t\t\t\t\tMatchValue:    pulumi.StringRef(\"192.0.2.0\"),\n\t\t\t\t\t\t\tNegate:        pulumi.BoolRef(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.StringRef(\"rule\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsForwardRewriteMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsForwardRewriteMatchRule(GetCloudletsForwardRewriteMatchRuleArgs.builder()\n            .matchRules(GetCloudletsForwardRewriteMatchRuleMatchRuleArgs.builder()\n                .forwardSettings(GetCloudletsForwardRewriteMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"1234\")\n                    .pathAndQs(\"/path\")\n                    .useIncomingQueryString(true)\n                    .build())\n                .matches(GetCloudletsForwardRewriteMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                    .matchOperator(\"equals\")\n                    .matchType(\"clientip\")\n                    .matchValue(\"192.0.2.0\")\n                    .negate(false)\n                    .build())\n                .name(\"rule\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsForwardRewriteMatchRule\n      Arguments:\n        matchRules:\n          - forwardSettings:\n              originId: '1234'\n              pathAndQs: /path\n              useIncomingQueryString: true\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: equals\n                matchType: clientip\n                matchValue: 192.0.2.0\n                negate: false\n            name: rule\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsForwardRewriteMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsForwardRewriteMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsForwardRewriteMatchRuleMatchRule:getCloudletsForwardRewriteMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsPhasedReleaseMatchRule:getCloudletsPhasedReleaseMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsPhasedReleaseMatchRule` data source to build a match rule JSON object for the Phased Release Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Phased Release Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsPhasedReleaseMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsPhasedReleaseMatchRule(GetCloudletsPhasedReleaseMatchRuleArgs.builder()\n            .matchRules(GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs.builder()\n                .end(1645037845)\n                .forwardSettings(GetCloudletsPhasedReleaseMatchRuleMatchRuleForwardSettingsArgs.builder()\n                    .originId(\"1234\")\n                    .percent(100)\n                    .build())\n                .matches(GetCloudletsPhasedReleaseMatchRuleMatchRuleMatchArgs.builder()\n                    .caseSensitive(false)\n                    .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                    .matchOperator(\"equals\")\n                    .matchType(\"header\")\n                    .negate(false)\n                    .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                    .build())\n                .name(\"rule\")\n                .start(1644865045)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsPhasedReleaseMatchRule\n      Arguments:\n        matchRules:\n          - end: 1.645037845e+09\n            forwardSettings:\n              originId: '1234'\n              percent: 100\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: equals\n                matchType: header\n                negate: false\n                objectMatchValue:\n                  - name: Content-Type\n                    options:\n                      value:\n                        - application/json\n                    type: object\n            name: rule\n            start: 1.644865045e+09\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsPhasedReleaseMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsPhasedReleaseMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPhasedReleaseMatchRuleMatchRule:getCloudletsPhasedReleaseMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsPolicy:getCloudletsPolicy": {
            "description": "Use the `akamai.CloudletsPolicy` data source to list details about a policy with and its specified version, or latest if not specified.\n\n## Basic usage\n\nThis example returns the policy details based on the policy ID and optionally, a version:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCloudletsPolicy({\n    policyId: 1234,\n    version: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_policy(policy_id=1234,\n    version=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCloudletsPolicy.Invoke(new()\n    {\n        PolicyId = 1234,\n        Version = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.LookupCloudletsPolicy(ctx, \u0026akamai.LookupCloudletsPolicyArgs{\n\t\t\tPolicyId: 1234,\n\t\t\tVersion:  pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsPolicy(GetCloudletsPolicyArgs.builder()\n            .policyId(1234)\n            .version(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsPolicy\n      Arguments:\n        policyId: 1234\n        version: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `group_id` - Defines the group association for the policy. You must have edit privileges for the group.\n* `name` - The unique name of the policy.\n* `api_version` - The specific version of the Cloudlets API.\n* `cloudlet_id` - A unique identifier that corresponds to a Cloudlets policy type. Enter `0` for Edge Redirector, `1` for Visitor Prioritization, `3` for Forward Rewrite, `4` for Request Control, `5` for API Prioritization, `6` for Audience Segmentation, `7` for Phased Release, `8` for Input Validation, or `9` for Application Load Balancer.\n* `cloudlet_code` - The two- or three- character code for the type of Cloudlet. Enter `ALB` for Application Load Balancer, `AP` for API Prioritization, `AS` for Audience Segmentation, `CD` for Phased Release, `ER` for Edge Redirector, `FR` for Forward Rewrite, `IG` for Request Control, `IV` for Input Validation, or `VP` for Visitor Prioritization.\n* `revision_id` - A unique identifier given to every policy version update.\n* `description` - The description of this specific policy.\n* `version_description` - The description of this specific policy version.\n* `rules_locked` - Whether editing `match_rules` for the Cloudlet policy version is blocked.\n* `match_rules`- A JSON structure that defines the rules for this policy.\n* `match_rule_format` - The format of the Cloudlet-specific `match_rules`.\n* `warnings` - A JSON encoded list of warnings.\n* `activations` - A list of of current policy activation information, including:\n  * `api_version` - The specific version of the Cloudlets API.\n  * `network` - The network, either `staging` or `prod` on which a property or a Cloudlets policy has been activated.\n  * `policy_info` - A list of Cloudlet policy information, including:\n      * `policy_id` - An integer identifier that is associated with all versions of a policy.\n      * `name` - The name of the policy.\n      * `version` - The version number of the policy.\n      * `status` - The activation status for the policy. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.\n      * `status_detail` - Information about the status of an activation operation. This field is not returned when it has no value.\n      * `activated_by` - The name of the user who activated the policy.\n      * `activation_date` - The date on which the policy was activated in milliseconds since epoch.\n  * `property_info` A list of Cloudlet property information, including:\n      * `name` - The name of the property.\n      * `version` - The version number of the activated property.\n      * `group_id` - Defines the group association for the policy or property. If returns `0`, the policy is not tied to a group and in effect appears in all groups for the account. You must have edit privileges for the group.\n      * `status` - The activation status for the property. Values include the following: `inactive` where the policy version has not been activated. No active property versions reference this policy. `active` where the policy version is currently active (published) and its associated property version is also active. `deactivated` where the policy version was previously activated but it has been superseded by a more recent activation of another policy version. `pending` where the policy version is proceeding through the activation workflow. `failed` where the policy version activation workflow has failed.\n      * `activated_by` - The name of the user who activated the property.\n      * `activation_date` - The date on which the property was activated in milliseconds since epoch.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsPolicy.\n",
                "properties": {
                    "policyId": {
                        "type": "integer",
                        "description": "(Required) An integer identifier that is associated with all versions of a policy.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version number of a policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "policyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsPolicy.\n",
                "properties": {
                    "activations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsPolicyActivation:getCloudletsPolicyActivation"
                        }
                    },
                    "apiVersion": {
                        "type": "string"
                    },
                    "cloudletCode": {
                        "type": "string"
                    },
                    "cloudletId": {
                        "type": "integer"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "matchRuleFormat": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policyId": {
                        "type": "integer"
                    },
                    "revisionId": {
                        "type": "integer"
                    },
                    "rulesLocked": {
                        "type": "boolean"
                    },
                    "version": {
                        "type": "integer"
                    },
                    "versionDescription": {
                        "type": "string"
                    },
                    "warnings": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "activations",
                    "apiVersion",
                    "cloudletCode",
                    "cloudletId",
                    "description",
                    "groupId",
                    "matchRuleFormat",
                    "matchRules",
                    "name",
                    "policyId",
                    "revisionId",
                    "rulesLocked",
                    "versionDescription",
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsRequestControlMatchRule:getCloudletsRequestControlMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsRequestControlMatchRule` data source to build a match rule JSON object for the Request Control Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Request Control Cloudlet:\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCloudletsRequestControlMatchRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCloudletsRequestControlMatchRule(GetCloudletsRequestControlMatchRuleArgs.builder()\n            .matchRules(            \n                GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()\n                    .allowDeny(\"allow\")\n                    .disabled(false)\n                    .end(2)\n                    .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()\n                        .caseSensitive(false)\n                        .checkIps(\"CONNECTING_IP XFF_HEADERS\")\n                        .matchOperator(\"contains\")\n                        .matchType(\"method\")\n                        .negate(false)\n                        .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .name(\"rule 1\")\n                    .start(1)\n                    .build(),\n                GetCloudletsRequestControlMatchRuleMatchRuleArgs.builder()\n                    .allowDeny(\"deny\")\n                    .disabled(true)\n                    .end(2)\n                    .matches(GetCloudletsRequestControlMatchRuleMatchRuleMatchArgs.builder()\n                        .caseSensitive(false)\n                        .checkIps(\"XFF_HEADERS\")\n                        .matchOperator(\"contains\")\n                        .matchType(\"header\")\n                        .negate(false)\n                        .objectMatchValue(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                        .build())\n                    .name(\"rule 2\")\n                    .start(1)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCloudletsRequestControlMatchRule\n      Arguments:\n        matchRules:\n          - allowDeny: allow\n            disabled: false\n            end: 2\n            matches:\n              - caseSensitive: false\n                checkIps: CONNECTING_IP XFF_HEADERS\n                matchOperator: contains\n                matchType: method\n                negate: false\n                objectMatchValue:\n                  - nameCaseSensitive: true\n                    nameHasWildcard: true\n                    type: simple\n                    value:\n                      - GET\n            name: rule 1\n            start: 1\n          - allowDeny: deny\n            disabled: true\n            end: 2\n            matches:\n              - caseSensitive: false\n                checkIps: XFF_HEADERS\n                matchOperator: contains\n                matchType: header\n                negate: false\n                objectMatchValue:\n                  - name: object 1\n                    nameCaseSensitive: true\n                    nameHasWildcard: true\n                    options:\n                      value:\n                        - text/html*\n                        - text/css*\n                        - application/x-javascript*\n                      valueCaseSensitive: true\n                      valueEscaped: true\n                      valueHasWildcard: true\n                    type: object\n            name: rule 2\n            start: 1\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsRequestControlMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsRequestControlMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsRequestControlMatchRuleMatchRule:getCloudletsRequestControlMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getCloudletsVisitorPrioritizationMatchRule:getCloudletsVisitorPrioritizationMatchRule": {
            "description": "Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.\n\nUse the `akamai.getCloudletsVisitorPrioritizationMatchRule` data source to build a match rule JSON object for the Visitor Prioritization Cloudlet.\n\n## Basic usage\n\nThis example returns the JSON-encoded rules for the Visitor Prioritization Cloudlet:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCloudletsVisitorPrioritizationMatchRule({\n    matchRules: [{\n        end: 1645037845,\n        matchUrl: \"example.com\",\n        matches: [{\n            caseSensitive: false,\n            checkIps: \"CONNECTING_IP\",\n            matchOperator: \"equals\",\n            matchType: \"protocol\",\n            matchValue: \"http\",\n            negate: false,\n        }],\n        name: \"rule\",\n        passThroughPercent: -1,\n        start: 1644865045,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cloudlets_visitor_prioritization_match_rule(match_rules=[akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleArgs(\n    end=1645037845,\n    match_url=\"example.com\",\n    matches=[akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchArgs(\n        case_sensitive=False,\n        check_ips=\"CONNECTING_IP\",\n        match_operator=\"equals\",\n        match_type=\"protocol\",\n        match_value=\"http\",\n        negate=False,\n    )],\n    name=\"rule\",\n    pass_through_percent=-1,\n    start=1644865045,\n)])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCloudletsVisitorPrioritizationMatchRule.Invoke(new()\n    {\n        MatchRules = new[]\n        {\n            new Akamai.Inputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleInputArgs\n            {\n                End = 1645037845,\n                MatchUrl = \"example.com\",\n                Matches = new[]\n                {\n                    new Akamai.Inputs.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatchInputArgs\n                    {\n                        CaseSensitive = false,\n                        CheckIps = \"CONNECTING_IP\",\n                        MatchOperator = \"equals\",\n                        MatchType = \"protocol\",\n                        MatchValue = \"http\",\n                        Negate = false,\n                    },\n                },\n                Name = \"rule\",\n                PassThroughPercent = -1,\n                Start = 1644865045,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCloudletsVisitorPrioritizationMatchRule(ctx, \u0026akamai.GetCloudletsVisitorPrioritizationMatchRuleArgs{\n\t\t\tMatchRules: []akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRule{\n\t\t\t\t{\n\t\t\t\t\tEnd:      pulumi.IntRef(1645037845),\n\t\t\t\t\tMatchUrl: pulumi.StringRef(\"example.com\"),\n\t\t\t\t\tMatches: []akamai.GetCloudletsVisitorPrioritizationMatchRuleMatchRuleMatch{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCaseSensitive: pulumi.BoolRef(false),\n\t\t\t\t\t\t\tCheckIps:      pulumi.StringRef(\"CONNECTING_IP\"),\n\t\t\t\t\t\t\tMatchOperator: pulumi.StringRef(\"equals\"),\n\t\t\t\t\t\t\tMatchType:     pulumi.StringRef(\"protocol\"),\n\t\t\t\t\t\t\tMatchValue:    pulumi.StringRef(\"http\"),\n\t\t\t\t\t\t\tNegate:        pulumi.BoolRef(false),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tName:               pulumi.StringRef(\"rule\"),\n\t\t\t\t\tPassThroughPercent: -1,\n\t\t\t\t\tStart:              pulumi.IntRef(1644865045),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `type` - The type of Cloudlet the rule is for.\n* `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudletsVisitorPrioritizationMatchRule.\n",
                "properties": {
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule"
                        },
                        "description": "(Optional) A list of Cloudlet-specific match rules for a policy.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCloudletsVisitorPrioritizationMatchRule.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "matchRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getCloudletsVisitorPrioritizationMatchRuleMatchRule:getCloudletsVisitorPrioritizationMatchRuleMatchRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getContract:getContract": {
            "description": "Use the `akamai.getContract` data source to find a contract ID.\n\n## Attributes reference\n\n* `id` - The contract's unique ID, including the `ctr_` prefix.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContract.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "Either the group ID or the group name that includes the contract. You can't use this argument with `group_id` and `group_name`.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The unique ID of the group containing the contract, including the  `grp_` prefix.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The name of the group containing the contract.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getContract.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "groupName",
                    "id"
                ]
            }
        },
        "akamai:index/getContracts:getContracts": {
            "description": "Use the `akamai.getContracts` data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn contracts associated with the EdgeGrid API client token currently used for authentication:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getContracts({});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_contracts()\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_example = Akamai.GetContracts.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = my_example.Apply(getContractsResult =\u003e getContractsResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetContracts(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getContracts();\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    fn::invoke:\n      Function: akamai:getContracts\n      Arguments: {}\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `contracts` - A list of supported contracts, with the following properties:\n  * `contract_id` - The contract's unique ID, including the `ctr_` prefix.\n  * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.\n",
            "outputs": {
                "description": "A collection of values returned by getContracts.\n",
                "properties": {
                    "contracts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getContractsContract:getContractsContract"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contracts",
                    "id"
                ]
            }
        },
        "akamai:index/getCpCode:getCpCode": {
            "inputs": {
                "description": "A collection of arguments for invoking getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The group's unique ID, including the `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the CP code.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "productIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "group",
                    "groupId",
                    "name",
                    "productIds",
                    "id"
                ]
            }
        },
        "akamai:index/getCpsCsr:getCpsCsr": {
            "description": "When setting up a third-party enrollment, use the `akamai.getCpsCsr` data source to retrieve the Certificate Signing Request (CSR) for that enrollment. When you create an enrollment in CPS, you also generate a PEM-formatted CSR. CPS encodes the CSR with a private key using either the RSA or the ECDSA algorithm. The CSR contains all the information the certificate authority (CA) needs to issue your certificate.\n\nIf you're using dual-stacked certificates, you'll see data for both ECDSA and RSA keys. \n\n\n## Basic usage\n\nThis example shows how to return CSR information for enrollment ID 12345:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCpsCsr({\n    enrollmentId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cps_csr(enrollment_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCpsCsr.Invoke(new()\n    {\n        EnrollmentId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCpsCsr(ctx, \u0026akamai.GetCpsCsrArgs{\n\t\t\tEnrollmentId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCpsCsrArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCpsCsr(GetCpsCsrArgs.builder()\n            .enrollmentId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCpsCsr\n      Arguments:\n        enrollmentId: 12345\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n  * `csr_rsa` - Returns CSR information for a certificate that uses the RSA algorithm. \n  * `csr_ecdsa` - Returns CSR information for a certificate that uses the ECDSA algorithm.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCpsCsr.\n",
                "properties": {
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier of the enrollment.\n"
                    }
                },
                "type": "object",
                "required": [
                    "enrollmentId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpsCsr.\n",
                "properties": {
                    "csrEcdsa": {
                        "type": "string"
                    },
                    "csrRsa": {
                        "type": "string"
                    },
                    "enrollmentId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "csrEcdsa",
                    "csrRsa",
                    "enrollmentId",
                    "id"
                ]
            }
        },
        "akamai:index/getCpsDeployments:getCpsDeployments": {
            "description": "Use the `akamai.getCpsDeployments` data source to retrieve deployed certificates for a specific enrollment. \n\nYou'll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.\n\n## Basic usage\n\nThis example shows how to return information about deployed certificates for enrollment ID 12345. \n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCpsDeployments({\n    enrollmentId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cps_deployments(enrollment_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCpsDeployments.Invoke(new()\n    {\n        EnrollmentId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCpsDeployments(ctx, \u0026akamai.GetCpsDeploymentsArgs{\n\t\t\tEnrollmentId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetCpsDeploymentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCpsDeployments(GetCpsDeploymentsArgs.builder()\n            .enrollmentId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCpsDeployments\n      Arguments:\n        enrollmentId: 12345\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `production_certificate_rsa` - The RSA certificate deployed on the production network. \n* `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.\n* `staging_certificate_rsa` - The RSA certificate deployed on the staging network.\n* `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.\n* `expiry_date` - The expiration date for the certificate in ISO-8601 format.\n* `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. \u003cbr\u003e For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. \u003cbr\u003e For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the `akamai.getCPSEnrollments` data source to view pending changes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCpsDeployments.\n",
                "properties": {
                    "enrollmentId": {
                        "type": "integer",
                        "description": "Unique identifier of the enrollment.\n"
                    }
                },
                "type": "object",
                "required": [
                    "enrollmentId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpsDeployments.\n",
                "properties": {
                    "autoRenewalStartTime": {
                        "type": "string"
                    },
                    "enrollmentId": {
                        "type": "integer"
                    },
                    "expiryDate": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "productionCertificateEcdsa": {
                        "type": "string"
                    },
                    "productionCertificateRsa": {
                        "type": "string"
                    },
                    "stagingCertificateEcdsa": {
                        "type": "string"
                    },
                    "stagingCertificateRsa": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "autoRenewalStartTime",
                    "enrollmentId",
                    "expiryDate",
                    "productionCertificateEcdsa",
                    "productionCertificateRsa",
                    "stagingCertificateEcdsa",
                    "stagingCertificateRsa",
                    "id"
                ]
            }
        },
        "akamai:index/getCpsWarnings:getCpsWarnings": {
            "description": "Use the `akamai.getCpsWarnings` data source to return a map of all possible pre- and post-verification warnings. The map includes both the ID needed to acknowledge a warning and a brief description of the issue. \n\nCPS produces warnings during enrollment creation or after a client uploads the certificate. CPS won't process a change until you acknowledge all warnings.\n\nYou can use the warning IDs returned by this data source to acknowledge or auto-approve warnings. The `akamai.CpsThirdPartyEnrollment` and `akamai.CpsUploadCertificate` resources include arguments to help you do this.\n\n## Basic usage\n\nThis example shows how to return a map of verification warnings:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getCpsWarnings({});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_cps_warnings()\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetCpsWarnings.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetCpsWarnings(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getCpsWarnings();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getCpsWarnings\n      Arguments: {}\n```\n\n## Attributes reference\n\nThis data source returns this attribute:\n\n  * `warnings` - Validation warnings for the current change you're making. Warnings display with an ID and a short description. Unless you auto-approve warnings, you need the ID to acknowledge the change. CPS won't process the change until you acknowledge these warnings.\n",
            "outputs": {
                "description": "A collection of values returned by getCpsWarnings.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "warnings": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getDatastreamActivationHistory:getDatastreamActivationHistory": {
            "description": "Use the `akamai.getDatastreamActivationHistory` data source to list detailed information about the activation status changes for all versions of a stream.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the activation history for a provided stream ID:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst ds = akamai.getDatastreamActivationHistory({\n    streamId: 12345,\n});\nexport const dsHistoryStreamId = ds.then(ds =\u003e ds.streamId);\nexport const dsHistoryActivations = ds.then(ds =\u003e ds.activations);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nds = akamai.get_datastream_activation_history(stream_id=12345)\npulumi.export(\"dsHistoryStreamId\", ds.stream_id)\npulumi.export(\"dsHistoryActivations\", ds.activations)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ds = Akamai.GetDatastreamActivationHistory.Invoke(new()\n    {\n        StreamId = 12345,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dsHistoryStreamId\"] = ds.Apply(getDatastreamActivationHistoryResult =\u003e getDatastreamActivationHistoryResult.StreamId),\n        [\"dsHistoryActivations\"] = ds.Apply(getDatastreamActivationHistoryResult =\u003e getDatastreamActivationHistoryResult.Activations),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tds, err := akamai.GetDatastreamActivationHistory(ctx, \u0026akamai.GetDatastreamActivationHistoryArgs{\n\t\t\tStreamId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"dsHistoryStreamId\", ds.StreamId)\n\t\tctx.Export(\"dsHistoryActivations\", ds.Activations)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetDatastreamActivationHistoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ds = AkamaiFunctions.getDatastreamActivationHistory(GetDatastreamActivationHistoryArgs.builder()\n            .streamId(12345)\n            .build());\n\n        ctx.export(\"dsHistoryStreamId\", ds.applyValue(getDatastreamActivationHistoryResult -\u003e getDatastreamActivationHistoryResult.streamId()));\n        ctx.export(\"dsHistoryActivations\", ds.applyValue(getDatastreamActivationHistoryResult -\u003e getDatastreamActivationHistoryResult.activations()));\n    }\n}\n```\n```yaml\nvariables:\n  ds:\n    fn::invoke:\n      Function: akamai:getDatastreamActivationHistory\n      Arguments:\n        streamId: 12345\noutputs:\n  dsHistoryStreamId: ${ds.streamId}\n  dsHistoryActivations: ${ds.activations}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `activations` - Detailed information about an activation status change for a version of a stream, including:\n  * `created_by` - The user who activated or deactivated the stream.\n  * `created_date` - The date and time of an activation status change.\n  * `stream_id` - A stream's unique identifier.\n  * `stream_version_id` - A stream version's unique identifier.\n  * `is_active` -\tWhether the version of the stream is active.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastreamActivationHistory.\n",
                "properties": {
                    "streamId": {
                        "type": "integer",
                        "description": "(Required) A stream's unique identifier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "streamId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastreamActivationHistory.\n",
                "properties": {
                    "activations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getDatastreamActivationHistoryActivation:getDatastreamActivationHistoryActivation"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "streamId": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "activations",
                    "streamId",
                    "id"
                ]
            }
        },
        "akamai:index/getDatastreamDatasetFields:getDatastreamDatasetFields": {
            "description": "Use the `akamai.getDatastreamDatasetFields` data source to list groups of data set fields available in the template.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns data set fields for a default template:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst fields = akamai.getDatastreamDatasetFields({});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nfields = akamai.get_datastream_dataset_fields()\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fields = Akamai.GetDatastreamDatasetFields.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetDatastreamDatasetFields(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetDatastreamDatasetFieldsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fields = AkamaiFunctions.getDatastreamDatasetFields();\n\n    }\n}\n```\n```yaml\nvariables:\n  fields:\n    fn::invoke:\n      Function: akamai:getDatastreamDatasetFields\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `fields` - A group of data set fields available in a template, including:\n  * `dataset_group_name` - The name of the data set group.\n  * `dataset_group_description` - Additional information about the data set group.\n  * `dataset_fields` - A list of data set fields available within the data set group, including:\n      * `dataset_field_description` - Additional information about the data set field.\n      * `dataset_field_id` - Unique identifier for the field.\n      * `dataset_field_json_key` - The JSON key for the field in a log line.\n      * `dataset_field_name` - The name of the data set field.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastreamDatasetFields.\n",
                "properties": {
                    "templateName": {
                        "type": "string",
                        "description": "(Optional) The name of the data set template you use in your stream configuration. Currently, `EDGE_LOGS` is the only available data set template and the default value for this argument.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatastreamDatasetFields.\n",
                "properties": {
                    "fields": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getDatastreamDatasetFieldsField:getDatastreamDatasetFieldsField"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "templateName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "fields",
                    "id"
                ]
            }
        },
        "akamai:index/getDatastreams:getDatastreams": {
            "description": "Use the `akamai.getDatastreams` data source to list details about the DataStream configuration.\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `streams` - Returns the latest versions of the stream configurations for all groups within in your account. You can use the `group_id` parameter to view the latest versions of all configurations in a specific group. \n  * `activation_status` - The activation status of the stream. These are possible values: `ACTIVATED`, `DEACTIVATED`, `ACTIVATING`, `DEACTIVATING`, or `INACTIVE`. See the [Activate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-activate) and [Deactivate a stream](https://techdocs.akamai.com/datastream2/reference/put-stream-deactivate) operations.\n  * `archived` - Whether the stream is archived.\n  * `connectors` - The connector where the stream sends logs. \n  * `contract_id` - Identifies the contract that the stream is associated with.\n  * `created_by` - The user who created the stream.\n  * `created_date` - The date and time when the stream was created in this format: `14-07-2020 07:07:40 GMT`.\n  * `current_version_id` - Identifies the current version of the stream.\n  * `errors` - Objects that may indicate stream failure errors. Learn more about [Errors](https://techdocs.akamai.com/datastream2/reference/errors).\n    * `detail` - A message informing about the status of the failed stream.\n    * `title` - A descriptive label for the type of error.\n    * `type` - Identifies the error type, either `ACTIVATION_ERROR` or `UNEXPECTED_SYSTEM_ERROR`. In case of these errors, contact support for assistance before continuing. \n  * `group_id` - Identifies the group where the stream is created. \n  * `group_name` - The group name where the stream is created. \n  * `properties` - List of properties associated with the stream. \n    * `property_id` - The identifier of the property. \n    * `property_name` - The descriptive label for the property. \n  * `stream_id` - A stream's unique identifier.\n  * `stream_name` - The name of the stream. \n  * `stream_type_name` - Specifies the type of the data stream. `Logs - Raw` is the only stream type name currently available. \n  * `stream_version_id` - A stream version's unique identifier.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastreams.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "Unique identifier of the group that can access the product.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatastreams.\n",
                "properties": {
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "streams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getDatastreamsStream:getDatastreamsStream"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "streams",
                    "id"
                ]
            }
        },
        "akamai:index/getDnsRecordSet:getDnsRecordSet": {
            "inputs": {
                "description": "A collection of arguments for invoking getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "recordType",
                    "zone"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDnsRecordSet.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rdatas": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "recordType": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "host",
                    "rdatas",
                    "recordType",
                    "zone",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorker:getEdgeWorker": {
            "description": "Use the `akamai.EdgeWorker` data source to get an EdgeWorker for a given EdgeWorker ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the resource tier fields for the selected EdgeWorker ID:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst test = akamai.getEdgeWorker({\n    edgeworkerId: 3,\n    localBundle: \"test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest = akamai.get_edge_worker(edgeworker_id=3,\n    local_bundle=\"test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Akamai.GetEdgeWorker.Invoke(new()\n    {\n        EdgeworkerId = 3,\n        LocalBundle = \"test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.LookupEdgeWorker(ctx, \u0026akamai.LookupEdgeWorkerArgs{\n\t\t\tEdgeworkerId: 3,\n\t\t\tLocalBundle:  pulumi.StringRef(\"test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetEdgeWorkerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = AkamaiFunctions.getEdgeWorker(GetEdgeWorkerArgs.builder()\n            .edgeworkerId(3)\n            .localBundle(\"test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: akamai:getEdgeWorker\n      Arguments:\n        edgeworkerId: 3\n        localBundle: test_tmp/TestDataEdgeWorkersEdgeWorker/bundles/edgeworker_one_warning.tgz\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `name` - The EdgeWorker name.\n* `group_id` - Defines the group association for the EdgeWorker.\n* `resource_tier_id` - The unique identifier of a resource tier.\n* `local_bundle_hash` - The local bundle hash for the EdgeWorker. It's used to identify content changes for the bundle.\n* `version` - The bundle version.\n* `warnings` - The list of warnings returned by EdgeWorker validation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorker.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "The unique identifier of the EdgeWorker.\n"
                    },
                    "localBundle": {
                        "type": "string",
                        "description": "The path where the EdgeWorkers `.tgz` code bundle will be stored.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorker.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "localBundle": {
                        "type": "string"
                    },
                    "localBundleHash": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourceTierId": {
                        "type": "integer"
                    },
                    "version": {
                        "type": "string"
                    },
                    "warnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId",
                    "groupId",
                    "localBundleHash",
                    "name",
                    "resourceTierId",
                    "version",
                    "warnings",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorkerActivation:getEdgeWorkerActivation": {
            "description": "Use the `akamai.getEdgeWorkerActivation` data source to fetch the latest activation for a given EdgeWorker ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the latest activation on the staging network:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst test = akamai.getEdgeWorkerActivation({\n    edgeworkerId: 1,\n    network: \"STAGING\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntest = akamai.get_edge_worker_activation(edgeworker_id=1,\n    network=\"STAGING\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Akamai.GetEdgeWorkerActivation.Invoke(new()\n    {\n        EdgeworkerId = 1,\n        Network = \"STAGING\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetEdgeWorkerActivation(ctx, \u0026akamai.GetEdgeWorkerActivationArgs{\n\t\t\tEdgeworkerId: 1,\n\t\t\tNetwork:      \"STAGING\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetEdgeWorkerActivationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = AkamaiFunctions.getEdgeWorkerActivation(GetEdgeWorkerActivationArgs.builder()\n            .edgeworkerId(1)\n            .network(\"STAGING\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: akamai:getEdgeWorkerActivation\n      Arguments:\n        edgeworkerId: 1\n        network: STAGING\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `activation_id` - The unique identifier of the activation.\n* `version` - The EdgeWorker version of the latest activation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorkerActivation.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "The unique identifier of the EdgeWorker.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "The network from where the activation information will be fetched.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId",
                    "network"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorkerActivation.\n",
                "properties": {
                    "activationId": {
                        "type": "integer"
                    },
                    "edgeworkerId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "network": {
                        "type": "string"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "activationId",
                    "edgeworkerId",
                    "network",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorkersPropertyRules:getEdgeWorkersPropertyRules": {
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorkersPropertyRules.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer",
                        "description": "Unique identifier of an EdgeWorker ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorkersPropertyRules.\n",
                "properties": {
                    "edgeworkerId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "edgeworkerId",
                    "json",
                    "id"
                ]
            }
        },
        "akamai:index/getEdgeWorkersResourceTier:getEdgeWorkersResourceTier": {
            "description": "Use the `akamai.getEdgeWorkersResourceTier` data source to list the available resource tiers for a specific contract ID. The resource tier defines the resource consumption [limits](https://techdocs.akamai.com/edgeworkers/docs/resource-tier-limitations) for an EdgeWorker ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the resource tier fields for an EdgeWorker ID:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getEdgeWorkersResourceTier({\n    contractId: \"1-ABC\",\n    resourceTierName: \"Basic Compute\",\n});\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_edge_workers_resource_tier(contract_id=\"1-ABC\",\n    resource_tier_name=\"Basic Compute\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetEdgeWorkersResourceTier.Invoke(new()\n    {\n        ContractId = \"1-ABC\",\n        ResourceTierName = \"Basic Compute\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := akamai.GetEdgeWorkersResourceTier(ctx, \u0026akamai.GetEdgeWorkersResourceTierArgs{\n\t\t\tContractId:       \"1-ABC\",\n\t\t\tResourceTierName: \"Basic Compute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetEdgeWorkersResourceTierArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getEdgeWorkersResourceTier(GetEdgeWorkersResourceTierArgs.builder()\n            .contractId(\"1-ABC\")\n            .resourceTierName(\"Basic Compute\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getEdgeWorkersResourceTier\n      Arguments:\n        contractId: 1-ABC\n        resourceTierName: Basic Compute\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `resource_tier_id` - Unique identifier of the resource tier.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEdgeWorkersResourceTier.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "Unique identifier of a contract.\n"
                    },
                    "resourceTierName": {
                        "type": "string",
                        "description": "Unique name of the resource tier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "resourceTierName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEdgeWorkersResourceTier.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "resourceTierId": {
                        "type": "integer"
                    },
                    "resourceTierName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "resourceTierId",
                    "resourceTierName",
                    "id"
                ]
            }
        },
        "akamai:index/getGroup:getGroup": {
            "description": "Use the `akamai.getGroup` data source to get a group by name.\n\nEach account features a hierarchy of groups, which control access to your\nAkamai configurations and help consolidate reporting functions, typically\nmapping to an organizational hierarchy. Using either Control Center or the\n[Identity Management: User Administration API](https://techdocs.akamai.com/iam-api/reference/api),\naccount administrators can assign properties to specific groups, each with\nits own set of users and accompanying roles.\n\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `id` - The group's unique ID, including the `grp_` prefix.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupName": {
                        "type": "string",
                        "description": "The group name.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Replaced by `group_name`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"name\" has been deprecated."
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "groupName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "deprecationMessage": "The setting \"name\" has been deprecated."
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "groupName",
                    "name",
                    "id"
                ]
            }
        },
        "akamai:index/getGroups:getGroups": {
            "description": "Use the `akamai.getGroups` data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n## Basic usage\n\nReturn groups associated with the EdgeGrid API client token you're using:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getGroups({});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_groups()\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_example = Akamai.GetGroups.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = my_example.Apply(getGroupsResult =\u003e getGroupsResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetGroups(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getGroups();\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    fn::invoke:\n      Function: akamai:getGroups\n      Arguments: {}\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `groups` - A list of supported groups, with the following attributes:\n  * `group_id` - A group's unique ID, including the `grp_` prefix.\n  * `group_name` - The name of the group.\n  * `parent_group_id` - The ID of the parent group, if applicable.\n  * `contract_ids` - An array of strings listing the contract IDs for each group.\n",
            "outputs": {
                "description": "A collection of values returned by getGroups.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getGroupsGroup:getGroupsGroup"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "id"
                ]
            }
        },
        "akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter": {
            "description": "Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.\n\n## Attributes reference\n\nThis data source supports these attributes:\n\n* `id` - The data resource ID. Enter in this format: `\u003cdomain\u003e:default_datacenter:\u003cdatacenter_id\u003e`.\n* `datacenter_id` - The default data center ID.\n* `nickname` - The default data center nickname.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer",
                        "description": "The default is `5400`.\n"
                    },
                    "domain": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "domain"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer"
                    },
                    "datacenterId": {
                        "type": "integer"
                    },
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nickname": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "domain",
                    "nickname",
                    "id"
                ]
            }
        },
        "akamai:index/getIamContactTypes:getIamContactTypes": {
            "description": "Use `akamai.getIamContactTypes` to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user's contact type.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst contactTypes = akamai.getIamContactTypes({});\nexport const supportedContactTypes = contactTypes;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncontact_types = akamai.get_iam_contact_types()\npulumi.export(\"supportedContactTypes\", contact_types)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var contactTypes = Akamai.GetIamContactTypes.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"supportedContactTypes\"] = contactTypes.Apply(getIamContactTypesResult =\u003e getIamContactTypesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcontactTypes, err := akamai.GetIamContactTypes(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedContactTypes\", contactTypes)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var contactTypes = AkamaiFunctions.getIamContactTypes();\n\n        ctx.export(\"supportedContactTypes\", contactTypes.applyValue(getIamContactTypesResult -\u003e getIamContactTypesResult));\n    }\n}\n```\n```yaml\nvariables:\n  contactTypes:\n    fn::invoke:\n      Function: akamai:getIamContactTypes\n      Arguments: {}\noutputs:\n  supportedContactTypes: ${contactTypes}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `contact_types` — A list of contact types.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)\n",
            "outputs": {
                "description": "A collection of values returned by getIamContactTypes.\n",
                "properties": {
                    "contactTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contactTypes",
                    "id"
                ]
            }
        },
        "akamai:index/getIamCountries:getIamCountries": {
            "description": "Use `akamai.getIamCountries` to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user's country information.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst countries = akamai.getIamCountries({});\nexport const supportedCountries = countries;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ncountries = akamai.get_iam_countries()\npulumi.export(\"supportedCountries\", countries)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var countries = Akamai.GetIamCountries.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"supportedCountries\"] = countries.Apply(getIamCountriesResult =\u003e getIamCountriesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcountries, err := akamai.GetIamCountries(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedCountries\", countries)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var countries = AkamaiFunctions.getIamCountries();\n\n        ctx.export(\"supportedCountries\", countries.applyValue(getIamCountriesResult -\u003e getIamCountriesResult));\n    }\n}\n```\n```yaml\nvariables:\n  countries:\n    fn::invoke:\n      Function: akamai:getIamCountries\n      Arguments: {}\noutputs:\n  supportedCountries: ${countries}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `countries` — A list of countries.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)\n",
            "outputs": {
                "description": "A collection of values returned by getIamCountries.\n",
                "properties": {
                    "countries": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "countries",
                    "id"
                ]
            }
        },
        "akamai:index/getIamGrantableRoles:getIamGrantableRoles": {
            "description": "List which grantable roles you can include in a new custom role or add to an existing custom role.\n\n## Basic usage\n\nThis example returns the available roles to grant to users:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getIamGrantableRoles({});\nexport const akaGrantableRolesCount = data.akamai_iam_grantable_roles.test.grantable_roles.length;\nexport const akaGrantableRoles = data.akamai_iam_grantable_roles.test;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_iam_grantable_roles()\npulumi.export(\"akaGrantableRolesCount\", len(data[\"akamai_iam_grantable_roles\"][\"test\"][\"grantable_roles\"]))\npulumi.export(\"akaGrantableRoles\", data[\"akamai_iam_grantable_roles\"][\"test\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetIamGrantableRoles.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"akaGrantableRolesCount\"] = data.Akamai_iam_grantable_roles.Test.Grantable_roles.Length,\n        [\"akaGrantableRoles\"] = data.Akamai_iam_grantable_roles.Test,\n    };\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getIamGrantableRoles();\n\n        ctx.export(\"akaGrantableRolesCount\", data.akamai_iam_grantable_roles().test().grantable_roles().length());\n        ctx.export(\"akaGrantableRoles\", data.akamai_iam_grantable_roles().test());\n    }\n}\n```\n\n## Attributes reference\n\nThis resource returns this attribute:\n\n* `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.\n  * `granted_role_id` - Granted role ID.\n  * `name` - Granted role name.\n  * `description` - Granted role description.\n",
            "outputs": {
                "description": "A collection of values returned by getIamGrantableRoles.\n",
                "properties": {
                    "grantableRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamGrantableRolesGrantableRole:getIamGrantableRolesGrantableRole"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "grantableRoles",
                    "id"
                ]
            }
        },
        "akamai:index/getIamRoles:getIamRoles": {
            "description": "Use `akamai.getIamRoles` to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user's auth grants.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-roles = akamai.getIamRoles({});\nexport const roles = my_roles;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_roles = akamai.get_iam_roles()\npulumi.export(\"roles\", my_roles)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_roles = Akamai.GetIamRoles.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"roles\"] = my_roles.Apply(getIamRolesResult =\u003e getIamRolesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_roles, err := akamai.GetIamRoles(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"roles\", my_roles)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-roles = AkamaiFunctions.getIamRoles();\n\n        ctx.export(\"roles\", my_roles);\n    }\n}\n```\n```yaml\nvariables:\n  my-roles:\n    fn::invoke:\n      Function: akamai:getIamRoles\n      Arguments: {}\noutputs:\n  roles: ${[\"my-roles\"]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `roles` — A list of roles.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)\n",
            "outputs": {
                "description": "A collection of values returned by getIamRoles.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamRolesRole:getIamRolesRole"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "roles",
                    "id"
                ]
            }
        },
        "akamai:index/getIamStates:getIamStates": {
            "description": "Use `akamai.getIamStates` to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don't know a user's state. Administrators use this data source to set a user's state.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst states = akamai.getIamStates({\n    country: \"canada\",\n});\nexport const supportedStates = states;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nstates = akamai.get_iam_states(country=\"canada\")\npulumi.export(\"supportedStates\", states)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var states = Akamai.GetIamStates.Invoke(new()\n    {\n        Country = \"canada\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"supportedStates\"] = states.Apply(getIamStatesResult =\u003e getIamStatesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tstates, err := akamai.GetIamStates(ctx, \u0026akamai.GetIamStatesArgs{\n\t\t\tCountry: \"canada\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedStates\", states)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetIamStatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var states = AkamaiFunctions.getIamStates(GetIamStatesArgs.builder()\n            .country(\"canada\")\n            .build());\n\n        ctx.export(\"supportedStates\", states.applyValue(getIamStatesResult -\u003e getIamStatesResult));\n    }\n}\n```\n```yaml\nvariables:\n  states:\n    fn::invoke:\n      Function: akamai:getIamStates\n      Arguments:\n        country: canada\noutputs:\n  supportedStates: ${states}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `states` — A list of states.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIamStates.\n",
                "properties": {
                    "country": {
                        "type": "string",
                        "description": "— (required, string) Specifies USA or Canada.\n"
                    }
                },
                "type": "object",
                "required": [
                    "country"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIamStates.\n",
                "properties": {
                    "country": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "states": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "country",
                    "states",
                    "id"
                ]
            }
        },
        "akamai:index/getIamSupportedLangs:getIamSupportedLangs": {
            "description": "Use `akamai.getIamSupportedLangs` to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst supportedLangs = akamai.getIamSupportedLangs({});\nexport const supportedSupportedLangs = supportedLangs;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nsupported_langs = akamai.get_iam_supported_langs()\npulumi.export(\"supportedSupportedLangs\", supported_langs)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var supportedLangs = Akamai.GetIamSupportedLangs.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"supportedSupportedLangs\"] = supportedLangs.Apply(getIamSupportedLangsResult =\u003e getIamSupportedLangsResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsupportedLangs, err := akamai.GetIamSupportedLangs(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedSupportedLangs\", supportedLangs)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var supportedLangs = AkamaiFunctions.getIamSupportedLangs();\n\n        ctx.export(\"supportedSupportedLangs\", supportedLangs.applyValue(getIamSupportedLangsResult -\u003e getIamSupportedLangsResult));\n    }\n}\n```\n```yaml\nvariables:\n  supportedLangs:\n    fn::invoke:\n      Function: akamai:getIamSupportedLangs\n      Arguments: {}\noutputs:\n  supportedSupportedLangs: ${supportedLangs}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `languages` — Languages supported by Akamai\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)\n",
            "outputs": {
                "description": "A collection of values returned by getIamSupportedLangs.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "languages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "languages",
                    "id"
                ]
            }
        },
        "akamai:index/getIamTimeoutPolicies:getIamTimeoutPolicies": {
            "description": "Use `akamai.getIamTimeoutPolicies` to list all the possible session timeout policies that Akamai supports. Use the values from this data source to set the session timeout for a user. The name for each timeout period is in minutes, and the time value is in seconds.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst timeoutPolicies = akamai.getIamTimeoutPolicies({});\nexport const supportedTimeoutPolicies = timeoutPolicies;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\ntimeout_policies = akamai.get_iam_timeout_policies()\npulumi.export(\"supportedTimeoutPolicies\", timeout_policies)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var timeoutPolicies = Akamai.GetIamTimeoutPolicies.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"supportedTimeoutPolicies\"] = timeoutPolicies.Apply(getIamTimeoutPoliciesResult =\u003e getIamTimeoutPoliciesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttimeoutPolicies, err := akamai.GetIamTimeoutPolicies(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"supportedTimeoutPolicies\", timeoutPolicies)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var timeoutPolicies = AkamaiFunctions.getIamTimeoutPolicies();\n\n        ctx.export(\"supportedTimeoutPolicies\", timeoutPolicies.applyValue(getIamTimeoutPoliciesResult -\u003e getIamTimeoutPoliciesResult));\n    }\n}\n```\n```yaml\nvariables:\n  timeoutPolicies:\n    fn::invoke:\n      Function: akamai:getIamTimeoutPolicies\n      Arguments: {}\noutputs:\n  supportedTimeoutPolicies: ${timeoutPolicies}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThese attributes are returned:\n\n* `policies` — A map of session timeout policy names to their value in seconds.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timeout-policies)\n",
            "outputs": {
                "description": "A collection of values returned by getIamTimeoutPolicies.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "policies": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "policies",
                    "id"
                ]
            }
        },
        "akamai:index/getIamTimezones:getIamTimezones": {
            "description": "Use `akamai.getIamTimezones` to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user's time zone. The default time zone is GMT.\n\n## Attributes reference\n\nThese attributes are returned:\n\n* `timezones` — Supported timezones.\n  * `timezone` - The time zone ID.\n  * `description` - The description of a time zone, including the GMT +/-.\n  * `offset` - The time zone offset from GMT.\n  * `posix` - The time zone posix.\n\n[API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)\n",
            "outputs": {
                "description": "A collection of values returned by getIamTimezones.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "timezones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getIamTimezonesTimezone:getIamTimezonesTimezone"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "timezones",
                    "id"
                ]
            }
        },
        "akamai:index/getNetworkLists:getNetworkLists": {
            "description": "Use the `akamai.getNetworkLists` data source to retrieve information about the available network lists,\noptionally filtered by list type or based on a search string. The information available is described in\n[List network lists](https://techdocs.akamai.com/network-lists/reference/get-network-lists).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst networkLists = akamai.getNetworkLists({});\nexport const networkListsText = networkLists.then(networkLists =\u003e networkLists.outputText);\nexport const networkListsJson = networkLists.then(networkLists =\u003e networkLists.json);\nexport const networkListsList = networkLists.then(networkLists =\u003e networkLists.lists);\nconst networkListsFilter = akamai.getNetworkLists({\n    name: \"Test Whitelist\",\n    type: \"IP\",\n});\nexport const networkListsFilterText = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.outputText);\nexport const networkListsFilterJson = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.json);\nexport const networkListsFilterList = networkListsFilter.then(networkListsFilter =\u003e networkListsFilter.lists);\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nnetwork_lists = akamai.get_network_lists()\npulumi.export(\"networkListsText\", network_lists.output_text)\npulumi.export(\"networkListsJson\", network_lists.json)\npulumi.export(\"networkListsList\", network_lists.lists)\nnetwork_lists_filter = akamai.get_network_lists(name=\"Test Whitelist\",\n    type=\"IP\")\npulumi.export(\"networkListsFilterText\", network_lists_filter.output_text)\npulumi.export(\"networkListsFilterJson\", network_lists_filter.json)\npulumi.export(\"networkListsFilterList\", network_lists_filter.lists)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkLists = Akamai.GetNetworkLists.Invoke();\n\n    var networkListsFilter = Akamai.GetNetworkLists.Invoke(new()\n    {\n        Name = \"Test Whitelist\",\n        Type = \"IP\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"networkListsText\"] = networkLists.Apply(getNetworkListsResult =\u003e getNetworkListsResult.OutputText),\n        [\"networkListsJson\"] = networkLists.Apply(getNetworkListsResult =\u003e getNetworkListsResult.Json),\n        [\"networkListsList\"] = networkLists.Apply(getNetworkListsResult =\u003e getNetworkListsResult.Lists),\n        [\"networkListsFilterText\"] = networkListsFilter.Apply(getNetworkListsResult =\u003e getNetworkListsResult.OutputText),\n        [\"networkListsFilterJson\"] = networkListsFilter.Apply(getNetworkListsResult =\u003e getNetworkListsResult.Json),\n        [\"networkListsFilterList\"] = networkListsFilter.Apply(getNetworkListsResult =\u003e getNetworkListsResult.Lists),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkLists, err := akamai.GetNetworkLists(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"networkListsText\", networkLists.OutputText)\n\t\tctx.Export(\"networkListsJson\", networkLists.Json)\n\t\tctx.Export(\"networkListsList\", networkLists.Lists)\n\t\tnetworkListsFilter, err := akamai.GetNetworkLists(ctx, \u0026akamai.GetNetworkListsArgs{\n\t\t\tName: pulumi.StringRef(\"Test Whitelist\"),\n\t\t\tType: pulumi.StringRef(\"IP\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"networkListsFilterText\", networkListsFilter.OutputText)\n\t\tctx.Export(\"networkListsFilterJson\", networkListsFilter.Json)\n\t\tctx.Export(\"networkListsFilterList\", networkListsFilter.Lists)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetNetworkListsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkLists = AkamaiFunctions.getNetworkLists();\n\n        ctx.export(\"networkListsText\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.outputText()));\n        ctx.export(\"networkListsJson\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.json()));\n        ctx.export(\"networkListsList\", networkLists.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()));\n        final var networkListsFilter = AkamaiFunctions.getNetworkLists(GetNetworkListsArgs.builder()\n            .name(\"Test Whitelist\")\n            .type(\"IP\")\n            .build());\n\n        ctx.export(\"networkListsFilterText\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.outputText()));\n        ctx.export(\"networkListsFilterJson\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.json()));\n        ctx.export(\"networkListsFilterList\", networkListsFilter.applyValue(getNetworkListsResult -\u003e getNetworkListsResult.lists()));\n    }\n}\n```\n```yaml\nvariables:\n  networkLists:\n    fn::invoke:\n      Function: akamai:getNetworkLists\n      Arguments: {}\n  networkListsFilter:\n    fn::invoke:\n      Function: akamai:getNetworkLists\n      Arguments:\n        name: Test Whitelist\n        type: IP\noutputs:\n  # tabular data of id, name, type, elementCount, syncPoint, readonly\n  networkListsText: ${networkLists.outputText}\n  networkListsJson: ${networkLists.json}\n  # custom output of network list ids\n  networkListsList: ${networkLists.lists}\n  networkListsFilterText: ${networkListsFilter.outputText}\n  networkListsFilterJson: ${networkListsFilter.json}\n  # custom output of single network list id\n  networkListsFilterList: ${networkListsFilter.lists}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkLists.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of a specific network list to retrieve. If not supplied, information about all network\nlists will be returned.\n"
                    },
                    "networkListId": {
                        "type": "string",
                        "description": "The ID of a specific network list to retrieve.\nIf not supplied, information about all network lists will be returned.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of network lists to be retrieved; must be either \"IP\" or \"GEO\". If not supplied,\ninformation about both types will be returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkLists.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "integer"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "A JSON-formatted list of information about the specified network list(s).\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list containing the IDs of the specified network lists(s).\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkListId": {
                        "type": "string"
                    },
                    "outputText": {
                        "type": "string",
                        "description": "A tabular display showing the network list information.\n"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "json",
                    "lists",
                    "networkListId",
                    "outputText",
                    "id"
                ]
            }
        },
        "akamai:index/getProperties:getProperties": {
            "description": "Use the `akamai.getProperties` data source to query and retrieve the list of properties for a group and contract\nbased on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn properties associated with the EdgeGrid API client token currently used for authentication:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const myPropertyList = data.akamai_properties.example;\n```\n```python\nimport pulumi\n\npulumi.export(\"myPropertyList\", data[\"akamai_properties\"][\"example\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myPropertyList\"] = data.Akamai_properties.Example,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"myPropertyList\", data.Akamai_properties.Example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"myPropertyList\", data.akamai_properties().example());\n    }\n}\n```\n```yaml\noutputs:\n  myPropertyList: ${data.akamai_properties.example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `properties` - A list of properties available for the contract and group IDs provided.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperties.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperties.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertiesProperty:getPropertiesProperty"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "properties",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertiesSearch:getPropertiesSearch": {
            "description": "Use the `akamai.getPropertiesSearch` data source to retrieve the list of properties matching a specific hostname, edge hostname or property name based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nReturn properties associated with the EdgeGrid API client token currently used for authentication:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const myPropertyList = data.akamai_properties_search.example;\n```\n```python\nimport pulumi\n\npulumi.export(\"myPropertyList\", data[\"akamai_properties_search\"][\"example\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myPropertyList\"] = data.Akamai_properties_search.Example,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"myPropertyList\", data.Akamai_properties_search.Example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"myPropertyList\", data.akamai_properties_search().example());\n    }\n}\n```\n```yaml\noutputs:\n  myPropertyList: ${data.akamai_properties_search.example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `properties` - A list of property version matching the given criteria.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertiesSearch.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key used for search. Valid values are:\n* **hostname**\n* **edgeHostname**\n* **propertyName**\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "(Required) Value to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "value"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertiesSearch.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertiesSearchProperty:getPropertiesSearchProperty"
                        }
                    },
                    "value": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "properties",
                    "value",
                    "id"
                ]
            }
        },
        "akamai:index/getProperty:getProperty": {
            "description": "Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the property ID and rule tree based on the property name and optional version argument:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getProperty({\n    name: \"terraform-demo\",\n    version: 1,\n});\nexport const myPropertyID = example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_property(name=\"terraform-demo\",\n    version=1)\npulumi.export(\"myPropertyID\", example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetProperty.Invoke(new()\n    {\n        Name = \"terraform-demo\",\n        Version = 1,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myPropertyID\"] = example.Apply(getPropertyResult =\u003e getPropertyResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.LookupProperty(ctx, \u0026akamai.LookupPropertyArgs{\n\t\t\tName:    \"terraform-demo\",\n\t\t\tVersion: pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myPropertyID\", example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()\n            .name(\"terraform-demo\")\n            .version(\"1\")\n            .build());\n\n        ctx.export(\"myPropertyID\", example.applyValue(getPropertyResult -\u003e getPropertyResult));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getProperty\n      Arguments:\n        name: terraform-demo\n        version: '1'\noutputs:\n  myPropertyID: ${example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `property_ID` - A property's unique identifier, including the `prp_` prefix.\n* `rules` - A JSON-encoded rule tree for a given property.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperty.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "(Required) The property name.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version of the property whose ID you want to list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperty.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rules",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyHostnames:getPropertyHostnames": {
            "description": "Use the `akamai.getPropertyHostnames` data source to query and retrieve hostnames and their certificate statuses for an existing property. This data source lets you search across the contracts and groups you have access to.\n\n## Basic usage\n\nThis example returns the property's hostnames based on the selected contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const propertyHostnames = data.akamai_property_hostnames[\"my-example\"].hostnames;\n```\n```python\nimport pulumi\n\npulumi.export(\"propertyHostnames\", data[\"akamai_property_hostnames\"][\"my-example\"][\"hostnames\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyHostnames\"] = data.Akamai_property_hostnames.My_example.Hostnames,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"propertyHostnames\", data.Akamai_property_hostnames.MyExample.Hostnames)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"propertyHostnames\", data.akamai_property_hostnames().my-example().hostnames());\n    }\n}\n```\n```yaml\noutputs:\n  propertyHostnames: ${data.akamai_property_hostnames\"my-example\"[%!s(MISSING)].hostnames}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `hostnames` - A list of hostnames for the property, including:\n  * `cname_type` - A string containing the hostname's cname type value.\n  * `edge_hostname_id` - The edge hostname's unique ID, including the `ehn_` prefix.\n  * `cname_from` - A string containing the original origin's hostname.\n  * `cname_to` - A string containing the hostname for edge content.\n  * `cert_provisioning_type` - The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the Certificate Provisioning System (CPS), or `DEFAULT` for certificates provisioned automatically.\n  * `cert_status` - If applicable, this shows a list of certificate statuses, including:\n    * `target` - The destination part of the CNAME record used to validate the certificate's domain.\n    * `hostname` - The hostname part of the CNAME record used to validate the certificate's domain.\n    * `production_status` - A string containing the status of the certificate deployment on the production network.\n    * `staging_status` - A string containing the status of the certificate deployment on the staging network.\n\n## Domain validation for DEFAULT certificates\n\nIf your `cert_provisioning_type = \"DEFAULT\"` and the value for `cert_status.production_status` or `cert_status.staging_status` is either `PENDING`, `EXPIRING_SOON_NEEDS_VALIDATION`, or `EXPIRED_NEEDS_VALIDATION`, you need to perform domain validation. This proves to the certificate authority that you control the domain and are authorized to create certificates for it.\n\nIn your DNS configuration, create a CNAME record and map the `cert_status.hostname` value to the `cert_status.target` value.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyHostnames.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "(Required) A property's unique ID, including the `prp_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyHostnames.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyHostnamesHostname:getPropertyHostnamesHostname"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "hostnames",
                    "propertyId",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyInclude:getPropertyInclude": {
            "description": "Use the `akamai.PropertyInclude` data source to get details about a specific include.\n\n## Basic usage\n\nThis example returns details for an include based on contract, group, and include IDs.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExamplePropertyInclude = akamai.getPropertyInclude({\n    contractId: \"ctr_1234\",\n    groupId: \"grp_5678\",\n    includeId: \"inc_9012\",\n});\nexport const myExample = myExamplePropertyInclude;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example_property_include = akamai.get_property_include(contract_id=\"ctr_1234\",\n    group_id=\"grp_5678\",\n    include_id=\"inc_9012\")\npulumi.export(\"myExample\", my_example_property_include)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExamplePropertyInclude = Akamai.GetPropertyInclude.Invoke(new()\n    {\n        ContractId = \"ctr_1234\",\n        GroupId = \"grp_5678\",\n        IncludeId = \"inc_9012\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myExample\"] = myExamplePropertyInclude.Apply(getPropertyIncludeResult =\u003e getPropertyIncludeResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyExamplePropertyInclude, err := akamai.LookupPropertyInclude(ctx, \u0026akamai.LookupPropertyIncludeArgs{\n\t\t\tContractId: \"ctr_1234\",\n\t\t\tGroupId:    \"grp_5678\",\n\t\t\tIncludeId:  \"inc_9012\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myExample\", myExamplePropertyInclude)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyIncludeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myExamplePropertyInclude = AkamaiFunctions.getPropertyInclude(GetPropertyIncludeArgs.builder()\n            .contractId(\"ctr_1234\")\n            .groupId(\"grp_5678\")\n            .includeId(\"inc_9012\")\n            .build());\n\n        ctx.export(\"myExample\", myExamplePropertyInclude.applyValue(getPropertyIncludeResult -\u003e getPropertyIncludeResult));\n    }\n}\n```\n```yaml\nvariables:\n  myExamplePropertyInclude:\n    fn::invoke:\n      Function: akamai:getPropertyInclude\n      Arguments:\n        contractId: ctr_1234\n        groupId: grp_5678\n        includeId: inc_9012\noutputs:\n  myExample: ${myExamplePropertyInclude}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `name` - The descriptive name for the include.\n* `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n* `latest_version` - Returns the most recent version of the include.\n* `staging_version` - The include version currently activated on the staging network.\n* `production_version` - The include version currently activated on the production network.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyInclude.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                    },
                    "includeId": {
                        "type": "string",
                        "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyInclude.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includeId": {
                        "type": "string"
                    },
                    "latestVersion": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "productionVersion": {
                        "type": "integer"
                    },
                    "stagingVersion": {
                        "type": "integer"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "latestVersion",
                    "name",
                    "productionVersion",
                    "stagingVersion",
                    "type",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyIncludeActivation:getPropertyIncludeActivation": {
            "description": "Use the `akamai.PropertyIncludeActivation` data source to get activation details for an include on the provided network.\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `version` - The version of the activated include.\n* `name` - The descriptive name for the property.\n* `note` - A log message assigned to the activation request.\n* `notify_emails` - The list of email addresses notified when the activation status changes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyIncludeActivation.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                    },
                    "includeId": {
                        "type": "string",
                        "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "(Required) The Akamai network where you want to check the activation details, either `STAGING` or `PRODUCTION`. `STAGING` is the default.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "network"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyIncludeActivation.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includeId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "network": {
                        "type": "string"
                    },
                    "note": {
                        "type": "string"
                    },
                    "notifyEmails": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "name",
                    "network",
                    "note",
                    "notifyEmails",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyIncludeParents:getPropertyIncludeParents": {
            "description": "Use the `akamai.getPropertyIncludeParents` data source to return a list of parent properties that use the given include. In your property's rule tree, you can reference an include by adding the `include` behavior and specifying the `include_id`.\n\n## Basic usage\n\nThis example returns all active properties a specific include is referenced in, based on the contract, group, and include IDs.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExamplePropertyIncludeParents = akamai.getPropertyIncludeParents({\n    contractId: \"ctr_1-AB123\",\n    groupId: \"grp_12345\",\n    includeId: \"inc_123456\",\n});\nexport const myExample = myExamplePropertyIncludeParents;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example_property_include_parents = akamai.get_property_include_parents(contract_id=\"ctr_1-AB123\",\n    group_id=\"grp_12345\",\n    include_id=\"inc_123456\")\npulumi.export(\"myExample\", my_example_property_include_parents)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExamplePropertyIncludeParents = Akamai.GetPropertyIncludeParents.Invoke(new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        GroupId = \"grp_12345\",\n        IncludeId = \"inc_123456\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myExample\"] = myExamplePropertyIncludeParents.Apply(getPropertyIncludeParentsResult =\u003e getPropertyIncludeParentsResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyExamplePropertyIncludeParents, err := akamai.GetPropertyIncludeParents(ctx, \u0026akamai.GetPropertyIncludeParentsArgs{\n\t\t\tContractId: \"ctr_1-AB123\",\n\t\t\tGroupId:    \"grp_12345\",\n\t\t\tIncludeId:  \"inc_123456\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myExample\", myExamplePropertyIncludeParents)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyIncludeParentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myExamplePropertyIncludeParents = AkamaiFunctions.getPropertyIncludeParents(GetPropertyIncludeParentsArgs.builder()\n            .contractId(\"ctr_1-AB123\")\n            .groupId(\"grp_12345\")\n            .includeId(\"inc_123456\")\n            .build());\n\n        ctx.export(\"myExample\", myExamplePropertyIncludeParents.applyValue(getPropertyIncludeParentsResult -\u003e getPropertyIncludeParentsResult));\n    }\n}\n```\n```yaml\nvariables:\n  myExamplePropertyIncludeParents:\n    fn::invoke:\n      Function: akamai:getPropertyIncludeParents\n      Arguments:\n        contractId: ctr_1-AB123\n        groupId: grp_12345\n        includeId: inc_123456\noutputs:\n  myExample: ${myExamplePropertyIncludeParents}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `parents` - The list of include's parent properties.\n * `id` - The property's unique identifier.\n * `name` - The descriptive name for the property.\n * `staging_version` - The property version currently activated on the staging network.\n * `production_version` - The property version currently activated on the production network.\n * `is_include_used_in_staging_version` - Whether the specified include is active on the staging network and is referenced in parent's `staging_version`.\n * `is_include_used_in_production_version` - Whether the specified include is active on the production network and is referenced in parent's `production_version`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyIncludeParents.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                    },
                    "includeId": {
                        "type": "string",
                        "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyIncludeParents.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includeId": {
                        "type": "string"
                    },
                    "parents": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyIncludeParentsParent:getPropertyIncludeParentsParent"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "parents",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyIncludeRules:getPropertyIncludeRules": {
            "description": "Use the `akamai.getPropertyIncludeRules` data source to query and get an include's rules. This data source lets you search across the contracts and groups you have access to.\n\n## Basic usage\n\nThis example returns the include's rule tree based on the specified contract, group, and include IDs:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExamplePropertyIncludeRules = akamai.getPropertyIncludeRules({\n    contractId: \"ctr_1-AB123\",\n    groupId: \"grp_12345\",\n    includeId: \"inc_123456\",\n    version: 3,\n});\nexport const myExample = myExamplePropertyIncludeRules;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example_property_include_rules = akamai.get_property_include_rules(contract_id=\"ctr_1-AB123\",\n    group_id=\"grp_12345\",\n    include_id=\"inc_123456\",\n    version=3)\npulumi.export(\"myExample\", my_example_property_include_rules)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExamplePropertyIncludeRules = Akamai.GetPropertyIncludeRules.Invoke(new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        GroupId = \"grp_12345\",\n        IncludeId = \"inc_123456\",\n        Version = 3,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myExample\"] = myExamplePropertyIncludeRules.Apply(getPropertyIncludeRulesResult =\u003e getPropertyIncludeRulesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyExamplePropertyIncludeRules, err := akamai.GetPropertyIncludeRules(ctx, \u0026akamai.GetPropertyIncludeRulesArgs{\n\t\t\tContractId: \"ctr_1-AB123\",\n\t\t\tGroupId:    \"grp_12345\",\n\t\t\tIncludeId:  \"inc_123456\",\n\t\t\tVersion:    3,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myExample\", myExamplePropertyIncludeRules)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyIncludeRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myExamplePropertyIncludeRules = AkamaiFunctions.getPropertyIncludeRules(GetPropertyIncludeRulesArgs.builder()\n            .contractId(\"ctr_1-AB123\")\n            .groupId(\"grp_12345\")\n            .includeId(\"inc_123456\")\n            .version(3)\n            .build());\n\n        ctx.export(\"myExample\", myExamplePropertyIncludeRules.applyValue(getPropertyIncludeRulesResult -\u003e getPropertyIncludeRulesResult));\n    }\n}\n```\n```yaml\nvariables:\n  myExamplePropertyIncludeRules:\n    fn::invoke:\n      Function: akamai:getPropertyIncludeRules\n      Arguments:\n        contractId: ctr_1-AB123\n        groupId: grp_12345\n        includeId: inc_123456\n        version: 3\noutputs:\n  myExample: ${myExamplePropertyIncludeRules}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `rules` - Include's rules as JSON.\n* `name` - The descriptive name for the include.\n* `rule_errors` - Rule's validation errors. You need to resolve returned errors, as they block an activation.\n* `rule_warnings` - Rule's validation warnings. You can activate a version that yields non-blocking warnings.\n* `rule_format` - Indicates the versioned set of features and criteria that are currently applied to a rule tree. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n* `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyIncludeRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                    },
                    "includeId": {
                        "type": "string",
                        "description": "(Required) An include's unique ID with the optional `inc_` prefix.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Required) The include version you want to view the rules for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "version"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyIncludeRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includeId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ruleErrors": {
                        "type": "string"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "ruleWarnings": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includeId",
                    "name",
                    "ruleErrors",
                    "ruleFormat",
                    "ruleWarnings",
                    "rules",
                    "type",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyIncludes:getPropertyIncludes": {
            "description": "Use the `akamai.getPropertyIncludes` data source to get all includes available for the current contract and group. Includes are small, reusable, and configurable components for your properties.\n\n## Basic usage\n\nThis example returns all includes for the specified contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst myExamplePropertyIncludes = akamai.getPropertyIncludes({\n    contractId: \"ctr_1-AB123\",\n    groupId: \"grp_12345\",\n});\nexport const myExample = myExamplePropertyIncludes;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example_property_includes = akamai.get_property_includes(contract_id=\"ctr_1-AB123\",\n    group_id=\"grp_12345\")\npulumi.export(\"myExample\", my_example_property_includes)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExamplePropertyIncludes = Akamai.GetPropertyIncludes.Invoke(new()\n    {\n        ContractId = \"ctr_1-AB123\",\n        GroupId = \"grp_12345\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myExample\"] = myExamplePropertyIncludes.Apply(getPropertyIncludesResult =\u003e getPropertyIncludesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyExamplePropertyIncludes, err := akamai.GetPropertyIncludes(ctx, \u0026akamai.GetPropertyIncludesArgs{\n\t\t\tContractId: \"ctr_1-AB123\",\n\t\t\tGroupId:    \"grp_12345\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myExample\", myExamplePropertyIncludes)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyIncludesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myExamplePropertyIncludes = AkamaiFunctions.getPropertyIncludes(GetPropertyIncludesArgs.builder()\n            .contractId(\"ctr_1-AB123\")\n            .groupId(\"grp_12345\")\n            .build());\n\n        ctx.export(\"myExample\", myExamplePropertyIncludes.applyValue(getPropertyIncludesResult -\u003e getPropertyIncludesResult));\n    }\n}\n```\n```yaml\nvariables:\n  myExamplePropertyIncludes:\n    fn::invoke:\n      Function: akamai:getPropertyIncludes\n      Arguments:\n        contractId: ctr_1-AB123\n        groupId: grp_12345\noutputs:\n  myExample: ${myExamplePropertyIncludes}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `includes` -  The small, reusable, configurable components for your properties.\n * `latest_version` - Returns the most recent version of the include.\n * `staging_version` - The include version currently activated on the staging network.\n * `production_version` - The include version currently activated on the production network.\n * `id` - The include's unique identifier.\n * `name` - The descriptive name for the include.\n * `type` - Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyIncludes.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the optional `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the optional `grp_` prefix.\n"
                    },
                    "parentProperty": {
                        "$ref": "#/types/akamai:index/getPropertyIncludesParentProperty:getPropertyIncludesParentProperty",
                        "description": "(Optional) The property that references the includes you want to list.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Optional) Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyIncludes.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyIncludesInclude:getPropertyIncludesInclude"
                        }
                    },
                    "parentProperty": {
                        "$ref": "#/types/akamai:index/getPropertyIncludesParentProperty:getPropertyIncludesParentProperty"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "groupId",
                    "includes",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyProducts:getPropertyProducts": {
            "description": "Use the `akamai.getPropertyProducts` data source to list the products included on a contract.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const propertyMatch = data.akamai_property_products[\"my-example\"];\n```\n```python\nimport pulumi\n\npulumi.export(\"propertyMatch\", data[\"akamai_property_products\"][\"my-example\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = data.Akamai_property_products.My_example,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"propertyMatch\", data.Akamai_property_products.MyExample)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"propertyMatch\", data.akamai_property_products().my-example());\n    }\n}\n```\n```yaml\noutputs:\n  propertyMatch: ${data.akamai_property_products\"my-example\"[%!s(MISSING)]}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `products` - A list of supported products for the contract, including:\n  * `product_id` - The product's unique ID, including the `prd_` prefix.\n  * `product_name` - A string containing the product name.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyProducts.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    }
                },
                "type": "object",
                "required": [
                    "contractId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyProducts.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "products": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyProductsProduct:getPropertyProductsProduct"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "products",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRuleFormats:getPropertyRuleFormats": {
            "description": "Use the `akamai.getPropertyRuleFormats` data source to query the list of\nknown rule formats.\nYou use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or\n[update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors\nand criteria a rule tree invokes. Without this mechanism, behaviors and criteria\nwould update automatically and generate unexpected errors.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nUse this example to list available property rule formats:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const propertyMatch = data.akamai_property_rule_formats[\"my-example\"];\n```\n```python\nimport pulumi\n\npulumi.export(\"propertyMatch\", data[\"akamai_property_rule_formats\"][\"my-example\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = data.Akamai_property_rule_formats.My_example,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"propertyMatch\", data.Akamai_property_rule_formats.MyExample)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"propertyMatch\", data.akamai_property_rule_formats().my-example());\n    }\n}\n```\n```yaml\noutputs:\n  propertyMatch: ${data.akamai_property_rule_formats\"my-example\"[%!s(MISSING)]}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getPropertyRuleFormats.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ruleFormats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "ruleFormats",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRules:getPropertyRules": {
            "description": "Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of\nan existing property version. This data source lets you search across the contracts\nand groups you have access to.\n\n## Basic usage\n\nThis example returns the rule tree for version 3 of a property based on the selected contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getPropertyRules({\n    propertyId: \"prp_123\",\n    groupId: \"grp_12345\",\n    contractId: \"ctr_1-AB123\",\n    version: 3,\n});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_property_rules(property_id=\"prp_123\",\n    group_id=\"grp_12345\",\n    contract_id=\"ctr_1-AB123\",\n    version=3)\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_example = Akamai.GetPropertyRules.Invoke(new()\n    {\n        PropertyId = \"prp_123\",\n        GroupId = \"grp_12345\",\n        ContractId = \"ctr_1-AB123\",\n        Version = 3,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = my_example.Apply(getPropertyRulesResult =\u003e getPropertyRulesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetPropertyRules(ctx, \u0026akamai.GetPropertyRulesArgs{\n\t\t\tPropertyId: \"prp_123\",\n\t\t\tGroupId:    pulumi.StringRef(\"grp_12345\"),\n\t\t\tContractId: pulumi.StringRef(\"ctr_1-AB123\"),\n\t\t\tVersion:    pulumi.IntRef(3),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()\n            .propertyId(\"prp_123\")\n            .groupId(\"grp_12345\")\n            .contractId(\"ctr_1-AB123\")\n            .version(3)\n            .build());\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    fn::invoke:\n      Function: akamai:getPropertyRules\n      Arguments:\n        propertyId: prp_123\n        groupId: grp_12345\n        contractId: ctr_1-AB123\n        version: 3\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n* `rules` - A JSON-encoded rule tree for the property.\n* `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "(Required) A property's unique ID, including the `prp_` prefix.\n"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version to return. Returns the latest version by default.\n"
                    }
                },
                "type": "object",
                "required": [
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "errors": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "errors",
                    "groupId",
                    "propertyId",
                    "rules",
                    "version",
                    "id"
                ]
            }
        },
        "akamai:index/getPropertyRulesTemplate:getPropertyRulesTemplate": {
            "description": "{{% examples %}}\n## Example Usage\n\n### JSON Template Files\n\nHere are some examples of how you can set up your JSON template files for use with this data source.\n{{% example %}}\n### Single JSON template that calls other templates\n\nHere's an example of a JSON template file with nested templates:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n{{% /example %}}\n{{% example %}}\n### Individual JSON rule template file\n\nHere’s a simple default rule example that you can include inside the `template_data` argument:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\n{{% /example %}}\n### Add Templates To The Data Source\n\nHere are some examples of how you can call your JSON template files with this data source.\n{{% example %}}\n### Call individual template files with this data source\n\nThis second example shows how to call a specific JSON template using the `template_data` field:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst examplePropertyRulesTemplate = akamai.getPropertyRulesTemplate({\n    templates: [{\n        templateData: JSON.stringify({\n            rules: {\n                name: \"default\",\n                children: [\"#include:rules.json\"],\n            },\n        }),\n        templateDir: \"property-snippets/\",\n    }],\n});\nconst exampleProperty = new akamai.Property(\"exampleProperty\", {\n    contractId: _var.contractid,\n    groupId: _var.groupid,\n    ruleFormat: \"v2020-03-04\",\n    rules: examplePropertyRulesTemplate.then(examplePropertyRulesTemplate =\u003e examplePropertyRulesTemplate.json),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_akamai as akamai\n\nexample_property_rules_template = akamai.get_property_rules_template(templates=[akamai.GetPropertyRulesTemplateTemplateArgs(\n    template_data=json.dumps({\n        \"rules\": {\n            \"name\": \"default\",\n            \"children\": [\"#include:rules.json\"],\n        },\n    }),\n    template_dir=\"property-snippets/\",\n)])\nexample_property = akamai.Property(\"exampleProperty\",\n    contract_id=var[\"contractid\"],\n    group_id=var[\"groupid\"],\n    rule_format=\"v2020-03-04\",\n    rules=example_property_rules_template.json)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var examplePropertyRulesTemplate = Akamai.GetPropertyRulesTemplate.Invoke(new()\n    {\n        Templates = new[]\n        {\n            new Akamai.Inputs.GetPropertyRulesTemplateTemplateInputArgs\n            {\n                TemplateData = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"rules\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"name\"] = \"default\",\n                        [\"children\"] = new[]\n                        {\n                            \"#include:rules.json\",\n                        },\n                    },\n                }),\n                TemplateDir = \"property-snippets/\",\n            },\n        },\n    });\n\n    var exampleProperty = new Akamai.Property(\"exampleProperty\", new()\n    {\n        ContractId = @var.Contractid,\n        GroupId = @var.Groupid,\n        RuleFormat = \"v2020-03-04\",\n        Rules = examplePropertyRulesTemplate.Apply(getPropertyRulesTemplateResult =\u003e getPropertyRulesTemplateResult.Json),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"rules\": map[string]interface{}{\n\t\t\t\t\"name\": \"default\",\n\t\t\t\t\"children\": []string{\n\t\t\t\t\t\"#include:rules.json\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\texamplePropertyRulesTemplate, err := akamai.GetPropertyRulesTemplate(ctx, \u0026akamai.GetPropertyRulesTemplateArgs{\n\t\t\tTemplates: []akamai.GetPropertyRulesTemplateTemplate{\n\t\t\t\t{\n\t\t\t\t\tTemplateData: json0,\n\t\t\t\t\tTemplateDir:  \"property-snippets/\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = akamai.NewProperty(ctx, \"exampleProperty\", \u0026akamai.PropertyArgs{\n\t\t\tContractId: pulumi.Any(_var.Contractid),\n\t\t\tGroupId:    pulumi.Any(_var.Groupid),\n\t\t\tRuleFormat: pulumi.String(\"v2020-03-04\"),\n\t\t\tRules:      *pulumi.String(examplePropertyRulesTemplate.Json),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesTemplateArgs;\nimport com.pulumi.akamai.Property;\nimport com.pulumi.akamai.PropertyArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var examplePropertyRulesTemplate = AkamaiFunctions.getPropertyRulesTemplate(GetPropertyRulesTemplateArgs.builder()\n            .templates(GetPropertyRulesTemplateTemplateArgs.builder()\n                .templateData(serializeJson(\n                    jsonObject(\n                        jsonProperty(\"rules\", jsonObject(\n                            jsonProperty(\"name\", \"default\"),\n                            jsonProperty(\"children\", jsonArray(\"#include:rules.json\"))\n                        ))\n                    )))\n                .templateDir(\"property-snippets/\")\n                .build())\n            .build());\n\n        var exampleProperty = new Property(\"exampleProperty\", PropertyArgs.builder()        \n            .contractId(var_.contractid())\n            .groupId(var_.groupid())\n            .ruleFormat(\"v2020-03-04\")\n            .rules(examplePropertyRulesTemplate.applyValue(getPropertyRulesTemplateResult -\u003e getPropertyRulesTemplateResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleProperty:\n    type: akamai:Property\n    properties:\n      contractId: ${var.contractid}\n      groupId: ${var.groupid}\n      ruleFormat: v2020-03-04\n      rules: ${examplePropertyRulesTemplate.json}\nvariables:\n  examplePropertyRulesTemplate:\n    fn::invoke:\n      Function: akamai:getPropertyRulesTemplate\n      Arguments:\n        templates:\n          - templateData:\n              fn::toJSON:\n                rules:\n                  name: default\n                  children:\n                    - '#include:rules.json'\n            templateDir: property-snippets/\n```\n\n{{% /example %}}\n### Variables\n\nYou can add variables individually or reference variable definition files.\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns this attribute:\n\n* `json` - The fully expanded template with variables and all nested templates resolved.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRulesTemplate.\n",
                "properties": {
                    "templateFile": {
                        "type": "string",
                        "description": "The absolute path to your top-level JSON template file. The top-level template combines smaller, nested JSON templates to form your property rule tree. This argument conflicts with the `template` argument.\n"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate"
                        },
                        "description": "The template you use in your configuration. This argument conflicts with the `template_file` argument.\n"
                    },
                    "varDefinitionFile": {
                        "type": "string",
                        "description": "Required when using `var_values_file`. The absolute path to the file containing variable definitions and defaults. This argument conflicts with the `variables` argument.\n"
                    },
                    "varValuesFile": {
                        "type": "string",
                        "description": "Required when using `var_definition_file`. The absolute path to the file containing variable values. This argument conflicts with the `variables` argument.\n"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable"
                        },
                        "description": "The definition of one or more variables. This argument conflicts with the `var_definition_file` and `var_values_file` arguments. A `variables` block includes:\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRulesTemplate.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "json": {
                        "type": "string"
                    },
                    "templateFile": {
                        "type": "string"
                    },
                    "templates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateTemplate:getPropertyRulesTemplateTemplate"
                        }
                    },
                    "varDefinitionFile": {
                        "type": "string"
                    },
                    "varValuesFile": {
                        "type": "string"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/akamai:index/getPropertyRulesTemplateVariable:getPropertyRulesTemplateVariable"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "json",
                    "id"
                ]
            }
        },
        "akamai:properties/getCpCode:getCpCode": {
            "inputs": {
                "description": "A collection of arguments for invoking getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "description": "Replaced by `contract_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"contract\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "Replaced by `group_id`. Maintained for legacy purposes.\n",
                        "deprecationMessage": "The setting \"group\" has been deprecated.",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The group's unique ID, including the `grp_` prefix.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the CP code.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCpCode.\n",
                "properties": {
                    "contract": {
                        "type": "string",
                        "deprecationMessage": "The setting \"contract\" has been deprecated."
                    },
                    "contractId": {
                        "type": "string"
                    },
                    "group": {
                        "type": "string",
                        "deprecationMessage": "The setting \"group\" has been deprecated."
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "productIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "contract",
                    "contractId",
                    "group",
                    "groupId",
                    "name",
                    "productIds",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode"
        },
        "akamai:properties/getProperty:getProperty": {
            "description": "Use the `akamai.Property` data source to query and list the property ID and rule tree based on the property name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example returns the property ID and rule tree based on the property name and optional version argument:\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst example = akamai.getProperty({\n    name: \"terraform-demo\",\n    version: 1,\n});\nexport const myPropertyID = example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nexample = akamai.get_property(name=\"terraform-demo\",\n    version=1)\npulumi.export(\"myPropertyID\", example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Akamai.GetProperty.Invoke(new()\n    {\n        Name = \"terraform-demo\",\n        Version = 1,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"myPropertyID\"] = example.Apply(getPropertyResult =\u003e getPropertyResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := akamai.LookupProperty(ctx, \u0026akamai.LookupPropertyArgs{\n\t\t\tName:    \"terraform-demo\",\n\t\t\tVersion: pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"myPropertyID\", example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AkamaiFunctions.getProperty(GetPropertyArgs.builder()\n            .name(\"terraform-demo\")\n            .version(\"1\")\n            .build());\n\n        ctx.export(\"myPropertyID\", example.applyValue(getPropertyResult -\u003e getPropertyResult));\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: akamai:getProperty\n      Arguments:\n        name: terraform-demo\n        version: '1'\noutputs:\n  myPropertyID: ${example}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `property_ID` - A property's unique identifier, including the `prp_` prefix.\n* `rules` - A JSON-encoded rule tree for a given property.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProperty.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "(Required) The property name.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version of the property whose ID you want to list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProperty.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "rules",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getProperty has been deprecated in favor of akamai.getProperty"
        },
        "akamai:properties/getPropertyRules:getPropertyRules": {
            "description": "Use the `akamai.getPropertyRules` data source to query and retrieve the rule tree of\nan existing property version. This data source lets you search across the contracts\nand groups you have access to.\n\n## Basic usage\n\nThis example returns the rule tree for version 3 of a property based on the selected contract and group:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as akamai from \"@pulumi/akamai\";\n\nconst my-example = akamai.getPropertyRules({\n    propertyId: \"prp_123\",\n    groupId: \"grp_12345\",\n    contractId: \"ctr_1-AB123\",\n    version: 3,\n});\nexport const propertyMatch = my_example;\n```\n```python\nimport pulumi\nimport pulumi_akamai as akamai\n\nmy_example = akamai.get_property_rules(property_id=\"prp_123\",\n    group_id=\"grp_12345\",\n    contract_id=\"ctr_1-AB123\",\n    version=3)\npulumi.export(\"propertyMatch\", my_example)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Akamai = Pulumi.Akamai;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var my_example = Akamai.GetPropertyRules.Invoke(new()\n    {\n        PropertyId = \"prp_123\",\n        GroupId = \"grp_12345\",\n        ContractId = \"ctr_1-AB123\",\n        Version = 3,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"propertyMatch\"] = my_example.Apply(getPropertyRulesResult =\u003e getPropertyRulesResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-akamai/sdk/v4/go/akamai\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmy_example, err := akamai.GetPropertyRules(ctx, \u0026akamai.GetPropertyRulesArgs{\n\t\t\tPropertyId: \"prp_123\",\n\t\t\tGroupId:    pulumi.StringRef(\"grp_12345\"),\n\t\t\tContractId: pulumi.StringRef(\"ctr_1-AB123\"),\n\t\t\tVersion:    pulumi.IntRef(3),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"propertyMatch\", my_example)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.akamai.AkamaiFunctions;\nimport com.pulumi.akamai.inputs.GetPropertyRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var my-example = AkamaiFunctions.getPropertyRules(GetPropertyRulesArgs.builder()\n            .propertyId(\"prp_123\")\n            .groupId(\"grp_12345\")\n            .contractId(\"ctr_1-AB123\")\n            .version(3)\n            .build());\n\n        ctx.export(\"propertyMatch\", my_example);\n    }\n}\n```\n```yaml\nvariables:\n  my-example:\n    fn::invoke:\n      Function: akamai:getPropertyRules\n      Arguments:\n        propertyId: prp_123\n        groupId: grp_12345\n        contractId: ctr_1-AB123\n        version: 3\noutputs:\n  propertyMatch: ${[\"my-example\"]}\n```\n\n## Attributes reference\n\nThis data source returns these attributes:\n\n* `rule_format` - The rule tree version used. Property rule objects are versioned infrequently, and are known as rule formats. See [Rule format schemas](https://techdocs.akamai.com/property-mgr/reference/rule-format-schemas) to learn more.\n* `rules` - A JSON-encoded rule tree for the property.\n* `errors` - A list of validation errors for the rule tree object returned. For more information see [Errors](https://techdocs.akamai.com/property-mgr/reference/api-errors) in the Property Manager API documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string",
                        "description": "(Required) A contract's unique ID, including the `ctr_` prefix.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "(Required) A group's unique ID, including the `grp_` prefix.\n"
                    },
                    "propertyId": {
                        "type": "string",
                        "description": "(Required) A property's unique ID, including the `prp_` prefix.\n"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer",
                        "description": "(Optional) The version to return. Returns the latest version by default.\n"
                    }
                },
                "type": "object",
                "required": [
                    "propertyId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPropertyRules.\n",
                "properties": {
                    "contractId": {
                        "type": "string"
                    },
                    "errors": {
                        "type": "string"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "propertyId": {
                        "type": "string"
                    },
                    "ruleFormat": {
                        "type": "string"
                    },
                    "rules": {
                        "type": "string"
                    },
                    "version": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "contractId",
                    "errors",
                    "groupId",
                    "propertyId",
                    "rules",
                    "version",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.properties.getPropertyRules has been deprecated in favor of akamai.getPropertyRules"
        },
        "akamai:trafficmanagement/getGtmDefaultDatacenter:getGtmDefaultDatacenter": {
            "description": "Use the `akamai.getGtmDefaultDatacenter` data source to retrieve the default data center, ID, and nickname.\n\n## Attributes reference\n\nThis data source supports these attributes:\n\n* `id` - The data resource ID. Enter in this format: `\u003cdomain\u003e:default_datacenter:\u003cdatacenter_id\u003e`.\n* `datacenter_id` - The default data center ID.\n* `nickname` - The default data center nickname.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer",
                        "description": "The default is `5400`.\n"
                    },
                    "domain": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "domain"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGtmDefaultDatacenter.\n",
                "properties": {
                    "datacenter": {
                        "type": "integer"
                    },
                    "datacenterId": {
                        "type": "integer"
                    },
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nickname": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "domain",
                    "nickname",
                    "id"
                ]
            },
            "deprecationMessage": "akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter"
        }
    }
}